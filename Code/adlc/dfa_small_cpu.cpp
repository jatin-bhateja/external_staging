//
// Copyright

// Machine Generated File.  Do Not Edit!

#include "precompiled.hpp"
#include "adfiles/ad_small_cpu.hpp"
#include "oops/compressedOops.hpp"
#include "opto/cfgnode.hpp"
#include "opto/intrinsicnode.hpp"
#include "opto/matcher.hpp"
#include "opto/narrowptrnode.hpp"
#include "opto/opcodes.hpp"
#include "opto/convertnode.hpp"
#include "opto/superword.hpp"
#include "utilities/powerOfTwo.hpp"

//------------------------- Source -----------------------------------------

//------------------------- Attributes -------------------------------------

// AttributeForm 
static const int ins_cost = 100;

// AttributeForm 
static const int op_cost = 100;

//------------------------- Macros -----------------------------------------
#define DFA_PRODUCTION(result, rule, cost)\
  assert(rule < (1 << 15), "too many rules"); _cost[ (result) ] = cost; _rule[ (result) ] = (rule << 1) | 0x1;

//------------------------- DFA --------------------------------------------
// DFA is a large switch with case statements for each ideal opcode encountered
// in any match rule in the ad file.  Each case has a series of if's to handle
// the match or fail decisions.  The matches test the cost function of that
// rule, and prune any cases which are higher cost for the same reduction.
// In order to generate the DFA we walk the table of ideal opcode/MatchList
// pairs generated by the ADLC front end to build the contents of the case
// statements (a series of if statements).


bool State::DFA(int opcode, const Node *n) {
  switch(opcode) {
  case Op_RegI: {
    {
      unsigned int c = 100;
        DFA_PRODUCTION(RREGI, rRegI_rule, c)
    }
    break;
  }
  case Op_RegF: {
    {
      unsigned int c = 100;
        DFA_PRODUCTION(LEGXMM1, legXmm1_rule, c)
    }
    {
      unsigned int c = 100;
        DFA_PRODUCTION(LEGXMM0, legXmm0_rule, c)
    }
    break;
  }
  case Op_AddF: {
    if( STATE__VALID_CHILD(_kids[0], LEGXMM0) && STATE__VALID_CHILD(_kids[1], LEGXMM1) &&
        (1) ) {
      unsigned int c = _kids[0]->_cost[LEGXMM0]+_kids[1]->_cost[LEGXMM1]+150;
        DFA_PRODUCTION(LEGXMM0, addF_reg_rule, c)
    }
    break;
  }
  case Op_AddI: {
    if( STATE__VALID_CHILD(_kids[0], RREGI) && STATE__VALID_CHILD(_kids[1], RREGI) &&
        (1) ) {
      unsigned int c = _kids[0]->_cost[RREGI]+_kids[1]->_cost[RREGI]+150;
        DFA_PRODUCTION(RREGI, addI_reg_rule, c)
    }
    break;
  }
  
  default:
    tty->print("Default case invoked for: \n");
    tty->print("   opcode  = %d, \"%s\"\n", opcode, NodeClassNames[opcode]);
    return false;
  }
  return true;
}
