Args: llc -show-mc-encoding -mcpu=skx ext.ll -debug 
	discovered a new reachable node %0
	discovered a new reachable node %0

Features:+sse2
CPU:skx

Subtarget features: SSELevel 9, 3DNowLevel 1, 64bit 1
G_ADD (opcode 35): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_SUB (opcode 36): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_MUL (opcode 37): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_SDIV (opcode 38): 1 type index
.. the first uncovered type index: 1, OK
G_UDIV (opcode 39): 1 type index
.. opcode 39 is aliased to 38
.. opcode 38 is aliased to 0
.. the first uncovered type index: 1, OK
G_SREM (opcode 40): 1 type index
.. opcode 40 is aliased to 38
.. opcode 38 is aliased to 0
.. the first uncovered type index: 1, OK
G_UREM (opcode 41): 1 type index
.. opcode 41 is aliased to 38
.. opcode 38 is aliased to 0
.. the first uncovered type index: 1, OK
G_AND (opcode 42): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_OR (opcode 43): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_XOR (opcode 44): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_IMPLICIT_DEF (opcode 45): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_PHI (opcode 46): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FRAME_INDEX (opcode 47): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_GLOBAL_VALUE (opcode 48): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_EXTRACT (opcode 49): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_UNMERGE_VALUES (opcode 50): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_INSERT (opcode 51): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_MERGE_VALUES (opcode 52): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_BUILD_VECTOR (opcode 53): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_BUILD_VECTOR_TRUNC (opcode 54): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_CONCAT_VECTORS (opcode 55): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_PTRTOINT (opcode 56): 2 type indices
.. the first uncovered type index: 2, OK
G_INTTOPTR (opcode 57): 2 type indices
.. the first uncovered type index: 2, OK
G_BITCAST (opcode 58): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_INTRINSIC_TRUNC (opcode 59): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_INTRINSIC_ROUND (opcode 60): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_LOAD (opcode 61): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_SEXTLOAD (opcode 62): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ZEXTLOAD (opcode 63): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_STORE (opcode 64): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMIC_CMPXCHG_WITH_SUCCESS (opcode 65): 3 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMIC_CMPXCHG (opcode 66): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMICRMW_XCHG (opcode 67): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMICRMW_ADD (opcode 68): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMICRMW_SUB (opcode 69): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMICRMW_AND (opcode 70): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMICRMW_NAND (opcode 71): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMICRMW_OR (opcode 72): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMICRMW_XOR (opcode 73): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMICRMW_MAX (opcode 74): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMICRMW_MIN (opcode 75): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMICRMW_UMAX (opcode 76): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMICRMW_UMIN (opcode 77): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_BRCOND (opcode 78): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_BRINDIRECT (opcode 79): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_INTRINSIC (opcode 80): 0 type indices
.. type index coverage check SKIPPED: no rules defined
G_INTRINSIC_W_SIDE_EFFECTS (opcode 81): 0 type indices
.. type index coverage check SKIPPED: no rules defined
G_ANYEXT (opcode 82): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_TRUNC (opcode 83): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_CONSTANT (opcode 84): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FCONSTANT (opcode 85): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_VASTART (opcode 86): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_VAARG (opcode 87): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_SEXT (opcode 88): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ZEXT (opcode 89): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_SHL (opcode 90): 2 type indices
.. the first uncovered type index: 2, OK
G_LSHR (opcode 91): 2 type indices
.. opcode 91 is aliased to 90
.. opcode 90 is aliased to 0
.. the first uncovered type index: 2, OK
G_ASHR (opcode 92): 2 type indices
.. opcode 92 is aliased to 90
.. opcode 90 is aliased to 0
.. the first uncovered type index: 2, OK
G_ICMP (opcode 93): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_FCMP (opcode 94): 2 type indices
.. the first uncovered type index: 2, OK
G_SELECT (opcode 95): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_UADDO (opcode 96): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_UADDE (opcode 97): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_USUBO (opcode 98): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_USUBE (opcode 99): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_SADDO (opcode 100): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_SADDE (opcode 101): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_SSUBO (opcode 102): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_SSUBE (opcode 103): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_UMULO (opcode 104): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_SMULO (opcode 105): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_UMULH (opcode 106): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_SMULH (opcode 107): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FADD (opcode 108): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FSUB (opcode 109): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FMUL (opcode 110): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FMA (opcode 111): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FDIV (opcode 112): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FREM (opcode 113): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FPOW (opcode 114): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FEXP (opcode 115): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FEXP2 (opcode 116): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FLOG (opcode 117): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FLOG2 (opcode 118): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FLOG10 (opcode 119): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FNEG (opcode 120): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FPEXT (opcode 121): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_FPTRUNC (opcode 122): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_FPTOSI (opcode 123): 2 type indices
.. the first uncovered type index: 2, OK
G_FPTOUI (opcode 124): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_SITOFP (opcode 125): 2 type indices
.. the first uncovered type index: 2, OK
G_UITOFP (opcode 126): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_FABS (opcode 127): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FCOPYSIGN (opcode 128): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_FCANONICALIZE (opcode 129): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_GEP (opcode 130): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_PTR_MASK (opcode 131): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_SMIN (opcode 132): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_SMAX (opcode 133): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_UMIN (opcode 134): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_UMAX (opcode 135): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_BR (opcode 136): 0 type indices
.. type index coverage check SKIPPED: no rules defined
G_INSERT_VECTOR_ELT (opcode 137): 3 type indices
.. type index coverage check SKIPPED: no rules defined
G_EXTRACT_VECTOR_ELT (opcode 138): 3 type indices
.. type index coverage check SKIPPED: no rules defined
G_SHUFFLE_VECTOR (opcode 139): 3 type indices
.. type index coverage check SKIPPED: no rules defined
G_CTTZ (opcode 140): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_CTTZ_ZERO_UNDEF (opcode 141): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_CTLZ (opcode 142): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_CTLZ_ZERO_UNDEF (opcode 143): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_CTPOP (opcode 144): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_BSWAP (opcode 145): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FCEIL (opcode 146): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FCOS (opcode 147): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FSIN (opcode 148): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FSQRT (opcode 149): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FFLOOR (opcode 150): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FRINT (opcode 151): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FNEARBYINT (opcode 152): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_ADDRSPACE_CAST (opcode 153): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_BLOCK_ADDR (opcode 154): 1 type index
.. type index coverage check SKIPPED: no rules defined
	discovered a new reachable node %0
	discovered a new reachable node %0
MergeICmpsLegacyPass: doOper
	discovered a new reachable node %0
---- Branch Probability Info : doOper ----

Computing probabilities for 

block-frequency: doOper
=======================
reverse-post-order-traversal
 - 0: 
loop-detection
compute-mass-in-function
 - node: 
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - : float = 1.0, scaled = 8.0, int = 8
block-frequency-info: doOper
 - : float = 1.0, int = 8

********** Begin Constant Hoisting **********
********** Function: doOper
********** End Constant Hoisting **********
	discovered a new reachable node %0
*** Interleaved Access Pass: doOper
	discovered a new reachable node %0
---- Branch Probability Info : doOper ----

Computing probabilities for 

block-frequency: doOper
=======================
reverse-post-order-traversal
 - 0: 
loop-detection
compute-mass-in-function
 - node: 
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - : float = 1.0, scaled = 8.0, int = 8
block-frequency-info: doOper
 - : float = 1.0, int = 8

	discovered a new reachable node %0
	discovered a new reachable node %0
MergeICmpsLegacyPass: doOper1
	discovered a new reachable node %0
---- Branch Probability Info : doOper1 ----

Computing probabilities for 

block-frequency: doOper1
========================
reverse-post-order-traversal
 - 0: 
loop-detection
compute-mass-in-function
 - node: 
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - : float = 1.0, scaled = 8.0, int = 8
block-frequency-info: doOper1
 - : float = 1.0, int = 8

********** Begin Constant Hoisting **********
********** Function: doOper1
********** End Constant Hoisting **********
	discovered a new reachable node %0
*** Interleaved Access Pass: doOper1
	discovered a new reachable node %0
---- Branch Probability Info : doOper1 ----

Computing probabilities for 

block-frequency: doOper1
========================
reverse-post-order-traversal
 - 0: 
loop-detection
compute-mass-in-function
 - node: 
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - : float = 1.0, scaled = 8.0, int = 8
block-frequency-info: doOper1
 - : float = 1.0, int = 8

	discovered a new reachable node %0
[SafeStack] Function: doOper
[SafeStack]     safestack is not requested for this function
	discovered a new reachable node %0
	discovered a new reachable node %0
---- Branch Probability Info : doOper ----

Computing probabilities for 



=== doOper
Creating new node: t2: v16i32,ch = CopyFromReg t0, Register:v16i32 %0
Creating new node: t4: v16i32,ch = CopyFromReg t0, Register:v16i32 %1
Creating new node: t5: v16i32 = add t2, t4
Creating new node: t6: v16i32 = undef
Creating constant: t7: i64 = Constant<0>
Creating new node: t8: v8i32 = extract_subvector t5, Constant:i64<0>
Creating new node: t9: v8i32 = undef
Creating constant: t10: i32 = Constant<1>
Creating new node: t11: v8i32 = BUILD_VECTOR Constant:i32<1>, Constant:i32<1>, Constant:i32<1>, Constant:i32<1>, Constant:i32<1>, Constant:i32<1>, Constant:i32<1>, Constant:i32<1>
Creating new node: t12: v8i32 = add t8, t11
Creating constant: t13: i32 = TargetConstant<0>
Creating new node: t15: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t12
Creating new node: t16: ch = X86ISD::RET_FLAG t15, TargetConstant:i32<0>, Register:v8i32 $ymm0, t15:1
Initial selection DAG: %bb.0 'doOper:'
SelectionDAG has 17 nodes:
  t0: ch = EntryToken
  t6: v16i32 = undef
  t9: v8i32 = undef
          t2: v16i32,ch = CopyFromReg t0, Register:v16i32 %0
          t4: v16i32,ch = CopyFromReg t0, Register:v16i32 %1
        t5: v16i32 = add t2, t4
      t8: v8i32 = extract_subvector t5, Constant:i64<0>
      t11: v8i32 = BUILD_VECTOR Constant:i32<1>, Constant:i32<1>, Constant:i32<1>, Constant:i32<1>, Constant:i32<1>, Constant:i32<1>, Constant:i32<1>, Constant:i32<1>
    t12: v8i32 = add t8, t11
  t15: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t12
  t16: ch = X86ISD::RET_FLAG t15, TargetConstant:i32<0>, Register:v8i32 $ymm0, t15:1



Combining: t16: ch = X86ISD::RET_FLAG t15, TargetConstant:i32<0>, Register:v8i32 $ymm0, t15:1

Combining: t15: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t12

Combining: t14: v8i32 = Register $ymm0

Combining: t13: i32 = TargetConstant<0>

Combining: t12: v8i32 = add t8, t11
Creating constant: t17: i32 = Constant<-1>
Creating new node: t18: v8i32 = BUILD_VECTOR Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>
Creating new node: t19: v8i32 = sub t8, t18
 ... into: t19: v8i32 = sub t8, t18

Combining: t15: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t19

Combining: t19: v8i32 = sub t8, t18

Combining: t18: v8i32 = BUILD_VECTOR Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>

Combining: t17: i32 = Constant<-1>

Combining: t8: v8i32 = extract_subvector t5, Constant:i64<0>
Creating new node: t20: v8i32 = extract_subvector t2, Constant:i64<0>
Creating new node: t21: v8i32 = extract_subvector t4, Constant:i64<0>
Creating new node: t22: v8i32 = add t20, t21
 ... into: t22: v8i32 = add t20, t21

Combining: t19: v8i32 = sub t22, t18

Combining: t22: v8i32 = add t20, t21

Combining: t21: v8i32 = extract_subvector t4, Constant:i64<0>

Combining: t20: v8i32 = extract_subvector t2, Constant:i64<0>

Combining: t7: i64 = Constant<0>

Combining: t4: v16i32,ch = CopyFromReg t0, Register:v16i32 %1

Combining: t3: v16i32 = Register %1

Combining: t2: v16i32,ch = CopyFromReg t0, Register:v16i32 %0

Combining: t1: v16i32 = Register %0

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.0 'doOper:'
SelectionDAG has 16 nodes:
  t0: ch = EntryToken
          t2: v16i32,ch = CopyFromReg t0, Register:v16i32 %0
        t20: v8i32 = extract_subvector t2, Constant:i64<0>
          t4: v16i32,ch = CopyFromReg t0, Register:v16i32 %1
        t21: v8i32 = extract_subvector t4, Constant:i64<0>
      t22: v8i32 = add t20, t21
      t18: v8i32 = BUILD_VECTOR Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>
    t19: v8i32 = sub t22, t18
  t15: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t19
  t16: ch = X86ISD::RET_FLAG t15, TargetConstant:i32<0>, Register:v8i32 $ymm0, t15:1


Legalizing node: t17: i32 = Constant<-1>
Analyzing result type: i32
Legal result type
Legally typed node: t17: i32 = Constant<-1>

Legalizing node: t18: v8i32 = BUILD_VECTOR Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>
Analyzing result type: v8i32
Legal result type
Analyzing operand: t17: i32 = Constant<-1>
Legal operand
Analyzing operand: t17: i32 = Constant<-1>
Legal operand
Analyzing operand: t17: i32 = Constant<-1>
Legal operand
Analyzing operand: t17: i32 = Constant<-1>
Legal operand
Analyzing operand: t17: i32 = Constant<-1>
Legal operand
Analyzing operand: t17: i32 = Constant<-1>
Legal operand
Analyzing operand: t17: i32 = Constant<-1>
Legal operand
Analyzing operand: t17: i32 = Constant<-1>
Legal operand
Legally typed node: t18: v8i32 = BUILD_VECTOR Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>

Legalizing node: t14: v8i32 = Register $ymm0
Ignoring node results
Legally typed node: t14: v8i32 = Register $ymm0

Legalizing node: t13: i32 = TargetConstant<0>
Ignoring node results
Legally typed node: t13: i32 = TargetConstant<0>

Legalizing node: t7: i64 = Constant<0>
Analyzing result type: i64
Legal result type
Legally typed node: t7: i64 = Constant<0>

Legalizing node: t3: v16i32 = Register %1
Ignoring node results
Legally typed node: t3: v16i32 = Register %1

Legalizing node: t1: v16i32 = Register %0
Ignoring node results
Legally typed node: t1: v16i32 = Register %0

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: v16i32,ch = CopyFromReg t0, Register:v16i32 %0
Analyzing result type: v16i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t2: v16i32,ch = CopyFromReg t0, Register:v16i32 %0

Legalizing node: t20: v8i32 = extract_subvector t2, Constant:i64<0>
Analyzing result type: v8i32
Legal result type
Analyzing operand: t2: v16i32,ch = CopyFromReg t0, Register:v16i32 %0
Legal operand
Analyzing operand: t7: i64 = Constant<0>
Legal operand
Legally typed node: t20: v8i32 = extract_subvector t2, Constant:i64<0>

Legalizing node: t4: v16i32,ch = CopyFromReg t0, Register:v16i32 %1
Analyzing result type: v16i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t4: v16i32,ch = CopyFromReg t0, Register:v16i32 %1

Legalizing node: t21: v8i32 = extract_subvector t4, Constant:i64<0>
Analyzing result type: v8i32
Legal result type
Analyzing operand: t4: v16i32,ch = CopyFromReg t0, Register:v16i32 %1
Legal operand
Analyzing operand: t7: i64 = Constant<0>
Legal operand
Legally typed node: t21: v8i32 = extract_subvector t4, Constant:i64<0>

Legalizing node: t22: v8i32 = add t20, t21
Analyzing result type: v8i32
Legal result type
Analyzing operand: t20: v8i32 = extract_subvector t2, Constant:i64<0>
Legal operand
Analyzing operand: t21: v8i32 = extract_subvector t4, Constant:i64<0>
Legal operand
Legally typed node: t22: v8i32 = add t20, t21

Legalizing node: t19: v8i32 = sub t22, t18
Analyzing result type: v8i32
Legal result type
Analyzing operand: t22: v8i32 = add t20, t21
Legal operand
Analyzing operand: t18: v8i32 = BUILD_VECTOR Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>
Legal operand
Legally typed node: t19: v8i32 = sub t22, t18

Legalizing node: t15: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t19
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t19: v8i32 = sub t22, t18
Legal operand
Legally typed node: t15: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t19

Legalizing node: t16: ch = X86ISD::RET_FLAG t15, TargetConstant:i32<0>, Register:v8i32 $ymm0, t15:1
Analyzing result type: ch
Legal result type
Analyzing operand: t15: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t19
Legal operand
Analyzing operand: t15: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t19
Legal operand
Legally typed node: t16: ch = X86ISD::RET_FLAG t15, TargetConstant:i32<0>, Register:v8i32 $ymm0, t15:1

Legalizing node: t65535: ch = handlenode t16
Analyzing result type: ch
Legal result type
Analyzing operand: t16: ch = X86ISD::RET_FLAG t15, TargetConstant:i32<0>, Register:v8i32 $ymm0, t15:1
Legal operand
Legally typed node: t65535: ch = handlenode t16

Type-legalized selection DAG: %bb.0 'doOper:'
SelectionDAG has 16 nodes:
  t0: ch = EntryToken
          t2: v16i32,ch = CopyFromReg t0, Register:v16i32 %0
        t20: v8i32 = extract_subvector t2, Constant:i64<0>
          t4: v16i32,ch = CopyFromReg t0, Register:v16i32 %1
        t21: v8i32 = extract_subvector t4, Constant:i64<0>
      t22: v8i32 = add t20, t21
      t18: v8i32 = BUILD_VECTOR Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>
    t19: v8i32 = sub t22, t18
  t15: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t19
  t16: ch = X86ISD::RET_FLAG t15, TargetConstant:i32<0>, Register:v8i32 $ymm0, t15:1



Legalizing vector op: t22: v8i32 = add t20, t21
Legal node: nothing to do

Legalizing vector op: t19: v8i32 = sub t22, t18
Legal node: nothing to do

Legalizing: t16: ch = X86ISD::RET_FLAG t15, TargetConstant:i32<0>, Register:v8i32 $ymm0, t15:1
Legal node: nothing to do

Legalizing: t15: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t19
Legal node: nothing to do

Legalizing: t19: v8i32 = sub t22, t18
Legal node: nothing to do

Legalizing: t22: v8i32 = add t20, t21
Legal node: nothing to do

Legalizing: t21: v8i32 = extract_subvector t4, Constant:i64<0>
Legal node: nothing to do

Legalizing: t20: v8i32 = extract_subvector t2, Constant:i64<0>
Legal node: nothing to do

Legalizing: t18: v8i32 = BUILD_VECTOR Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>
Trying custom legalization

Legalizing: t4: v16i32,ch = CopyFromReg t0, Register:v16i32 %1
Legal node: nothing to do

Legalizing: t2: v16i32,ch = CopyFromReg t0, Register:v16i32 %0
Legal node: nothing to do

Legalizing: t17: i32 = Constant<-1>
Legal node: nothing to do

Legalizing: t14: v8i32 = Register $ymm0

Legalizing: t13: i32 = TargetConstant<0>

Legalizing: t7: i64 = Constant<0>
Legal node: nothing to do

Legalizing: t3: v16i32 = Register %1

Legalizing: t1: v16i32 = Register %0

Legalizing: t0: ch = EntryToken
Legal node: nothing to do
Legalized selection DAG: %bb.0 'doOper:'
SelectionDAG has 16 nodes:
  t0: ch = EntryToken
          t2: v16i32,ch = CopyFromReg t0, Register:v16i32 %0
        t20: v8i32 = extract_subvector t2, Constant:i64<0>
          t4: v16i32,ch = CopyFromReg t0, Register:v16i32 %1
        t21: v8i32 = extract_subvector t4, Constant:i64<0>
      t22: v8i32 = add t20, t21
      t18: v8i32 = BUILD_VECTOR Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>
    t19: v8i32 = sub t22, t18
  t15: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t19
  t16: ch = X86ISD::RET_FLAG t15, TargetConstant:i32<0>, Register:v8i32 $ymm0, t15:1



Legalizing: t16: ch = X86ISD::RET_FLAG t15, TargetConstant:i32<0>, Register:v8i32 $ymm0, t15:1
Legal node: nothing to do

Combining: t16: ch = X86ISD::RET_FLAG t15, TargetConstant:i32<0>, Register:v8i32 $ymm0, t15:1

Legalizing: t15: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t19
Legal node: nothing to do

Combining: t15: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t19

Legalizing: t19: v8i32 = sub t22, t18
Legal node: nothing to do

Combining: t19: v8i32 = sub t22, t18

Legalizing: t22: v8i32 = add t20, t21
Legal node: nothing to do

Combining: t22: v8i32 = add t20, t21

Legalizing: t21: v8i32 = extract_subvector t4, Constant:i64<0>
Legal node: nothing to do

Combining: t21: v8i32 = extract_subvector t4, Constant:i64<0>

Legalizing: t20: v8i32 = extract_subvector t2, Constant:i64<0>
Legal node: nothing to do

Combining: t20: v8i32 = extract_subvector t2, Constant:i64<0>

Legalizing: t18: v8i32 = BUILD_VECTOR Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>
Trying custom legalization

Combining: t18: v8i32 = BUILD_VECTOR Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>

Legalizing: t4: v16i32,ch = CopyFromReg t0, Register:v16i32 %1
Legal node: nothing to do

Combining: t4: v16i32,ch = CopyFromReg t0, Register:v16i32 %1

Legalizing: t2: v16i32,ch = CopyFromReg t0, Register:v16i32 %0
Legal node: nothing to do

Combining: t2: v16i32,ch = CopyFromReg t0, Register:v16i32 %0

Legalizing: t17: i32 = Constant<-1>
Legal node: nothing to do

Combining: t17: i32 = Constant<-1>

Legalizing: t14: v8i32 = Register $ymm0

Combining: t14: v8i32 = Register $ymm0

Legalizing: t13: i32 = TargetConstant<0>

Combining: t13: i32 = TargetConstant<0>

Legalizing: t7: i64 = Constant<0>
Legal node: nothing to do

Combining: t7: i64 = Constant<0>

Legalizing: t3: v16i32 = Register %1

Combining: t3: v16i32 = Register %1

Legalizing: t1: v16i32 = Register %0

Combining: t1: v16i32 = Register %0

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.0 'doOper:'
SelectionDAG has 16 nodes:
  t0: ch = EntryToken
          t2: v16i32,ch = CopyFromReg t0, Register:v16i32 %0
        t20: v8i32 = extract_subvector t2, Constant:i64<0>
          t4: v16i32,ch = CopyFromReg t0, Register:v16i32 %1
        t21: v8i32 = extract_subvector t4, Constant:i64<0>
      t22: v8i32 = add t20, t21
      t18: v8i32 = BUILD_VECTOR Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>
    t19: v8i32 = sub t22, t18
  t15: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t19
  t16: ch = X86ISD::RET_FLAG t15, TargetConstant:i32<0>, Register:v8i32 $ymm0, t15:1


===== Instruction selection begins: %bb.0 ''

ISEL: Starting selection on root node: t16: ch = X86ISD::RET_FLAG t15, TargetConstant:i32<0>, Register:v8i32 $ymm0, t15:1
ISEL: Starting pattern match
  Morphed node: t16: ch = RET TargetConstant:i32<0>, Register:v8i32 $ymm0, t15, t15:1
ISEL: Match complete!

ISEL: Starting selection on root node: t15: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t19

ISEL: Starting selection on root node: t19: v8i32 = sub t22, t18
ISEL: Starting pattern match
  Initial Opcode index to 99902
  Match failed at index 99906
  Continuing at 100009
  Match failed at index 100011
  Continuing at 100067
  Match failed at index 100071
  Continuing at 100202
  Match failed at index 100203
  Continuing at 100248
  Match failed at index 100258
  Continuing at 100374
  Match failed at index 100375
  Continuing at 100386
  Match failed at index 100387
  Continuing at 100398
  Match failed at index 100399
  Continuing at 100410
  Match failed at index 100411
  Continuing at 100422
  Continuing at 100423
  Match failed at index 100426
  Continuing at 101111
  TypeSwitch[v8i32] from 101114 to 101280
  Skipped scope entry (due to false predicate) at index 101282, continuing at 101292
  Morphed node: t19: v8i32 = VPSUBDZ256rr t22, t18
ISEL: Match complete!

ISEL: Starting selection on root node: t22: v8i32 = add t20, t21
ISEL: Starting pattern match
  Initial Opcode index to 97192
  Match failed at index 97196
  Continuing at 97299
  Match failed at index 97301
  Continuing at 97408
  Match failed at index 97410
  Continuing at 97466
  Match failed at index 97469
  Continuing at 97490
  Match failed at index 97492
  Continuing at 97514
  Skipped scope entry (due to false predicate) at index 97519, continuing at 97571
  Skipped scope entry (due to false predicate) at index 97572, continuing at 97633
  Skipped scope entry (due to false predicate) at index 97634, continuing at 97708
  Skipped scope entry (due to false predicate) at index 97709, continuing at 97738
  Match failed at index 97744
  Continuing at 97860
  Match failed at index 97861
  Continuing at 97872
  Match failed at index 97873
  Continuing at 97884
  Match failed at index 97885
  Continuing at 97896
  Match failed at index 97897
  Continuing at 97908
  Continuing at 97909
  Continuing at 97910
  Match failed at index 97912
  Continuing at 97978
  Match failed at index 97982
  Continuing at 98133
  Match failed at index 98136
  Continuing at 98289
  Match failed at index 98293
  Continuing at 98891
  Match failed at index 98894
  Continuing at 99511
  Match failed at index 99517
  Continuing at 99591
  TypeSwitch[v8i32] from 99594 to 99760
  Skipped scope entry (due to false predicate) at index 99762, continuing at 99772
  Morphed node: t22: v8i32 = VPADDDZ256rr t20, t21
ISEL: Match complete!

ISEL: Starting selection on root node: t21: v8i32 = extract_subvector t4, Constant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 495959
  Skipped scope entry (due to false predicate) at index 495965, continuing at 495984
  Skipped scope entry (due to false predicate) at index 495985, continuing at 496019
  Skipped scope entry (due to false predicate) at index 496020, continuing at 496067
  Skipped scope entry (due to false predicate) at index 496068, continuing at 496128
  Skipped scope entry (due to false predicate) at index 496129, continuing at 496202
  Skipped scope entry (due to false predicate) at index 496203, continuing at 496276
  Match failed at index 496284
  Continuing at 496297
  Match failed at index 496298
  Continuing at 496315
  Match failed at index 496316
  Continuing at 496333
  Match failed at index 496334
  Continuing at 496351
  Match failed at index 496352
  Continuing at 496369
  Match failed at index 496374
  Continuing at 496387
  Match failed at index 496388
  Continuing at 496405
  Match failed at index 496406
  Continuing at 496423
  Match failed at index 496424
  Continuing at 496441
  TypeSwitch[v8i32] from 496444 to 496447
Creating constant: t23: i32 = TargetConstant<10>
  Morphed node: t21: v8i32 = EXTRACT_SUBREG t4, TargetConstant:i32<10>
ISEL: Match complete!

ISEL: Starting selection on root node: t20: v8i32 = extract_subvector t2, Constant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 495959
  Skipped scope entry (due to false predicate) at index 495965, continuing at 495984
  Skipped scope entry (due to false predicate) at index 495985, continuing at 496019
  Skipped scope entry (due to false predicate) at index 496020, continuing at 496067
  Skipped scope entry (due to false predicate) at index 496068, continuing at 496128
  Skipped scope entry (due to false predicate) at index 496129, continuing at 496202
  Skipped scope entry (due to false predicate) at index 496203, continuing at 496276
  Match failed at index 496284
  Continuing at 496297
  Match failed at index 496298
  Continuing at 496315
  Match failed at index 496316
  Continuing at 496333
  Match failed at index 496334
  Continuing at 496351
  Match failed at index 496352
  Continuing at 496369
  Match failed at index 496374
  Continuing at 496387
  Match failed at index 496388
  Continuing at 496405
  Match failed at index 496406
  Continuing at 496423
  Match failed at index 496424
  Continuing at 496441
  TypeSwitch[v8i32] from 496444 to 496447
  Morphed node: t20: v8i32 = EXTRACT_SUBREG t2, TargetConstant:i32<10>
ISEL: Match complete!

ISEL: Starting selection on root node: t18: v8i32 = BUILD_VECTOR Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>, Constant:i32<-1>
ISEL: Starting pattern match
  Initial Opcode index to 501406
  Match failed at index 501409
  Continuing at 501588
  TypeSwitch[v8i32] from 501591 to 501602
  Skipped scope entry (due to false predicate) at index 501604, continuing at 501612
  Morphed node: t18: v8i32 = AVX2_SETALLONES
ISEL: Match complete!

ISEL: Starting selection on root node: t4: v16i32,ch = CopyFromReg t0, Register:v16i32 %1

ISEL: Starting selection on root node: t2: v16i32,ch = CopyFromReg t0, Register:v16i32 %0

ISEL: Starting selection on root node: t14: v8i32 = Register $ymm0

ISEL: Starting selection on root node: t13: i32 = TargetConstant<0>

ISEL: Starting selection on root node: t3: v16i32 = Register %1

ISEL: Starting selection on root node: t1: v16i32 = Register %0

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.0 'doOper:'
SelectionDAG has 15 nodes:
  t0: ch = EntryToken
          t2: v16i32,ch = CopyFromReg t0, Register:v16i32 %0
        t20: v8i32 = EXTRACT_SUBREG t2, TargetConstant:i32<10>
          t4: v16i32,ch = CopyFromReg t0, Register:v16i32 %1
        t21: v8i32 = EXTRACT_SUBREG t4, TargetConstant:i32<10>
      t22: v8i32 = VPADDDZ256rr t20, t21
    t19: v8i32 = VPSUBDZ256rr t22, AVX2_SETALLONES:v8i32
  t15: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t19
  t16: ch = RET TargetConstant:i32<0>, Register:v8i32 $ymm0, t15, t15:1


********** List Scheduling %bb.0 '' **********
SU(0): t16: ch = RET TargetConstant:i32<0>, Register:v8i32 $ymm0, t15, t15:1

    t15: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t19

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1
SU(1): t19: v8i32 = VPSUBDZ256rr t22, AVX2_SETALLONES:v8i32

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 1
  Predecessors:
    SU(3): Data Latency=1
    SU(2): Data Latency=1
  Successors:
    SU(0): Data Latency=1
SU(2): t18: v8i32 = AVX2_SETALLONES

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1
SU(3): t22: v8i32 = VPADDDZ256rr t20, t21

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(6): Data Latency=1
    SU(4): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(4): t21: v8i32 = EXTRACT_SUBREG t4, TargetConstant:i32<10>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(3): Data Latency=1
SU(5): t4: v16i32,ch = CopyFromReg t0, Register:v16i32 %1

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(4): Data Latency=1
SU(6): t20: v8i32 = EXTRACT_SUBREG t2, TargetConstant:i32<10>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(7): Data Latency=1
  Successors:
    SU(3): Data Latency=1
SU(7): t2: v16i32,ch = CopyFromReg t0, Register:v16i32 %0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(6): Data Latency=1

Examining Available:
Height 0: SU(0): t16: ch = RET TargetConstant:i32<0>, Register:v8i32 $ymm0, t15, t15:1

    t15: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t19


*** Scheduling [0]: SU(0): t16: ch = RET TargetConstant:i32<0>, Register:v8i32 $ymm0, t15, t15:1

    t15: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t19


Examining Available:
Height 1: SU(1): t19: v8i32 = VPSUBDZ256rr t22, AVX2_SETALLONES:v8i32


*** Scheduling [1]: SU(1): t19: v8i32 = VPSUBDZ256rr t22, AVX2_SETALLONES:v8i32


Examining Available:
Height 2: SU(2): t18: v8i32 = AVX2_SETALLONES

Height 2: SU(3): t22: v8i32 = VPADDDZ256rr t20, t21


*** Scheduling [2]: SU(2): t18: v8i32 = AVX2_SETALLONES


Examining Available:
Height 2: SU(3): t22: v8i32 = VPADDDZ256rr t20, t21


*** Scheduling [3]: SU(3): t22: v8i32 = VPADDDZ256rr t20, t21


Examining Available:
Height 4: SU(6): t20: v8i32 = EXTRACT_SUBREG t2, TargetConstant:i32<10>

Height 4: SU(4): t21: v8i32 = EXTRACT_SUBREG t4, TargetConstant:i32<10>


*** Scheduling [4]: SU(6): t20: v8i32 = EXTRACT_SUBREG t2, TargetConstant:i32<10>


Examining Available:
Height 4: SU(4): t21: v8i32 = EXTRACT_SUBREG t4, TargetConstant:i32<10>

Height 5: SU(7): t2: v16i32,ch = CopyFromReg t0, Register:v16i32 %0


*** Scheduling [5]: SU(4): t21: v8i32 = EXTRACT_SUBREG t4, TargetConstant:i32<10>


Examining Available:
Height 6: SU(5): t4: v16i32,ch = CopyFromReg t0, Register:v16i32 %1

Height 5: SU(7): t2: v16i32,ch = CopyFromReg t0, Register:v16i32 %0


*** Scheduling [6]: SU(5): t4: v16i32,ch = CopyFromReg t0, Register:v16i32 %1


Examining Available:
Height 5: SU(7): t2: v16i32,ch = CopyFromReg t0, Register:v16i32 %0


*** Scheduling [7]: SU(7): t2: v16i32,ch = CopyFromReg t0, Register:v16i32 %0

*** Final schedule ***
SU(7): t2: v16i32,ch = CopyFromReg t0, Register:v16i32 %0

SU(5): t4: v16i32,ch = CopyFromReg t0, Register:v16i32 %1

SU(4): t21: v8i32 = EXTRACT_SUBREG t4, TargetConstant:i32<10>

SU(6): t20: v8i32 = EXTRACT_SUBREG t2, TargetConstant:i32<10>

SU(3): t22: v8i32 = VPADDDZ256rr t20, t21

SU(2): t18: v8i32 = AVX2_SETALLONES

SU(1): t19: v8i32 = VPSUBDZ256rr t22, AVX2_SETALLONES:v8i32

SU(0): t16: ch = RET TargetConstant:i32<0>, Register:v8i32 $ymm0, t15, t15:1

    t15: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t19


Total amount of phi nodes to update: 0
*** MachineFunction at end of ISel ***
# Machine code for function doOper: IsSSA, TracksLiveness
Function Live Ins: $zmm31 in %0, $zmm30 in %1

bb.0 (%ir-block.0):
  liveins: $zmm31, $zmm30
  %1:vr512 = COPY $zmm30
  %0:vr512 = COPY $zmm31
  %2:vr256x = COPY %1.sub_ymm:vr512
  %3:vr256x = COPY %0.sub_ymm:vr512
  %4:vr256x = VPADDDZ256rr killed %3:vr256x, killed %2:vr256x
  %5:vr256 = AVX2_SETALLONES
  %6:vr256x = VPSUBDZ256rr killed %4:vr256x, killed %5:vr256
  $ymm0 = COPY %6:vr256x
  RET 0, $ymm0

# End machine code for function doOper.

	discovered a new reachable node %bb.0
***** Machine Function before Domain Reassignment *****
# Machine code for function doOper: IsSSA, TracksLiveness
Function Live Ins: $zmm31 in %0, $zmm30 in %1

bb.0 (%ir-block.0):
  liveins: $zmm31, $zmm30
  %1:vr512 = COPY $zmm30
  %0:vr512 = COPY $zmm31
  %2:vr256x = COPY %1.sub_ymm:vr512
  %3:vr256x = COPY %0.sub_ymm:vr512
  %4:vr256x = VPADDDZ256rr killed %3:vr256x, killed %2:vr256x
  %5:vr256 = AVX2_SETALLONES
  %6:vr256x = VPSUBDZ256rr killed %4:vr256x, killed %5:vr256
  $ymm0 = COPY %6:vr256x
  RET 0, $ymm0

# End machine code for function doOper.

***** Machine Function after Domain Reassignment *****
# Machine code for function doOper: IsSSA, TracksLiveness
Function Live Ins: $zmm31 in %0, $zmm30 in %1

bb.0 (%ir-block.0):
  liveins: $zmm31, $zmm30
  %1:vr512 = COPY $zmm30
  %0:vr512 = COPY $zmm31
  %2:vr256x = COPY %1.sub_ymm:vr512
  %3:vr256x = COPY %0.sub_ymm:vr512
  %4:vr256x = VPADDDZ256rr killed %3:vr256x, killed %2:vr256x
  %5:vr256 = AVX2_SETALLONES
  %6:vr256x = VPSUBDZ256rr killed %4:vr256x, killed %5:vr256
  $ymm0 = COPY %6:vr256x
  RET 0, $ymm0

# End machine code for function doOper.

# Machine code for function doOper: IsSSA, TracksLiveness
Function Live Ins: $zmm31 in %0, $zmm30 in %1

0B	bb.0 (%ir-block.0):
	  liveins: $zmm31, $zmm30
16B	  %1:vr512 = COPY $zmm30
32B	  %0:vr512 = COPY $zmm31
48B	  %2:vr256x = COPY %1.sub_ymm:vr512
64B	  %3:vr256x = COPY %0.sub_ymm:vr512
80B	  %4:vr256x = VPADDDZ256rr killed %3:vr256x, killed %2:vr256x
96B	  %5:vr256 = AVX2_SETALLONES
112B	  %6:vr256x = VPSUBDZ256rr killed %4:vr256x, killed %5:vr256
128B	  $ymm0 = COPY %6:vr256x
144B	  RET 0, $ymm0

# End machine code for function doOper.

********** Stack Coloring **********
********** Function: doOper
	discovered a new reachable node %bb.0
********** EARLY IF-CONVERSION **********
********** Function: doOper
Machine InstCombiner: doOper
Combining MBB 
********** X86 cmov Conversion : doOper**********
	discovered a new reachable node %bb.0
******** Pre-regalloc Machine LICM: doOper ********
Entering: 
Exiting: 
		Looking for trivial roots
Found a new trivial root: %bb.0
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.0
Found roots: %bb.0 
	discovered a new reachable node nullptr
	discovered a new reachable node %bb.0

block-frequency: doOper
=======================
reverse-post-order-traversal
 - 0: BB0[]
loop-detection
compute-mass-in-function
 - node: BB0[]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: doOper
 - BB0[]: float = 1.0, int = 8

******** Machine Sinking ********
********** PEEPHOLE OPTIMIZER **********
********** Function: doOper
**** Analysing doOper
Start X86AvoidStoreForwardBlocks
End X86AvoidStoreForwardBlocks
********** X86 speculative load hardening : doOper **********
	discovered a new reachable node %bb.0
********** X86 EFLAGS copy lowering : doOper **********
Skipping Detect dead lanes pass
********** PROCESS IMPLICIT DEFS **********
********** Function: doOper
	discovered a new reachable node %bb.0
********** REWRITING TWO-ADDR INSTRS **********
********** Function: doOper
# Machine code for function doOper: NoPHIs, TracksLiveness
Function Live Ins: $zmm31 in %0, $zmm30 in %1

0B	bb.0 (%ir-block.0):
	  liveins: $zmm31, $zmm30
16B	  %1:vr512 = COPY killed $zmm30
32B	  %0:vr512 = COPY killed $zmm31
48B	  %2:vr256x = COPY killed %1.sub_ymm:vr512
64B	  %3:vr256x = COPY killed %0.sub_ymm:vr512
80B	  %4:vr256x = VPADDDZ256rr killed %3:vr256x, killed %2:vr256x
96B	  %5:vr256 = AVX2_SETALLONES
112B	  %6:vr256x = VPSUBDZ256rr killed %4:vr256x, killed %5:vr256
128B	  $ymm0 = COPY killed %6:vr256x
144B	  RET 0, killed $ymm0

# End machine code for function doOper.

Computing live-in reg-units in ABI blocks.
0B	%bb.0 XMM31#0 XMM30#0
Created 2 new intervals.
********** INTERVALS **********
XMM30 [0B,16r:0)  0@0B-phi
XMM31 [0B,32r:0)  0@0B-phi
%0 [32r,64r:0)  0@32r weight:0.000000e+00
%1 [16r,48r:0)  0@16r weight:0.000000e+00
%2 [48r,80r:0)  0@48r weight:0.000000e+00
%3 [64r,80r:0)  0@64r weight:0.000000e+00
%4 [80r,112r:0)  0@80r weight:0.000000e+00
%5 [96r,112r:0)  0@96r weight:0.000000e+00
%6 [112r,128r:0)  0@112r weight:0.000000e+00
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function doOper: NoPHIs, TracksLiveness
Function Live Ins: $zmm31 in %0, $zmm30 in %1

0B	bb.0 (%ir-block.0):
	  liveins: $zmm31, $zmm30
16B	  %1:vr512 = COPY $zmm30
32B	  %0:vr512 = COPY $zmm31
48B	  %2:vr256x = COPY %1.sub_ymm:vr512
64B	  %3:vr256x = COPY %0.sub_ymm:vr512
80B	  %4:vr256x = VPADDDZ256rr %3:vr256x, %2:vr256x
96B	  %5:vr256 = AVX2_SETALLONES
112B	  %6:vr256x = VPSUBDZ256rr %4:vr256x, %5:vr256
128B	  $ymm0 = COPY %6:vr256x
144B	  RET 0, killed $ymm0

# End machine code for function doOper.

********** SIMPLE REGISTER COALESCING **********
********** Function: doOper
********** JOINING INTERVALS ***********
:
16B	%1:vr512 = COPY $zmm30
	Considering merging %1 with $zmm30
	Can only merge into reserved registers.
32B	%0:vr512 = COPY $zmm31
	Considering merging %0 with $zmm31
	Can only merge into reserved registers.
128B	$ymm0 = COPY %6:vr256x
	Considering merging %6 with $ymm0
	Can only merge into reserved registers.
48B	%2:vr256x = COPY %1.sub_ymm:vr512
	Considering merging to VR512 with %2 in %1:sub_ymm
		RHS = %2 [48r,80r:0)  0@48r weight:0.000000e+00
		LHS = %1 [16r,48r:0)  0@16r weight:0.000000e+00
		merge %2:0@48r into %1:0@16r --> @16r
		erased:	48r	%2:vr256x = COPY %1.sub_ymm:vr512
AllocationOrder(VR512) = [ $zmm31 $zmm30 $zmm29 $zmm28 $zmm27 $zmm26 $zmm25 $zmm24 $zmm23 $zmm22 $zmm21 $zmm20 $zmm19 $zmm18 $zmm17 $zmm16 $zmm15 $zmm14 $zmm13 $zmm12 $zmm11 $zmm10 $zmm9 $zmm8 $zmm7 $zmm6 $zmm5 $zmm4 $zmm3 $zmm2 $zmm1 $zmm0 ]
		updated: 80B	%4:vr256x = VPADDDZ256rr %3:vr256x, %1.sub_ymm:vr512
	Success: %2:sub_ymm -> %1
	Result = %1 [16r,80r:0)  0@16r weight:0.000000e+00
64B	%3:vr256x = COPY %0.sub_ymm:vr512
	Considering merging to VR512 with %3 in %0:sub_ymm
		RHS = %3 [64r,80r:0)  0@64r weight:0.000000e+00
		LHS = %0 [32r,64r:0)  0@32r weight:0.000000e+00
		merge %3:0@64r into %0:0@32r --> @32r
		erased:	64r	%3:vr256x = COPY %0.sub_ymm:vr512
		updated: 80B	%4:vr256x = VPADDDZ256rr %0.sub_ymm:vr512, %1.sub_ymm:vr512
	Success: %3:sub_ymm -> %0
	Result = %0 [32r,80r:0)  0@32r weight:0.000000e+00
Trying to inflate 0 regs.
********** INTERVALS **********
XMM30 [0B,16r:0)  0@0B-phi
XMM31 [0B,32r:0)  0@0B-phi
%0 [32r,80r:0)  0@32r weight:0.000000e+00
%1 [16r,80r:0)  0@16r weight:0.000000e+00
%4 [80r,112r:0)  0@80r weight:0.000000e+00
%5 [96r,112r:0)  0@96r weight:0.000000e+00
%6 [112r,128r:0)  0@112r weight:0.000000e+00
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function doOper: NoPHIs, TracksLiveness
Function Live Ins: $zmm31 in %0, $zmm30 in %1

0B	bb.0 (%ir-block.0):
	  liveins: $zmm31, $zmm30
16B	  %1:vr512 = COPY $zmm30
32B	  %0:vr512 = COPY $zmm31
80B	  %4:vr256x = VPADDDZ256rr %0.sub_ymm:vr512, %1.sub_ymm:vr512
96B	  %5:vr256 = AVX2_SETALLONES
112B	  %6:vr256x = VPSUBDZ256rr %4:vr256x, %5:vr256
128B	  $ymm0 = COPY %6:vr256x
144B	  RET 0, killed $ymm0

# End machine code for function doOper.

Before MISched:
# Machine code for function doOper: NoPHIs, TracksLiveness
Function Live Ins: $zmm31 in %0, $zmm30 in %1

bb.0 (%ir-block.0):
  liveins: $zmm31, $zmm30
  %1:vr512 = COPY $zmm30
  %0:vr512 = COPY $zmm31
  %4:vr256x = VPADDDZ256rr %0.sub_ymm:vr512, %1.sub_ymm:vr512
  %5:vr256 = AVX2_SETALLONES
  %6:vr256x = VPSUBDZ256rr %4:vr256x, %5:vr256
  $ymm0 = COPY %6:vr256x
  RET 0, killed $ymm0

# End machine code for function doOper.

AllocationOrder(GR32) = [ $eax $ecx $edx $esi $edi $r8d $r9d $r10d $r11d $ebx $ebp $r14d $r15d $r12d $r13d ]
AllocationOrder(GR16) = [ $ax $cx $dx $si $di $r8w $r9w $r10w $r11w $bx $bp $r14w $r15w $r12w $r13w ]
AllocationOrder(GR8) = [ $al $cl $dl $sil $dil $r8b $r9b $r10b $r11b $bl $bpl $r14b $r15b $r12b $r13b ]
********** MI Scheduling **********
doOper:%bb.0 
  From: %1:vr512 = COPY $zmm30
    To: RET 0, killed $ymm0
 RegionInstrs: 6
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
Disabled scoreboard hazard recognizer
Disabled scoreboard hazard recognizer
SU(0):   %1:vr512 = COPY $zmm30
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 2
  Successors:
    SU(2): Data Latency=0 Reg=%1
  Single Issue       : false;
SU(1):   %0:vr512 = COPY $zmm31
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 2
  Successors:
    SU(2): Data Latency=0 Reg=%0
  Single Issue       : false;
SU(2):   %4:vr256x = VPADDDZ256rr %0.sub_ymm:vr512, %1.sub_ymm:vr512
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 2
  Predecessors:
    SU(1): Data Latency=0 Reg=%0
    SU(0): Data Latency=0 Reg=%1
  Successors:
    SU(4): Data Latency=1 Reg=%4
  Single Issue       : false;
SU(3):   %5:vr256 = AVX2_SETALLONES
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(4): Data Latency=1 Reg=%5
  Single Issue       : false;
SU(4):   %6:vr256x = VPSUBDZ256rr %4:vr256x, %5:vr256
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(3): Data Latency=1 Reg=%5
    SU(2): Data Latency=1 Reg=%4
  Successors:
    SU(5): Data Latency=1 Reg=%6
  Single Issue       : false;
SU(5):   $ymm0 = COPY %6:vr256x
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 2
  Height             : 0
  Predecessors:
    SU(4): Data Latency=1 Reg=%6
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   RET 0, killed $ymm0
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 2
  Height             : 0
  Predecessors:
    SU(5): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 2
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 5 
Scheduling SU(5) $ymm0 = COPY %6:vr256x
  Ready @0c
  BotQ.A TopLatency SU(5) 2c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 
Scheduling SU(4) %6:vr256x = VPSUBDZ256rr %4:vr256x, %5:vr256
  Ready @1c
  SKXPort015 +1x8u
  *** Critical resource SKXPort015: 0c
  SKXPort0156 +1x6u
  SKXPortAny +1x3u
  BotQ.A BotLatency SU(4) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKXPort015
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 2 
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %5:vr256 = AVX2_SETALLONES
  Ready @2c
  BotQ.A BotLatency SU(3) 2c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 1 SKXPort015
  ExpectedLatency: 2c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) %4:vr256x = VPADDDZ256rr %0.sub_ymm:vr512, %1.sub_ymm:vr512
  Ready @2c
  SKXPort015 +1x8u
  SKXPort0156 +1x6u
  SKXPortAny +1x3u
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 2 SKXPort015
  ExpectedLatency: 2c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %0:vr512 = COPY $zmm31
  Ready @2c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 2 SKXPort015
  ExpectedLatency: 2c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %1:vr512 = COPY $zmm30
  Ready @2c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 2 SKXPort015
  ExpectedLatency: 2c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.0 ***
SU(0):   %1:vr512 = COPY $zmm30
SU(1):   %0:vr512 = COPY $zmm31
SU(2):   %4:vr256x = VPADDDZ256rr %0.sub_ymm:vr512, %1.sub_ymm:vr512
SU(3):   %5:vr256 = AVX2_SETALLONES
SU(4):   %6:vr256x = VPSUBDZ256rr %4:vr256x, %5:vr256
SU(5):   $ymm0 = COPY %6:vr256x

********** INTERVALS **********
XMM30 [0B,16r:0)  0@0B-phi
XMM31 [0B,32r:0)  0@0B-phi
%0 [32r,80r:0)  0@32r weight:0.000000e+00
%1 [16r,80r:0)  0@16r weight:0.000000e+00
%4 [80r,112r:0)  0@80r weight:0.000000e+00
%5 [96r,112r:0)  0@96r weight:0.000000e+00
%6 [112r,128r:0)  0@112r weight:0.000000e+00
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function doOper: NoPHIs, TracksLiveness
Function Live Ins: $zmm31 in %0, $zmm30 in %1

0B	bb.0 (%ir-block.0):
	  liveins: $zmm31, $zmm30
16B	  %1:vr512 = COPY $zmm30
32B	  %0:vr512 = COPY $zmm31
80B	  %4:vr256x = VPADDDZ256rr %0.sub_ymm:vr512, %1.sub_ymm:vr512
96B	  %5:vr256 = AVX2_SETALLONES
112B	  %6:vr256x = VPSUBDZ256rr %4:vr256x, %5:vr256
128B	  $ymm0 = COPY %6:vr256x
144B	  RET 0, killed $ymm0

# End machine code for function doOper.


block-frequency: doOper
=======================
reverse-post-order-traversal
 - 0: BB0[]
loop-detection
compute-mass-in-function
 - node: BB0[]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: doOper
 - BB0[]: float = 1.0, int = 8

********** GREEDY REGISTER ALLOCATION **********
********** Function: doOper
********** Compute Spill Weights **********
********** Function: doOper
********** INTERVALS **********
XMM30 [0B,16r:0)  0@0B-phi
XMM31 [0B,32r:0)  0@0B-phi
%0 [32r,80r:0)  0@32r weight:INF
%1 [16r,80r:0)  0@16r weight:4.353448e-03
%4 [80r,112r:0)  0@80r weight:4.629630e-03
%5 [96r,112r:0)  0@96r weight:INF
%6 [112r,128r:0)  0@112r weight:INF
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function doOper: NoPHIs, TracksLiveness
Function Live Ins: $zmm31 in %0, $zmm30 in %1

0B	bb.0 (%ir-block.0):
	  liveins: $zmm31, $zmm30
16B	  %1:vr512 = COPY $zmm30
32B	  %0:vr512 = COPY $zmm31
80B	  %4:vr256x = VPADDDZ256rr %0.sub_ymm:vr512, %1.sub_ymm:vr512
96B	  %5:vr256 = AVX2_SETALLONES
112B	  %6:vr256x = VPSUBDZ256rr %4:vr256x, %5:vr256
128B	  $ymm0 = COPY %6:vr256x
144B	  RET 0, killed $ymm0

# End machine code for function doOper.


selectOrSplit VR512:%1 [16r,80r:0)  0@16r weight:4.353448e-03 w=4.353448e-03
AllocationOrder(VR512) = [ $zmm31 $zmm30 $zmm29 $zmm28 $zmm27 $zmm26 $zmm25 $zmm24 $zmm23 $zmm22 $zmm21 $zmm20 $zmm19 $zmm18 $zmm17 $zmm16 $zmm15 $zmm14 $zmm13 $zmm12 $zmm11 $zmm10 $zmm9 $zmm8 $zmm7 $zmm6 $zmm5 $zmm4 $zmm3 $zmm2 $zmm1 $zmm0 ]
hints: $zmm30
assigning %1 to $zmm30: XMM30 [16r,80r:0)  0@16r

selectOrSplit VR512:%0 [32r,80r:0)  0@32r weight:INF w=INF
hints: $zmm31
assigning %0 to $zmm31: XMM31 [32r,80r:0)  0@32r

selectOrSplit VR256X:%6 [112r,128r:0)  0@112r weight:INF w=INF
AllocationOrder(VR256X) = [ $ymm0 $ymm1 $ymm2 $ymm3 $ymm4 $ymm5 $ymm6 $ymm7 $ymm8 $ymm9 $ymm10 $ymm11 $ymm12 $ymm13 $ymm14 $ymm15 $ymm16 $ymm17 $ymm18 $ymm19 $ymm20 $ymm21 $ymm22 $ymm23 $ymm24 $ymm25 $ymm26 $ymm27 $ymm28 $ymm29 $ymm30 $ymm31 ]
hints: $ymm0
assigning %6 to $ymm0: XMM0 [112r,128r:0)  0@112r

selectOrSplit VR256X:%4 [80r,112r:0)  0@80r weight:4.629630e-03 w=4.629630e-03
assigning %4 to $ymm0: XMM0 [80r,112r:0)  0@80r

selectOrSplit VR256:%5 [96r,112r:0)  0@96r weight:INF w=INF
AllocationOrder(VR256) = [ $ymm0 $ymm1 $ymm2 $ymm3 $ymm4 $ymm5 $ymm6 $ymm7 $ymm8 $ymm9 $ymm10 $ymm11 $ymm12 $ymm13 $ymm14 $ymm15 ] (sub-class)
assigning %5 to $ymm1: XMM1 [96r,112r:0)  0@96r
********** REWRITE VIRTUAL REGISTERS **********
********** Function: doOper
********** REGISTER MAP **********
[%0 -> $zmm31] VR512
[%1 -> $zmm30] VR512
[%4 -> $ymm0] VR256X
[%5 -> $ymm1] VR256
[%6 -> $ymm0] VR256X

0B	bb.0 (%ir-block.0):
	  liveins: $zmm30, $zmm31
16B	  %1:vr512 = COPY $zmm30
32B	  %0:vr512 = COPY $zmm31
80B	  %4:vr256x = VPADDDZ256rr killed %0.sub_ymm:vr512, killed %1.sub_ymm:vr512
96B	  %5:vr256 = AVX2_SETALLONES
112B	  %6:vr256x = VPSUBDZ256rr killed %4:vr256x, killed %5:vr256
128B	  $ymm0 = COPY killed %6:vr256x
144B	  RET 0, $ymm0
> renamable $zmm30 = COPY $zmm30
Identity copy: renamable $zmm30 = COPY $zmm30
  deleted.
> renamable $zmm31 = COPY $zmm31
Identity copy: renamable $zmm31 = COPY $zmm31
  deleted.
> renamable $ymm0 = VPADDDZ256rr renamable $ymm31, renamable $ymm30, implicit killed $zmm30, implicit killed $zmm31
> renamable $ymm1 = AVX2_SETALLONES
> renamable $ymm0 = VPSUBDZ256rr killed renamable $ymm0, killed renamable $ymm1
> $ymm0 = COPY killed renamable $ymm0
Identity copy: $ymm0 = COPY killed renamable $ymm0
  deleted.
> RET 0, $ymm0
********** Stack Slot Coloring **********
********** Function: doOper
MCP: CopyPropagateBlock 
******** Post-regalloc Machine LICM: doOper ********

block-frequency: doOper
=======================
reverse-post-order-traversal
 - 0: BB0[]
loop-detection
compute-mass-in-function
 - node: BB0[]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: doOper
 - BB0[]: float = 1.0, int = 8

		Looking for trivial roots
Found a new trivial root: %bb.0
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.0
Found roots: %bb.0 
	discovered a new reachable node nullptr
	discovered a new reachable node %bb.0
MCP: CopyPropagateBlock 
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: doOper
	discovered a new reachable node %bb.0

block-frequency: doOper
=======================
reverse-post-order-traversal
 - 0: BB0[]
loop-detection
compute-mass-in-function
 - node: BB0[]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: doOper
 - BB0[]: float = 1.0, int = 8

		Looking for trivial roots
Found a new trivial root: %bb.0
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.0
Found roots: %bb.0 
	discovered a new reachable node nullptr
	discovered a new reachable node %bb.0
********** REACHING DEFINITION ANALYSIS **********
%bb.0: entry
$ymm0:	0	renamable $ymm0 = VPADDDZ256rr renamable $ymm31, renamable $ymm30, implicit killed $zmm30, implicit killed $zmm31
$ymm1:	1	renamable $ymm1 = VPCMPEQDYrr undef $ymm1, undef $ymm1
$ymm0:	2	renamable $ymm0 = VPSUBDZ256rr killed renamable $ymm0, killed renamable $ymm1
********** FIX EXECUTION DOMAIN: VR128X **********
%bb.0: entry
$xmm0:	renamable $ymm0 = VPADDDZ256rr renamable $ymm31, renamable $ymm30, implicit killed $zmm30, implicit killed $zmm31
$xmm1:	renamable $ymm1 = VPCMPEQDYrr undef $ymm1, undef $ymm1
$xmm0:	renamable $ymm0 = VPSUBDZ256rr killed renamable $ymm0, killed renamable $ymm1
********** BREAK FALSE DEPENDENCIES **********
MBB #0 exit state: Exits-dirty
	discovered a new reachable node %bb.0
Start X86FixupBWInsts
End X86FixupBWInsts
Start X86FixupLEAs
End X86FixupLEAs
********** COMPUTING STACKMAP LIVENESS: doOper **********
X86 Retpoline Thunks
	discovered a new reachable node %bb.0
	discovered a new reachable node %0
[SafeStack] Function: doOper1
[SafeStack]     safestack is not requested for this function
	discovered a new reachable node %0
	discovered a new reachable node %0
---- Branch Probability Info : doOper1 ----

Computing probabilities for 



=== doOper1
Creating new node: t2: v8i32,ch = CopyFromReg t0, Register:v8i32 %0
Creating new node: t4: v8i32,ch = CopyFromReg t0, Register:v8i32 %1
Creating new node: t5: v8i32 = add t2, t4
Creating constant: t6: i32 = TargetConstant<0>
Creating new node: t8: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t5
Creating new node: t9: ch = X86ISD::RET_FLAG t8, TargetConstant:i32<0>, Register:v8i32 $ymm0, t8:1
Initial selection DAG: %bb.0 'doOper1:'
SelectionDAG has 10 nodes:
  t0: ch = EntryToken
      t2: v8i32,ch = CopyFromReg t0, Register:v8i32 %0
      t4: v8i32,ch = CopyFromReg t0, Register:v8i32 %1
    t5: v8i32 = add t2, t4
  t8: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t5
  t9: ch = X86ISD::RET_FLAG t8, TargetConstant:i32<0>, Register:v8i32 $ymm0, t8:1



Combining: t9: ch = X86ISD::RET_FLAG t8, TargetConstant:i32<0>, Register:v8i32 $ymm0, t8:1

Combining: t8: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t5

Combining: t7: v8i32 = Register $ymm0

Combining: t6: i32 = TargetConstant<0>

Combining: t5: v8i32 = add t2, t4

Combining: t4: v8i32,ch = CopyFromReg t0, Register:v8i32 %1

Combining: t3: v8i32 = Register %1

Combining: t2: v8i32,ch = CopyFromReg t0, Register:v8i32 %0

Combining: t1: v8i32 = Register %0

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.0 'doOper1:'
SelectionDAG has 10 nodes:
  t0: ch = EntryToken
      t2: v8i32,ch = CopyFromReg t0, Register:v8i32 %0
      t4: v8i32,ch = CopyFromReg t0, Register:v8i32 %1
    t5: v8i32 = add t2, t4
  t8: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t5
  t9: ch = X86ISD::RET_FLAG t8, TargetConstant:i32<0>, Register:v8i32 $ymm0, t8:1


Legalizing node: t7: v8i32 = Register $ymm0
Ignoring node results
Legally typed node: t7: v8i32 = Register $ymm0

Legalizing node: t6: i32 = TargetConstant<0>
Ignoring node results
Legally typed node: t6: i32 = TargetConstant<0>

Legalizing node: t3: v8i32 = Register %1
Ignoring node results
Legally typed node: t3: v8i32 = Register %1

Legalizing node: t1: v8i32 = Register %0
Ignoring node results
Legally typed node: t1: v8i32 = Register %0

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: v8i32,ch = CopyFromReg t0, Register:v8i32 %0
Analyzing result type: v8i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t2: v8i32,ch = CopyFromReg t0, Register:v8i32 %0

Legalizing node: t4: v8i32,ch = CopyFromReg t0, Register:v8i32 %1
Analyzing result type: v8i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t4: v8i32,ch = CopyFromReg t0, Register:v8i32 %1

Legalizing node: t5: v8i32 = add t2, t4
Analyzing result type: v8i32
Legal result type
Analyzing operand: t2: v8i32,ch = CopyFromReg t0, Register:v8i32 %0
Legal operand
Analyzing operand: t4: v8i32,ch = CopyFromReg t0, Register:v8i32 %1
Legal operand
Legally typed node: t5: v8i32 = add t2, t4

Legalizing node: t8: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t5
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t5: v8i32 = add t2, t4
Legal operand
Legally typed node: t8: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t5

Legalizing node: t9: ch = X86ISD::RET_FLAG t8, TargetConstant:i32<0>, Register:v8i32 $ymm0, t8:1
Analyzing result type: ch
Legal result type
Analyzing operand: t8: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t5
Legal operand
Analyzing operand: t8: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t5
Legal operand
Legally typed node: t9: ch = X86ISD::RET_FLAG t8, TargetConstant:i32<0>, Register:v8i32 $ymm0, t8:1

Legalizing node: t65535: ch = handlenode t9
Analyzing result type: ch
Legal result type
Analyzing operand: t9: ch = X86ISD::RET_FLAG t8, TargetConstant:i32<0>, Register:v8i32 $ymm0, t8:1
Legal operand
Legally typed node: t65535: ch = handlenode t9

Type-legalized selection DAG: %bb.0 'doOper1:'
SelectionDAG has 10 nodes:
  t0: ch = EntryToken
      t2: v8i32,ch = CopyFromReg t0, Register:v8i32 %0
      t4: v8i32,ch = CopyFromReg t0, Register:v8i32 %1
    t5: v8i32 = add t2, t4
  t8: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t5
  t9: ch = X86ISD::RET_FLAG t8, TargetConstant:i32<0>, Register:v8i32 $ymm0, t8:1



Legalizing vector op: t5: v8i32 = add t2, t4
Legal node: nothing to do

Legalizing: t9: ch = X86ISD::RET_FLAG t8, TargetConstant:i32<0>, Register:v8i32 $ymm0, t8:1
Legal node: nothing to do

Legalizing: t8: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t5
Legal node: nothing to do

Legalizing: t5: v8i32 = add t2, t4
Legal node: nothing to do

Legalizing: t4: v8i32,ch = CopyFromReg t0, Register:v8i32 %1
Legal node: nothing to do

Legalizing: t2: v8i32,ch = CopyFromReg t0, Register:v8i32 %0
Legal node: nothing to do

Legalizing: t7: v8i32 = Register $ymm0

Legalizing: t6: i32 = TargetConstant<0>

Legalizing: t3: v8i32 = Register %1

Legalizing: t1: v8i32 = Register %0

Legalizing: t0: ch = EntryToken
Legal node: nothing to do
Legalized selection DAG: %bb.0 'doOper1:'
SelectionDAG has 10 nodes:
  t0: ch = EntryToken
      t2: v8i32,ch = CopyFromReg t0, Register:v8i32 %0
      t4: v8i32,ch = CopyFromReg t0, Register:v8i32 %1
    t5: v8i32 = add t2, t4
  t8: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t5
  t9: ch = X86ISD::RET_FLAG t8, TargetConstant:i32<0>, Register:v8i32 $ymm0, t8:1



Legalizing: t9: ch = X86ISD::RET_FLAG t8, TargetConstant:i32<0>, Register:v8i32 $ymm0, t8:1
Legal node: nothing to do

Combining: t9: ch = X86ISD::RET_FLAG t8, TargetConstant:i32<0>, Register:v8i32 $ymm0, t8:1

Legalizing: t8: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t5
Legal node: nothing to do

Combining: t8: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t5

Legalizing: t5: v8i32 = add t2, t4
Legal node: nothing to do

Combining: t5: v8i32 = add t2, t4

Legalizing: t4: v8i32,ch = CopyFromReg t0, Register:v8i32 %1
Legal node: nothing to do

Combining: t4: v8i32,ch = CopyFromReg t0, Register:v8i32 %1

Legalizing: t2: v8i32,ch = CopyFromReg t0, Register:v8i32 %0
Legal node: nothing to do

Combining: t2: v8i32,ch = CopyFromReg t0, Register:v8i32 %0

Legalizing: t7: v8i32 = Register $ymm0

Combining: t7: v8i32 = Register $ymm0

Legalizing: t6: i32 = TargetConstant<0>

Combining: t6: i32 = TargetConstant<0>

Legalizing: t3: v8i32 = Register %1

Combining: t3: v8i32 = Register %1

Legalizing: t1: v8i32 = Register %0

Combining: t1: v8i32 = Register %0

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.0 'doOper1:'
SelectionDAG has 10 nodes:
  t0: ch = EntryToken
      t2: v8i32,ch = CopyFromReg t0, Register:v8i32 %0
      t4: v8i32,ch = CopyFromReg t0, Register:v8i32 %1
    t5: v8i32 = add t2, t4
  t8: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t5
  t9: ch = X86ISD::RET_FLAG t8, TargetConstant:i32<0>, Register:v8i32 $ymm0, t8:1


===== Instruction selection begins: %bb.0 ''

ISEL: Starting selection on root node: t9: ch = X86ISD::RET_FLAG t8, TargetConstant:i32<0>, Register:v8i32 $ymm0, t8:1
ISEL: Starting pattern match
  Initial Opcode index to 132143
  Morphed node: t9: ch = RET TargetConstant:i32<0>, Register:v8i32 $ymm0, t8, t8:1
ISEL: Match complete!

ISEL: Starting selection on root node: t8: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t5

ISEL: Starting selection on root node: t5: v8i32 = add t2, t4
ISEL: Starting pattern match
  Initial Opcode index to 97192
  Match failed at index 97196
  Continuing at 97299
  Match failed at index 97301
  Continuing at 97408
  Match failed at index 97410
  Continuing at 97466
  Match failed at index 97469
  Continuing at 97490
  Match failed at index 97492
  Continuing at 97514
  Skipped scope entry (due to false predicate) at index 97519, continuing at 97571
  Skipped scope entry (due to false predicate) at index 97572, continuing at 97633
  Skipped scope entry (due to false predicate) at index 97634, continuing at 97708
  Skipped scope entry (due to false predicate) at index 97709, continuing at 97738
  Match failed at index 97744
  Continuing at 97860
  Match failed at index 97861
  Continuing at 97872
  Match failed at index 97873
  Continuing at 97884
  Match failed at index 97885
  Continuing at 97896
  Match failed at index 97897
  Continuing at 97908
  Continuing at 97909
  Continuing at 97910
  Match failed at index 97912
  Continuing at 97978
  Match failed at index 97982
  Continuing at 98133
  Match failed at index 98136
  Continuing at 98289
  Match failed at index 98293
  Continuing at 98891
  Match failed at index 98894
  Continuing at 99511
  Match failed at index 99517
  Continuing at 99591
  TypeSwitch[v8i32] from 99594 to 99760
  Skipped scope entry (due to false predicate) at index 99762, continuing at 99772
  Morphed node: t5: v8i32 = VPADDDZ256rr t2, t4
ISEL: Match complete!

ISEL: Starting selection on root node: t4: v8i32,ch = CopyFromReg t0, Register:v8i32 %1

ISEL: Starting selection on root node: t2: v8i32,ch = CopyFromReg t0, Register:v8i32 %0

ISEL: Starting selection on root node: t7: v8i32 = Register $ymm0

ISEL: Starting selection on root node: t6: i32 = TargetConstant<0>

ISEL: Starting selection on root node: t3: v8i32 = Register %1

ISEL: Starting selection on root node: t1: v8i32 = Register %0

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.0 'doOper1:'
SelectionDAG has 10 nodes:
  t0: ch = EntryToken
      t2: v8i32,ch = CopyFromReg t0, Register:v8i32 %0
      t4: v8i32,ch = CopyFromReg t0, Register:v8i32 %1
    t5: v8i32 = VPADDDZ256rr t2, t4
  t8: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t5
  t9: ch = RET TargetConstant:i32<0>, Register:v8i32 $ymm0, t8, t8:1


********** List Scheduling %bb.0 '' **********
SU(0): t9: ch = RET TargetConstant:i32<0>, Register:v8i32 $ymm0, t8, t8:1

    t8: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t5

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1
SU(1): t5: v8i32 = VPADDDZ256rr t2, t4

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(3): Data Latency=1
    SU(2): Data Latency=1
  Successors:
    SU(0): Data Latency=1
SU(2): t4: v8i32,ch = CopyFromReg t0, Register:v8i32 %1

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1
SU(3): t2: v8i32,ch = CopyFromReg t0, Register:v8i32 %0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1

Examining Available:
Height 0: SU(0): t9: ch = RET TargetConstant:i32<0>, Register:v8i32 $ymm0, t8, t8:1

    t8: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t5


*** Scheduling [0]: SU(0): t9: ch = RET TargetConstant:i32<0>, Register:v8i32 $ymm0, t8, t8:1

    t8: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t5


Examining Available:
Height 1: SU(1): t5: v8i32 = VPADDDZ256rr t2, t4


*** Scheduling [1]: SU(1): t5: v8i32 = VPADDDZ256rr t2, t4


Examining Available:
Height 2: SU(3): t2: v8i32,ch = CopyFromReg t0, Register:v8i32 %0

Height 2: SU(2): t4: v8i32,ch = CopyFromReg t0, Register:v8i32 %1


*** Scheduling [2]: SU(3): t2: v8i32,ch = CopyFromReg t0, Register:v8i32 %0


Examining Available:
Height 2: SU(2): t4: v8i32,ch = CopyFromReg t0, Register:v8i32 %1


*** Scheduling [3]: SU(2): t4: v8i32,ch = CopyFromReg t0, Register:v8i32 %1

*** Final schedule ***
SU(2): t4: v8i32,ch = CopyFromReg t0, Register:v8i32 %1

SU(3): t2: v8i32,ch = CopyFromReg t0, Register:v8i32 %0

SU(1): t5: v8i32 = VPADDDZ256rr t2, t4

SU(0): t9: ch = RET TargetConstant:i32<0>, Register:v8i32 $ymm0, t8, t8:1

    t8: ch,glue = CopyToReg t0, Register:v8i32 $ymm0, t5


Total amount of phi nodes to update: 0
*** MachineFunction at end of ISel ***
# Machine code for function doOper1: IsSSA, TracksLiveness
Function Live Ins: $ymm0 in %0, $ymm1 in %1

bb.0 (%ir-block.0):
  liveins: $ymm0, $ymm1
  %1:vr256x = COPY $ymm1
  %0:vr256x = COPY $ymm0
  %2:vr256x = VPADDDZ256rr %0:vr256x, %1:vr256x
  $ymm0 = COPY %2:vr256x
  RET 0, $ymm0

# End machine code for function doOper1.

	discovered a new reachable node %bb.0
***** Machine Function before Domain Reassignment *****
# Machine code for function doOper1: IsSSA, TracksLiveness
Function Live Ins: $ymm0 in %0, $ymm1 in %1

bb.0 (%ir-block.0):
  liveins: $ymm0, $ymm1
  %1:vr256x = COPY $ymm1
  %0:vr256x = COPY $ymm0
  %2:vr256x = VPADDDZ256rr %0:vr256x, %1:vr256x
  $ymm0 = COPY %2:vr256x
  RET 0, $ymm0

# End machine code for function doOper1.

***** Machine Function after Domain Reassignment *****
# Machine code for function doOper1: IsSSA, TracksLiveness
Function Live Ins: $ymm0 in %0, $ymm1 in %1

bb.0 (%ir-block.0):
  liveins: $ymm0, $ymm1
  %1:vr256x = COPY $ymm1
  %0:vr256x = COPY $ymm0
  %2:vr256x = VPADDDZ256rr %0:vr256x, %1:vr256x
  $ymm0 = COPY %2:vr256x
  RET 0, $ymm0

# End machine code for function doOper1.

# Machine code for function doOper1: IsSSA, TracksLiveness
Function Live Ins: $ymm0 in %0, $ymm1 in %1

0B	bb.0 (%ir-block.0):
	  liveins: $ymm0, $ymm1
16B	  %1:vr256x = COPY $ymm1
32B	  %0:vr256x = COPY $ymm0
48B	  %2:vr256x = VPADDDZ256rr %0:vr256x, %1:vr256x
64B	  $ymm0 = COPY %2:vr256x
80B	  RET 0, $ymm0

# End machine code for function doOper1.

********** Stack Coloring **********
********** Function: doOper1
	discovered a new reachable node %bb.0
********** EARLY IF-CONVERSION **********
********** Function: doOper1
Machine InstCombiner: doOper1
Combining MBB 
********** X86 cmov Conversion : doOper1**********
	discovered a new reachable node %bb.0
******** Pre-regalloc Machine LICM: doOper1 ********
Entering: 
Exiting: 
		Looking for trivial roots
Found a new trivial root: %bb.0
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.0
Found roots: %bb.0 
	discovered a new reachable node nullptr
	discovered a new reachable node %bb.0

block-frequency: doOper1
========================
reverse-post-order-traversal
 - 0: BB0[]
loop-detection
compute-mass-in-function
 - node: BB0[]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: doOper1
 - BB0[]: float = 1.0, int = 8

******** Machine Sinking ********
********** PEEPHOLE OPTIMIZER **********
********** Function: doOper1
**** Analysing doOper1
Start X86AvoidStoreForwardBlocks
End X86AvoidStoreForwardBlocks
********** X86 speculative load hardening : doOper1 **********
	discovered a new reachable node %bb.0
********** X86 EFLAGS copy lowering : doOper1 **********
Skipping Detect dead lanes pass
********** PROCESS IMPLICIT DEFS **********
********** Function: doOper1
	discovered a new reachable node %bb.0
********** REWRITING TWO-ADDR INSTRS **********
********** Function: doOper1
# Machine code for function doOper1: NoPHIs, TracksLiveness
Function Live Ins: $ymm0 in %0, $ymm1 in %1

0B	bb.0 (%ir-block.0):
	  liveins: $ymm0, $ymm1
16B	  %1:vr256x = COPY killed $ymm1
32B	  %0:vr256x = COPY killed $ymm0
48B	  %2:vr256x = VPADDDZ256rr killed %0:vr256x, killed %1:vr256x
64B	  $ymm0 = COPY killed %2:vr256x
80B	  RET 0, killed $ymm0

# End machine code for function doOper1.

Computing live-in reg-units in ABI blocks.
0B	%bb.0 XMM0#0 XMM1#0
Created 2 new intervals.
********** INTERVALS **********
XMM0 [0B,32r:0)[64r,80r:1)  0@0B-phi 1@64r
XMM1 [0B,16r:0)  0@0B-phi
%0 [32r,48r:0)  0@32r weight:0.000000e+00
%1 [16r,48r:0)  0@16r weight:0.000000e+00
%2 [48r,64r:0)  0@48r weight:0.000000e+00
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function doOper1: NoPHIs, TracksLiveness
Function Live Ins: $ymm0 in %0, $ymm1 in %1

0B	bb.0 (%ir-block.0):
	  liveins: $ymm0, $ymm1
16B	  %1:vr256x = COPY $ymm1
32B	  %0:vr256x = COPY $ymm0
48B	  %2:vr256x = VPADDDZ256rr %0:vr256x, %1:vr256x
64B	  $ymm0 = COPY %2:vr256x
80B	  RET 0, $ymm0

# End machine code for function doOper1.

********** SIMPLE REGISTER COALESCING **********
********** Function: doOper1
********** JOINING INTERVALS ***********
:
16B	%1:vr256x = COPY $ymm1
	Considering merging %1 with $ymm1
	Can only merge into reserved registers.
32B	%0:vr256x = COPY $ymm0
	Considering merging %0 with $ymm0
	Can only merge into reserved registers.
64B	$ymm0 = COPY %2:vr256x
	Considering merging %2 with $ymm0
	Can only merge into reserved registers.
Trying to inflate 0 regs.
********** INTERVALS **********
XMM0 [0B,32r:0)[64r,80r:1)  0@0B-phi 1@64r
XMM1 [0B,16r:0)  0@0B-phi
%0 [32r,48r:0)  0@32r weight:0.000000e+00
%1 [16r,48r:0)  0@16r weight:0.000000e+00
%2 [48r,64r:0)  0@48r weight:0.000000e+00
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function doOper1: NoPHIs, TracksLiveness
Function Live Ins: $ymm0 in %0, $ymm1 in %1

0B	bb.0 (%ir-block.0):
	  liveins: $ymm0, $ymm1
16B	  %1:vr256x = COPY $ymm1
32B	  %0:vr256x = COPY $ymm0
48B	  %2:vr256x = VPADDDZ256rr %0:vr256x, %1:vr256x
64B	  $ymm0 = COPY %2:vr256x
80B	  RET 0, $ymm0

# End machine code for function doOper1.

Before MISched:
# Machine code for function doOper1: NoPHIs, TracksLiveness
Function Live Ins: $ymm0 in %0, $ymm1 in %1

bb.0 (%ir-block.0):
  liveins: $ymm0, $ymm1
  %1:vr256x = COPY $ymm1
  %0:vr256x = COPY $ymm0
  %2:vr256x = VPADDDZ256rr %0:vr256x, %1:vr256x
  $ymm0 = COPY %2:vr256x
  RET 0, $ymm0

# End machine code for function doOper1.

********** MI Scheduling **********
doOper1:%bb.0 
  From: %1:vr256x = COPY $ymm1
    To: RET 0, $ymm0
 RegionInstrs: 4
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
Disabled scoreboard hazard recognizer
Disabled scoreboard hazard recognizer
SU(0):   %1:vr256x = COPY $ymm1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 1
  Successors:
    SU(2): Data Latency=0 Reg=%1
  Single Issue       : false;
SU(1):   %0:vr256x = COPY $ymm0
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 1
  Successors:
    SU(2): Data Latency=0 Reg=%0
    SU(3): Anti Latency=0
  Single Issue       : false;
SU(2):   %2:vr256x = VPADDDZ256rr %0:vr256x, %1:vr256x
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Predecessors:
    SU(1): Data Latency=0 Reg=%0
    SU(0): Data Latency=0 Reg=%1
  Successors:
    SU(3): Data Latency=1 Reg=%2
  Single Issue       : false;
SU(3):   $ymm0 = COPY %2:vr256x
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(2): Data Latency=1 Reg=%2
    SU(1): Anti Latency=0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   RET 0, $ymm0
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(3): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 
Scheduling SU(3) $ymm0 = COPY %2:vr256x
  Ready @0c
  BotQ.A TopLatency SU(3) 1c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) %2:vr256x = VPADDDZ256rr %0:vr256x, %1:vr256x
  Ready @1c
  SKXPort015 +1x8u
  *** Critical resource SKXPort015: 0c
  SKXPort0156 +1x6u
  SKXPortAny +1x3u
  BotQ.A BotLatency SU(2) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKXPort015
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %0:vr256x = COPY $ymm0
  Ready @1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKXPort015
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %1:vr256x = COPY $ymm1
  Ready @1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKXPort015
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.0 ***
SU(0):   %1:vr256x = COPY $ymm1
SU(1):   %0:vr256x = COPY $ymm0
SU(2):   %2:vr256x = VPADDDZ256rr %0:vr256x, %1:vr256x
SU(3):   $ymm0 = COPY %2:vr256x

********** INTERVALS **********
XMM0 [0B,32r:0)[64r,80r:1)  0@0B-phi 1@64r
XMM1 [0B,16r:0)  0@0B-phi
%0 [32r,48r:0)  0@32r weight:0.000000e+00
%1 [16r,48r:0)  0@16r weight:0.000000e+00
%2 [48r,64r:0)  0@48r weight:0.000000e+00
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function doOper1: NoPHIs, TracksLiveness
Function Live Ins: $ymm0 in %0, $ymm1 in %1

0B	bb.0 (%ir-block.0):
	  liveins: $ymm0, $ymm1
16B	  %1:vr256x = COPY $ymm1
32B	  %0:vr256x = COPY $ymm0
48B	  %2:vr256x = VPADDDZ256rr %0:vr256x, %1:vr256x
64B	  $ymm0 = COPY %2:vr256x
80B	  RET 0, $ymm0

# End machine code for function doOper1.


block-frequency: doOper1
========================
reverse-post-order-traversal
 - 0: BB0[]
loop-detection
compute-mass-in-function
 - node: BB0[]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: doOper1
 - BB0[]: float = 1.0, int = 8

********** GREEDY REGISTER ALLOCATION **********
********** Function: doOper1
********** Compute Spill Weights **********
********** Function: doOper1
********** INTERVALS **********
XMM0 [0B,32r:0)[64r,80r:1)  0@0B-phi 1@64r
XMM1 [0B,16r:0)  0@0B-phi
%0 [32r,48r:0)  0@32r weight:INF
%1 [16r,48r:0)  0@16r weight:4.675926e-03
%2 [48r,64r:0)  0@48r weight:INF
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function doOper1: NoPHIs, TracksLiveness
Function Live Ins: $ymm0 in %0, $ymm1 in %1

0B	bb.0 (%ir-block.0):
	  liveins: $ymm0, $ymm1
16B	  %1:vr256x = COPY $ymm1
32B	  %0:vr256x = COPY $ymm0
48B	  %2:vr256x = VPADDDZ256rr %0:vr256x, %1:vr256x
64B	  $ymm0 = COPY %2:vr256x
80B	  RET 0, $ymm0

# End machine code for function doOper1.


selectOrSplit VR256X:%1 [16r,48r:0)  0@16r weight:4.675926e-03 w=4.675926e-03
hints: $ymm1
assigning %1 to $ymm1: XMM1 [16r,48r:0)  0@16r

selectOrSplit VR256X:%0 [32r,48r:0)  0@32r weight:INF w=INF
hints: $ymm0
assigning %0 to $ymm0: XMM0 [32r,48r:0)  0@32r

selectOrSplit VR256X:%2 [48r,64r:0)  0@48r weight:INF w=INF
hints: $ymm0
assigning %2 to $ymm0: XMM0 [48r,64r:0)  0@48r
********** REWRITE VIRTUAL REGISTERS **********
********** Function: doOper1
********** REGISTER MAP **********
[%0 -> $ymm0] VR256X
[%1 -> $ymm1] VR256X
[%2 -> $ymm0] VR256X

0B	bb.0 (%ir-block.0):
	  liveins: $ymm0, $ymm1
16B	  %1:vr256x = COPY $ymm1
32B	  %0:vr256x = COPY $ymm0
48B	  %2:vr256x = VPADDDZ256rr killed %0:vr256x, killed %1:vr256x
64B	  $ymm0 = COPY killed %2:vr256x
80B	  RET 0, $ymm0
> renamable $ymm1 = COPY $ymm1
Identity copy: renamable $ymm1 = COPY $ymm1
  deleted.
> renamable $ymm0 = COPY $ymm0
Identity copy: renamable $ymm0 = COPY $ymm0
  deleted.
> renamable $ymm0 = VPADDDZ256rr killed renamable $ymm0, killed renamable $ymm1
> $ymm0 = COPY killed renamable $ymm0
Identity copy: $ymm0 = COPY killed renamable $ymm0
  deleted.
> RET 0, $ymm0
********** Stack Slot Coloring **********
********** Function: doOper1
MCP: CopyPropagateBlock 
******** Post-regalloc Machine LICM: doOper1 ********

block-frequency: doOper1
========================
reverse-post-order-traversal
 - 0: BB0[]
loop-detection
compute-mass-in-function
 - node: BB0[]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: doOper1
 - BB0[]: float = 1.0, int = 8

		Looking for trivial roots
Found a new trivial root: %bb.0
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.0
Found roots: %bb.0 
	discovered a new reachable node nullptr
	discovered a new reachable node %bb.0
MCP: CopyPropagateBlock 
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: doOper1
	discovered a new reachable node %bb.0

block-frequency: doOper1
========================
reverse-post-order-traversal
 - 0: BB0[]
loop-detection
compute-mass-in-function
 - node: BB0[]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: doOper1
 - BB0[]: float = 1.0, int = 8

		Looking for trivial roots
Found a new trivial root: %bb.0
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.0
Found roots: %bb.0 
	discovered a new reachable node nullptr
	discovered a new reachable node %bb.0
********** REACHING DEFINITION ANALYSIS **********
%bb.0: entry
$ymm0:	0	renamable $ymm0 = VPADDDZ256rr killed renamable $ymm0, killed renamable $ymm1
********** FIX EXECUTION DOMAIN: VR128X **********
%bb.0: entry
$xmm0:	renamable $ymm0 = VPADDDZ256rr killed renamable $ymm0, killed renamable $ymm1
********** BREAK FALSE DEPENDENCIES **********
MBB #0 exit state: Exits-dirty
	discovered a new reachable node %bb.0
Start X86FixupBWInsts
End X86FixupBWInsts
Start X86FixupLEAs
End X86FixupLEAs
********** COMPUTING STACKMAP LIVENESS: doOper1 **********
X86 Retpoline Thunks
	discovered a new reachable node %bb.0
