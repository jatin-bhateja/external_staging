1/

  void FieldLayoutBuilder::compute_regular_layout() {
   -  check for significance of layout changes for   if (_super_ends_with_oop) {

  Current field layout order :  multifield, big primitives, small primitives, oop fields

  It seems idea of super_ends_with_oop is to maintain contiguity of oop fields for better
  cache behavior during oop traversal.

2/  ObjectValue currently preserves _is_larval (deprecate in future) , is_init removed in lworld


3/  Re-visit following post-merge.

  // Can this inline type be passed as multiple values?
  bool InlineKlass::can_be_passed_as_fields() const {
    return !VectorSupport::skip_value_scalarization(const_cast<InlineKlass*>(this)) &&
           InlineTypePassFieldsAsArgs;
  }

  // Can this inline type be returned as multiple values?
  bool InlineKlass::can_be_returned_as_fields(bool init) const {
    return !VectorSupport::skip_value_scalarization(const_cast<InlineKlass*>(this)) &&
           InlineTypeReturnedAsFields &&
           (init || return_regs() != nullptr);
  }


4/ Orthogonal CDS
     - VectorSupport being java.base module class has MaxSpecies Payloads which are concretized
       at class parsing stage.
    .................
     parse_fields
      ...........
      if (bundle_size < 0) {
        bundle_size = VectorSupport::get_max_multifield_count(_class_name);
      }
      ...........

     - jdk.incubator.vector classes cannot be part of CDS archive 

    @LooselyConsistentValue
    public value static class VectorPayloadMFMaxS extends VectorPayloadMF {
        @MultiField(value = -1)
        short mfield = 0;

   - TODO: re-visit Archive Builder and also check latest AOT cached along with this exploration.


5/   Important code pointer 
       a.  void JVMState::format(PhaseRegAlloc *regalloc, const Node *n, outputStream* st) const {
              .....
              Compiler bookkeeps null_marker for eliminated InlineTypeNode on SafePointScalarObjectNode
              during process_inline_types -> make_scalar_in_safepoints

        b. Checkout:  GraphKit::cast_to_non_larval
 
        c. InlineTypeNode::convert_to_payload
              - For 128 bit payload support for storing flat atomic field.
              - Vector store extensions to non-atomic flat field store

        d.  InlineTypeNode::store_flat
              - null marker store is explicit, can't it be packed in payload, compare perf of two stores with packing + one store.
 
        e.  Checkout inline_unsafe_flat_access

        f.   InlineTypeNode interactions with escape analysis,  create_scalarized_object_description.
                - NullMarker and is_Larval ordering is important for SafePointScalarObjectNode, as FillLocArray expects materialization fields in strict sequence.
    
6/   Earlier is_init flag was propagated to materialized object for nullable value instance, now its the null_marker flag.
     -  Currently, we also pass _is_larval to ObjectValue for materializing larval value object, this was done for explicitly larval value using makePrivateBuffer

      // An ObjectValue describes an object eliminated by escape analysis.
      class ObjectValue: public ScopeValue {
            protected:
                int                        _id;
                ScopeValue*                _klass;
                ScopeValue*                _properties; // Used to pass additional data like the null marker or array properties.

7/   Check if Enum and inline_klass() can be made private after successful build, there was a direct usage in the code using inlinetypenode, if not make is private again.

8/   Fix me TODO in inline_unsafe_access along with larval state assertion check for store to value type instance fields.  

9/   Review and remove the following larval bit propagation handling for de-optimization if we plan to remove makePrivateBuffer
            -  make_scalar_in_safepoint
            -  add_inst_fields_to_safepoint


10/ [non-merge info]  Elimination condition for arrays.
            -  Non-constant array length.
            - The array should have fewer than  EliminateAllocationArraySizeLimit	elements. 
            -  Allocate -> Initialize  -> ChechCast (rawptr -> exact TypeInstPtr/TypeAryPtr)
                   -  Escaping state is determined using the connectivity graph 
                   -  Scalarizability is determined based on following
                             -  Offset of field is constant. 
                             -  Alias Index =  [] for arrays -- all the elements of the array are considered as aliases.
                                                              a[0]
                                                              a[1]
                                                              a[2]
                                                              ......
                                                              a[7]   are all assigned same alias index i.e. type[].
                                                    =  Multiple assignment to an array index expressions with constant indices forms chain of initializations which can be
                                                        traversed through the memory merge node chain, and find_previous_stores forwards the initialization value against a strict
                                                        offset match.
                         
                                                    =  fields, based on the rules of type-based alias analysis, two fields with different offsets are never considered as aliases, and are assigned different alias indices. 
                             - checkout ConnectionGraph::adjust_scalar_replaceable_state for implementation level details.        


11/   Merging state of two blocks - current handling has safety checks.  Re-instantiate if needed.  Removing to align with latest code for now.


12/    do_put_xxx :-
                                -->    VectorPayload*MF 
                                         -->   multifield 
                                -->    Initialization of the multifield base is part of the constructor, using the put field bytecode.
                                         -->    We cannot pass an uninitializedThis to an unsafe or any other method call,  there is no scheme to initialize all the synthetic fields of multifield in a constructor. 
                                         -->    JDK-8368810, tracks this issue.
                                         --> Until now,  C2 do_put_xxx was doing a special handling for this by broadcasting the value before put, but it was a kludge which should be fixed by JDK-8368810.
  
                                -->   Cases to handle:  Write dedicated tests for each case on the lines of JDK-8368810, this will cover entire range of vector API use cases.
                                        -->  put multifield scalarized
                                        -->  put multifield non-scalarized
                                        -->  put flat payload with  multifield 
                                        -->  put  non-flat payload with multifield 
                                        -->  get multifield scalarized
                                        -->  get multifield non-scalarized
                                        -->  get flat payload with multifield
                                        -->  get non-flat payload with multifield.


13/   Two questions:-
          - In Valhalla stock larval state exists only during new object creation.
          - In vector API we update multiple lanes in an update loop.
              -  With each iteration we ought to create a new immutable entity.
              -  Lets discuss various alternatives to achieve this 

 Core concept (New model):-
          - A value object can be updated when it's in the larval state, either explicitly or implicitly.
          - When a value is in larval state, then it must be in non-scalarized form, i.e., an oop.
          - An update to a value object field is through a store IR, during this time object must be larval and hence exist in oop form.
          - Value object is transitioned to a non-larval state after the constructor call or after finishPrivateBuffer.
          - Update to multifield in larval state requires an unsafe API.

            Premise:  Value objects are immutable and two vector values with same lanes contents must be treated as equals.
 
             a/  Current update loop :-
                 ----------------------------------                
                          res = Unsafe.makePrivateBuffer(arg1);
                          for (int i = 0; i < laneCount; i++) {
                                 larg1 =  Unsafe.getFloat(arg1, offset[i]);
                                 larg2 =  Unsafe.getFloat(arg2, offset[i]);
	                         Unsafe.putFloat(res, larg1 + larg2);                // res is in oop form since its in a mutable state.         
                          }
                          res = Unsafe.finishPrivateBuffer(res);                   // re-create scalarized representation from larval state. 
                          
             
                  Lifetime of larval is very restricted today and though java application we cannot inject any bytecode b/w new and its subsequent initializing constructor.
                  However, using hand crafted bytecode we can have a gap b/w new uninitialized allocation and its initializing constructor, but JVM runtime rules for bytecode
                  verification catches any undefined behavior during verification stage.

                  Unsafe operations are outside the purview of JVM byte code verification.

                  Problem arises when we make the life time of larval object being acted upon by an unsafe API span across a block or even loop of bytecode, in such a cases we may need to
                  handle larval and non-larval merges OR emit undefined behavior error.

                  Q. How performant is  unsafe get / put operation ?
                  A. There are intrinsic and native implementation of get/put APIs,  given that its an unsafe operation compiler does not care about emitting any out-of-bound checks
                      as its the responsibility of the user. In such a case an unsafe get simply computes an effective address (base + offset) and emit load / store instructions.
                      Does, the loop involving unsafe operation auto-vectorized ?  yes, since auto-vectorizer look for contiguity in address across iterations.

    
<statistics type='intrinsic'>
Compiler intrinsic usage:
     2 (50.0%) _getFloat (worked)
     1 (25.0%) _putFloat (worked)
     1 (25.0%) _makePrivateBuffer (worked)
     0 ( 0.0%) _finishPrivateBuffer (failed)
     4 (100.0%) total (worked,failed)
</statistics> 
                   
                    Consider impact of long live range larval state in above update loop.
                    res, was made a larval quantity using makePrivateBuffer,  but  scalarization triggered at gen_checkcast, which observed an value type oop which is in larval state.
                    In the previous code model, any such occurrence of value oop (which by the way is a larval value) is scalarized by the compiler which is incorrect handling. 

                    As a result, finishPrivateBuffer receives an InlineTypeNode while it always expects to receive a larval value oop, and hence intrinsification fails, its side effect is on
                    auto-vectorization which does not observe an IR expression for store and its associated address computation since we take the native implementation route.

                   Hence, the performance of fall back implementation degrades. 

                   What are the possible solutions here ? Compiler should never try to scalarize the larval oop at checkcast bytecode, handling exists because type profiling by sharpen
                   the oop type to a value type.

                   Another solution is to make finishPrivateBuffer intrinsic more robust, it should simply return the InlineTypeNode by setting the Allocation->_larval to false. [1]
                   
              All in all there are loopholes if we increase the life span of larval object in this case it spans across the loop. 

              b/  Other larval lifetime limiting options:-
              ----------------------------------------------------------------

                     In fallback implementation we intend to preform operation are lane level, it may turn out that generated IR is auto-vectorizable, but its purely performance optimization
                     by Compiler, and was not intent of user in first place. 

                     So we read the input lanes using Unsafe API, we need an Unsafe get here since synthetic multifields are not part of user visible java code and has no symbol or
                     type information in constant pool. Thus with multi-field we ought to use unsafe APIs. Unsafe.get does not mandates larval transitions of input value vector.
                     what needs to change, well to limit the larval life time we need to allocate a temporary buffer prior to loop for storing the result of computation loop.
                     We need a new Unsafe API which accepts the temporary buffer and result value object, this API will internally buffer the scalarized value, update its field from
                     the temporary result storage and then re-materialize scalarized re-presentation from the updated buffer.

                     Will this API again have both native and intrinsic implementation ? yes, it will definitely have native implementation and the intrinsic implementation should 
                     make use of vector IR if target supports the required vector size OR it will need to emit scalar load / store IR, we can be intelligent in the intrinsic implementation
                     to optimize this copy operation using narrower vector. 

                     Will this be performant over existing solution ?  Additional allocation of temporary buffer is costly, we can bank of escape analysis and loop unrolling to eliminate
                     this allocation, but given that the temporary storage is passed to native routine it escapes the scope, with Vector IR based intrinsic implementation we do need
                     contiguous memory  view of temporary storage, otherwise we may need to emit multiple scalar inserts into vector which is very costly, over all we don't expect
                     new implementation to be performant mainly due to additional allocation penalty, BTW even today vector are immutable and vector factory routines used in the 
                     fall back implementation do allocate memory for backing storage,  thus we not only allocate new concrete vector but also its backing storage, with current Valhalla
                     with flat payloads we have one additional allocation penalty of backing storage, with new approach we may have to give away that benefit for reduced larval lifetime.
                      
                     It may turnout that the new approach is inferior in terms of performance w.r.t to existing vector api - Valhalla solution but eventually may be at par with mainline support.

                    So its tempting to try out the new solution to limit the complexity due to long lifespan larval objects. 


              c/   Alternative approach :  Create a new immutable value with each iteration of the update loop.

                          res = __default_value__
                          for (int i = 0; i < laneCount; i++) {
                                 larg1 =  Unsafe.getFloat(arg1, offset[i]);
                                 larg2 =  Unsafe.getFloat(arg2, offset[i]);
	                         res =     Unsafe.updateLane(res, larg1 + larg2);     // res is in oop form since its in a mutable state.         
                          }
                          
                   This also limits the lifetime of larval value object, but in the hind side performs a buffering and scalarization with each iteration, when we buffer we not only
                   allocate a new temporary storage but also emits field level stores to dump the contents into temporary storage, this is very expensive if done for each lane
                   update, given that we are only updating one lane of vector but are still paying the penalty to save and restores all unmodified lanes per iteration.
                   While this does limit the larval life span, but has a huge performance penalty in comparison to both existing approach of larval life time across loop and 
                   single update with temporary storage allocation.

        In vector API fall back implementation is wrapped with in the intrinsic entry point,  as long as intrinsification is successful we are not hit by fall back, a poor fall back
        may delay the warmup stage there by impacting the overall application through put, but for long running SIMD kernels warmps are not an issue at all. 

         
   
[1]  Currently compiler does not handle vector calling convention emitting out of scalarization,  this is concern with generic handling of multifield where return value was a container of
a multifield and the multifield value was  part of a vector register, in such a case caller will expect to receive the value in a vector register, with vector API we deal in abstract vectors
across method boundaries which are never scalarized, anyways extending the calling convention is on our list of items for Valhalla after preview. 

2763    bool LibraryCallKit::inline_unsafe_finish_private_buffer() {
(gdb) ssl
(gdb) p $8
$9 = (ciMethod *) 0x7b73c4032638
(gdb) p $8->get_Method ()->name_and_sig_as_C_string ()
$10 = 0x7b733c0df768 "Float256Vector.add(LFloat256Vector;LFloat256Vector;)LFloat256Vector;"
(gdb) ssl

To circumvent this issue seen with the test case we can disable scalarization of return values using -XX:-InlineTypeReturnedAsFields

                   
                     
                     

 

Hi Chen, All,

Here is a quick sync-up on the merge status.

I started the merge yesterday but it may take few more days as there have been lots of changes in the code since last 4 months, I am studying the code changes and documenting the new code model, in crystalline form following is out new model for larval objects.


 Core concept (New model):-
          - A value object can be updated when it's in the larval state, either explicitly though makePrivateBuffer or implicitly during new object creation.
          - When a value is in larval state, then it must be in non-scalarized form, i.e., should exists as an oop.
          - To update an larval value field, we must emit a Store operation/ IR,  this mandates oop form of larval object, this is a major change from earlier model

            where puffield could directly update the incoming edge of scalarized InlineTypeNode IR. Given that a value object is a immutable quantity hence any update

            is only possible by way of creating a new value there by going though a temporary larval state.
          - Value object is transitioned to a non-larval state after the constructor call or after finishPrivateBuffer.
          - For vector API, backing storage is in the form of a @Multifield payload, since only the base field is exposed in java code and rest of synthetic fields are internally generated based on the   
            annotation during parse time hence we definitely need an Unsafe API to update all the synthetic fields.
          - New flexible constructor allow does allow updates to fields before the super call, but we still cannot pass uninitializedThis to an external initializing unsafe API from constructor.
            As a result of this currently the VectorPayalod*MF constructors only initialize base multifield though a putfield bytecode. JDK-8368810 tracks this issue.


In current context , we have following options to perform vector updates in fall back implementation :-

Premise:  Value objects are immutable and two vector values with same lanes contents must be treated as equals.
 
             a/  Current update loop :-
                 ----------------------------------                
                          res = Unsafe.makePrivateBuffer(arg1);
                          for (int i = 0; i < laneCount; i++) {
                                 larg1 =  Unsafe.getFloat(arg1, offset[i]);
                                 larg2 =  Unsafe.getFloat(arg2, offset[i]);
	                         Unsafe.putFloat(res, larg1 + larg2);                // res is in oop form since its in a mutable state.         
                          }
                          res = Unsafe.finishPrivateBuffer(res);                   // re-create scalarized representation from larval state. 
                          
             
                  Lifetime of larval is very restricted today and though java application we cannot inject any bytecode b/w new and its subsequent initializing constructor.
                  However, using hand crafted bytecode we can have a gap b/w new uninitialized allocation and its initializing constructor, but JVM runtime rules for bytecode
                  verification catches any undefined behavior during verification stage.

                  Unsafe operations are outside the purview of JVM byte code verification.

                  Problem arises when we make the lifetime of larval object being acted upon by an unsafe API span across a block or even loop of bytecode, in such a cases we may need to
                  handle larval and non-larval merges OR emit undefined behavior error.

                  Q. How performant is  unsafe get / put operation ?
                  A. There are intrinsic and native implementation of get/put APIs,  given that its an unsafe operation compiler does not care about emitting any out-of-bound checks
                      as its the responsibility of the user. In such a case an unsafe get simply computes an effective address (base + offset) and emit load / store instructions.
                      Does, the loop involving unsafe operation auto-vectorized ?  yes, since auto-vectorizer look for contiguity in address across iterations.

                    Consider impact of long live range larval state in above update loop on intrisicfication 

                    <statistics type='intrinsic'>
                      Compiler intrinsic usage:
                         2 (50.0%) _getFloat (worked)
                         1 (25.0%) _putFloat (worked)
                         1 (25.0%) _makePrivateBuffer (worked)
                         0 ( 0.0%) _finishPrivateBuffer (failed)
                         4 (100.0%) total (worked,failed)
                    </statistics> 
                   
                    res, was made a larval quantity using makePrivateBuffer,  but  scalarization triggered at gen_checkcast, which observed an value type oop which by the was is in larval state.
                    As a result, finishPrivateBuffer receives an InlineTypeNode while it always expects to receive a larval value oop, and hence intrinsification fails, its has a side effect on
                    auto-vectorization which does not observe an IR expression for store and its associated address computation since we take the native implementation route.

                   Hence, the performance of fall back implementation degrades. 

                   What are the possible solutions here ? Compiler should never try to scalarize the larval oop at checkcast bytecode, handling exists because type profiling sharpens
                   the oop type to a value type.

                   Another solution is to make finishPrivateBuffer intrinsic more robust, it should simply return the InlineTypeNode by setting the Allocation->_larval to false. This is attempted by
                   an unmerged patch [1].
                   
              All in all there are loopholes if we increase the life span of larval object in this case it spans across the loop. 

              b/  Other larval lifetime limiting options:-
              ----------------------------------------------------------------

                     In fallback implementation we intend to preform operation at the lane level, it may turn out that generated IR is auto-vectorizable, but its purely performance optimization
                     by Compiler, and was not intent of user in first place. 

                     So we read the input lanes using Unsafe API, we need an Unsafe get here since synthetic multifields are not part of user visible java code and has no symbol or
                     type information in constant pool. Thus with multi-field we ought to use unsafe APIs. Unsafe.get does not mandates larval transitions of input value vector.
                     what needs to change, well to limit the larval life time we need to allocate a temporary buffer prior to loop for storing the result of the computation loop.
                     We need a new Unsafe API which accepts the temporary buffer and result value object, this API will internally buffer the scalarized value, update its field from
                     the temporary result storage and then re-materialize scalarized re-presentation from the updated buffer.

                     Will this API again have both native and intrinsic implementation ? yes, it will definitely have native implementation and the intrinsic implementation should 
                     make use of vector IR if target supports the required vector size OR it will need to emit scalar load / store IR, we can be intelligent in the intrinsic implementation
                     to optimize this copy operation using narrower vector. 

                     Will this be performant over existing solution ?  Additional allocation of temporary buffer is costly, we can bank of escape analysis and loop unrolling to eliminate
                     this allocation, but given that the temporary storage is passed to native routine it escapes the scope, with Vector IR based intrinsic implementation we do need
                     contiguous memory  view of temporary storage, otherwise we may need to emit multiple scalar inserts into vector which is very costly, over all we don't expect
                     new implementation to be performant mainly due to additional allocation penalty, BTW even today vector are immutable and vector factory routines used in the 
                     fall back implementation do allocate memory for backing storage,  thus we not only allocate new concrete vector but also its backing storage, with current Valhalla
                     and flat payloads we only need one allocation for vector and its backing storage, with new approach we may have to give away that benefit for reduced larval lifetime.
                      
                     It may turnout that the new approach is inferior in terms of performance w.r.t to existing VectorAPI-Valhalla solution but eventually may be at par with mainline support.

                    So its tempting to try out the new solution to limit the complexity due to long lifespan larval objects. 


              c/   Alternative approach :  Create a new immutable value with each iteration of the update loop.

                          res = __default_value__
                          for (int i = 0; i < laneCount; i++) {
                                 larg1 =  Unsafe.getFloat(arg1, offset[i]);
                                 larg2 =  Unsafe.getFloat(arg2, offset[i]);
	                         res =     Unsafe.updateLane(res, larg1 + larg2);     // res is in oop form since its in a mutable state.         
                          }
                          
                   This also limits the lifetime of larval value object, but in the hind side performs a buffering and scalarization with each iteration, when we buffer we not only
                   allocate a new temporary storage but also emits field level stores to dump the contents into temporary storage, this is very expensive if done for each lane
                   update, given that we are only updating one lane of vector but are still paying the penalty to save and restores all unmodified lanes per iteration.
                   While this does limit the larval life span, but has a huge performance penalty in comparison to both existing approach of larval life time across loop and 
                   single update with temporary storage allocation.

         In vector API fall back implementation is wrapped with in the intrinsic entry point,  as long as intrinsification is successful we are not hit by fall back, a poor fall back
        may delay the warmup stage, but for long running SIMD kernels warmups are never an issue as long as intrinsificstions are successful. 

  I have a created a prototype application [2] mimicking the vector API usecase for you, please give it try with exiting lworld+vector branch after integrating the patch [1]
  
  While I am merging and understanding the implications of new code mode, it will help if you can share your plan of new API to limit the scope of larval transition keeping
  in view the above context.
        
Some notes on implication of patch [1] 
   
Currently compiler does not handle vector calling convention emitting out of scalarization,  this is concern with generic handling of multifield where return value was a container of
a multifield and the multifield value was held by a vector register, in such a case caller will expect to receive the value in a vector register, with vector API we deal in abstract vectors
across method boundaries which are never scalarized, anyways extending the calling convention is on our list of items for Valhalla. 

To circumvent this issue seen with the test case we can disable scalarization of return values using -XX:-InlineTypeReturnedAsFields

[1] 
[2]
                                 
                                                                          