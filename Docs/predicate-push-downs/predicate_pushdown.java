
import jdk.incubator.vector.*;

//----------------------------------------------------------------------------
// Interfaces generated by query parser.
interface query {
  boolean apply (int a, int b);
}

interface query_vec {
  VectorMask<Integer> apply(Vector<Integer> va, Vector<Integer> vb);
}

class query_generator {
  public enum SQLQueryOp {
     CMP_GT,
     CMP_LT,
     CMP_EQ
  }

  public static query genBinaryQuery(SQLQueryOp oper) {
     switch(oper) {
        case CMP_GT: return (a, b) -> a > b;
        case CMP_LT: return (a, b) -> a < b;
        case CMP_EQ: return (a, b) -> a == b;
     }
     return null;
  }

  public static query_vec genBinaryVecQuery(SQLQueryOp oper) {
     switch(oper) {
        case CMP_GT: return (Vector<Integer> va, Vector<Integer> vb) -> va.compare(VectorOperators.GT, vb);
        case CMP_LT: return (Vector<Integer> va, Vector<Integer> vb) -> va.compare(VectorOperators.LT, vb);
        case CMP_EQ: return (Vector<Integer> va, Vector<Integer> vb) -> va.compare(VectorOperators.EQ, vb);
     }
     return null;
  }
}

//---------------------------------------------------------------------------

class predicate_pushdown {
  
  public static int[][] db_table;
  public static int[][] result;

  public static final VectorSpecies<Integer> SPECIES = IntVector.SPECIES_512;

  public static boolean execute_scalar(int a, int b, query func) {
     return func.apply(a, b);
  }

  public static VectorMask<Integer> execute_vector(Vector<Integer> va, Vector<Integer> vb, query_vec func) {
     return func.apply(va, vb);
  }

  public static void init_db(int rows, int cols) {
     db_table = new int[rows][cols];
     result = new int[rows][cols];
     for(int i = 0; i < rows; i++) {
        for(int j = 0; j < cols; j++) {
           db_table[i][j] = i*cols + j;
        }
     }
  }

  // SELECT * FROM db_table WHERE col0 > 3
  public static int process_query_scalar(int ctr, query func) {
     // Push the predicate down from analytic layer down to data source layer.
     int selection_count = 0;
     int [] col0 = db_table[0];
     boolean [] filter = new boolean[col0.length];

     for (int i = 0; i < col0.length; i++) {
        boolean predicate = func.apply(col0[i], 3);
        selection_count += predicate ? 1 : 0;
        filter[i] = predicate;
     }

     for (int i = 0; i < db_table.length; i++) {
        for (int j = 0, k = 0; j < filter.length; j++) {
           if (filter[j]) {
              result[i][k++] = db_table[i][j];
           }
        }
     }
     return result[ctr][0];
  }

  // SELECT * FROM db_table WHERE col0 > 3
  public static int process_query_vector(int ctr, query func, query_vec vfunc) {
     // Push the predicate down from analytic layer down to data source layer.
     int i = 0;
     int k = 0;
     int [] col0 = db_table[0];

     for (; i < SPECIES.loopBound(col0.length); i += SPECIES.length()) {
         Vector<Integer> col0v = IntVector.fromArray(SPECIES, col0, i);
         Vector<Integer> cvec  = SPECIES.broadcast(3);
         VectorMask<Integer> predicate = vfunc.apply(col0v, cvec);
         int pred_true_count = predicate.trueCount(); 
         if (pred_true_count > 0) {
            for (int j = 0; j < db_table.length; j++) {
               IntVector colj = IntVector.fromArray(SPECIES, db_table[j], i);
               colj = colj.compress(predicate);
               colj.intoArray(result[j], k);
            }
            k += pred_true_count; 
         }
     }
     if (i < col0.length) {
        boolean [] predicate = new boolean[col0.length - i + 1];
        for (int j = i, n = 0; j < col0.length; j++) {
           predicate[n++] = func.apply(col0[j], 3);
        }
        for (int j = 0; j < db_table.length; j++) {
           for(int n = i, l = 0; n < col0.length; n++) { 
              if(predicate[n-i]) {
                result[j][l++] = db_table[j][n];
              }
           }
        }
     }
     return result[ctr][0];
  }

  public static void main(String [] args) {
      int res = 0;
      int algo = Integer.parseInt(args[0]);
      int rows = Integer.parseInt(args[1]);
      int cols = Integer.parseInt(args[2]);

      assert rows > 0 && ((rows & (rows -1 )) == 0);

      init_db(rows, cols);

      if (algo == 0) {
          query q = query_generator.genBinaryQuery(query_generator.SQLQueryOp.CMP_GT);

          for (int i = 0; i < 80000; i++) {
             res += process_query_scalar(i & (rows-1), q);
          }
    
          long t1 = System.currentTimeMillis();
          for (int i = 0; i < 80000; i++) {
             res += process_query_scalar(i & (rows-1), q);
          }
          long t2 = System.currentTimeMillis();
    
          System.out.println("[Res Scalar Query] " + res + " [Time] " + (t2-t1) + " ms ");

      } else { 
          query q = query_generator.genBinaryQuery(query_generator.SQLQueryOp.CMP_GT);
          query_vec vecq = query_generator.genBinaryVecQuery(query_generator.SQLQueryOp.CMP_GT);

          for (int i = 0; i < 80000; i++) {
             res += process_query_vector(i & (rows-1), q, vecq);
          }
    
          long t1 = System.currentTimeMillis();
          for (int i = 0; i < 80000; i++) {
             res += process_query_vector(i & (rows-1), q, vecq);
          }
          long t2 = System.currentTimeMillis();
    
          System.out.println("[Res Vector Query] " + res + " [Time] " + (t2-t1) + " ms ");
      }
  }
}
