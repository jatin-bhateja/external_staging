	
UTF8 encoding:
--------------

We place the characters from least significant byte starting from least significant bit.
  - ASCII single byte encoding
    0xxxyyyy
  - Two byte encoding
    110xxxyy 10yyzzzz
  - Three byte encoding
    1110gggg  10xxxxyy  10yyzzzz
  - Four byte encoding
    11110cdd  10ddgggg  10xxxxyy  10yyzzzz

Validation:
-----------

1) If none of the bytes begin has 1 in its MSB then all the bytes of the stream are ASCII characters.
2) We need to verify that all byte values are no larger than 0xF4 (or 244): we can achieve this check with
an 8-bit saturated subtraction with 0xF4. The result of the subtraction is zero.
3) When the byte value 0xED is found, the next byte must be no larger than 0x9F; when the byte value
0xF4 is found, the next byte must be no larger than 0x8F.We can check these conditions with vectorized
byte comparisons and byte shifts.
  - Above checks ensures we honor the constraints on three and four bytes  encoding.

✅ Valid UTF-8 Must:
Respect leading byte rules (as per table above)
Have correct continuation bytes (10xxxxxx)
Use minimal length encoding
Avoid surrogate halves (U+D800 to U+DFFF)
Stay within max range (up to U+10FFFF)

Above constraints on 3 and 4 byte encodings ensures that the decoded UTF string does not exceeds U+10FFFF

4) The byte values 0xC0 and 0xC1 are forbidden. When the byte value is 0xE0, the next byte value is larger
than 0xA0. When the byte value is 0xF0, the next byte value is at least 0x90.

– When a byte value is outside the range of ASCII values, it belongs to one out of four classes, depending
on the value of its high nibble:
– If the high nibble is 8, 9, a or b (in hexadecimal) then the byte is the second, third of fourth byte
in a code point.
– If the high nibble is c or d then the byte must be the first of a sequence of two bytes forming a
code point.
    - 110x xxxx => 1101 / 1100   
– If the high nibble is e then the byte is the first out of a code point made of three bytes.
    - 1110 xxxx => 1110
– Finally, if the high nibble is f, then the byte is first in a sequence of four bytes.
    - 1111 0xxx => 1111

Quick test for valid UTF using saturate subtraction and VPSHUFB 

  - Map input bytes to 0 1 2 3 4  where 
    -  continuation byte is mapped to  0
    -  first byte of two byte encoding is mapped to 2
    -  first byte of three byte encoding is mapped to 3
    -  first byte of four byte encoding is mapped to 4
    and 
    -  ascii bytes are mapped to 1.

 Thus, the UTF-8 sequence will look like following
    - four byte UTF-8 sequence - 4 0 0 0 
    - three byte UTF-8 sequence - 3 0 0
    - two byte UTF-8 sequence - 2 0
    - ASCII sequence will be - 1
   
step 0 :    4 0 0 0 3 0 0 2 0 1 1  (input string)
step 1 :      4 0 0 0 3 0 0 2 0 1  (s0 >> 1)
step 2 :      3 0 0 0 2 0 0 1 0 0  (s1 - 1)
step 3 :    4 3 0 0 3 2 0 2 1 1 1  (s0 + s2)
step 4 :        4 0 0 0 3 0 0 2 0  (s3 >> 1)
step 5 :        2 0 0 0 1 0 0 0 0  (s4 - 1)
step 6 :    4 3 2 0 3 2 1 2 1 1 1  (s3 + s5)
step 7 :          4 0 0 0 3 0 0 2
step 8 :          1 0 0 0 1 0 0 0
step 9 :    4 3 2 1 3 2 1 3 1 1 1
step 10:    1 1 1 1 1 1 1 1 1 1 1  (s6 > s8)
step 11:    allones             

Lets check for invalid input
0
step 0 :    4 0 0 1 3 0 0 2 0 1 1  (input string)
step 1 :      4 0 0 1 3 0 0 2 0 1  (s0 >> 1)
step 2 :      3 0 0 0 2 0 0 1 0 0  (s1 - 1)
step 3 :    4 3 0 1 3 2 0 2 1 1 1  (s0 + s2)
step 4 :        4 3 0 1 3 0 0 2 0  (s3 >> 1)
step 5 :        2 1 0 0 1 0 0 0 0  (s4 - 1)
step 6 :    4 3 2 1 3 2 1 2 1 1 1  (s3 + s5)
step 7 :    0 0 0 0 0 0 0 0 0 0 0  (bcast)
step 8 :    1 1 1 1 1 1 1 1 1 1 1  (s6 > s8)
step 9 :    allones             


110X XXXX
1110 XXXX
1111 0XXX

Table to identify two, three or four byte UTF encoding.
-------------------------------------------------------
 - 1100 | 1101 -> 2
 - 1110        -> 3
 - 1111        -> 4

 0000 -> 1
 0001 -> 1
 0010 -> 1
 0011 -> 1
 0100 -> 1
 0101 -> 1
 0110 -> 1
 0111 -> 1
 1000 -> 0
 1001 -> 0
 1010 -> 0
 1011 -> 0
 1100 -> 2
 1101 -> 2
 1110 -> 3
 1111 -> 4


    1111
    1001
 --------
    1111
   0000X
  0000XX
 1111XXX
 -------
 1110111 -> XOR carryless
 0001000 -> flip the bits
         -> LZC -> 3, mask -> (1 << (7 - 3) - 1) -> 1111
 0001111


jshell> // Double quote mask

jshell> byte [] str = {(byte)0, (byte) 1, (byte)2, (byte)0x9, (byte)1, (byte)4, (byte)3, (byte)0x9}
str ==> byte[8] { 0, 1, 2, 9, 1, 4, 3, 9 }

jshell> var mask = vec.compare(VectorOperators.EQ, (byte)0x9)
mask ==> Mask[...T...T]

jshell> var p2 = 64 - Long.numberOfLeadingZeros(mask.toLong()) - 1
p2 ==> 7

jshell> var p1 = Long.numberOfTrailingZeros(mask.toLong())
p1 ==> 3

jshell> var str_mask = ((1L << (p2 - p1)) - 1) << p1
str_mask ==> 120

jshell> var vec = ByteVector.fromArray(ByteVector.SPECIES_64, str, 0)
vec ==> [0, 1, 2, 9, 1, 4, 3, 9]

jshell> VectorMask.fromLong(ByteVector.SPECIES_64, str_mask)
$47 ==> Mask[...TTTT.]

jshell> var extract = VectorMask.fromLong(ByteVector.SPECIES_64, str_mask)
extract ==> Mask[...TTTT.]


// bit mask to index.

jshell> ByteVector.SPECIES_64.iotaShuffle(0, 1, true).toVector().compress(extract)
$53 ==> [3, 4, 5, 6, 0, 0, 0, 0]


jshell> ByteVector.SPECIES_64.iotaShuffle(0, 1, true).toVector().blend(ByteVector.broadcast(ByteVector.SPECIES_64, 0), extract.not())
$57 ==> [0, 0, 0, 3, 4, 5, 6, 0]


/*
 * legal utf-8 byte sequence
 * http://www.unicode.org/versions/Unicode6.0.0/ch03.pdf - page 94
 *
 *  Code Points        1st       2s       3s       4s
 * U+0000..U+007F     00..7F
 * U+0080..U+07FF     C2..DF   80..BF
 * U+0800..U+0FFF     E0       A0..BF   80..BF
 * U+1000..U+CFFF     E1..EC   80..BF   80..BF
 * U+D000..U+D7FF     ED       80..9F   80..BF
 * U+E000..U+FFFF     EE..EF   80..BF   80..BF
 * U+10000..U+3FFFF   F0       90..BF   80..BF   80..BF
 * U+40000..U+FFFFF   F1..F3   80..BF   80..BF   80..BF
 * U+100000..U+10FFFF F4       80..8F   80..BF   80..BF
 *
 */


Two byte violations 
-------------------

0... ....  | 10.. ....     - continuation after ascii 
110. ....  | 00.. ....     - missing continuation
1100 ...1  | 10.. ....     - C1 in upper byte of two byte encoding.
1100 ..10  | 10.. ....     - C2 in upper byte of two byte encoding.
1110 ....  | 10....... 00  - missing continuation 
1110 ....  | 10....... 10...... 10.....  - overlong continuation for 3 byte encoding.
1111 0...  | 10....... 00...... .......  - missing continuation for 4 byte encoding.
1111 0...  | 10....... 10...... 10...... 10..... - overlong continuation for 4 byte encoding.


U+0080	U+07FF	110xxxyy	10yyzzzz
Min UTF8 - 2 byte value  - 11000010   10000000
Max UTF8 - 2 byte value - 11011111   10111111

U+0800	U+FFFF	1110wwww	10xxxxyy	   10yyzzzz
Min UTF8 - 3 byte value  -   1110|0000  10|100000    10|000000
Max UTF8 - 3 byte value -   1110|1111   10|111111   10|111111
                                                                                                    

----------------------------------------------------------------------
Quick notes on Utf8Validation implementation :-
----------------------------------------------------------------------

There are two categories of errors which are detected using 3 distributed lookup table which are indexed using 4 bit values i.e. first three nibbles of pair of bytes.

    a.  errors detected using two consecutive byte sequence, strictly speaking higher order 12 bits of consecutive byte sequence.
        -  overlong 2 bytes
        -  overlong 3 bytes
        -  overlong 4 bytes
                 - All overlong errors are related to encoding which can be represented in smaller number of bytes, given that all the binary number
                   holds a property that a number lesser than a given binary number can be formed by displacing its trailing set bits to a lower bit position 
                   hence we pick minimum value of multi byte encodings and check for bit patterns lower than the first 12 bits.
                   2 byte encoding
                          -  11yyxxxx 10zzzzzz
                          -  Min value :  110|00010 10|000000   -> C0 and C1 are illegal two byte encodings.
                                -   Byte1hi - 110|0 
                                -   Byte1lo - 0010
                                -   Byte2hi - 10|00

                         - Any value less than minimum value will have Byte1lo as 0000,  0001, therefore first two rows of second lookup table 
                           "createByte1LowLookup" sets bits for OVERLONG_2BYTE.
                         - Existing distributed table lookup are generated based on this concept.
                 
                  Similarly for 3 byte encoding minimum value is 
                          - 1110 xxxx 10yyzzzz 10vvuuuu
                          - Min value : 1110 0000 1000000 1000000
                          - Thus Byte1hi lookup table set OVERLONG_3BYTE at index 1110 while Byte2hi lookup table set OVERLONG_3BYTE at index value
                            less than 1000 i.e. 0000 0001 0010 0011 0100 0101 0110 0111.
                  
                  Similar logic also applies to malformed 4 byte encoding less than 0x10FFFF.
                         -   1111 0xxx 10yyzzzz 10uuvvvv 10aabbbb
                         -   Minimum value :  11110|000 10|000000 10|000000 10|000000 
                         -   | convention used here differentiates b/w fixed format bits and actual decodable bits.
                         -   There are no set decodable bits in first twelve bits of minimum bit sequence of 4 byte encoding.
                              thus, we set OVERLONG_4BYTS bit at index 1111 of Byte1hi and  at index 0000 of Byte1lo lookup tables.

    b.  TOO_SHORT, these are the cases where a leading byte is followed by non-continuation byte.
            -  11xx xxx   - a 2, 3 and 4 byte encoded UTF8 characters will always has most significant two bits set.
            -  Thus we set TOO_SHORT bit for 1100, 1101, 1110 and 1111 indexes of Byte1hi lookup table.
            -  This byte should be followed by a continuation byte, i.e. the one which begins with 10 at the most significant bits else its an error scenario
            -  Which is why TOO_SHORT bit is set for index values 0000, 0001, 0010, 0011, 0100, 0101, 0110, 0111 of  Byte2hi lookup table.
    
     c.  TOO_LONG, these are the cases where a leading ASCII byte is followed by a continuation byte.
            - All ASCII characters begin with 0 at the most significant bit, thus 0000-0111 indexes of Byte1hi lookup table set a TOO_LONG bit.
            - If upper nibble of second byte holds a bit pattern '10' as its most significant two bits then its an error scenario, which is why
              indexes 1000-1011 of Byte2hi lookup table set TOO_LONG bit.
 
     d.  TOO_LARGE,  these are characters where decoded bits are greater than U+10FFFF.
           -  This check is mainly for 4 byte encoding, where any value greater than 11110_100 10_001111 10_111111 10_111111 is illegal.
           -  Therefore, index 1111 of Byte1hi, index range 0100 -> 1111 of table Byte1lo and indexes greater than equal to 1001 of Byte2hi lookup table set TOO_LARGE bit.
 
     e.   SURROGATE, these are bit patterns which overlap with legal UTF16 encoding bit patterns and therefore qualify as illegal UTF8 encodings.
           - Again central ideal here is that we set the same bit across index ranges of all the lookup tables to enable fast error detection.

     f.   3 or 4 bytes encoding error, missing continuation bytes.
        - We first look for previous 2 and pervious 3 bytes of each consecutive continuation bit pattern and error out if bit patten of leading byte 
          does not match with 3 or 4 byte encoding format bits i.e. 1110 or 11110.
        -  TWO_CONTINUATIONS bits are set for index corresponding to 10xx  10xx of Byte1hi and Byte2hi lookup tables.
           Since we use 4 bit nibble of first twelve bit of consecutive byte pair,  and perform a logical and b/w the results of lookup
           hence TWO_CONTINUATIONS bit is set for all the indexes of Byte1lo lookup table.

    Current, implementation of distribute 3 lookup table is very efficient, for this patch we are aiming to reduce the code of looking up last, last two and last three bytes 
    using constant index Vector.slice operation.
               
