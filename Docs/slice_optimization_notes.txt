8303762: Optimize vector slice operation with constant index using VPALIGNR instruction #24104

- Current support:
  A) Slice:-
    - C2 IR node for VectorSlice for leaf level intrinsic corresponding to Vector.slice(int)
    - Other flavors
        - Vector.slice(int, Vector)
            - Second vector argument is background vector which replaces zero broadcasted vector of base version of API. 
            - API calls same intrinsic entry point as the base version.
        - Vector.slice(int, Vector, VectorMask)
            - This version of API internally calls above slice API followed by an explicit blend with broadcasted zero vector.
    - Current support implicitly covers all the 3 variants of slice APIs.
 
 B) Unslice:-
    -  Similar to slice, unslice also has three interfaces.
    -  Leaf level interface only accepts an index argument. 
       - It internally performs following operation
           -   vec.unslice(idx)   <=>  broadcast(0).slice(VEC.length() - idx, vec)
   -  Other variants of unslice accepts unslice index, back ground vector and part number.
   - We can assume the receiver vector to be sliding over two contiguously placed background vectors.
   - Its possible to implement all the three variants of unslice using slice operations as follows.

jshell> // Input and synthesized vector.

jshell> vec
vec ==> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
jshell> vec2
vec2 ==> [10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160]
jshell> bzvec
bzvec ==> [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

jshell> // Case 1:
jshell> vec.unslice(4)
$79 ==> [0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
jshell> bzvec.slice(vec.length() - 4, vec)
$80 ==> [0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]

jshell> // Case 2:
jshell> vec.unslice(4, vec2, 0)
$81 ==> [10, 20, 30, 40, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
jshell> vec2.blend(vec2.slice(vec2.length() - 4, vec), VectorMask.fromLong(IntVector.SPECIES_512, ((1L << (vec.length() - 4)) - 1) << 4))
$82 ==> [10, 20, 30, 40, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]

jshell> // Case 3:
jshell> vec.unslice(4, vec2, 1)
$83 ==> [13, 14, 15, 16, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160]
jshell> vec2.blend(vec.slice(vec.length() - 4, vec2), VectorMask.fromLong(IntVector.SPECIES_512, ((1L << 4) - 1)))
$84 ==> [13, 14, 15, 16, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160]

jshell> // Case 4:
jshell> vec.unslice(4, vec2, 0, VectorMask.fromLong(IntVector.SPECIES_512, 0xFF))
$85 ==> [10, 20, 30, 40, 1, 2, 3, 4, 5, 6, 7, 8, 130, 140, 150, 160]
jshell> // Current Java fall back implementation for this version is based on slice and unslice operations.

