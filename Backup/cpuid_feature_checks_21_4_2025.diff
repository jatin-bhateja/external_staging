diff --git a/src/hotspot/cpu/aarch64/vm_version_aarch64.cpp b/src/hotspot/cpu/aarch64/vm_version_aarch64.cpp
index b2d34553487..8a844ddb701 100644
--- a/src/hotspot/cpu/aarch64/vm_version_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/vm_version_aarch64.cpp
@@ -68,6 +68,12 @@ static SpinWait get_spin_wait_desc() {
   return SpinWait{};
 }
 
+void VM_Version::pre_initialize() {
+  _features_array_size =  1;
+  _features = NEW_C_HEAP_ARRAY(uint64_t, _features_array_size, mtInternal);
+  memset(_features, 0, sizeof(uint64_t) * _features_array_size);
+}
+
 void VM_Version::initialize() {
   _supports_atomic_getset4 = true;
   _supports_atomic_getadd4 = true;
@@ -203,7 +209,7 @@ void VM_Version::initialize() {
 
   // Cortex A53
   if (_cpu == CPU_ARM && model_is(0xd03)) {
-    _features |= CPU_A53MAC;
+    SET_FEATURE(CPU_A53MAC);
     if (FLAG_IS_DEFAULT(UseSIMDForArrayEquals)) {
       FLAG_SET_DEFAULT(UseSIMDForArrayEquals, false);
     }
@@ -243,7 +249,7 @@ void VM_Version::initialize() {
     }
   }
 
-  if (_features & (CPU_FP | CPU_ASIMD)) {
+  if (SUPPORTS_FEATURE(CPU_FP) || SUPPORTS_FEATURE(CPU_ASIMD)) {
     if (FLAG_IS_DEFAULT(UseSignumIntrinsic)) {
       FLAG_SET_DEFAULT(UseSignumIntrinsic, true);
     }
@@ -406,7 +412,7 @@ void VM_Version::initialize() {
     FLAG_SET_DEFAULT(UseGHASHIntrinsics, false);
   }
 
-  if (_features & CPU_ASIMD) {
+  if (SUPPORTS_FEATURE(CPU_ASIMD)) {
     if (FLAG_IS_DEFAULT(UseChaCha20Intrinsics)) {
       UseChaCha20Intrinsics = true;
     }
@@ -417,7 +423,7 @@ void VM_Version::initialize() {
     FLAG_SET_DEFAULT(UseChaCha20Intrinsics, false);
   }
 
-  if (_features & CPU_ASIMD) {
+  if (SUPPORTS_FEATURE(CPU_ASIMD)) {
       if (FLAG_IS_DEFAULT(UseKyberIntrinsics)) {
           UseKyberIntrinsics = true;
       }
@@ -428,7 +434,7 @@ void VM_Version::initialize() {
       FLAG_SET_DEFAULT(UseKyberIntrinsics, false);
   }
 
-  if (_features & CPU_ASIMD) {
+  if (SUPPORTS_FEATURE(CPU_ASIMD)) {
       if (FLAG_IS_DEFAULT(UseDilithiumIntrinsics)) {
           UseDilithiumIntrinsics = true;
       }
@@ -629,11 +635,11 @@ void VM_Version::initialize() {
 
   // Sync SVE related CPU features with flags
   if (UseSVE < 2) {
-    _features &= ~CPU_SVE2;
-    _features &= ~CPU_SVEBITPERM;
+    CLEAR_FEATURE(CPU_SVE2);
+    CLEAR_FEATURE(CPU_SVEBITPERM);
   }
   if (UseSVE < 1) {
-    _features &= ~CPU_SVE;
+    CLEAR_FEATURE(CPU_SVE);
   }
 
   // Construct the "features" string
diff --git a/src/hotspot/cpu/aarch64/vm_version_aarch64.hpp b/src/hotspot/cpu/aarch64/vm_version_aarch64.hpp
index 04cf9c9c2a0..b0924e3a028 100644
--- a/src/hotspot/cpu/aarch64/vm_version_aarch64.hpp
+++ b/src/hotspot/cpu/aarch64/vm_version_aarch64.hpp
@@ -63,6 +63,7 @@ class VM_Version : public Abstract_VM_Version {
 
 public:
   // Initialization
+  static void pre_initialize();
   static void initialize();
   static void check_virtualizations();
 
@@ -136,14 +137,14 @@ enum Ampere_CPU_Model {
     decl(A53MAC,        a53mac,        31)
 
   enum Feature_Flag {
-#define DECLARE_CPU_FEATURE_FLAG(id, name, bit) CPU_##id = (1 << bit),
+#define DECLARE_CPU_FEATURE_FLAG(id, name, bit) CPU_##id = (bit),
     CPU_FEATURE_FLAGS(DECLARE_CPU_FEATURE_FLAG)
 #undef DECLARE_CPU_FEATURE_FLAG
   };
 
   // Feature identification
 #define CPU_FEATURE_DETECTION(id, name, bit) \
-  static bool supports_##name() { return (_features & CPU_##id) != 0; };
+  static bool supports_##name() { return SUPPORTS_FEATURE(CPU_##id); };
   CPU_FEATURE_FLAGS(CPU_FEATURE_DETECTION)
 #undef CPU_FEATURE_DETECTION
 
diff --git a/src/hotspot/cpu/arm/vm_version_arm.hpp b/src/hotspot/cpu/arm/vm_version_arm.hpp
index 11c89da2005..e4b6bf7611a 100644
--- a/src/hotspot/cpu/arm/vm_version_arm.hpp
+++ b/src/hotspot/cpu/arm/vm_version_arm.hpp
@@ -39,6 +39,7 @@ class VM_Version: public Abstract_VM_Version {
   static bool _is_initialized;
 
  public:
+  static void pre_initialize();
   static void initialize();
   static bool is_initialized()      { return _is_initialized; }
 
@@ -54,11 +55,6 @@ class VM_Version: public Abstract_VM_Version {
   enum Feature_Flag_Set {
     unknown_m           = 0,
     all_features_m      = -1,
-
-    vfp_m     = 1 << vfp,
-    vfp3_32_m = 1 << vfp3_32,
-    simd_m    = 1 << simd,
-    mp_ext_m  = 1 << mp_ext
   };
 
   // The value stored by "STR PC, [addr]" instruction can be either
@@ -95,10 +91,10 @@ class VM_Version: public Abstract_VM_Version {
   static bool supports_kuser_cmpxchg32() { return _kuser_helper_version >= KUSER_VERSION_CMPXCHG32; }
   static bool supports_kuser_cmpxchg64() { return _kuser_helper_version >= KUSER_VERSION_CMPXCHG64; }
 
-  static bool has_vfp()             { return (_features & vfp_m) != 0; }
-  static bool has_vfp3_32()         { return (_features & vfp3_32_m) != 0; }
-  static bool has_simd()            { return (_features & simd_m) != 0; }
-  static bool has_multiprocessing_extensions() { return (_features & mp_ext_m) != 0; }
+  static bool has_vfp()             { return SUPPORTS_FEATURE(vfp); }
+  static bool has_vfp3_32()         { return SUPPORTS_FEATURE(vfp3_32); }
+  static bool has_simd()            { return SUPPORTS_FEATURE(simd); }
+  static bool has_multiprocessing_extensions() { return SUPPORTS_FEATURE(mp_ext); }
 
   static bool simd_math_is_compliant() { return false; }
 
diff --git a/src/hotspot/cpu/arm/vm_version_arm_32.cpp b/src/hotspot/cpu/arm/vm_version_arm_32.cpp
index 148786a55da..1d82c539445 100644
--- a/src/hotspot/cpu/arm/vm_version_arm_32.cpp
+++ b/src/hotspot/cpu/arm/vm_version_arm_32.cpp
@@ -165,7 +165,7 @@ void VM_Version::initialize() {
   check_vfp_fault_instr = (address)check_vfp;
   double dummy;
   if (check_vfp(&dummy)) {
-    _features |= vfp_m;
+    SET_FEATURE(vfp_m);
   }
 
 #ifdef COMPILER2
@@ -175,14 +175,14 @@ void VM_Version::initialize() {
     check_vfp3_32_fault_instr = (address)check_vfp3_32;
     double dummy;
     if (check_vfp3_32(&dummy)) {
-      _features |= vfp3_32_m;
+      SET_FEATURE(vfp3_32_m);
     }
 
     address check_simd_pc =g.generate_check_simd();
     check_simd_t check_simd = CAST_TO_FN_PTR(check_simd_t, check_simd_pc);
     check_simd_fault_instr = (address)check_simd;
     if (check_simd()) {
-      _features |= simd_m;
+      SET_FEATURE(simd_m);
     }
   }
 #endif
@@ -193,7 +193,7 @@ void VM_Version::initialize() {
   check_mp_ext_fault_instr = (address)check_mp_ext;
   int dummy_local_variable;
   if (check_mp_ext(&dummy_local_variable)) {
-    _features |= mp_ext_m;
+    SET_FEATURE(mp_ext_m);
   }
 
   if (UseAESIntrinsics && !FLAG_IS_DEFAULT(UseAESIntrinsics)) {
diff --git a/src/hotspot/cpu/ppc/vm_version_ppc.cpp b/src/hotspot/cpu/ppc/vm_version_ppc.cpp
index 8ec69bffe15..939e5f9eda0 100644
--- a/src/hotspot/cpu/ppc/vm_version_ppc.cpp
+++ b/src/hotspot/cpu/ppc/vm_version_ppc.cpp
@@ -53,6 +53,15 @@ uint64_t VM_Version::_dscr_val = 0;
                   "warning: -XX:+" #flag " requires -XX:+UseSIGTRAP\n" \
                   "         -XX:+" #flag " will be disabled!\n");
 
+static uint64_t* saved_features = nullptr;
+
+void VM_Version::pre_initialize() {
+  _features_array_size =  num_features >> 6;
+  _features = NEW_C_HEAP_ARRAY(uint64_t, _features_array_size, mtInternal);
+  saved_features = NEW_C_HEAP_ARRAY(uint64_t, _features_array_size, mtInternal);
+  memset(_features, 0, sizeof(uint64_t) * _features_array_size);
+}
+
 void VM_Version::initialize() {
 
   // Test which instructions are supported and measure cache line size.
@@ -537,7 +546,6 @@ void VM_Version::determine_features() {
   // 7 InstWords for each call (function descriptor + blr instruction).
   const int code_size = (num_features+1+2*7)*BytesPerInstWord;
 #endif
-  int features = 0;
 
   // create test area
   enum { BUFFER_SIZE = 2*4*K }; // Needs to be >=2* max cache line size (cache line size can't exceed min page size).
@@ -550,7 +558,7 @@ void VM_Version::determine_features() {
   MacroAssembler* a = new MacroAssembler(&cb);
 
   // Must be set to true so we can generate the test code.
-  _features = VM_Version::all_features_m;
+  memset(_features, VM_Version::all_features_m, sizeof(uint64_t) * _features_array_size);
 
   // Emit code.
   void (*test)(address addr, uint64_t offset)=(void(*)(address addr, uint64_t offset))(void *)a->function_entry();
@@ -558,17 +566,17 @@ void VM_Version::determine_features() {
   // Don't use R0 in ldarx.
   // Keep R3_ARG1 unmodified, it contains &field (see below).
   // Keep R4_ARG2 unmodified, it contains offset = 0 (see below).
-  a->fsqrt(F3, F4);                            // code[0]  -> fsqrt_m
-  a->fsqrts(F3, F4);                           // code[1]  -> fsqrts_m
-  a->isel(R7, R5, R6, 0);                      // code[2]  -> isel_m
-  a->ldarx_unchecked(R7, R3_ARG1, R4_ARG2, 1); // code[3]  -> lxarx_m
+  a->fsqrt(F3, F4);                            // code[0]  -> fsqrt
+  a->fsqrts(F3, F4);                           // code[1]  -> fsqrts
+  a->isel(R7, R5, R6, 0);                      // code[2]  -> isel
+  a->ldarx_unchecked(R7, R3_ARG1, R4_ARG2, 1); // code[3]  -> lxarx
   a->cmpb(R7, R5, R6);                         // code[4]  -> cmpb
   a->popcntb(R7, R5);                          // code[5]  -> popcntb
   a->popcntw(R7, R5);                          // code[6]  -> popcntw
   a->fcfids(F3, F4);                           // code[7]  -> fcfids
   a->vand(VR0, VR0, VR0);                      // code[8]  -> vand
   // arg0 of lqarx must be an even register, (arg1 + arg2) must be a multiple of 16
-  a->lqarx_unchecked(R6, R3_ARG1, R4_ARG2, 1); // code[9]  -> lqarx_m
+  a->lqarx_unchecked(R6, R3_ARG1, R4_ARG2, 1); // code[9]  -> lqarx
   a->vcipher(VR0, VR1, VR2);                   // code[10] -> vcipher
   a->vpmsumb(VR0, VR1, VR2);                   // code[11] -> vpmsumb
   a->mfdscr(R0);                               // code[12] -> mfdscr
@@ -587,7 +595,7 @@ void VM_Version::determine_features() {
 
   uint32_t *code_end = (uint32_t *)a->pc();
   a->flush();
-  _features = VM_Version::unknown_m;
+  memset(_features, VM_Version::unknown_m, sizeof(uint64_t) * _features_array_size);
 
   // Print the detection code.
   if (PrintAssembly) {
@@ -612,25 +620,25 @@ void VM_Version::determine_features() {
 
   // determine which instructions are legal.
   int feature_cntr = 0;
-  if (code[feature_cntr++]) features |= fsqrt_m;
-  if (code[feature_cntr++]) features |= fsqrts_m;
-  if (code[feature_cntr++]) features |= isel_m;
-  if (code[feature_cntr++]) features |= lxarxeh_m;
-  if (code[feature_cntr++]) features |= cmpb_m;
-  if (code[feature_cntr++]) features |= popcntb_m;
-  if (code[feature_cntr++]) features |= popcntw_m;
-  if (code[feature_cntr++]) features |= fcfids_m;
-  if (code[feature_cntr++]) features |= vand_m;
-  if (code[feature_cntr++]) features |= lqarx_m;
-  if (code[feature_cntr++]) features |= vcipher_m;
-  if (code[feature_cntr++]) features |= vpmsumb_m;
-  if (code[feature_cntr++]) features |= mfdscr_m;
-  if (code[feature_cntr++]) features |= vsx_m;
-  if (code[feature_cntr++]) features |= ldbrx_m;
-  if (code[feature_cntr++]) features |= stdbrx_m;
-  if (code[feature_cntr++]) features |= vshasig_m;
-  if (code[feature_cntr++]) features |= darn_m;
-  if (code[feature_cntr++]) features |= brw_m;
+  if (code[feature_cntr++]) SET_FEATURE(fsqrt);
+  if (code[feature_cntr++]) SET_FEATURE(fsqrts);
+  if (code[feature_cntr++]) SET_FEATURE(isel);
+  if (code[feature_cntr++]) SET_FEATURE(lxarxeh);
+  if (code[feature_cntr++]) SET_FEATURE(cmpb);
+  if (code[feature_cntr++]) SET_FEATURE(popcntb);
+  if (code[feature_cntr++]) SET_FEATURE(popcntw);
+  if (code[feature_cntr++]) SET_FEATURE(fcfids);
+  if (code[feature_cntr++]) SET_FEATURE(vand);
+  if (code[feature_cntr++]) SET_FEATURE(lqarx);
+  if (code[feature_cntr++]) SET_FEATURE(vcipher);
+  if (code[feature_cntr++]) SET_FEATURE(vpmsumb);
+  if (code[feature_cntr++]) SET_FEATURE(mfdscr);
+  if (code[feature_cntr++]) SET_FEATURE(vsx);
+  if (code[feature_cntr++]) SET_FEATURE(ldbrx);
+  if (code[feature_cntr++]) SET_FEATURE(stdbrx);
+  if (code[feature_cntr++]) SET_FEATURE(vshasig);
+  if (code[feature_cntr++]) SET_FEATURE(darn);
+  if (code[feature_cntr++]) SET_FEATURE(brw);
 
   // Print the detection code.
   if (PrintAssembly) {
@@ -638,8 +646,6 @@ void VM_Version::determine_features() {
     tty->print_cr("Decoding cpu-feature detection stub at " INTPTR_FORMAT " after execution:", p2i(code));
     Disassembler::decode((u_char*)code, (u_char*)code_end, tty);
   }
-
-  _features = features;
 }
 
 // Power 8: Configure Data Stream Control Register.
@@ -704,15 +710,13 @@ void VM_Version::config_dscr() {
   }
 }
 
-static uint64_t saved_features = 0;
-
 void VM_Version::allow_all() {
-  saved_features = _features;
-  _features      = all_features_m;
+  memcpy(saved_features, _features, sizeof(uint64_t) * _features_array_size);
+  memset(_features, all_features_m, sizeof(uint64_t) * _features_array_size);
 }
 
 void VM_Version::revert() {
-  _features = saved_features;
+  memcpy(_features, saved_features, sizeof(uint64_t) * _features_array_size);
 }
 
 // get cpu information.
diff --git a/src/hotspot/cpu/ppc/vm_version_ppc.hpp b/src/hotspot/cpu/ppc/vm_version_ppc.hpp
index 6096f8e4fd1..60572a0a060 100644
--- a/src/hotspot/cpu/ppc/vm_version_ppc.hpp
+++ b/src/hotspot/cpu/ppc/vm_version_ppc.hpp
@@ -55,25 +55,6 @@ class VM_Version: public Abstract_VM_Version {
   };
   enum Feature_Flag_Set {
     unknown_m             = 0,
-    fsqrt_m               = (1 << fsqrt  ),
-    fsqrts_m              = (1 << fsqrts ),
-    isel_m                = (1 << isel   ),
-    lxarxeh_m             = (1 << lxarxeh),
-    cmpb_m                = (1 << cmpb   ),
-    popcntb_m             = (1 << popcntb),
-    popcntw_m             = (1 << popcntw),
-    fcfids_m              = (1 << fcfids ),
-    vand_m                = (1 << vand   ),
-    lqarx_m               = (1 << lqarx  ),
-    vcipher_m             = (1 << vcipher),
-    vpmsumb_m             = (1 << vpmsumb),
-    mfdscr_m              = (1 << mfdscr ),
-    vsx_m                 = (1 << vsx    ),
-    ldbrx_m               = (1 << ldbrx  ),
-    stdbrx_m              = (1 << stdbrx ),
-    vshasig_m             = (1 << vshasig),
-    darn_m                = (1 << darn   ),
-    brw_m                 = (1 << brw    ),
     all_features_m        = (unsigned long)-1
   };
 
@@ -85,6 +66,7 @@ class VM_Version: public Abstract_VM_Version {
 
 public:
   // Initialization
+  static void pre_initialize();
   static void initialize();
   static void check_virtualizations();
 
@@ -101,25 +83,25 @@ class VM_Version: public Abstract_VM_Version {
 
   static bool is_determine_features_test_running() { return _is_determine_features_test_running; }
   // CPU instruction support
-  static bool has_fsqrt()   { return (_features & fsqrt_m) != 0; }
-  static bool has_fsqrts()  { return (_features & fsqrts_m) != 0; }
-  static bool has_isel()    { return (_features & isel_m) != 0; }
-  static bool has_lxarxeh() { return (_features & lxarxeh_m) !=0; }
-  static bool has_cmpb()    { return (_features & cmpb_m) != 0; }
-  static bool has_popcntb() { return (_features & popcntb_m) != 0; }
-  static bool has_popcntw() { return (_features & popcntw_m) != 0; }
-  static bool has_fcfids()  { return (_features & fcfids_m) != 0; }
-  static bool has_vand()    { return (_features & vand_m) != 0; }
-  static bool has_lqarx()   { return (_features & lqarx_m) != 0; }
-  static bool has_vcipher() { return (_features & vcipher_m) != 0; }
-  static bool has_vpmsumb() { return (_features & vpmsumb_m) != 0; }
-  static bool has_mfdscr()  { return (_features & mfdscr_m) != 0; }
-  static bool has_vsx()     { return (_features & vsx_m) != 0; }
-  static bool has_ldbrx()   { return (_features & ldbrx_m) != 0; }
-  static bool has_stdbrx()  { return (_features & stdbrx_m) != 0; }
-  static bool has_vshasig() { return (_features & vshasig_m) != 0; }
-  static bool has_darn()    { return (_features & darn_m) != 0; }
-  static bool has_brw()     { return (_features & brw_m) != 0; }
+  static bool has_fsqrt()   { return SUPPORTS_FEATURE(fsqrt); }
+  static bool has_fsqrts()  { return SUPPORTS_FEATURE(fsqrts); }
+  static bool has_isel()    { return SUPPORTS_FEATURE(isel); }
+  static bool has_lxarxeh() { return SUPPORTS_FEATURE(lxarxeh); }
+  static bool has_cmpb()    { return SUPPORTS_FEATURE(cmpb); }
+  static bool has_popcntb() { return SUPPORTS_FEATURE(popcntb); }
+  static bool has_popcntw() { return SUPPORTS_FEATURE(popcntw); }
+  static bool has_fcfids()  { return SUPPORTS_FEATURE(fcfids); }
+  static bool has_vand()    { return SUPPORTS_FEATURE(vand); }
+  static bool has_lqarx()   { return SUPPORTS_FEATURE(lqarx); }
+  static bool has_vcipher() { return SUPPORTS_FEATURE(vcipher); }
+  static bool has_vpmsumb() { return SUPPORTS_FEATURE(vpmsumb); }
+  static bool hasfdscr()    { return SUPPORTS_FEATURE(mfdscr); }
+  static bool has_vsx()     { return SUPPORTS_FEATURE(vsx); }
+  static bool has_ldbrx()   { return SUPPORTS_FEATURE(ldbrx); }
+  static bool has_stdbrx()  { return SUPPORTS_FEATURE(stdbrx); }
+  static bool has_vshasig() { return SUPPORTS_FEATURE(vshasig); }
+  static bool has_darn()    { return SUPPORTS_FEATURE(darn); }
+  static bool has_brw()     { return SUPPORTS_FEATURE(brw); }
 
   static bool has_mtfprd()  { return has_vpmsumb(); } // alias for P8
 
diff --git a/src/hotspot/cpu/riscv/vm_version_riscv.cpp b/src/hotspot/cpu/riscv/vm_version_riscv.cpp
index 8dcffc9c646..712a39fb0f0 100644
--- a/src/hotspot/cpu/riscv/vm_version_riscv.cpp
+++ b/src/hotspot/cpu/riscv/vm_version_riscv.cpp
@@ -64,6 +64,12 @@ void VM_Version::initialize() {
 #endif // COMPILER2
 }
 
+void VM_Version::pre_initialize() {
+  _features_array_size =  (MAX_FEATURE_BITS >> 6) + 1;
+  _features = NEW_C_HEAP_ARRAY(uint64_t, _features_array_size, mtInternal);
+  memset(_features, 0, sizeof(uint64_t) * _features_array_size);
+}
+
 void VM_Version::common_initialize() {
   _supports_atomic_getset4 = true;
   _supports_atomic_getadd4 = true;
diff --git a/src/hotspot/cpu/riscv/vm_version_riscv.hpp b/src/hotspot/cpu/riscv/vm_version_riscv.hpp
index 4214d6c53dc..321f32a09b3 100644
--- a/src/hotspot/cpu/riscv/vm_version_riscv.hpp
+++ b/src/hotspot/cpu/riscv/vm_version_riscv.hpp
@@ -211,6 +211,8 @@ class VM_Version : public Abstract_VM_Version {
   RV_FEATURE_FLAGS(DECLARE_RV_FEATURE)
   #undef DECLARE_RV_FEATURE
 
+  #define MAX_FEATURE_BITS 63
+
   // enable extensions based on profile, current supported profiles:
   //  RVA20U64
   //  RVA22U64
@@ -305,6 +307,7 @@ class VM_Version : public Abstract_VM_Version {
 
  public:
   // Initialization
+  static void pre_initialize();
   static void initialize();
   static void initialize_cpu_information();
 
diff --git a/src/hotspot/cpu/s390/vm_version_s390.cpp b/src/hotspot/cpu/s390/vm_version_s390.cpp
index 157b945e6e1..324bfd8c405 100644
--- a/src/hotspot/cpu/s390/vm_version_s390.cpp
+++ b/src/hotspot/cpu/s390/vm_version_s390.cpp
@@ -88,6 +88,12 @@ static const char* z_features[] = {"  ",
                                        "bear_enh, sort_enh, nnpa_assist, storage_key_removal, vpack_decimal_enh"
                                   };
 
+void VM_Version::pre_initialize() {
+  _features_array_size =  _features_buffer_len;
+  _features = NEW_C_HEAP_ARRAY(uint64_t, _features_array_size, mtInternal);
+  memset(_features, 0, sizeof(uint64_t) * _features_array_size);
+}
+
 void VM_Version::initialize() {
   determine_features();      // Get processor capabilities.
   set_features_string();     // Set a descriptive feature indication.
diff --git a/src/hotspot/cpu/s390/vm_version_s390.hpp b/src/hotspot/cpu/s390/vm_version_s390.hpp
index 49e6f5686f6..b777308b64f 100644
--- a/src/hotspot/cpu/s390/vm_version_s390.hpp
+++ b/src/hotspot/cpu/s390/vm_version_s390.hpp
@@ -411,6 +411,7 @@ class VM_Version: public Abstract_VM_Version {
   };
 
   // Initialization
+  static void pre_initialize();
   static void initialize();
   static void print_features();
   static bool is_determine_features_test_running() { return _is_determine_features_test_running; }
diff --git a/src/hotspot/cpu/x86/vm_version_x86.cpp b/src/hotspot/cpu/x86/vm_version_x86.cpp
index f360d60de9a..b03e869912e 100644
--- a/src/hotspot/cpu/x86/vm_version_x86.cpp
+++ b/src/hotspot/cpu/x86/vm_version_x86.cpp
@@ -51,10 +51,6 @@ VM_Version::CpuidInfo VM_Version::_cpuid_info = { 0, };
 const char* VM_Version::_features_names[] = { CPU_FEATURE_FLAGS(DECLARE_CPU_FEATURE_NAME)};
 #undef DECLARE_CPU_FEATURE_FLAG
 
-#define DECLARE_EXTRA_CPU_FEATURE_NAME(id, name, bit) name,
-const char* VM_Version::_extra_features_names[] = { EXTRA_CPU_FEATURE_FLAGS(DECLARE_EXTRA_CPU_FEATURE_NAME)};
-#undef DECLARE_EXTRA_CPU_FEATURE_FLAG
-
 // Address of instruction which causes SEGV
 address VM_Version::_cpuinfo_segv_addr = nullptr;
 // Address of instruction after the one which causes SEGV
@@ -88,7 +84,7 @@ bool VM_Version::supports_clflush() {
   // up. Assembler::flush calls this routine to check that clflush
   // is allowed. So, we give the caller a free pass if Universe init
   // is still in progress.
-  assert ((!Universe::is_fully_initialized() || (_features & CPU_FLUSH) != 0), "clflush should be available");
+  assert ((!Universe::is_fully_initialized() || SUPPORTS_FEATURE(CPU_FLUSH)), "clflush should be available");
   return true;
 }
 #endif
@@ -875,7 +871,6 @@ void VM_Version::get_processor_features() {
   _cpu = 4; // 486 by default
   _model = 0;
   _stepping = 0;
-  _features = 0;
   _logical_processors_per_package = 1;
   // i486 internal cache is both I&D and has a 16-byte line size
   _L1_data_cache_line_size = 16;
@@ -890,9 +885,8 @@ void VM_Version::get_processor_features() {
   _stepping = cpu_stepping();
 
   if (cpu_family() > 4) { // it supports CPUID
-    _features = _cpuid_info.feature_flags(); // These can be changed by VM settings
-    _extra_features = _cpuid_info.extra_feature_flags(); // These can be changed by VM settings
-    _cpu_features = _features;   // Preserve features
+    _cpuid_info.feature_flags(); // These can be changed by VM settings
+    memcpy(_cpu_features, _features, sizeof(uint64_t) * _features_array_size);   // Preserve features
     // Logical processors are only available on P4s and above,
     // and only if hyperthreading is available.
     _logical_processors_per_package = logical_processor_count();
@@ -948,21 +942,21 @@ void VM_Version::get_processor_features() {
   }
 
   if (UseSSE < 4) {
-    _features &= ~CPU_SSE4_1;
-    _features &= ~CPU_SSE4_2;
+    CLEAR_FEATURE(CPU_SSE4_1);
+    CLEAR_FEATURE(CPU_SSE4_2);
   }
 
   if (UseSSE < 3) {
-    _features &= ~CPU_SSE3;
-    _features &= ~CPU_SSSE3;
-    _features &= ~CPU_SSE4A;
+    CLEAR_FEATURE(CPU_SSE3);
+    CLEAR_FEATURE(CPU_SSSE3);
+    CLEAR_FEATURE(CPU_SSE4A);
   }
 
   if (UseSSE < 2)
-    _features &= ~CPU_SSE2;
+    CLEAR_FEATURE(CPU_SSE2);
 
   if (UseSSE < 1)
-    _features &= ~CPU_SSE;
+    CLEAR_FEATURE(CPU_SSE);
 
   //since AVX instructions is slower than SSE in some ZX cpus, force USEAVX=0.
   if (is_zx() && ((cpu_family() == 6) || (cpu_family() == 7))) {
@@ -1028,25 +1022,25 @@ void VM_Version::get_processor_features() {
   }
 
   if (UseAVX < 3) {
-    _features &= ~CPU_AVX512F;
-    _features &= ~CPU_AVX512DQ;
-    _features &= ~CPU_AVX512CD;
-    _features &= ~CPU_AVX512BW;
-    _features &= ~CPU_AVX512ER;
-    _features &= ~CPU_AVX512PF;
-    _features &= ~CPU_AVX512VL;
-    _features &= ~CPU_AVX512_VPOPCNTDQ;
-    _features &= ~CPU_AVX512_VPCLMULQDQ;
-    _features &= ~CPU_AVX512_VAES;
-    _features &= ~CPU_AVX512_VNNI;
-    _features &= ~CPU_AVX512_VBMI;
-    _features &= ~CPU_AVX512_VBMI2;
-    _features &= ~CPU_AVX512_BITALG;
-    _features &= ~CPU_AVX512_IFMA;
-    _features &= ~CPU_APX_F;
-    _features &= ~CPU_AVX512_FP16;
-    _features &= ~CPU_AVX10_1;
-    _features &= ~EXTRA_CPU_AVX10_2;
+    CLEAR_FEATURE(CPU_AVX512F);
+    CLEAR_FEATURE(CPU_AVX512DQ);
+    CLEAR_FEATURE(CPU_AVX512CD);
+    CLEAR_FEATURE(CPU_AVX512BW);
+    CLEAR_FEATURE(CPU_AVX512ER);
+    CLEAR_FEATURE(CPU_AVX512PF);
+    CLEAR_FEATURE(CPU_AVX512VL);
+    CLEAR_FEATURE(CPU_AVX512_VPOPCNTDQ);
+    CLEAR_FEATURE(CPU_AVX512_VPCLMULQDQ);
+    CLEAR_FEATURE(CPU_AVX512_VAES);
+    CLEAR_FEATURE(CPU_AVX512_VNNI);
+    CLEAR_FEATURE(CPU_AVX512_VBMI);
+    CLEAR_FEATURE(CPU_AVX512_VBMI2);
+    CLEAR_FEATURE(CPU_AVX512_BITALG);
+    CLEAR_FEATURE(CPU_AVX512_IFMA);
+    CLEAR_FEATURE(CPU_APX_F);
+    CLEAR_FEATURE(CPU_AVX512_FP16);
+    CLEAR_FEATURE(CPU_AVX10_1);
+    CLEAR_FEATURE(CPU_AVX10_2);
   }
 
   // Currently APX support is only enabled for targets supporting AVX512VL feature.
@@ -1059,45 +1053,45 @@ void VM_Version::get_processor_features() {
   }
 
   if (!UseAPX) {
-    _features &= ~CPU_APX_F;
+    CLEAR_FEATURE(CPU_APX_F);
   }
 
   if (UseAVX < 2) {
-    _features &= ~CPU_AVX2;
-    _features &= ~CPU_AVX_IFMA;
+    CLEAR_FEATURE(CPU_AVX2);
+    CLEAR_FEATURE(CPU_AVX_IFMA);
   }
 
   if (UseAVX < 1) {
-    _features &= ~CPU_AVX;
-    _features &= ~CPU_VZEROUPPER;
-    _features &= ~CPU_F16C;
-    _features &= ~CPU_SHA512;
+    CLEAR_FEATURE(CPU_AVX);
+    CLEAR_FEATURE(CPU_VZEROUPPER);
+    CLEAR_FEATURE(CPU_F16C);
+    CLEAR_FEATURE(CPU_SHA512);
   }
 
   if (logical_processors_per_package() == 1) {
     // HT processor could be installed on a system which doesn't support HT.
-    _features &= ~CPU_HT;
+    CLEAR_FEATURE(CPU_HT);
   }
 
   if (is_intel()) { // Intel cpus specific settings
     if (is_knights_family()) {
-      _features &= ~CPU_VZEROUPPER;
-      _features &= ~CPU_AVX512BW;
-      _features &= ~CPU_AVX512VL;
-      _features &= ~CPU_AVX512DQ;
-      _features &= ~CPU_AVX512_VNNI;
-      _features &= ~CPU_AVX512_VAES;
-      _features &= ~CPU_AVX512_VPOPCNTDQ;
-      _features &= ~CPU_AVX512_VPCLMULQDQ;
-      _features &= ~CPU_AVX512_VBMI;
-      _features &= ~CPU_AVX512_VBMI2;
-      _features &= ~CPU_CLWB;
-      _features &= ~CPU_FLUSHOPT;
-      _features &= ~CPU_GFNI;
-      _features &= ~CPU_AVX512_BITALG;
-      _features &= ~CPU_AVX512_IFMA;
-      _features &= ~CPU_AVX_IFMA;
-      _features &= ~CPU_AVX512_FP16;
+      CLEAR_FEATURE(CPU_VZEROUPPER);
+      CLEAR_FEATURE(CPU_AVX512BW);
+      CLEAR_FEATURE(CPU_AVX512VL);
+      CLEAR_FEATURE(CPU_AVX512DQ);
+      CLEAR_FEATURE(CPU_AVX512_VNNI);
+      CLEAR_FEATURE(CPU_AVX512_VAES);
+      CLEAR_FEATURE(CPU_AVX512_VPOPCNTDQ);
+      CLEAR_FEATURE(CPU_AVX512_VPCLMULQDQ);
+      CLEAR_FEATURE(CPU_AVX512_VBMI);
+      CLEAR_FEATURE(CPU_AVX512_VBMI2);
+      CLEAR_FEATURE(CPU_CLWB);
+      CLEAR_FEATURE(CPU_FLUSHOPT);
+      CLEAR_FEATURE(CPU_GFNI);
+      CLEAR_FEATURE(CPU_AVX512_BITALG);
+      CLEAR_FEATURE(CPU_AVX512_IFMA);
+      CLEAR_FEATURE(CPU_AVX_IFMA);
+      CLEAR_FEATURE(CPU_AVX512_FP16);
     }
   }
 
@@ -1114,9 +1108,10 @@ void VM_Version::get_processor_features() {
               cores_per_cpu(), threads_per_core(),
               cpu_family(), _model, _stepping, os::cpu_microcode_revision());
   assert(res > 0, "not enough temporary space allocated");
-  insert_features_names(_features, buf + res, sizeof(buf) - res, _features_names);
-  res = (int)strlen(buf);
-  insert_features_names(_extra_features, buf + res, sizeof(buf) - res, _extra_features_names);
+  for (uint64_t i = 0; i < _features_array_size; i++) {
+    insert_features_names(_features[i], buf + res, sizeof(buf) - res, _features_names, 64 * i);
+    res = strlen(buf);
+  }
 
   _features_string = os::strdup(buf);
 
@@ -2199,6 +2194,14 @@ void VM_Version::clear_apx_test_state() {
 
 static bool _vm_version_initialized = false;
 
+void VM_Version::pre_initialize() {
+  _features_array_size =  (MAX_CPU_FEATURES >> 6) + 1;
+  _features = NEW_C_HEAP_ARRAY(uint64_t, _features_array_size, mtInternal);
+  _cpu_features = NEW_C_HEAP_ARRAY(uint64_t, _features_array_size, mtInternal);
+  memset(_features, 0, sizeof(uint64_t) * _features_array_size);
+  memset(_cpu_features, 0, sizeof(uint64_t) * _features_array_size);
+}
+
 void VM_Version::initialize() {
   ResourceMark rm;
   // Making this stub must be FIRST use of assembler
@@ -2979,112 +2982,96 @@ int64_t VM_Version::maximum_qualified_cpu_frequency(void) {
   return _max_qualified_cpu_frequency;
 }
 
-uint64_t VM_Version::CpuidInfo::extra_feature_flags() const {
-  uint64_t result = 0;
-  if (is_intel()) {
-    if (sefsl1_cpuid7_edx.bits.avx10 != 0 &&
-        std_cpuid24_ebx.bits.avx10_vlen_512 !=0 &&
-        std_cpuid24_ebx.bits.avx10_converged_isa_version >= 2 &&
-        xem_xcr0_eax.bits.opmask != 0 &&
-        xem_xcr0_eax.bits.zmm512 != 0 &&
-        xem_xcr0_eax.bits.zmm32 != 0) {
-      result |= EXTRA_CPU_AVX10_2;
-    }
-  }
-  return result;
-}
-
-uint64_t VM_Version::CpuidInfo::feature_flags() const {
-  uint64_t result = 0;
+void VM_Version::CpuidInfo::feature_flags() const {
   if (std_cpuid1_edx.bits.cmpxchg8 != 0)
-    result |= CPU_CX8;
+    SET_FEATURE(CPU_CX8);
   if (std_cpuid1_edx.bits.cmov != 0)
-    result |= CPU_CMOV;
+    SET_FEATURE(CPU_CMOV);
   if (std_cpuid1_edx.bits.clflush != 0)
-    result |= CPU_FLUSH;
+    SET_FEATURE(CPU_FLUSH);
 #ifdef _LP64
   // clflush should always be available on x86_64
   // if not we are in real trouble because we rely on it
   // to flush the code cache.
-  assert ((result & CPU_FLUSH) != 0, "clflush should be available");
+  assert (SUPPORTS_FEATURE(CPU_FLUSH), "clflush should be available");
 #endif
   if (std_cpuid1_edx.bits.fxsr != 0 || (is_amd_family() &&
       ext_cpuid1_edx.bits.fxsr != 0))
-    result |= CPU_FXSR;
+    SET_FEATURE(CPU_FXSR);
   // HT flag is set for multi-core processors also.
   if (threads_per_core() > 1)
-    result |= CPU_HT;
+    SET_FEATURE(CPU_HT);
   if (std_cpuid1_edx.bits.mmx != 0 || (is_amd_family() &&
       ext_cpuid1_edx.bits.mmx != 0))
-    result |= CPU_MMX;
+    SET_FEATURE(CPU_MMX);
   if (std_cpuid1_edx.bits.sse != 0)
-    result |= CPU_SSE;
+    SET_FEATURE(CPU_SSE);
   if (std_cpuid1_edx.bits.sse2 != 0)
-    result |= CPU_SSE2;
+    SET_FEATURE(CPU_SSE2);
   if (std_cpuid1_ecx.bits.sse3 != 0)
-    result |= CPU_SSE3;
+    SET_FEATURE(CPU_SSE3);
   if (std_cpuid1_ecx.bits.ssse3 != 0)
-    result |= CPU_SSSE3;
+    SET_FEATURE(CPU_SSSE3);
   if (std_cpuid1_ecx.bits.sse4_1 != 0)
-    result |= CPU_SSE4_1;
+    SET_FEATURE(CPU_SSE4_1);
   if (std_cpuid1_ecx.bits.sse4_2 != 0)
-    result |= CPU_SSE4_2;
+    SET_FEATURE(CPU_SSE4_2);
   if (std_cpuid1_ecx.bits.popcnt != 0)
-    result |= CPU_POPCNT;
+    SET_FEATURE(CPU_POPCNT);
   if (sefsl1_cpuid7_edx.bits.apx_f != 0 &&
       xem_xcr0_eax.bits.apx_f != 0) {
-    result |= CPU_APX_F;
+    SET_FEATURE(CPU_APX_F);
   }
   if (std_cpuid1_ecx.bits.avx != 0 &&
       std_cpuid1_ecx.bits.osxsave != 0 &&
       xem_xcr0_eax.bits.sse != 0 &&
       xem_xcr0_eax.bits.ymm != 0) {
-    result |= CPU_AVX;
-    result |= CPU_VZEROUPPER;
+    SET_FEATURE(CPU_AVX);
+    SET_FEATURE(CPU_VZEROUPPER);
     if (sefsl1_cpuid7_eax.bits.sha512 != 0)
-      result |= CPU_SHA512;
+      SET_FEATURE(CPU_SHA512);
     if (std_cpuid1_ecx.bits.f16c != 0)
-      result |= CPU_F16C;
+      SET_FEATURE(CPU_F16C);
     if (sef_cpuid7_ebx.bits.avx2 != 0) {
-      result |= CPU_AVX2;
+      SET_FEATURE(CPU_AVX2);
       if (sefsl1_cpuid7_eax.bits.avx_ifma != 0)
-        result |= CPU_AVX_IFMA;
+        SET_FEATURE(CPU_AVX_IFMA);
     }
     if (sef_cpuid7_ecx.bits.gfni != 0)
-        result |= CPU_GFNI;
+        SET_FEATURE(CPU_GFNI);
     if (sef_cpuid7_ebx.bits.avx512f != 0 &&
         xem_xcr0_eax.bits.opmask != 0 &&
         xem_xcr0_eax.bits.zmm512 != 0 &&
         xem_xcr0_eax.bits.zmm32 != 0) {
-      result |= CPU_AVX512F;
+      SET_FEATURE(CPU_AVX512F);
       if (sef_cpuid7_ebx.bits.avx512cd != 0)
-        result |= CPU_AVX512CD;
+        SET_FEATURE(CPU_AVX512CD);
       if (sef_cpuid7_ebx.bits.avx512dq != 0)
-        result |= CPU_AVX512DQ;
+        SET_FEATURE(CPU_AVX512DQ);
       if (sef_cpuid7_ebx.bits.avx512ifma != 0)
-        result |= CPU_AVX512_IFMA;
+        SET_FEATURE(CPU_AVX512_IFMA);
       if (sef_cpuid7_ebx.bits.avx512pf != 0)
-        result |= CPU_AVX512PF;
+        SET_FEATURE(CPU_AVX512PF);
       if (sef_cpuid7_ebx.bits.avx512er != 0)
-        result |= CPU_AVX512ER;
+        SET_FEATURE(CPU_AVX512ER);
       if (sef_cpuid7_ebx.bits.avx512bw != 0)
-        result |= CPU_AVX512BW;
+        SET_FEATURE(CPU_AVX512BW);
       if (sef_cpuid7_ebx.bits.avx512vl != 0)
-        result |= CPU_AVX512VL;
+        SET_FEATURE(CPU_AVX512VL);
       if (sef_cpuid7_ecx.bits.avx512_vpopcntdq != 0)
-        result |= CPU_AVX512_VPOPCNTDQ;
+        SET_FEATURE(CPU_AVX512_VPOPCNTDQ);
       if (sef_cpuid7_ecx.bits.avx512_vpclmulqdq != 0)
-        result |= CPU_AVX512_VPCLMULQDQ;
+        SET_FEATURE(CPU_AVX512_VPCLMULQDQ);
       if (sef_cpuid7_ecx.bits.vaes != 0)
-        result |= CPU_AVX512_VAES;
+        SET_FEATURE(CPU_AVX512_VAES);
       if (sef_cpuid7_ecx.bits.avx512_vnni != 0)
-        result |= CPU_AVX512_VNNI;
+        SET_FEATURE(CPU_AVX512_VNNI);
       if (sef_cpuid7_ecx.bits.avx512_bitalg != 0)
-        result |= CPU_AVX512_BITALG;
+        SET_FEATURE(CPU_AVX512_BITALG);
       if (sef_cpuid7_ecx.bits.avx512_vbmi != 0)
-        result |= CPU_AVX512_VBMI;
+        SET_FEATURE(CPU_AVX512_VBMI);
       if (sef_cpuid7_ecx.bits.avx512_vbmi2 != 0)
-        result |= CPU_AVX512_VBMI2;
+        SET_FEATURE(CPU_AVX512_VBMI2);
     }
     if (is_intel()) {
       if (sefsl1_cpuid7_edx.bits.avx10 != 0 &&
@@ -3093,114 +3080,114 @@ uint64_t VM_Version::CpuidInfo::feature_flags() const {
           xem_xcr0_eax.bits.opmask != 0 &&
           xem_xcr0_eax.bits.zmm512 != 0 &&
           xem_xcr0_eax.bits.zmm32 != 0) {
-        result |= CPU_AVX10_1;
-        result |= CPU_AVX_IFMA;
-        result |= CPU_AVX512F;
-        result |= CPU_AVX512CD;
-        result |= CPU_AVX512DQ;
-        result |= CPU_AVX512PF;
-        result |= CPU_AVX512ER;
-        result |= CPU_AVX512BW;
-        result |= CPU_AVX512VL;
-        result |= CPU_AVX512_VPOPCNTDQ;
-        result |= CPU_AVX512_VPCLMULQDQ;
-        result |= CPU_AVX512_VAES;
-        result |= CPU_AVX512_VNNI;
-        result |= CPU_AVX512_BITALG;
-        result |= CPU_AVX512_VBMI;
-        result |= CPU_AVX512_VBMI2;
+        SET_FEATURE(CPU_AVX10_1);
+        SET_FEATURE(CPU_AVX512F);
+        SET_FEATURE(CPU_AVX512CD);
+        SET_FEATURE(CPU_AVX512DQ);
+        SET_FEATURE(CPU_AVX512PF);
+        SET_FEATURE(CPU_AVX512ER);
+        SET_FEATURE(CPU_AVX512BW);
+        SET_FEATURE(CPU_AVX512VL);
+        SET_FEATURE(CPU_AVX512_VPOPCNTDQ);
+        SET_FEATURE(CPU_AVX512_VPCLMULQDQ);
+        SET_FEATURE(CPU_AVX512_VAES);
+        SET_FEATURE(CPU_AVX512_VNNI);
+        SET_FEATURE(CPU_AVX512_BITALG);
+        SET_FEATURE(CPU_AVX512_VBMI);
+        SET_FEATURE(CPU_AVX512_VBMI2);
+        if (std_cpuid24_ebx.bits.avx10_converged_isa_version >= 2) {
+          SET_FEATURE(CPU_AVX10_2);
+        }
       }
     }
   }
 
   if (std_cpuid1_ecx.bits.hv != 0)
-    result |= CPU_HV;
+    SET_FEATURE(CPU_HV);
   if (sef_cpuid7_ebx.bits.bmi1 != 0)
-    result |= CPU_BMI1;
+    SET_FEATURE(CPU_BMI1);
   if (std_cpuid1_edx.bits.tsc != 0)
-    result |= CPU_TSC;
+    SET_FEATURE(CPU_TSC);
   if (ext_cpuid7_edx.bits.tsc_invariance != 0)
-    result |= CPU_TSCINV_BIT;
+    SET_FEATURE(CPU_TSCINV_BIT);
   if (std_cpuid1_ecx.bits.aes != 0)
-    result |= CPU_AES;
+    SET_FEATURE(CPU_AES);
   if (ext_cpuid1_ecx.bits.lzcnt != 0)
-    result |= CPU_LZCNT;
+    SET_FEATURE(CPU_LZCNT);
   if (ext_cpuid1_ecx.bits.prefetchw != 0)
-    result |= CPU_3DNOW_PREFETCH;
+    SET_FEATURE(CPU_3DNOW_PREFETCH);
   if (sef_cpuid7_ebx.bits.erms != 0)
-    result |= CPU_ERMS;
+    SET_FEATURE(CPU_ERMS);
   if (sef_cpuid7_edx.bits.fast_short_rep_mov != 0)
-    result |= CPU_FSRM;
+    SET_FEATURE(CPU_FSRM);
   if (std_cpuid1_ecx.bits.clmul != 0)
-    result |= CPU_CLMUL;
+    SET_FEATURE(CPU_CLMUL);
   if (sef_cpuid7_ebx.bits.rtm != 0)
-    result |= CPU_RTM;
+    SET_FEATURE(CPU_RTM);
   if (sef_cpuid7_ebx.bits.adx != 0)
-     result |= CPU_ADX;
+     SET_FEATURE(CPU_ADX);
   if (sef_cpuid7_ebx.bits.bmi2 != 0)
-    result |= CPU_BMI2;
+    SET_FEATURE(CPU_BMI2);
   if (sef_cpuid7_ebx.bits.sha != 0)
-    result |= CPU_SHA;
+    SET_FEATURE(CPU_SHA);
   if (std_cpuid1_ecx.bits.fma != 0)
-    result |= CPU_FMA;
+    SET_FEATURE(CPU_FMA);
   if (sef_cpuid7_ebx.bits.clflushopt != 0)
-    result |= CPU_FLUSHOPT;
+    SET_FEATURE(CPU_FLUSHOPT);
   if (sef_cpuid7_ebx.bits.clwb != 0)
-    result |= CPU_CLWB;
+    SET_FEATURE(CPU_CLWB);
   if (ext_cpuid1_edx.bits.rdtscp != 0)
-    result |= CPU_RDTSCP;
+    SET_FEATURE(CPU_RDTSCP);
   if (sef_cpuid7_ecx.bits.rdpid != 0)
-    result |= CPU_RDPID;
+    SET_FEATURE(CPU_RDPID);
 
   // AMD|Hygon additional features.
   if (is_amd_family()) {
     // PREFETCHW was checked above, check TDNOW here.
     if ((ext_cpuid1_edx.bits.tdnow != 0))
-      result |= CPU_3DNOW_PREFETCH;
+      SET_FEATURE(CPU_3DNOW_PREFETCH);
     if (ext_cpuid1_ecx.bits.sse4a != 0)
-      result |= CPU_SSE4A;
+      SET_FEATURE(CPU_SSE4A);
   }
 
   // Intel additional features.
   if (is_intel()) {
     if (sef_cpuid7_edx.bits.serialize != 0)
-      result |= CPU_SERIALIZE;
+      SET_FEATURE(CPU_SERIALIZE);
     if (_cpuid_info.sef_cpuid7_edx.bits.avx512_fp16 != 0)
-      result |= CPU_AVX512_FP16;
+      SET_FEATURE(CPU_AVX512_FP16);
   }
 
   // ZX additional features.
   if (is_zx()) {
     // We do not know if these are supported by ZX, so we cannot trust
     // common CPUID bit for them.
-    assert((result & CPU_CLWB) == 0, "Check if it is supported?");
-    result &= ~CPU_CLWB;
+    assert(SUPPORTS_FEATURE(CPU_CLWB), "Check if it is supported?");
+    CLEAR_FEATURE(CPU_CLWB);
   }
 
   // Protection key features.
   if (sef_cpuid7_ecx.bits.pku != 0) {
-    result |= CPU_PKU;
+    SET_FEATURE(CPU_PKU);
   }
   if (sef_cpuid7_ecx.bits.ospke != 0) {
-    result |= CPU_OSPKE;
+    SET_FEATURE(CPU_OSPKE);
   }
 
   // Control flow enforcement (CET) features.
   if (sef_cpuid7_ecx.bits.cet_ss != 0) {
-    result |= CPU_CET_SS;
+    SET_FEATURE(CPU_CET_SS);
   }
   if (sef_cpuid7_edx.bits.cet_ibt != 0) {
-    result |= CPU_CET_IBT;
+    SET_FEATURE(CPU_CET_IBT);
   }
 
   // Composite features.
   if (supports_tscinv_bit() &&
       ((is_amd_family() && !is_amd_Barcelona()) ||
        is_intel_tsc_synched_at_init())) {
-    result |= CPU_TSCINV;
+    SET_FEATURE(CPU_TSCINV);
   }
-
-  return result;
 }
 
 bool VM_Version::os_supports_avx_vectors() {
diff --git a/src/hotspot/cpu/x86/vm_version_x86.hpp b/src/hotspot/cpu/x86/vm_version_x86.hpp
index c39d186a054..ca1506c8232 100644
--- a/src/hotspot/cpu/x86/vm_version_x86.hpp
+++ b/src/hotspot/cpu/x86/vm_version_x86.hpp
@@ -364,7 +364,7 @@ class VM_Version : public Abstract_VM_Version {
    * test/lib-test/jdk/test/whitebox/CPUInfoTest.java
    * src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/amd64/AMD64.java
    */
-  enum Feature_Flag : uint64_t {
+  enum Feature_Flag : uint32_t {
 #define CPU_FEATURE_FLAGS(decl) \
     decl(CX8,               "cx8",               0)  /*  next bits are from cpuid 1 (EDX) */ \
     decl(CMOV,              "cmov",              1)  \
@@ -441,29 +441,17 @@ class VM_Version : public Abstract_VM_Version {
     decl(APX_F,             "apx_f",             60) /* Intel Advanced Performance Extensions*/ \
     decl(SHA512,            "sha512",            61) /* SHA512 instructions*/ \
     decl(AVX512_FP16,       "avx512_fp16",       62) /* AVX512 FP16 ISA support*/ \
-    decl(AVX10_1,           "avx10_1",           63) /* AVX10 512 bit vector ISA Version 1 support*/
+    decl(AVX10_1,           "avx10_1",           63) /* AVX10 512 bit vector ISA Version 1 support*/ \
+    decl(AVX10_2,           "avx10_2",           64) /* AVX10 512 bit vector ISA Version 2 support*/
 
-#define DECLARE_CPU_FEATURE_FLAG(id, name, bit) CPU_##id = (1ULL << bit),
+#define DECLARE_CPU_FEATURE_FLAG(id, name, bit) CPU_##id = (bit),
     CPU_FEATURE_FLAGS(DECLARE_CPU_FEATURE_FLAG)
 #undef DECLARE_CPU_FEATURE_FLAG
   };
 
-  /*
-   * Update following files when declaring new flags:
-   * test/lib-test/jdk/test/whitebox/CPUInfoTest.java
-   * src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/amd64/AMD64.java
-   */
-  enum Extra_Feature_Flag : uint64_t {
-#define EXTRA_CPU_FEATURE_FLAGS(decl) \
-    decl(AVX10_2,           "avx10_2",           0) /* AVX10 512 bit vector ISA Version 2 support*/
-
-#define DECLARE_EXTRA_CPU_FEATURE_FLAG(id, name, bit) EXTRA_CPU_##id = (1ULL << bit),
-    EXTRA_CPU_FEATURE_FLAGS(DECLARE_EXTRA_CPU_FEATURE_FLAG)
-#undef DECLARE_EXTRA_CPU_FEATURE_FLAG
-  };
+#define MAX_CPU_FEATURES 64
 
   static const char* _features_names[];
-  static const char* _extra_features_names[];
 
   enum Extended_Family {
     // AMD
@@ -606,8 +594,7 @@ class VM_Version : public Abstract_VM_Version {
     // Space to save apx registers after signal handle
     jlong        apx_save[2]; // Save r16 and r31
 
-    uint64_t feature_flags() const;
-    uint64_t extra_feature_flags() const;
+    void feature_flags() const;
 
     // Asserts
     void assert_is_initialized() const {
@@ -687,13 +674,30 @@ class VM_Version : public Abstract_VM_Version {
 
   LP64_ONLY(static void clear_apx_test_state());
 
-  static void clean_cpuFeatures()   { _features = 0; }
-  static void set_avx_cpuFeatures() { _features |= (CPU_SSE | CPU_SSE2 | CPU_AVX | CPU_VZEROUPPER ); }
-  static void set_evex_cpuFeatures() { _features |= (CPU_AVX10_1 | CPU_AVX512F | CPU_SSE | CPU_SSE2 | CPU_VZEROUPPER ); }
-  static void set_apx_cpuFeatures() { _features |= CPU_APX_F; }
-  static void set_bmi_cpuFeatures() { _features |= (CPU_BMI1 | CPU_BMI2 | CPU_LZCNT | CPU_POPCNT); }
+  static void clean_cpuFeatures()   { memset(_features, 0, sizeof(uint64_t) * _features_array_size); }
+  static void set_avx_cpuFeatures() {
+    SET_FEATURE(CPU_SSE);
+    SET_FEATURE(CPU_SSE2);
+    SET_FEATURE(CPU_AVX);
+    SET_FEATURE(CPU_VZEROUPPER);
+  }
+  static void set_evex_cpuFeatures() {
+    SET_FEATURE(CPU_AVX10_1);
+    SET_FEATURE(CPU_AVX512F);
+    SET_FEATURE(CPU_SSE);
+    SET_FEATURE(CPU_SSE2);
+    SET_FEATURE(CPU_VZEROUPPER);
+  }
+  static void set_apx_cpuFeatures() { SET_FEATURE(CPU_APX_F); }
+  static void set_bmi_cpuFeatures() {
+    SET_FEATURE(CPU_BMI1);
+    SET_FEATURE(CPU_BMI2);
+    SET_FEATURE(CPU_LZCNT);
+    SET_FEATURE(CPU_POPCNT);
+  }
 
   // Initialization
+  static void pre_initialize();
   static void initialize();
 
   // Override Abstract_VM_Version implementation
@@ -746,40 +750,40 @@ class VM_Version : public Abstract_VM_Version {
   //
   // Feature identification which can be affected by VM settings
   //
-  static bool supports_cpuid()        { return _features  != 0; }
-  static bool supports_cmov()         { return (_features & CPU_CMOV) != 0; }
-  static bool supports_fxsr()         { return (_features & CPU_FXSR) != 0; }
-  static bool supports_ht()           { return (_features & CPU_HT) != 0; }
-  static bool supports_mmx()          { return (_features & CPU_MMX) != 0; }
-  static bool supports_sse()          { return (_features & CPU_SSE) != 0; }
-  static bool supports_sse2()         { return (_features & CPU_SSE2) != 0; }
-  static bool supports_sse3()         { return (_features & CPU_SSE3) != 0; }
-  static bool supports_ssse3()        { return (_features & CPU_SSSE3)!= 0; }
-  static bool supports_sse4_1()       { return (_features & CPU_SSE4_1) != 0; }
-  static bool supports_sse4_2()       { return (_features & CPU_SSE4_2) != 0; }
-  static bool supports_popcnt()       { return (_features & CPU_POPCNT) != 0; }
-  static bool supports_avx()          { return (_features & CPU_AVX) != 0; }
-  static bool supports_avx2()         { return (_features & CPU_AVX2) != 0; }
-  static bool supports_tsc()          { return (_features & CPU_TSC) != 0; }
-  static bool supports_rdtscp()       { return (_features & CPU_RDTSCP) != 0; }
-  static bool supports_rdpid()        { return (_features & CPU_RDPID) != 0; }
-  static bool supports_aes()          { return (_features & CPU_AES) != 0; }
-  static bool supports_erms()         { return (_features & CPU_ERMS) != 0; }
-  static bool supports_fsrm()         { return (_features & CPU_FSRM) != 0; }
-  static bool supports_clmul()        { return (_features & CPU_CLMUL) != 0; }
-  static bool supports_rtm()          { return (_features & CPU_RTM) != 0; }
-  static bool supports_bmi1()         { return (_features & CPU_BMI1) != 0; }
-  static bool supports_bmi2()         { return (_features & CPU_BMI2) != 0; }
-  static bool supports_adx()          { return (_features & CPU_ADX) != 0; }
-  static bool supports_evex()         { return (_features & CPU_AVX512F) != 0; }
-  static bool supports_avx512dq()     { return (_features & CPU_AVX512DQ) != 0; }
-  static bool supports_avx512ifma()   { return (_features & CPU_AVX512_IFMA) != 0; }
-  static bool supports_avxifma()      { return (_features & CPU_AVX_IFMA) != 0; }
-  static bool supports_avx512pf()     { return (_features & CPU_AVX512PF) != 0; }
-  static bool supports_avx512er()     { return (_features & CPU_AVX512ER) != 0; }
-  static bool supports_avx512cd()     { return (_features & CPU_AVX512CD) != 0; }
-  static bool supports_avx512bw()     { return (_features & CPU_AVX512BW) != 0; }
-  static bool supports_avx512vl()     { return (_features & CPU_AVX512VL) != 0; }
+  static bool supports_cpuid()        { return _features  != nullptr; }
+  static bool supports_cmov()         { return SUPPORTS_FEATURE(CPU_CMOV); }
+  static bool supports_fxsr()         { return SUPPORTS_FEATURE(CPU_FXSR); }
+  static bool supports_ht()           { return SUPPORTS_FEATURE(CPU_HT); }
+  static bool supports_mmx()          { return SUPPORTS_FEATURE(CPU_MMX); }
+  static bool supports_sse()          { return SUPPORTS_FEATURE(CPU_SSE); }
+  static bool supports_sse2()         { return SUPPORTS_FEATURE(CPU_SSE2); }
+  static bool supports_sse3()         { return SUPPORTS_FEATURE(CPU_SSE3); }
+  static bool supports_ssse3()        { return SUPPORTS_FEATURE(CPU_SSSE3); }
+  static bool supports_sse4_1()       { return SUPPORTS_FEATURE(CPU_SSE4_1); }
+  static bool supports_sse4_2()       { return SUPPORTS_FEATURE(CPU_SSE4_2); }
+  static bool supports_popcnt()       { return SUPPORTS_FEATURE(CPU_POPCNT); }
+  static bool supports_avx()          { return SUPPORTS_FEATURE(CPU_AVX); }
+  static bool supports_avx2()         { return SUPPORTS_FEATURE(CPU_AVX2); }
+  static bool supports_tsc()          { return SUPPORTS_FEATURE(CPU_TSC); }
+  static bool supports_rdtscp()       { return SUPPORTS_FEATURE(CPU_RDTSCP); }
+  static bool supports_rdpid()        { return SUPPORTS_FEATURE(CPU_RDPID); }
+  static bool supports_aes()          { return SUPPORTS_FEATURE(CPU_AES); }
+  static bool supports_erms()         { return SUPPORTS_FEATURE(CPU_ERMS); }
+  static bool supports_fsrm()         { return SUPPORTS_FEATURE(CPU_FSRM); }
+  static bool supports_clmul()        { return SUPPORTS_FEATURE(CPU_CLMUL); }
+  static bool supports_rtm()          { return SUPPORTS_FEATURE(CPU_RTM); }
+  static bool supports_bmi1()         { return SUPPORTS_FEATURE(CPU_BMI1); }
+  static bool supports_bmi2()         { return SUPPORTS_FEATURE(CPU_BMI2); }
+  static bool supports_adx()          { return SUPPORTS_FEATURE(CPU_ADX); }
+  static bool supports_evex()         { return SUPPORTS_FEATURE(CPU_AVX512F); }
+  static bool supports_avx512dq()     { return SUPPORTS_FEATURE(CPU_AVX512DQ); }
+  static bool supports_avx512ifma()   { return SUPPORTS_FEATURE(CPU_AVX512_IFMA); }
+  static bool supports_avxifma()      { return SUPPORTS_FEATURE(CPU_AVX_IFMA); }
+  static bool supports_avx512pf()     { return SUPPORTS_FEATURE(CPU_AVX512PF); }
+  static bool supports_avx512er()     { return SUPPORTS_FEATURE(CPU_AVX512ER); }
+  static bool supports_avx512cd()     { return SUPPORTS_FEATURE(CPU_AVX512CD); }
+  static bool supports_avx512bw()     { return SUPPORTS_FEATURE(CPU_AVX512BW); }
+  static bool supports_avx512vl()     { return SUPPORTS_FEATURE(CPU_AVX512VL); }
   static bool supports_avx512vlbw()   { return (supports_evex() && supports_avx512bw() && supports_avx512vl()); }
   static bool supports_avx512bwdq()   { return (supports_evex() && supports_avx512bw() && supports_avx512dq()); }
   static bool supports_avx512vldq()   { return (supports_evex() && supports_avx512dq() && supports_avx512vl()); }
@@ -788,39 +792,39 @@ class VM_Version : public Abstract_VM_Version {
   static bool supports_avx512novl()   { return (supports_evex() && !supports_avx512vl()); }
   static bool supports_avx512nobw()   { return (supports_evex() && !supports_avx512bw()); }
   static bool supports_avx256only()   { return (supports_avx2() && !supports_evex()); }
-  static bool supports_apx_f()        { return (_features & CPU_APX_F) != 0; }
+  static bool supports_apx_f()        { return SUPPORTS_FEATURE(CPU_APX_F); }
   static bool supports_avxonly()      { return ((supports_avx2() || supports_avx()) && !supports_evex()); }
-  static bool supports_sha()          { return (_features & CPU_SHA) != 0; }
-  static bool supports_fma()          { return (_features & CPU_FMA) != 0 && supports_avx(); }
-  static bool supports_vzeroupper()   { return (_features & CPU_VZEROUPPER) != 0; }
-  static bool supports_avx512_vpopcntdq()  { return (_features & CPU_AVX512_VPOPCNTDQ) != 0; }
-  static bool supports_avx512_vpclmulqdq() { return (_features & CPU_AVX512_VPCLMULQDQ) != 0; }
-  static bool supports_avx512_vaes()  { return (_features & CPU_AVX512_VAES) != 0; }
-  static bool supports_gfni()         { return (_features & CPU_GFNI) != 0; }
-  static bool supports_avx512_vnni()  { return (_features & CPU_AVX512_VNNI) != 0; }
-  static bool supports_avx512_bitalg()  { return (_features & CPU_AVX512_BITALG) != 0; }
-  static bool supports_avx512_vbmi()  { return (_features & CPU_AVX512_VBMI) != 0; }
-  static bool supports_avx512_vbmi2() { return (_features & CPU_AVX512_VBMI2) != 0; }
-  static bool supports_avx512_fp16()  { return (_features & CPU_AVX512_FP16) != 0; }
-  static bool supports_hv()           { return (_features & CPU_HV) != 0; }
-  static bool supports_serialize()    { return (_features & CPU_SERIALIZE) != 0; }
-  static bool supports_f16c()         { return (_features & CPU_F16C) != 0; }
-  static bool supports_pku()          { return (_features & CPU_PKU) != 0; }
-  static bool supports_ospke()        { return (_features & CPU_OSPKE) != 0; }
-  static bool supports_cet_ss()       { return (_features & CPU_CET_SS) != 0; }
-  static bool supports_cet_ibt()      { return (_features & CPU_CET_IBT) != 0; }
-  static bool supports_sha512()       { return (_features & CPU_SHA512) != 0; }
+  static bool supports_sha()          { return SUPPORTS_FEATURE(CPU_SHA); }
+  static bool supports_fma()          { return SUPPORTS_FEATURE(CPU_FMA) && supports_avx(); }
+  static bool supports_vzeroupper()   { return SUPPORTS_FEATURE(CPU_VZEROUPPER); }
+  static bool supports_avx512_vpopcntdq()  { return SUPPORTS_FEATURE(CPU_AVX512_VPOPCNTDQ); }
+  static bool supports_avx512_vpclmulqdq() { return SUPPORTS_FEATURE(CPU_AVX512_VPCLMULQDQ); }
+  static bool supports_avx512_vaes()  { return SUPPORTS_FEATURE(CPU_AVX512_VAES); }
+  static bool supports_gfni()         { return SUPPORTS_FEATURE(CPU_GFNI); }
+  static bool supports_avx512_vnni()  { return SUPPORTS_FEATURE(CPU_AVX512_VNNI); }
+  static bool supports_avx512_bitalg()  { return SUPPORTS_FEATURE(CPU_AVX512_BITALG); }
+  static bool supports_avx512_vbmi()  { return SUPPORTS_FEATURE(CPU_AVX512_VBMI); }
+  static bool supports_avx512_vbmi2() { return SUPPORTS_FEATURE(CPU_AVX512_VBMI2); }
+  static bool supports_avx512_fp16()  { return SUPPORTS_FEATURE(CPU_AVX512_FP16); }
+  static bool supports_hv()           { return SUPPORTS_FEATURE(CPU_HV); }
+  static bool supports_serialize()    { return SUPPORTS_FEATURE(CPU_SERIALIZE); }
+  static bool supports_f16c()         { return SUPPORTS_FEATURE(CPU_F16C); }
+  static bool supports_pku()          { return SUPPORTS_FEATURE(CPU_PKU); }
+  static bool supports_ospke()        { return SUPPORTS_FEATURE(CPU_OSPKE); }
+  static bool supports_cet_ss()       { return SUPPORTS_FEATURE(CPU_CET_SS); }
+  static bool supports_cet_ibt()      { return SUPPORTS_FEATURE(CPU_CET_IBT); }
+  static bool supports_sha512()       { return SUPPORTS_FEATURE(CPU_SHA512); }
 
   // Intel AVX10 introduces a versioned approach for enumeration that is monotonically increasing, inclusive,
   // and supporting all vector lengths. Feature set supported by an AVX10 vector ISA version is also supported
   // by all the versions above it.
-  static bool supports_avx10_1()      { return (_features & CPU_AVX10_1) != 0;}
-  static bool supports_avx10_2()      { return (_extra_features & EXTRA_CPU_AVX10_2) != 0;}
+  static bool supports_avx10_1()      { return SUPPORTS_FEATURE(CPU_AVX10_1);}
+  static bool supports_avx10_2()      { return SUPPORTS_FEATURE(CPU_AVX10_2);}
 
   //
   // Feature identification not affected by VM flags
   //
-  static bool cpu_supports_evex()     { return (_cpu_features & CPU_AVX512F) != 0; }
+  static bool cpu_supports_evex()     { return SUPPORTS_CPU_FEATURE(CPU_AVX512F); }
 
   static bool supports_avx512_simd_sort() {
     if (supports_avx512dq()) {
@@ -858,19 +862,19 @@ class VM_Version : public Abstract_VM_Version {
   static bool has_intel_jcc_erratum() { return _has_intel_jcc_erratum; }
 
   // AMD features
-  static bool supports_3dnow_prefetch()    { return (_features & CPU_3DNOW_PREFETCH) != 0; }
-  static bool supports_lzcnt()    { return (_features & CPU_LZCNT) != 0; }
-  static bool supports_sse4a()    { return (_features & CPU_SSE4A) != 0; }
+  static bool supports_3dnow_prefetch()    { return SUPPORTS_FEATURE(CPU_3DNOW_PREFETCH); }
+  static bool supports_lzcnt()    { return SUPPORTS_FEATURE(CPU_LZCNT); }
+  static bool supports_sse4a()    { return SUPPORTS_FEATURE(CPU_SSE4A); }
 
   static bool is_amd_Barcelona()  { return is_amd() &&
                                            extended_cpu_family() == CPU_FAMILY_AMD_11H; }
 
   // Intel and AMD newer cores support fast timestamps well
   static bool supports_tscinv_bit() {
-    return (_features & CPU_TSCINV_BIT) != 0;
+    return SUPPORTS_FEATURE(CPU_TSCINV_BIT);
   }
   static bool supports_tscinv() {
-    return (_features & CPU_TSCINV) != 0;
+    return SUPPORTS_FEATURE(CPU_TSCINV);
   }
 
   // Intel Core and newer cpus have fast IDIV instruction (excluding Atom).
@@ -931,12 +935,12 @@ class VM_Version : public Abstract_VM_Version {
 #ifdef _LP64
   static bool supports_clflush(); // Can't inline due to header file conflict
 #else
-  static bool supports_clflush() { return  ((_features & CPU_FLUSH) != 0); }
+  static bool supports_clflush() { return  (SUPPORTS_FEATURE(CPU_FLUSH)); }
 #endif // _LP64
 
   // Note: CPU_FLUSHOPT and CPU_CLWB bits should always be zero for 32-bit
-  static bool supports_clflushopt() { return ((_features & CPU_FLUSHOPT) != 0); }
-  static bool supports_clwb() { return ((_features & CPU_CLWB) != 0); }
+  static bool supports_clflushopt() { return (SUPPORTS_FEATURE(CPU_FLUSHOPT)); }
+  static bool supports_clwb() { return (SUPPORTS_FEATURE(CPU_CLWB)); }
 
   // Old CPUs perform lea on AGU which causes additional latency transferring the
   // value from/to ALU for other operations
diff --git a/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp
index 5424b58da6d..a34a25304da 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp
@@ -67,7 +67,8 @@ void VM_Version::get_os_cpu_info() {
   // 2) ID_AA64PFR0_EL1 describes AdvSIMD always equals to FP field.
   //    See the Arm ARM, section "ID_AA64PFR0_EL1, AArch64 Processor Feature
   //    Register 0".
-  _features = CPU_FP | CPU_ASIMD;
+  SET_FEATURE(CPU_FP);
+  SET_FEATURE(CPU_ASIMD);
 
   // All Apple-darwin Arm processors have AES, PMULL, SHA1 and SHA2.
   // See https://github.com/apple-oss-distributions/xnu/blob/main/osfmk/arm/commpage/commpage.c#L412
@@ -75,22 +76,25 @@ void VM_Version::get_os_cpu_info() {
   // these four CPU features, e.g., "hw.optional.arm.FEAT_AES", but the
   // corresponding string names are not available before xnu-8019 version.
   // Hence, assertions are omitted considering backward compatibility.
-  _features |= CPU_AES | CPU_PMULL | CPU_SHA1 | CPU_SHA2;
+  SET_FEATURE(CPU_AES);
+  SET_FEATURE(CPU_PMULL);
+  SET_FEATURE(CPU_SHA1);
+  SET_FEATURE(CPU_SHA2);
 
   if (cpu_has("hw.optional.armv8_crc32")) {
-    _features |= CPU_CRC32;
+    SET_FEATURE(CPU_CRC32);
   }
   if (cpu_has("hw.optional.arm.FEAT_LSE") ||
       cpu_has("hw.optional.armv8_1_atomics")) {
-    _features |= CPU_LSE;
+    SET_FEATURE(CPU_LSE);
   }
   if (cpu_has("hw.optional.arm.FEAT_SHA512") ||
       cpu_has("hw.optional.armv8_2_sha512")) {
-    _features |= CPU_SHA512;
+    SET_FEATURE(CPU_SHA512);
   }
   if (cpu_has("hw.optional.arm.FEAT_SHA3") ||
       cpu_has("hw.optional.armv8_2_sha3")) {
-    _features |= CPU_SHA3;
+    SET_FEATURE(CPU_SHA3);
   }
 
   int cache_line_size;
diff --git a/src/hotspot/os_cpu/linux_aarch64/vm_version_linux_aarch64.cpp b/src/hotspot/os_cpu/linux_aarch64/vm_version_linux_aarch64.cpp
index dabc69403f3..ffa3cc2d848 100644
--- a/src/hotspot/os_cpu/linux_aarch64/vm_version_linux_aarch64.cpp
+++ b/src/hotspot/os_cpu/linux_aarch64/vm_version_linux_aarch64.cpp
@@ -170,7 +170,7 @@ void VM_Version::get_os_cpu_info() {
           _revision = v;
         } else if (strncmp(buf, "flags", sizeof("flags") - 1) == 0) {
           if (strstr(p+1, "dcpop")) {
-            guarantee(_features & CPU_DCPOP, "dcpop availability should be consistent");
+            guarantee(SUPPORTS_FEATURE(CPU_DCPOP), "dcpop availability should be consistent");
           }
         }
       }
diff --git a/src/hotspot/os_cpu/linux_riscv/vm_version_linux_riscv.cpp b/src/hotspot/os_cpu/linux_riscv/vm_version_linux_riscv.cpp
index b6095c279cb..9d89320ca2b 100644
--- a/src/hotspot/os_cpu/linux_riscv/vm_version_linux_riscv.cpp
+++ b/src/hotspot/os_cpu/linux_riscv/vm_version_linux_riscv.cpp
@@ -167,7 +167,7 @@ void VM_Version::setup_cpu_available_features() {
       }
       // Feature bit
       if (_feature_list[i]->feature_bit() != 0) {
-        _features |= _feature_list[i]->feature_bit();
+        SET_FEATURE(_feature_list[i]->feature_bit());
       }
     }
     i++;
diff --git a/src/hotspot/os_cpu/windows_aarch64/vm_version_windows_aarch64.cpp b/src/hotspot/os_cpu/windows_aarch64/vm_version_windows_aarch64.cpp
index de9bf76fdb0..9e1ae6a0f84 100644
--- a/src/hotspot/os_cpu/windows_aarch64/vm_version_windows_aarch64.cpp
+++ b/src/hotspot/os_cpu/windows_aarch64/vm_version_windows_aarch64.cpp
@@ -27,22 +27,29 @@
 #include "runtime/vm_version.hpp"
 
 int VM_Version::get_current_sve_vector_length() {
-  assert(_features & CPU_SVE, "should not call this");
+  assert(SUPPORTS_FEATURE(CPU_SVE), "should not call this");
   ShouldNotReachHere();
   return 0;
 }
 
 int VM_Version::set_and_get_current_sve_vector_length(int length) {
-  assert(_features & CPU_SVE, "should not call this");
+  assert(SUPPORTS_FEATURE(CPU_SVE), "should not call this");
   ShouldNotReachHere();
   return 0;
 }
 
 void VM_Version::get_os_cpu_info() {
-
-  if (IsProcessorFeaturePresent(PF_ARM_V8_CRC32_INSTRUCTIONS_AVAILABLE))   _features |= CPU_CRC32;
-  if (IsProcessorFeaturePresent(PF_ARM_V8_CRYPTO_INSTRUCTIONS_AVAILABLE))  _features |= CPU_AES | CPU_SHA1 | CPU_SHA2;
-  if (IsProcessorFeaturePresent(PF_ARM_VFP_32_REGISTERS_AVAILABLE))        _features |= CPU_ASIMD;
+  if (IsProcessorFeaturePresent(PF_ARM_V8_CRC32_INSTRUCTIONS_AVAILABLE)) {
+    SET_FEATURE(CPU_CRC32);
+  }
+  if (IsProcessorFeaturePresent(PF_ARM_V8_CRYPTO_INSTRUCTIONS_AVAILABLE)) {
+    SET_FEATURE(CPU_AES);
+    SET_FEATURE(CPU_SHA1);
+    SET_FEATURE(CPU_SHA2);
+  }
+  if (IsProcessorFeaturePresent(PF_ARM_VFP_32_REGISTERS_AVAILABLE)) {
+    SET_FEATURE(CPU_ASIMD);
+  }
   // No check for CPU_PMULL, CPU_SVE, CPU_SVE2
 
   __int64 dczid_el0 = _ReadStatusReg(0x5807 /* ARM64_DCZID_EL0 */);
diff --git a/src/hotspot/share/jvmci/vmStructs_jvmci.cpp b/src/hotspot/share/jvmci/vmStructs_jvmci.cpp
index 2bc484108d6..b930320ba8f 100644
--- a/src/hotspot/share/jvmci/vmStructs_jvmci.cpp
+++ b/src/hotspot/share/jvmci/vmStructs_jvmci.cpp
@@ -144,10 +144,10 @@
                                                                                                                                      \
   static_field(CompilerToVM::Data,             data_section_item_alignment,            int)                                          \
                                                                                                                                      \
-  JVMTI_ONLY(static_field(CompilerToVM::Data,  _should_notify_object_alloc,            int*))                                         \
+  JVMTI_ONLY(static_field(CompilerToVM::Data,  _should_notify_object_alloc,            int*))                                        \
                                                                                                                                      \
-  static_field(Abstract_VM_Version,            _features,                              uint64_t)                                     \
-  static_field(Abstract_VM_Version,            _extra_features,                        uint64_t)                                     \
+  static_field(Abstract_VM_Version,            _features,                              uint64_t*)                                    \
+  static_field(Abstract_VM_Version,            _features_array_size,                   uint64_t)                                     \
                                                                                                                                      \
   nonstatic_field(Annotations,                 _class_annotations,                     AnnotationArray*)                             \
   nonstatic_field(Annotations,                 _fields_annotations,                    Array<AnnotationArray*>*)                     \
@@ -984,10 +984,8 @@
   declare_constant(frame::interpreter_frame_last_sp_offset)
 
 #define DECLARE_LONG_CPU_FEATURE_CONSTANT(id, name, bit) GENERATE_VM_LONG_CONSTANT_ENTRY(VM_Version::CPU_##id)
-#define DECLARE_LONG_EXTRA_CPU_FEATURE_CONSTANT(id, name, bit) GENERATE_VM_LONG_CONSTANT_ENTRY(VM_Version::EXTRA_CPU_##id)
 #define VM_LONG_CPU_FEATURE_CONSTANTS \
-   CPU_FEATURE_FLAGS(DECLARE_LONG_CPU_FEATURE_CONSTANT) \
-   EXTRA_CPU_FEATURE_FLAGS(DECLARE_LONG_EXTRA_CPU_FEATURE_CONSTANT)
+   CPU_FEATURE_FLAGS(DECLARE_LONG_CPU_FEATURE_CONSTANT)
 
 #endif
 
diff --git a/src/hotspot/share/runtime/abstract_vm_version.cpp b/src/hotspot/share/runtime/abstract_vm_version.cpp
index 4ae08ab962a..d6381bbcb70 100644
--- a/src/hotspot/share/runtime/abstract_vm_version.cpp
+++ b/src/hotspot/share/runtime/abstract_vm_version.cpp
@@ -32,10 +32,10 @@
 const char* Abstract_VM_Version::_s_vm_release = Abstract_VM_Version::vm_release();
 const char* Abstract_VM_Version::_s_internal_vm_info_string = Abstract_VM_Version::internal_vm_info_string();
 
-uint64_t Abstract_VM_Version::_features = 0;
-uint64_t Abstract_VM_Version::_extra_features = 0;
+uint64_t* Abstract_VM_Version::_features = nullptr;
 const char* Abstract_VM_Version::_features_string = "";
-uint64_t Abstract_VM_Version::_cpu_features = 0;
+uint64_t* Abstract_VM_Version::_cpu_features = nullptr;
+uint64_t Abstract_VM_Version::_features_array_size = 0;
 
 #ifndef SUPPORTS_NATIVE_CX8
 bool Abstract_VM_Version::_supports_cx8 = false;
@@ -325,9 +325,8 @@ unsigned int Abstract_VM_Version::jvm_version() {
          (Abstract_VM_Version::vm_build_number() & 0xFF);
 }
 
-void Abstract_VM_Version::insert_features_names(uint64_t features, char* buf, size_t buflen, const char* features_names[]) {
-  uint features_names_index = 0;
-
+void Abstract_VM_Version::insert_features_names(uint64_t features, char* buf, size_t buflen, const char* features_names[],
+                                                uint features_names_index) {
   while (features != 0) {
     if (features & 1) {
       int res = jio_snprintf(buf, buflen, ", %s", features_names[features_names_index]);
diff --git a/src/hotspot/share/runtime/abstract_vm_version.hpp b/src/hotspot/share/runtime/abstract_vm_version.hpp
index 52021e715bc..b515c4e02c8 100644
--- a/src/hotspot/share/runtime/abstract_vm_version.hpp
+++ b/src/hotspot/share/runtime/abstract_vm_version.hpp
@@ -55,14 +55,15 @@ class Abstract_VM_Version: AllStatic {
   static const char*  _s_internal_vm_info_string;
 
   // CPU feature flags, can be affected by VM settings.
-  static uint64_t _features;
+  static uint64_t* _features;
+  static uint64_t _features_array_size;
+
   // Extra CPU feature flags used when all 64 bits of _features are exhausted for
   // on a given target, currently only used for x86_64, can be affected by VM settings.
-  static uint64_t _extra_features;
   static const char* _features_string;
 
   // Original CPU feature flags, not affected by VM settings.
-  static uint64_t _cpu_features;
+  static uint64_t* _cpu_features;
 
   // These are set by machine-dependent initializations
 #ifndef SUPPORTS_NATIVE_CX8
@@ -129,11 +130,59 @@ class Abstract_VM_Version: AllStatic {
   static const char* jdk_debug_level();
   static const char* printable_jdk_debug_level();
 
-  static uint64_t features()           { return _features; }
-  static uint64_t extra_features()     { return _extra_features; }
+  static uint64_t features(uint32_t index = 0) {
+    assert(index < _features_array_size, "Features array index out of bounds");
+    return _features[index];
+  }
+
+  static void set_feature(uint32_t feature) {
+    uint32_t index = feature >> 6;
+    assert(index < _features_array_size, "Features array index out of bounds");
+    _features[index] |= (1ULL << (feature & 63));
+  }
+
+  static void set_cpu_feature(uint32_t feature) {
+    uint32_t index = feature >> 6;
+    assert(index < _features_array_size, "Features array index out of bounds");
+    _cpu_features[index] |= (1ULL << (feature & 63));
+  }
+
+  static bool supports_feature(uint32_t feature) {
+    uint32_t index = feature >> 6;
+    assert(index < _features_array_size, "Features array index out of bounds");
+    return (_features[index] & (1ULL << (feature & 63))) != 0;
+  }
+
+  static bool supports_cpu_feature(uint32_t feature) {
+    uint32_t index = feature >> 6;
+    assert(index < _features_array_size, "Features array index out of bounds");
+    return (_cpu_features[index] & (1ULL << (feature & 63))) != 0;
+  }
+
+  static void clear_feature(uint32_t feature) {
+    uint32_t index = feature >> 6;
+    assert(index < _features_array_size, "Features array index out of bounds");
+    _features[index] &= ~(1ULL << (feature & 63));
+  }
+
+#define SET_FEATURE(feature) \
+  Abstract_VM_Version::set_feature(feature)
+
+#define SET_CPU_FEATURE(feature) \
+  Abstract_VM_Version::set_cpu_feature(feature)
+
+#define CLEAR_FEATURE(feature) \
+  Abstract_VM_Version::clear_feature(feature)
+
+#define SUPPORTS_FEATURE(feature) \
+  Abstract_VM_Version::supports_feature(feature)
+
+#define SUPPORTS_CPU_FEATURE(feature) \
+  Abstract_VM_Version::supports_cpu_feature(feature)
+
   static const char* features_string() { return _features_string; }
 
-  static void insert_features_names(uint64_t features, char* buf, size_t buflen, const char* features_names[]);
+  static void insert_features_names(uint64_t features, char* buf, size_t buflen, const char* features_names[], uint features_names_index = 0);
 
   static VirtualizationType get_detected_virtualization() {
     return _detected_virtualization;
diff --git a/src/hotspot/share/runtime/init.cpp b/src/hotspot/share/runtime/init.cpp
index 417bba6c3fa..d5bcff402c6 100644
--- a/src/hotspot/share/runtime/init.cpp
+++ b/src/hotspot/share/runtime/init.cpp
@@ -65,6 +65,7 @@ void classLoader_init1();
 void compilationPolicy_init();
 void codeCache_init();
 void VM_Version_init();
+void VM_Version_pre_init();
 void initial_stubs_init();
 
 jint universe_init();           // depends on codeCache_init and initial_stubs_init
@@ -123,6 +124,7 @@ jint init_globals() {
   bytecodes_init();
   classLoader_init1();
   compilationPolicy_init();
+  VM_Version_pre_init();          // allocate feature flags arrays
   codeCache_init();
   VM_Version_init();              // depends on codeCache_init for emitting code
   // stub routines in initial blob are referenced by later generated code
diff --git a/src/hotspot/share/runtime/vmStructs.cpp b/src/hotspot/share/runtime/vmStructs.cpp
index f865380fdb7..afd9600ed95 100644
--- a/src/hotspot/share/runtime/vmStructs.cpp
+++ b/src/hotspot/share/runtime/vmStructs.cpp
@@ -700,7 +700,8 @@
                                                                                                                                      \
      static_field(Abstract_VM_Version,         _s_vm_release,                                 const char*)                           \
      static_field(Abstract_VM_Version,         _s_internal_vm_info_string,                    const char*)                           \
-     static_field(Abstract_VM_Version,         _features,                                     uint64_t)                              \
+     static_field(Abstract_VM_Version,         _features,                                     uint64_t*)                             \
+     static_field(Abstract_VM_Version,         _features_array_size,                          uint64_t)                              \
      static_field(Abstract_VM_Version,         _features_string,                              const char*)                           \
      static_field(Abstract_VM_Version,         _vm_major_version,                             int)                                   \
      static_field(Abstract_VM_Version,         _vm_minor_version,                             int)                                   \
diff --git a/src/hotspot/share/runtime/vm_version.cpp b/src/hotspot/share/runtime/vm_version.cpp
index 7c5b7fe3f3e..149f6f01f13 100644
--- a/src/hotspot/share/runtime/vm_version.cpp
+++ b/src/hotspot/share/runtime/vm_version.cpp
@@ -27,6 +27,10 @@
 #include "memory/resourceArea.hpp"
 #include "runtime/vm_version.hpp"
 
+void VM_Version_pre_init() {
+  VM_Version::pre_initialize();
+}
+
 void VM_Version_init() {
   VM_Version::initialize();
   guarantee(VM_Version::supports_cx8(), "Support for 64-bit atomic operations is required");
diff --git a/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/HotSpotJVMCIBackendFactory.java b/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/HotSpotJVMCIBackendFactory.java
index 1a3adae7b53..73cd63916e6 100644
--- a/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/HotSpotJVMCIBackendFactory.java
+++ b/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/HotSpotJVMCIBackendFactory.java
@@ -30,6 +30,7 @@
 
 import jdk.vm.ci.common.JVMCIError;
 import jdk.vm.ci.runtime.JVMCIBackend;
+import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
 
 public interface HotSpotJVMCIBackendFactory {
 
@@ -56,30 +57,24 @@
     static <CPUFeatureType extends Enum<CPUFeatureType>> EnumSet<CPUFeatureType> convertFeatures(
                     Class<CPUFeatureType> enumType,
                     Map<String, Long> constants,
-                    long features,
-                    long extra_features,
+                    long features_pointer,
+                    long features_array_size,
                     Map<String, String> renaming) {
         EnumSet<CPUFeatureType> outFeatures = EnumSet.noneOf(enumType);
         List<String> missing = new ArrayList<>();
         for (Entry<String, Long> e : constants.entrySet()) {
-            long bitMask = e.getValue();
             String key = e.getKey();
+            long bitIndex = e.getValue();
             if (key.startsWith("VM_Version::CPU_")) {
                 String name = key.substring("VM_Version::CPU_".length());
                 try {
                     CPUFeatureType feature = Enum.valueOf(enumType, renaming.getOrDefault(name, name));
-                    if ((features & bitMask) != 0) {
-                        outFeatures.add(feature);
-                    }
-                } catch (IllegalArgumentException iae) {
-                    missing.add(name);
-                }
-            }
-            if (key.startsWith("VM_Version::EXTRA_CPU_")) {
-                String name = key.substring("VM_Version::EXTRA_CPU_".length());
-                try {
-                    CPUFeatureType feature = Enum.valueOf(enumType, renaming.getOrDefault(name, name));
-                    if ((extra_features & bitMask) != 0) {
+                    long features_array_index = bitIndex >>> 6;
+                    assert features_array_index < features_array_size;
+
+                    long features = UNSAFE.getLong(features_pointer + features_array_index * Long.BYTES);
+                    long effective_bitMask = 1L << (bitIndex & (Long.SIZE - 1));
+                    if ((features & effective_bitMask) != 0) {
                         outFeatures.add(feature);
                     }
                 } catch (IllegalArgumentException iae) {
diff --git a/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/aarch64/AArch64HotSpotJVMCIBackendFactory.java b/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/aarch64/AArch64HotSpotJVMCIBackendFactory.java
index 0c8f4a5d44a..2ea5c4596d7 100644
--- a/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/aarch64/AArch64HotSpotJVMCIBackendFactory.java
+++ b/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/aarch64/AArch64HotSpotJVMCIBackendFactory.java
@@ -49,7 +49,8 @@
     private static EnumSet<AArch64.CPUFeature> computeFeatures(AArch64HotSpotVMConfig config) {
         // Configure the feature set using the HotSpot flag settings.
         Map<String, Long> constants = config.getStore().getConstants();
-        return HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, config.vmVersionFeatures, 0L, emptyMap());
+        return HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, config.vmVersionFeatures,
+                                                          config.vmVersionFeaturesArraySize, emptyMap());
     }
 
     private static EnumSet<AArch64.Flag> computeFlags(AArch64HotSpotVMConfig config) {
diff --git a/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/aarch64/AArch64HotSpotVMConfig.java b/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/aarch64/AArch64HotSpotVMConfig.java
index a388687c69a..7feded2f2e3 100644
--- a/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/aarch64/AArch64HotSpotVMConfig.java
+++ b/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/aarch64/AArch64HotSpotVMConfig.java
@@ -50,6 +50,7 @@
     final boolean useBlockZeroing = getFlag("UseBlockZeroing", Boolean.class);
 
     final long vmVersionFeatures = getFieldValue("Abstract_VM_Version::_features", Long.class, "uint64_t");
+    final long vmVersionFeaturesArraySize = getFieldValue("Abstract_VM_Version::_features_array_size", Long.class, "uint64_t");
 
     /*
      * These flags are set if the corresponding support is in the hardware.
diff --git a/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/amd64/AMD64HotSpotJVMCIBackendFactory.java b/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/amd64/AMD64HotSpotJVMCIBackendFactory.java
index bd9b60574dc..544a3e05594 100644
--- a/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/amd64/AMD64HotSpotJVMCIBackendFactory.java
+++ b/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/amd64/AMD64HotSpotJVMCIBackendFactory.java
@@ -51,7 +51,7 @@
         Map<String, String> renaming = Map.of("3DNOW_PREFETCH", "AMD_3DNOW_PREFETCH");
         assert config.useSSE >= 2 : "minimum config for x64";
         EnumSet<CPUFeature> features = HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, config.vmVersionFeatures,
-                                                                                  config.vmVersionExtraFeatures, renaming);
+                                                                                  config.vmVersionFeaturesArraySize, renaming);
         features.add(AMD64.CPUFeature.SSE);
         features.add(AMD64.CPUFeature.SSE2);
         return features;
diff --git a/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/amd64/AMD64HotSpotVMConfig.java b/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/amd64/AMD64HotSpotVMConfig.java
index 67241fffddd..f27e31efc8d 100644
--- a/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/amd64/AMD64HotSpotVMConfig.java
+++ b/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/amd64/AMD64HotSpotVMConfig.java
@@ -46,8 +46,8 @@
     final int useSSE = getFlag("UseSSE", Integer.class);
     final int useAVX = getFlag("UseAVX", Integer.class);
 
-    final long vmVersionFeatures = getFieldValue("Abstract_VM_Version::_features", Long.class, "uint64_t");
-    final long vmVersionExtraFeatures = getFieldValue("Abstract_VM_Version::_extra_features", Long.class, "uint64_t");
+    final long vmVersionFeatures = getFieldAddress("Abstract_VM_Version::_features", "uint64_t*");
+    final long vmVersionFeaturesArraySize = getFieldValue("Abstract_VM_Version::_features_array_size", Long.class, "uint64_t");
 
     // CPU feature flags
     final long amd64CX8 = getConstant("VM_Version::CPU_CX8", Long.class);
@@ -90,5 +90,5 @@
     final long amd64CET_IBT = getConstant("VM_Version::CPU_CET_IBT", Long.class);
     final long amd64CET_SS = getConstant("VM_Version::CPU_CET_SS", Long.class);
     final long avx10_1 = getConstant("VM_Version::CPU_AVX10_1", Long.class);
-    final long avx10_2 = getConstant("VM_Version::EXTRA_CPU_AVX10_2", Long.class);
+    final long avx10_2 = getConstant("VM_Version::CPU_AVX10_2", Long.class);
 }
diff --git a/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/riscv64/RISCV64HotSpotJVMCIBackendFactory.java b/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/riscv64/RISCV64HotSpotJVMCIBackendFactory.java
index 881cbf983e0..bc02091a187 100644
--- a/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/riscv64/RISCV64HotSpotJVMCIBackendFactory.java
+++ b/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/riscv64/RISCV64HotSpotJVMCIBackendFactory.java
@@ -49,7 +49,8 @@
     private static EnumSet<RISCV64.CPUFeature> computeFeatures(RISCV64HotSpotVMConfig config) {
         // Configure the feature set using the HotSpot flag settings.
         Map<String, Long> constants = config.getStore().getConstants();
-        return HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, config.vmVersionFeatures, 0L, emptyMap());
+        return HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, config.vmVersionFeatures,
+                                                          config.vmVersionFeaturesArraySize, emptyMap());
     }
 
     private static EnumSet<RISCV64.Flag> computeFlags(RISCV64HotSpotVMConfig config) {
diff --git a/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/riscv64/RISCV64HotSpotVMConfig.java b/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/riscv64/RISCV64HotSpotVMConfig.java
index 1d52556522e..9325f1fa343 100644
--- a/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/riscv64/RISCV64HotSpotVMConfig.java
+++ b/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/riscv64/RISCV64HotSpotVMConfig.java
@@ -52,4 +52,5 @@
     final boolean useZbb = getFlag("UseZbb", Boolean.class);
 
     final long vmVersionFeatures = getFieldValue("Abstract_VM_Version::_features", Long.class, "uint64_t");
+    final long vmVersionFeaturesArraySize = getFieldValue("Abstract_VM_Version::_features_array_size", Long.class, "uint64_t");
 }
diff --git a/test/hotspot/jtreg/serviceability/sa/ClhsdbLongConstant.java b/test/hotspot/jtreg/serviceability/sa/ClhsdbLongConstant.java
index 1f039eb73b5..5a3336de64d 100644
--- a/test/hotspot/jtreg/serviceability/sa/ClhsdbLongConstant.java
+++ b/test/hotspot/jtreg/serviceability/sa/ClhsdbLongConstant.java
@@ -105,7 +105,7 @@ private static void checkForTruncation(String longConstantOutput) throws Excepti
             // Expected value obtained from the CPU_SHA definition in vm_version_x86.hpp
             checkLongValue("VM_Version::CPU_SHA ",
                            longConstantOutput,
-                           17179869184L);
+                           34L);
         }
     }
 
