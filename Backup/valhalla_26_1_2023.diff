diff --git a/make/Docs.gmk b/make/Docs.gmk
index aff3a23c77b..0f4629c83d5 100644
--- a/make/Docs.gmk
+++ b/make/Docs.gmk
@@ -110,7 +110,7 @@ JAVA_WARNINGS_ARE_ERRORS ?= -Werror
 JAVADOC_OPTIONS := -XDignore.symbol.file=true -use -keywords -notimestamp \
     -encoding ISO-8859-1 -docencoding UTF-8 -breakiterator \
     -splitIndex --system none -javafx --expand-requires transitive \
-    -XDenableValueTypes \
+    -XDenableValueTypes -XDenablePrimitiveClasses \
     --override-methods=summary
 
 # The reference options must stay stable to allow for comparisons across the
diff --git a/make/common/JavaCompilation.gmk b/make/common/JavaCompilation.gmk
index 69defaed9e7..86c631e00af 100644
--- a/make/common/JavaCompilation.gmk
+++ b/make/common/JavaCompilation.gmk
@@ -268,7 +268,7 @@ define SetupJavaCompilationBody
   endif
 
   # Allow overriding on the command line
-  JAVA_WARNINGS_ARE_ERRORS ?= -Werror
+  JAVA_WARNINGS_ARE_ERRORS ?=
 
   # Tell javac to do exactly as told and no more
   PARANOIA_FLAGS := -implicit:none -Xprefer:source -XDignore.symbol.file=true -encoding ascii
diff --git a/src/hotspot/share/ci/ciField.cpp b/src/hotspot/share/ci/ciField.cpp
index f9a7df6d17d..f967940989d 100644
--- a/src/hotspot/share/ci/ciField.cpp
+++ b/src/hotspot/share/ci/ciField.cpp
@@ -204,12 +204,14 @@ ciField::ciField(fieldDescriptor *fd) :
 
   BasicType field_type = fd->field_type();
 
+  initialize_from(fd);
+
   // If the field is a pointer type, get the klass of the
   // field.
   if (is_reference_type(field_type)) {
     _type = NULL;  // must call compute_type on first access
   } else {
-    _type = ciType::make(field_type);
+    _type = ciType::make(field_type, _secondary_fields_count);
   }
 
   initialize_from(fd);
@@ -242,6 +244,10 @@ ciField::ciField(ciField* field, ciInstanceKlass* holder, int offset, bool is_fi
   _is_flattened = false;
   _is_null_free = field->_is_null_free;
   _original_holder = (field->_original_holder != NULL) ? field->_original_holder : field->_holder;
+  _is_multifield = field->_is_multifield;
+  _is_multifield_base = field->_is_multifield_base;
+  _secondary_fields_count = field->_secondary_fields_count;
+
 }
 
 static bool trust_final_non_static_fields(ciInstanceKlass* holder) {
@@ -295,6 +301,10 @@ void ciField::initialize_from(fieldDescriptor* fd) {
   _is_null_free = fd->signature()->is_Q_signature();
   _original_holder = NULL;
 
+  _is_multifield = fd->is_multifield();
+  _is_multifield_base = fd->is_multifield_base();
+  _secondary_fields_count = fd->secondary_fields_count(fd->index());
+
   // Check to see if the field is constant.
   Klass* k = _holder->get_Klass();
   bool is_stable_field = FoldStableValues && is_stable();
diff --git a/src/hotspot/share/ci/ciField.hpp b/src/hotspot/share/ci/ciField.hpp
index f923b78eeeb..d69a26d40a5 100644
--- a/src/hotspot/share/ci/ciField.hpp
+++ b/src/hotspot/share/ci/ciField.hpp
@@ -49,9 +49,12 @@ private:
   ciSymbol*        _signature;
   ciType*          _type;
   int              _offset;
+  int              _secondary_fields_count;
   bool             _is_constant;
   bool             _is_flattened;
   bool             _is_null_free;
+  bool             _is_multifield;
+  bool             _is_multifield_base;
   ciMethod*        _known_to_link_with_put;
   ciInstanceKlass* _known_to_link_with_get;
   ciConstant       _constant_value;
@@ -105,6 +108,10 @@ public:
   // Of what type is this field?
   ciType* type() { return (_type == NULL) ? compute_type() : _type; }
 
+  bool is_multifield() { return _is_multifield; }
+  bool is_multifield_base() { return _is_multifield_base; }
+  int secondary_fields_count() { return _secondary_fields_count; } const
+
   // How is this field actually stored in memory?
   BasicType layout_type() { return type2field[type()->basic_type()]; }
 
@@ -180,6 +187,8 @@ public:
   bool is_transient            () const { return flags().is_transient(); }
   bool is_flattened            () const { return _is_flattened; }
   bool is_null_free            () const { return _is_null_free; }
+  bool is_multifield           () const { return _is_multifield; }
+
 
   // The field is modified outside of instance initializer methods
   // (or class/initializer methods if the field is static).
diff --git a/src/hotspot/share/ci/ciInstanceKlass.cpp b/src/hotspot/share/ci/ciInstanceKlass.cpp
index e07447aebb6..0071447689f 100644
--- a/src/hotspot/share/ci/ciInstanceKlass.cpp
+++ b/src/hotspot/share/ci/ciInstanceKlass.cpp
@@ -531,6 +531,7 @@ GrowableArray<ciField*>* ciInstanceKlass::compute_nonstatic_fields_impl(Growable
   InstanceKlass* k = get_instanceKlass();
   for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
     if (fs.access_flags().is_static())  continue;
+    if (fs.is_multifield()) continue;
     flen += 1;
   }
 
@@ -549,6 +550,7 @@ GrowableArray<ciField*>* ciInstanceKlass::compute_nonstatic_fields_impl(Growable
 
   for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
     if (fs.access_flags().is_static())  continue;
+    if (fs.is_multifield()) continue;
     fieldDescriptor& fd = fs.field_descriptor();
     if (fd.is_inlined() && flatten) {
       // Inline type fields are embedded
diff --git a/src/hotspot/share/ci/ciType.cpp b/src/hotspot/share/ci/ciType.cpp
index 79512966846..19fe37ae69d 100644
--- a/src/hotspot/share/ci/ciType.cpp
+++ b/src/hotspot/share/ci/ciType.cpp
@@ -39,13 +39,15 @@ ciType* ciType::_basic_types[T_CONFLICT+1];
 // ------------------------------------------------------------------
 // ciType::ciType
 //
-ciType::ciType(BasicType basic_type) : ciMetadata() {
+ciType::ciType(BasicType basic_type, int bundle_size) : ciMetadata() {
   assert(basic_type >= T_BOOLEAN && basic_type <= T_CONFLICT, "range check");
   _basic_type = basic_type;
+  _bundle_size = bundle_size;
 }
 
 ciType::ciType(Klass* k) : ciMetadata(k) {
   _basic_type = k->is_array_klass() ? T_ARRAY : (k->is_inline_klass() ? T_PRIMITIVE_OBJECT : T_OBJECT);
+  _bundle_size = 1;
 }
 
 
@@ -106,13 +108,17 @@ ciInstance* ciType::java_mirror() {
 // Produce the ciType for a given primitive BasicType.
 // As a bonus, produce the right reference type for T_OBJECT.
 // Does not work on T_ARRAY.
-ciType* ciType::make(BasicType t) {
-  // short, etc.
-  // Note: Bare T_ADDRESS means a raw pointer type, not a return_address.
-  assert((uint)t < T_CONFLICT+1, "range check");
-  if (t == T_OBJECT)  return ciEnv::_Object_klass;  // java/lang/Object
-  assert(_basic_types[t] != NULL, "domain check");
-  return _basic_types[t];
+ciType* ciType::make(BasicType t, int bundle_size) {
+  if (bundle_size == 1) {
+    // short, etc.
+    // Note: Bare T_ADDRESS means a raw pointer type, not a return_address.
+    assert((uint)t < T_CONFLICT+1, "range check");
+    if (t == T_OBJECT)  return ciEnv::_Object_klass;  // java/lang/Object
+    assert(_basic_types[t] != NULL, "domain check");
+    return _basic_types[t];
+  } else {
+    return new (CURRENT_ENV->arena()) ciType(t, bundle_size);
+  }
 }
 
 // ciReturnAddress
diff --git a/src/hotspot/share/ci/ciType.hpp b/src/hotspot/share/ci/ciType.hpp
index 2df869600ba..f8fd47675d5 100644
--- a/src/hotspot/share/ci/ciType.hpp
+++ b/src/hotspot/share/ci/ciType.hpp
@@ -39,8 +39,9 @@ class ciType : public ciMetadata {
 
 private:
   BasicType _basic_type;
+  int _bundle_size;
 
-  ciType(BasicType t);     // for primitive and unloaded types
+  ciType(BasicType t, int bundle_size = 1);     // for primitive and unloaded types
   ciType(Klass* k);        // for subclasses (reference types)
 
   const char* type_string() { return "ciType"; }
@@ -63,7 +64,8 @@ public:
 
   // Returns true if this is not a klass or array (i.e., not a reference type).
   bool is_primitive_type() const            { return !is_reference_type(basic_type()); }
-  int size() const                          { return type2size[basic_type()]; }
+  int size() const                          { return _bundle_size * type2size[basic_type()]; }
+  int bundle_size() const                   { return _bundle_size; }
   bool is_void() const                      { return basic_type() == T_VOID; }
   bool is_one_word() const                  { return size() == 1; }
   bool is_two_word() const                  { return size() == 2; }
@@ -81,7 +83,7 @@ public:
     print_name_on(tty);
   }
 
-  static ciType* make(BasicType t);
+  static ciType* make(BasicType t, int bundle_size = 1);
 };
 
 
diff --git a/src/hotspot/share/classfile/vmSymbols.hpp b/src/hotspot/share/classfile/vmSymbols.hpp
index 64a6ff82580..fd60f2184cd 100644
--- a/src/hotspot/share/classfile/vmSymbols.hpp
+++ b/src/hotspot/share/classfile/vmSymbols.hpp
@@ -99,6 +99,7 @@
   template(jdk_internal_vm_vector_VectorPayloadMF256, "jdk/internal/vm/vector/VectorSupport$VectorPayloadMF256") \
   template(jdk_internal_vm_vector_VectorPayloadMF512, "jdk/internal/vm/vector/VectorSupport$VectorPayloadMF512") \
   template(payload_name,                              "payload")                                  \
+  template(mfield_name,                               "mfield")                                   \
   template(ETYPE_name,                                "ETYPE")                                    \
   template(VLENGTH_name,                              "VLENGTH")                                  \
                                                                                                   \
diff --git a/src/hotspot/share/opto/callGenerator.cpp b/src/hotspot/share/opto/callGenerator.cpp
index 4a9dc0ad329..27fdf0541b3 100644
--- a/src/hotspot/share/opto/callGenerator.cpp
+++ b/src/hotspot/share/opto/callGenerator.cpp
@@ -790,7 +790,7 @@ void CallGenerator::do_late_inline_helper() {
 
     // Handle inline type returns
     InlineTypeNode* vt = result->isa_InlineType();
-    if (vt != NULL) {
+    if (vt != NULL && !result->is_VectorBox()) {
       if (call->tf()->returns_inline_type_as_fields()) {
         vt->replace_call_results(&kit, call, C, inline_method->signature()->returns_null_free_inline_type());
       } else if (vt->is_InlineType()) {
diff --git a/src/hotspot/share/opto/cfgnode.cpp b/src/hotspot/share/opto/cfgnode.cpp
index a76d62078ee..b32c537351d 100644
--- a/src/hotspot/share/opto/cfgnode.cpp
+++ b/src/hotspot/share/opto/cfgnode.cpp
@@ -2698,7 +2698,7 @@ Node* PhiNode::merge_through_phi(Node* root_phi, PhaseIterGVN* igvn) {
   const TypeVect*    vtype = cached_vbox->vec_type();
   Node* new_vbox_phi = clone_through_phi(root_phi, btype, VectorBoxNode::Box,   igvn);
   Node* new_vect_phi = clone_through_phi(root_phi, vtype, VectorBoxNode::Value, igvn);
-  return new VectorBoxNode(igvn->C, new_vbox_phi, new_vect_phi, btype, vtype);
+  return VectorBoxNode::make_box_node(*igvn, igvn->C, new_vbox_phi, new_vect_phi, btype, vtype);
 }
 
 bool PhiNode::is_data_loop(RegionNode* r, Node* uin, const PhaseGVN* phase) {
diff --git a/src/hotspot/share/opto/compile.cpp b/src/hotspot/share/opto/compile.cpp
index bbb9a91fdf1..b9beb54deef 100644
--- a/src/hotspot/share/opto/compile.cpp
+++ b/src/hotspot/share/opto/compile.cpp
@@ -2739,16 +2739,6 @@ void Compile::Optimize() {
   // so keep only the actual candidates for optimizations.
   cleanup_expensive_nodes(igvn);
 
-  assert(EnableVectorSupport || !has_vbox_nodes(), "sanity");
-  if (EnableVectorSupport && has_vbox_nodes()) {
-    TracePhase tp("", &timers[_t_vector]);
-    PhaseVector pv(igvn);
-    pv.optimize_vector_boxes();
-
-    print_method(PHASE_ITER_GVN_AFTER_VECTOR, 2);
-  }
-  assert(!has_vbox_nodes(), "sanity");
-
   if (!failing() && RenumberLiveNodes && live_nodes() + NodeLimitFudgeFactor < unique()) {
     Compile::TracePhase tp("", &timers[_t_renumberLive]);
     initial_gvn()->replace_with(&igvn);
@@ -2773,6 +2763,17 @@ void Compile::Optimize() {
   // Process inline type nodes now that all inlining is over
   process_inline_types(igvn);
 
+  assert(EnableVectorSupport || !has_vbox_nodes(), "sanity");
+  if (EnableVectorSupport && has_vbox_nodes()) {
+    TracePhase tp("", &timers[_t_vector]);
+    PhaseVector pv(igvn);
+    pv.optimize_vector_boxes();
+
+    print_method(PHASE_ITER_GVN_AFTER_VECTOR, 2);
+  }
+  assert(!has_vbox_nodes(), "sanity");
+
+
   adjust_flattened_array_access_aliases(igvn);
 
   // Perform escape analysis
diff --git a/src/hotspot/share/opto/inlinetypenode.cpp b/src/hotspot/share/opto/inlinetypenode.cpp
index 9a0d8bd2911..2d492defd6a 100644
--- a/src/hotspot/share/opto/inlinetypenode.cpp
+++ b/src/hotspot/share/opto/inlinetypenode.cpp
@@ -32,6 +32,8 @@
 #include "opto/inlinetypenode.hpp"
 #include "opto/rootnode.hpp"
 #include "opto/phaseX.hpp"
+#include "opto/vectornode.hpp"
+
 
 uint InlineTypeNode::size_of() const {
   return sizeof(*this);
@@ -84,6 +86,9 @@ InlineTypeNode* InlineTypeNode::clone_with_phis(PhaseGVN* gvn, Node* region, boo
       value = value->as_InlineType()->clone_with_phis(gvn, region);
     } else {
       phi_type = Type::get_const_type(type);
+      if (vt->is_multifield_base(i)) {
+        phi_type = TypeVect::make(phi_type, vt->secondary_field_count(i));
+      }
       value = PhiNode::make(region, value, phi_type);
       gvn->set_type(value, phi_type);
       gvn->record_for_igvn(value);
@@ -233,6 +238,21 @@ ciType* InlineTypeNode::field_type(uint index) const {
   return inline_klass()->declared_nonstatic_field_at(index)->type();
 }
 
+int InlineTypeNode::secondary_field_count(uint index) const {
+  assert(is_multifield_base(index), "non-multifield field at index");
+  return inline_klass()->declared_nonstatic_field_at(index)->secondary_fields_count();
+}
+
+bool InlineTypeNode::is_multifield(uint index) const {
+  assert(index < field_count(), "index out of bounds");
+  return inline_klass()->declared_nonstatic_field_at(index)->is_multifield();
+}
+
+bool InlineTypeNode::is_multifield_base(uint index) const {
+  assert(index < field_count(), "index out of bounds");
+  return inline_klass()->declared_nonstatic_field_at(index)->is_multifield_base();
+}
+
 bool InlineTypeNode::field_is_flattened(uint index) const {
   assert(index < field_count(), "index out of bounds");
   ciField* field = inline_klass()->declared_nonstatic_field_at(index);
@@ -398,7 +418,11 @@ void InlineTypeNode::load(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass*
         if (is_array) {
           decorators |= IS_ARRAY;
         }
-        value = kit->access_load_at(base, adr, adr_type, val_type, bt, decorators);
+        if (ft->bundle_size() > 1) {
+          value = kit->gvn().transform(LoadVectorNode::make(0, kit->control(), kit->memory(adr), adr, adr_type, ft->bundle_size(), ft->basic_type()));
+        } else {
+          value = kit->access_load_at(base, adr, adr_type, val_type, bt, decorators);
+        }
       }
       // Loading a non-flattened inline type from memory
       if (ft->is_inlinetype()) {
@@ -429,11 +453,19 @@ void InlineTypeNode::store(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass
     Node* value = field_value(i);
     ciType* ft = field_type(i);
     if (field_is_flattened(i)) {
-      // Recursively store the flattened inline type field
-      if (!value->is_InlineType()) {
-        value = InlineTypeNode::make_from_oop(kit, value, ft->as_inline_klass());
+      if (kit->gvn().type(value)->isa_vect()) {
+        int vec_len = kit->gvn().type(value)->is_vect()->length();
+        const TypePtr* adr_type = field_adr_type(base, offset, holder, decorators, kit->gvn());
+        Node* adr = kit->basic_plus_adr(base, ptr, offset);
+        Node* store = kit->gvn().transform(StoreVectorNode::make(0, kit->control(), kit->memory(adr), adr, adr_type, value, vec_len));
+        kit->set_memory(store, adr_type);
+      } else {
+        if (!value->is_InlineType()) {
+          // Recursively store the flattened inline type field
+          value = InlineTypeNode::make_from_oop(kit, value, ft->as_inline_klass());
+        }
+        value->as_InlineType()->store_flattened(kit, base, ptr, holder, offset, decorators);
       }
-      value->as_InlineType()->store_flattened(kit, base, ptr, holder, offset, decorators);
     } else {
       // Store field value to memory
       const TypePtr* adr_type = field_adr_type(base, offset, holder, decorators, kit->gvn());
@@ -445,7 +477,16 @@ void InlineTypeNode::store(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass
       if (ary_type != NULL) {
         decorators |= IS_ARRAY;
       }
-      kit->access_store_at(base, adr, adr_type, value, val_type, bt, decorators);
+      if (ft->bundle_size() > 1) {
+        // Handling for non-flattened case, with default InlineFieldMaxFlatSize of 128
+        // all the concrete vectors should be fully flattened.
+        value = value->bottom_type()->isa_vect() ? value : kit->gvn().transform(VectorNode::scalar2vector(value, ft->bundle_size(), val_type, false));
+        assert(value->bottom_type()->isa_vect() && value->bottom_type()->is_vect()->length() == (uint)ft->bundle_size(), "");
+        Node* store = kit->gvn().transform(StoreVectorNode::make(0, kit->control(), kit->memory(adr), adr, adr_type, value, ft->bundle_size()));
+        kit->set_memory(store, adr_type);
+      } else {
+        kit->access_store_at(base, adr, adr_type, value, val_type, bt, decorators);
+      }
     }
   }
 }
@@ -551,6 +592,7 @@ bool InlineTypeNode::is_allocated(PhaseGVN* phase) const {
   }
   Node* oop = get_oop();
   const Type* oop_type = (phase != NULL) ? phase->type(oop) : oop->bottom_type();
+  // Primitive objects are always null free.
   return !oop_type->maybe_null();
 }
 
@@ -637,14 +679,18 @@ static void replace_allocation(PhaseIterGVN* igvn, Node* res, Node* dom) {
 
 Node* InlineTypeNode::Ideal(PhaseGVN* phase, bool can_reshape) {
   Node* oop = get_oop();
-  if (is_default(phase) && inline_klass()->is_initialized() &&
+  // An InlineTypeNode in larval state is up for updation and
+  // should not be replaced by precomputed default oops.
+  Node* alloc = AllocateNode::Ideal_allocation(oop, phase);
+  bool is_larval_alloc = alloc && alloc->as_Allocate()->_larval == true;
+  if (!is_larval_alloc && is_default(phase) && inline_klass()->is_initialized() &&
       (!oop->is_Con() || phase->type(oop)->is_zero_type())) {
     // Use the pre-allocated oop for default inline types
     set_oop(default_oop(*phase, inline_klass()));
     assert(is_allocated(phase), "should now be allocated");
     return this;
   }
-  if (oop->isa_InlineType() && !phase->type(oop)->maybe_null()) {
+  if (oop->isa_InlineType() && !oop->isa_VectorBox() && !phase->type(oop)->maybe_null()) {
     InlineTypeNode* vtptr = oop->as_InlineType();
     set_oop(vtptr->get_oop());
     set_is_init(*phase);
@@ -703,6 +749,14 @@ Node* InlineTypeNode::default_oop(PhaseGVN& gvn, ciInlineKlass* vk) {
   return gvn.makecon(TypeInstPtr::make(vk->default_instance()));
 }
 
+Node* InlineTypeNode::default_value(PhaseGVN& gvn, ciType* field_type) {
+  Node* value = gvn.zerocon(field_type->basic_type());
+  if (field_type->bundle_size() > 1)  {
+    value = gvn.transform(VectorNode::scalar2vector(value, field_type->bundle_size(), Type::get_const_type(field_type), false));
+  }
+  return value;
+}
+
 InlineTypeNode* InlineTypeNode::make_default(PhaseGVN& gvn, ciInlineKlass* vk) {
   // Create a new InlineTypeNode with default values
   Node* oop = vk->is_initialized() ? default_oop(gvn, vk) : gvn.zerocon(T_PRIMITIVE_OBJECT);
@@ -710,7 +764,7 @@ InlineTypeNode* InlineTypeNode::make_default(PhaseGVN& gvn, ciInlineKlass* vk) {
   vt->set_is_init(gvn);
   for (uint i = 0; i < vt->field_count(); ++i) {
     ciType* field_type = vt->field_type(i);
-    Node* value = gvn.zerocon(field_type->basic_type());
+    Node* value = default_value(gvn, field_type);
     if (field_type->is_inlinetype()) {
       ciInlineKlass* vk = field_type->as_inline_klass();
       if (vt->field_is_null_free(i)) {
@@ -742,7 +796,8 @@ bool InlineTypeNode::is_default(PhaseGVN* gvn) const {
     } else if (value->is_InlineType()) {
       value = value->as_InlineType()->get_oop();
     }
-    if (!gvn->type(value)->is_zero_type()) {
+    if (!gvn->type(value)->is_zero_type() &&
+        !VectorNode::is_all_zeros_vector(value)) {
       return false;
     }
   }
@@ -1109,7 +1164,7 @@ InlineTypeNode* InlineTypeNode::make_null(PhaseGVN& gvn, ciInlineKlass* vk) {
   ptr->set_req(IsInit, gvn.intcon(0));
   for (uint i = 0; i < ptr->field_count(); i++) {
     ciType* field_type = ptr->field_type(i);
-    Node* value = gvn.zerocon(field_type->basic_type());
+    Node* value = default_value(gvn, field_type);
     if (field_type->is_inlinetype()) {
       value = InlineTypeNode::make_null(gvn, field_type->as_inline_klass());
     }
diff --git a/src/hotspot/share/opto/inlinetypenode.hpp b/src/hotspot/share/opto/inlinetypenode.hpp
index dee49217c00..f44f69c2a9b 100644
--- a/src/hotspot/share/opto/inlinetypenode.hpp
+++ b/src/hotspot/share/opto/inlinetypenode.hpp
@@ -71,7 +71,6 @@ protected:
   void initialize_fields(GraphKit* kit, MultiNode* multi, uint& base_input, bool in, bool null_free = true, Node* null_check_region = NULL);
 
 public:
-
   // Create with default field values
   static InlineTypeNode* make_default(PhaseGVN& gvn, ciInlineKlass* vk);
   // Create uninitialized
@@ -88,6 +87,8 @@ public:
   // Returns the constant oop of the default inline type allocation
   static Node* default_oop(PhaseGVN& gvn, ciInlineKlass* vk);
 
+  static Node* default_value(PhaseGVN& gvn, ciType* field_type);
+
   // Support for control flow merges
   bool has_phi_inputs(Node* region);
   InlineTypeNode* clone_with_phis(PhaseGVN* gvn, Node* region, bool is_init = false);
@@ -102,13 +103,18 @@ public:
   void  set_is_buffered() { _is_buffered = true; }
 
   // Inline type fields
-  uint          field_count() const { return req() - Values; }
-  Node*         field_value(uint index) const;
+  virtual uint  field_count() const { return req() - Values; }
+  virtual Node* field_value(uint index) const;
+  uint          field_index(int offset) const;
+
   Node*         field_value_by_offset(int offset, bool recursive = false) const;
-  void      set_field_value(uint index, Node* value);
-  void      set_field_value_by_offset(int offset, Node* value);
+  void          set_field_value(uint index, Node* value);
+  void          set_field_value_by_offset(int offset, Node* value);
   int           field_offset(uint index) const;
-  uint          field_index(int offset) const;
+  bool          is_multifield(uint index) const;
+  bool          is_multifield_base(uint index) const;
+  int           secondary_field_count(uint index) const;
+  bool          is_multifield() const;
   ciType*       field_type(uint index) const;
   bool          field_is_flattened(uint index) const;
   bool          field_is_null_free(uint index) const;
diff --git a/src/hotspot/share/opto/library_call.hpp b/src/hotspot/share/opto/library_call.hpp
index e12d042d25b..f170174701b 100644
--- a/src/hotspot/share/opto/library_call.hpp
+++ b/src/hotspot/share/opto/library_call.hpp
@@ -109,7 +109,9 @@ class LibraryCallKit : public GraphKit {
     Node* res = result();
     if (!stopped() && res != NULL) {
       BasicType bt = res->bottom_type()->basic_type();
-      if (C->inlining_incrementally() && res->is_InlineType()) {
+      // VectorBoxes should be treated as special InlineTypeNodes, we will defer its buffering
+      // to a later stage to give opportunity for consumption by subsequent expanders.
+      if (C->inlining_incrementally() && res->is_InlineType() && !res->is_VectorBox()) {
         // The caller expects an oop when incrementally inlining an intrinsic that returns an
         // inline type. Make sure the call is re-executed if the allocation triggers a deoptimization.
         PreserveReexecuteState preexecs(this);
diff --git a/src/hotspot/share/opto/node.hpp b/src/hotspot/share/opto/node.hpp
index a30e2ab8e5b..b969b2ba7e9 100644
--- a/src/hotspot/share/opto/node.hpp
+++ b/src/hotspot/share/opto/node.hpp
@@ -167,6 +167,7 @@ class Type;
 class TypeNode;
 class UnlockNode;
 class InlineTypeNode;
+class VectorBoxNode;
 class VectorNode;
 class LoadVectorNode;
 class LoadVectorMaskedNode;
@@ -719,6 +720,7 @@ public:
         DEFINE_CLASS_ID(ExpandV, Vector, 5)
         DEFINE_CLASS_ID(CompressM, Vector, 6)
       DEFINE_CLASS_ID(InlineType, Type, 8)
+        DEFINE_CLASS_ID(VectorBox, InlineType, 0)
 
     DEFINE_CLASS_ID(Proj,  Node, 3)
       DEFINE_CLASS_ID(CatchProj, Proj, 0)
@@ -952,6 +954,7 @@ public:
   DEFINE_CLASS_QUERY(SubTypeCheck)
   DEFINE_CLASS_QUERY(Type)
   DEFINE_CLASS_QUERY(InlineType)
+  DEFINE_CLASS_QUERY(VectorBox)
   DEFINE_CLASS_QUERY(Vector)
   DEFINE_CLASS_QUERY(VectorMaskCmp)
   DEFINE_CLASS_QUERY(VectorUnbox)
diff --git a/src/hotspot/share/opto/vector.cpp b/src/hotspot/share/opto/vector.cpp
index 7000372c0e7..533569f56d3 100644
--- a/src/hotspot/share/opto/vector.cpp
+++ b/src/hotspot/share/opto/vector.cpp
@@ -31,6 +31,7 @@
 #include "opto/rootnode.hpp"
 #include "opto/vector.hpp"
 #include "utilities/macros.hpp"
+#include "prims/vectorSupport.hpp"
 
 static bool is_vector_mask(ciKlass* klass) {
   return klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());
@@ -52,7 +53,7 @@ void PhaseVector::optimize_vector_boxes() {
   C->initial_gvn()->replace_with(&_igvn);
 
   expand_vunbox_nodes();
-  scalarize_vbox_nodes();
+  // scalarize_vbox_nodes();
 
   C->inline_vector_reboxing_calls();
 
@@ -306,14 +307,15 @@ void PhaseVector::expand_vbox_node(VectorBoxNode* vec_box) {
   if (vec_box->outcnt() > 0) {
     Node* vbox = vec_box->in(VectorBoxNode::Box);
     Node* vect = vec_box->in(VectorBoxNode::Value);
-    Node* result = expand_vbox_node_helper(vbox, vect, vec_box->box_type(), vec_box->vec_type());
+    Node* result = expand_vbox_node_helper(vec_box, vbox, vect, vec_box->box_type(), vec_box->vec_type());
     C->gvn_replace_by(vec_box, result);
     C->print_method(PHASE_EXPAND_VBOX, 3, vec_box);
   }
   C->remove_macro_node(vec_box);
 }
 
-Node* PhaseVector::expand_vbox_node_helper(Node* vbox,
+Node* PhaseVector::expand_vbox_node_helper(Node* vec_box,
+                                           Node* vbox,
                                            Node* vect,
                                            const TypeInstPtr* box_type,
                                            const TypeVect* vect_type) {
@@ -321,7 +323,7 @@ Node* PhaseVector::expand_vbox_node_helper(Node* vbox,
     assert(vbox->as_Phi()->region() == vect->as_Phi()->region(), "");
     Node* new_phi = new PhiNode(vbox->as_Phi()->region(), box_type);
     for (uint i = 1; i < vbox->req(); i++) {
-      Node* new_box = expand_vbox_node_helper(vbox->in(i), vect->in(i), box_type, vect_type);
+      Node* new_box = expand_vbox_node_helper(vec_box, vbox->in(i), vect->in(i), box_type, vect_type);
       new_phi->set_req(i, new_box);
     }
     new_phi = C->initial_gvn()->transform(new_phi);
@@ -336,14 +338,14 @@ Node* PhaseVector::expand_vbox_node_helper(Node* vbox,
     // move up and are guaranteed to dominate.
     Node* new_phi = new PhiNode(vbox->as_Phi()->region(), box_type);
     for (uint i = 1; i < vbox->req(); i++) {
-      Node* new_box = expand_vbox_node_helper(vbox->in(i), vect, box_type, vect_type);
+      Node* new_box = expand_vbox_node_helper(vec_box, vbox->in(i), vect, box_type, vect_type);
       new_phi->set_req(i, new_box);
     }
     new_phi = C->initial_gvn()->transform(new_phi);
     return new_phi;
   } else if (vbox->is_Proj() && vbox->in(0)->Opcode() == Op_VectorBoxAllocate) {
     VectorBoxAllocateNode* vbox_alloc = static_cast<VectorBoxAllocateNode*>(vbox->in(0));
-    return expand_vbox_alloc_node(vbox_alloc, vect, box_type, vect_type);
+    return expand_vbox_alloc_node(vec_box, vbox_alloc, vect, box_type, vect_type);
   } else {
     assert(!vbox->is_Phi(), "");
     // TODO: assert that expanded vbox is initialized with the same value (vect).
@@ -351,10 +353,12 @@ Node* PhaseVector::expand_vbox_node_helper(Node* vbox,
   }
 }
 
-Node* PhaseVector::expand_vbox_alloc_node(VectorBoxAllocateNode* vbox_alloc,
+Node* PhaseVector::expand_vbox_alloc_node(Node* vbox,
+                                          VectorBoxAllocateNode* vbox_alloc,
                                           Node* value,
                                           const TypeInstPtr* box_type,
                                           const TypeVect* vect_type) {
+  assert(vbox->isa_InlineType(), "");
   JVMState* jvms = clone_jvms(C, vbox_alloc);
   GraphKit kit(jvms);
   PhaseGVN& gvn = kit.gvn();
@@ -362,6 +366,7 @@ Node* PhaseVector::expand_vbox_alloc_node(VectorBoxAllocateNode* vbox_alloc,
   ciInstanceKlass* box_klass = box_type->instance_klass();
   BasicType bt = vect_type->element_basic_type();
   int num_elem = vect_type->length();
+  int elem_size = type2aelembytes(bt);
 
   bool is_mask = is_vector_mask(box_klass);
   // If boxed mask value is present in a predicate register, it must be
@@ -375,53 +380,51 @@ Node* PhaseVector::expand_vbox_alloc_node(VectorBoxAllocateNode* vbox_alloc,
            "must be consistent with mask representation");
   }
 
-  // Generate array allocation for the field which holds the values.
-  const TypeKlassPtr* array_klass = TypeKlassPtr::make(ciTypeArrayKlass::make(bt));
-  Node* arr = kit.new_array(kit.makecon(array_klass), kit.intcon(num_elem), 1);
+  const TypeKlassPtr* klass_type = box_type->as_klass_type();
+  Node* klass_node = kit.makecon(klass_type);
+  Node* buffer_mem = kit.new_instance(klass_node, NULL, NULL, /* deoptimize_on_exception */ true, vbox->as_InlineType());
+  // TODO: Re-use existing value storage routine from InlineTypeNode.
+  //vbox->as_InlineType()->store(&kit, buffer, buffer, box_klass);
 
   // Store the vector value into the array.
   // (The store should be captured by InitializeNode and turned into initialized store later.)
-  Node* arr_adr = kit.array_element_address(arr, kit.intcon(0), bt);
-  const TypePtr* arr_adr_type = arr_adr->bottom_type()->is_ptr();
-  Node* arr_mem = kit.memory(arr_adr);
+  ciSymbol* payload_sig = ciSymbol::make(VectorSupport::get_vector_payload_field_signature(num_elem * elem_size)->as_C_string());
+  ciSymbol* payload_name = ciSymbol::make(vmSymbols::payload_name()->as_C_string());
+  ciField* payload = box_klass->get_field_by_name(payload_name, payload_sig, false);
+
+  Node* buffer_start_adr = kit.basic_plus_adr(buffer_mem, payload->offset());
+  const TypePtr* buffer_adr_type = buffer_start_adr->bottom_type()->is_ptr();
+  Node* buffer_mem_start = kit.memory(buffer_start_adr);
   Node* vstore = gvn.transform(StoreVectorNode::make(0,
                                                      kit.control(),
-                                                     arr_mem,
-                                                     arr_adr,
-                                                     arr_adr_type,
+                                                     buffer_mem_start,
+                                                     buffer_start_adr,
+                                                     buffer_adr_type,
                                                      value,
                                                      num_elem));
-  kit.set_memory(vstore, arr_adr_type);
+  // TODO: With respect to aliasing behaviour multi-field alias type should be same as that of
+  // array, since multi-field is a bundle of scalars. An alias type determines the size of
+  // memory slice updated in global memory at a particular alias index, subsequent memory read
+  // with same alias type can directly fetch the value thus saving an extra load operation.
+  kit.set_memory(vstore, buffer_adr_type);
 
   C->set_max_vector_size(MAX2(C->max_vector_size(), vect_type->length_in_bytes()));
 
-  // Generate the allocate for the Vector object.
-  const TypeKlassPtr* klass_type = box_type->as_klass_type();
-  Node* klass_node = kit.makecon(klass_type);
-  Node* vec_obj = kit.new_instance(klass_node);
-
-  // Store the allocated array into object.
-  ciField* field = ciEnv::current()->vector_VectorPayload_klass()->get_field_by_name(ciSymbols::payload_name(),
-                                                                                     ciSymbols::object_signature(),
-                                                                                     false);
-  assert(field != NULL, "");
-  Node* vec_field = kit.basic_plus_adr(vec_obj, field->offset_in_bytes());
-  const TypePtr* vec_adr_type = vec_field->bottom_type()->is_ptr();
-
-  // The store should be captured by InitializeNode and turned into initialized store later.
-  Node* field_store = gvn.transform(kit.access_store_at(vec_obj,
-                                                        vec_field,
-                                                        vec_adr_type,
-                                                        arr,
-                                                        TypeOopPtr::make_from_klass(field->type()->as_klass()),
-                                                        T_OBJECT,
-                                                        IN_HEAP));
-  kit.set_memory(field_store, vec_adr_type);
-
-  kit.replace_call(vbox_alloc, vec_obj, true);
+  kit.replace_call(vbox_alloc, buffer_mem, true);
   C->remove_macro_node(vbox_alloc);
 
-  return vec_obj;
+  return buffer_mem;
+}
+
+Node* PhaseVector::get_loaded_payload(VectorUnboxNode* vec_unbox) {
+   Node* obj = vec_unbox->obj();
+   while(obj->is_InlineType()) {
+      obj = obj->as_InlineType()->field_value(0);
+   }
+   if (obj->is_LoadVector()) {
+     return obj;
+   }
+   return NULL;
 }
 
 void PhaseVector::expand_vunbox_node(VectorUnboxNode* vec_unbox) {
@@ -435,6 +438,7 @@ void PhaseVector::expand_vunbox_node(VectorUnboxNode* vec_unbox) {
     const TypeVect* vt = vec_unbox->bottom_type()->is_vect();
     BasicType bt = vt->element_basic_type();
     BasicType masktype = bt;
+    int num_elem = vt->length();
 
     if (is_vector_mask(from_kls)) {
       bt = T_BOOLEAN;
@@ -442,43 +446,47 @@ void PhaseVector::expand_vunbox_node(VectorUnboxNode* vec_unbox) {
       bt = T_BYTE;
     }
 
-    ciField* field = ciEnv::current()->vector_VectorPayload_klass()->get_field_by_name(ciSymbols::payload_name(),
-                                                                                       ciSymbols::object_signature(),
-                                                                                       false);
-    assert(field != NULL, "");
-    int offset = field->offset_in_bytes();
-    Node* vec_adr = kit.basic_plus_adr(obj, offset);
-
-    Node* mem = vec_unbox->mem();
-    Node* ctrl = vec_unbox->in(0);
-    Node* vec_field_ld;
-    {
-      DecoratorSet decorators = MO_UNORDERED | IN_HEAP;
-      C2AccessValuePtr addr(vec_adr, vec_adr->bottom_type()->is_ptr());
-      MergeMemNode* local_mem = MergeMemNode::make(mem);
-      gvn.record_for_igvn(local_mem);
-      BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();
-      C2OptAccess access(gvn, ctrl, local_mem, decorators, T_OBJECT, obj, addr);
-      const Type* type = TypeOopPtr::make_from_klass(field->type()->as_klass());
-      vec_field_ld = bs->load_at(access, type);
-    }
+    int elem_size = type2aelembytes(bt);
+    Node* vec_val_load = get_loaded_payload(vec_unbox);
+    if (vec_val_load == NULL) {
+      ciSymbol* payload_sig = ciSymbol::make(VectorSupport::get_vector_payload_field_signature(num_elem * elem_size)->as_C_string());
+      ciSymbol* payload_name = ciSymbol::make(vmSymbols::payload_name()->as_C_string());
+      ciField* payload = from_kls->get_field_by_name(payload_name, payload_sig, false);
+      int offset = payload->offset();
+      Node* vec_adr = kit.basic_plus_adr(obj, offset);
 
-    // For proper aliasing, attach concrete payload type.
-    ciKlass* payload_klass = ciTypeArrayKlass::make(bt);
-    const Type* payload_type = TypeAryPtr::make_from_klass(payload_klass)->cast_to_ptr_type(TypePtr::NotNull);
-    vec_field_ld = gvn.transform(new CastPPNode(vec_field_ld, payload_type));
+      Node* mem = vec_unbox->mem();
+      Node* ctrl = vec_unbox->in(0);
+      Node* vec_field_ld;
 
-    Node* adr = kit.array_element_address(vec_field_ld, gvn.intcon(0), bt);
-    const TypePtr* adr_type = adr->bottom_type()->is_ptr();
-    int num_elem = vt->length();
-    Node* vec_val_load = LoadVectorNode::make(0,
-                                              ctrl,
-                                              mem,
-                                              adr,
-                                              adr_type,
-                                              num_elem,
-                                              bt);
-    vec_val_load = gvn.transform(vec_val_load);
+      {
+        DecoratorSet decorators = MO_UNORDERED | IN_HEAP;
+        C2AccessValuePtr addr(vec_adr, vec_adr->bottom_type()->is_ptr());
+        MergeMemNode* local_mem = MergeMemNode::make(mem);
+        gvn.record_for_igvn(local_mem);
+        BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();
+        C2OptAccess access(gvn, ctrl, local_mem, decorators, T_OBJECT, obj, addr);
+        const Type* type = TypeOopPtr::make_from_klass(payload->type()->as_klass());
+        vec_field_ld = bs->load_at(access, type);
+      }
+
+      // For proper aliasing, attach concrete payload type.
+      ciKlass* payload_klass = ciTypeArrayKlass::make(bt);
+      const Type* payload_type = TypeAryPtr::make_from_klass(payload_klass)->cast_to_ptr_type(TypePtr::NotNull);
+      vec_field_ld = gvn.transform(new CastPPNode(vec_field_ld, payload_type));
+
+      Node* adr = kit.array_element_address(vec_field_ld, gvn.intcon(0), bt);
+      const TypePtr* adr_type = adr->bottom_type()->is_ptr();
+      int num_elem = vt->length();
+      vec_val_load = LoadVectorNode::make(0,
+                                          ctrl,
+                                          mem,
+                                          adr,
+                                          adr_type,
+                                          num_elem,
+                                          bt);
+      vec_val_load = gvn.transform(vec_val_load);
+    }
 
     C->set_max_vector_size(MAX2(C->max_vector_size(), vt->length_in_bytes()));
 
diff --git a/src/hotspot/share/opto/vector.hpp b/src/hotspot/share/opto/vector.hpp
index 067a2280d30..b096ea01f79 100644
--- a/src/hotspot/share/opto/vector.hpp
+++ b/src/hotspot/share/opto/vector.hpp
@@ -37,13 +37,17 @@ class PhaseVector : public Phase {
   void expand_vbox_nodes();
   void expand_vbox_node(VectorBoxNode* vec_box);
   Node* expand_vbox_node_helper(Node* vbox,
+                                Node* vbox_alloc,
                                 Node* vect,
                                 const TypeInstPtr* box_type,
                                 const TypeVect* vect_type);
-  Node* expand_vbox_alloc_node(VectorBoxAllocateNode* vbox_alloc,
+  Node* expand_vbox_alloc_node(Node* vbox,
+                               VectorBoxAllocateNode* vbox_alloc,
                                Node* value,
                                const TypeInstPtr* box_type,
                                const TypeVect* vect_type);
+  Node* get_loaded_payload(VectorUnboxNode* vec_unbox);
+
   void scalarize_vbox_nodes();
   void scalarize_vbox_node(VectorBoxNode* vec_box);
   void expand_vunbox_nodes();
diff --git a/src/hotspot/share/opto/vectorIntrinsics.cpp b/src/hotspot/share/opto/vectorIntrinsics.cpp
index ec4ed774ada..caa55a19aec 100644
--- a/src/hotspot/share/opto/vectorIntrinsics.cpp
+++ b/src/hotspot/share/opto/vectorIntrinsics.cpp
@@ -157,7 +157,7 @@ Node* GraphKit::box_vector(Node* vector, const TypeInstPtr* vbox_type, BasicType
 
   assert(check_vbox(vbox_type), "");
   const TypeVect* vt = TypeVect::make(elem_bt, num_elem, is_vector_mask(vbox_type->instance_klass()));
-  VectorBoxNode* vbox = new VectorBoxNode(C, ret, vector, vbox_type, vt);
+  Node* vbox = VectorBoxNode::make_box_node(gvn(), C, ret, vector, vbox_type, vt);
   return gvn().transform(vbox);
 }
 
diff --git a/src/hotspot/share/opto/vectornode.cpp b/src/hotspot/share/opto/vectornode.cpp
index dfc81402ede..9047c07234a 100644
--- a/src/hotspot/share/opto/vectornode.cpp
+++ b/src/hotspot/share/opto/vectornode.cpp
@@ -1623,7 +1623,11 @@ Node* VectorInsertNode::make(Node* vec, Node* new_val, int position) {
 }
 
 Node* VectorUnboxNode::Ideal(PhaseGVN* phase, bool can_reshape) {
-  Node* n = obj()->uncast();
+  Node* n = obj();
+  if (n->is_InlineType() && !n->is_VectorBox() && n->as_InlineType()->field_count() == 1) {
+    n = n->as_InlineType()->get_oop();
+  }
+  n = n->uncast();
   if (EnableVectorReboxing && n->Opcode() == Op_VectorBox) {
     if (Type::cmp(bottom_type(), n->in(VectorBoxNode::Value)->bottom_type()) == 0) {
       // Handled by VectorUnboxNode::Identity()
@@ -1660,7 +1664,11 @@ Node* VectorUnboxNode::Ideal(PhaseGVN* phase, bool can_reshape) {
 }
 
 Node* VectorUnboxNode::Identity(PhaseGVN* phase) {
-  Node* n = obj()->uncast();
+  Node* n = obj();
+  if (n->is_InlineType() && !n->is_VectorBox() && n->as_InlineType()->field_count() == 1) {
+    n = n->as_InlineType()->get_oop();
+  }
+  n = n->uncast();
   if (EnableVectorReboxing && n->Opcode() == Op_VectorBox) {
     if (Type::cmp(bottom_type(), n->in(VectorBoxNode::Value)->bottom_type()) == 0) {
       return n->in(VectorBoxNode::Value); // VectorUnbox (VectorBox v) ==> v
diff --git a/src/hotspot/share/opto/vectornode.hpp b/src/hotspot/share/opto/vectornode.hpp
index 21a8a8737a6..cd89c129fba 100644
--- a/src/hotspot/share/opto/vectornode.hpp
+++ b/src/hotspot/share/opto/vectornode.hpp
@@ -28,6 +28,7 @@
 #include "opto/matcher.hpp"
 #include "opto/memnode.hpp"
 #include "opto/node.hpp"
+#include "opto/inlinetypenode.hpp"
 #include "opto/opcodes.hpp"
 #include "prims/vectorSupport.hpp"
 
@@ -1665,20 +1666,46 @@ class VectorInsertNode : public VectorNode {
   static Node* make(Node* vec, Node* new_val, int position);
 };
 
-class VectorBoxNode : public Node {
+class VectorBoxNode : public InlineTypeNode {
  private:
-  const TypeInstPtr* const _box_type;
-  const TypeVect*    const _vec_type;
+  const TypeInstPtr* _box_type;
+  const TypeVect*    _vec_type;
+
  public:
   enum {
-     Box   = 1,
-     Value = 2
+     Box   = InlineTypeNode::Values,
+     Value
   };
-  VectorBoxNode(Compile* C, Node* box, Node* val,
-                const TypeInstPtr* box_type, const TypeVect* vt)
-    : Node(NULL, box, val), _box_type(box_type), _vec_type(vt) {
-    init_flags(Flag_is_macro);
-    C->add_macro_node(this);
+
+  void set_box_type(const TypeInstPtr* box_type) { _box_type = box_type; }
+  void set_vec_type(const TypeVect* vec_type) { _vec_type = vec_type; }
+
+  virtual uint  field_count() const { return req() - (InlineTypeNode::Values + 1); }
+  virtual Node* field_value(uint index) const {
+    assert(index < field_count(), "index out of bounds");
+    return in(VectorBoxNode::Value + index);
+  }
+
+  VectorBoxNode(ciInlineKlass* vk, Node* oop, bool null_free, bool is_buffered) :
+    InlineTypeNode(vk, oop, null_free, is_buffered) {}
+
+  static VectorBoxNode* make_box_node(PhaseGVN& gvn, Compile* C, Node* box, Node* val,
+                                      const TypeInstPtr* box_type, const TypeVect* vt) {
+    assert(box_type->instance_klass()->is_inlinetype(), "");
+    ciInlineKlass* vk = static_cast<ciInlineKlass*>(box_type->inline_klass());
+    Node* oop = (vk->is_empty() && vk->is_initialized()) ? default_oop(gvn, vk) : gvn.zerocon(T_PRIMITIVE_OBJECT);
+
+    VectorBoxNode* box_node = new VectorBoxNode(vk, oop, true, vk->is_empty() && vk->is_initialized());
+    box_node->set_is_init(gvn);
+    box_node->set_vec_type(vt);
+    box_node->set_box_type(box_type);
+    box_node->init_flags(Flag_is_macro);
+    box_node->init_class_id(Class_VectorBox);
+    box_node->init_req(VectorBoxNode::Box, box);
+    box_node->add_req(val);
+    C->add_macro_node(box_node);
+
+    return box_node;
   }
 
   const  TypeInstPtr* box_type() const { assert(_box_type != NULL, ""); return _box_type; };
diff --git a/src/hotspot/share/prims/vectorSupport.cpp b/src/hotspot/share/prims/vectorSupport.cpp
index 92d0371806c..573b33b8a47 100644
--- a/src/hotspot/share/prims/vectorSupport.cpp
+++ b/src/hotspot/share/prims/vectorSupport.cpp
@@ -26,6 +26,7 @@
 #include "classfile/javaClasses.inline.hpp"
 #include "classfile/vmClasses.hpp"
 #include "classfile/vmSymbols.hpp"
+#include "classfile/vmClassMacros.hpp"
 #include "code/location.hpp"
 #include "jni.h"
 #include "jvm.h"
@@ -38,6 +39,7 @@
 #include "runtime/interfaceSupport.inline.hpp"
 #include "runtime/jniHandles.inline.hpp"
 #include "runtime/stackValue.hpp"
+#include "utilities/debug.hpp"
 #ifdef COMPILER2
 #include "opto/matcher.hpp"
 #endif // COMPILER2
@@ -137,30 +139,85 @@ Handle VectorSupport::allocate_vector_payload_helper(InstanceKlass* ik, frame* f
   BasicType elem_bt = klass2bt(ik);
   int elem_size = type2aelembytes(elem_bt);
 
+  // FIXME: Existing handling is used for shuffles and mask classes, to be removed after
+  // complete support.
   // On-heap vector values are represented as primitive arrays.
-  TypeArrayKlass* tak = TypeArrayKlass::cast(Universe::typeArrayKlassObj(elem_bt));
+  if (is_vector_shuffle(ik) || is_vector_mask(ik)) {
+    TypeArrayKlass* tak = TypeArrayKlass::cast(Universe::typeArrayKlassObj(elem_bt));
+    typeArrayOop arr = tak->allocate(num_elem, CHECK_NH); // safepoint
 
-  typeArrayOop arr = tak->allocate(num_elem, CHECK_NH); // safepoint
+    if (location.is_register()) {
+      // Value was in a callee-saved register.
+      VMReg vreg = VMRegImpl::as_VMReg(location.register_number());
 
-  if (location.is_register()) {
-    // Value was in a callee-saved register.
-    VMReg vreg = VMRegImpl::as_VMReg(location.register_number());
+      for (int i = 0; i < num_elem; i++) {
+        int vslot = (i * elem_size) / VMRegImpl::stack_slot_size;
+        int off   = (i * elem_size) % VMRegImpl::stack_slot_size;
 
-    for (int i = 0; i < num_elem; i++) {
-      int vslot = (i * elem_size) / VMRegImpl::stack_slot_size;
-      int off   = (i * elem_size) % VMRegImpl::stack_slot_size;
-
-      address elem_addr = reg_map->location(vreg, vslot) + off; // assumes little endian element order
-      init_payload_element(arr, elem_bt, i, elem_addr);
+        address elem_addr = reg_map->location(vreg, vslot) + off; // assumes little endian element order
+        init_payload_element(arr, elem_bt, i, elem_addr);
+      }
+    } else {
+      // Value was directly saved on the stack.
+      address base_addr = ((address)fr->unextended_sp()) + location.stack_offset();
+      for (int i = 0; i < num_elem; i++) {
+        init_payload_element(arr, elem_bt, i, base_addr + i * elem_size);
+      }
     }
+    return Handle(THREAD, arr);
   } else {
-    // Value was directly saved on the stack.
-    address base_addr = ((address)fr->unextended_sp()) + location.stack_offset();
-    for (int i = 0; i < num_elem; i++) {
-      init_payload_element(arr, elem_bt, i, base_addr + i * elem_size);
-    }
+    // On-heap vector values are represented as primitive class instances with a multi-field payload.
+    int vec_size = elem_size * num_elem;
+    InstanceKlass* payload_kls = get_vector_payload_klass(vec_size);
+    assert(payload_kls->is_inline_klass(), "");
+    instanceOop obj = InlineKlass::cast(payload_kls)->allocate_instance(THREAD);
+
+    fieldDescriptor fd;
+    Klass* def = payload_kls->find_field(vmSymbols::mfield_name(), vmSymbols::type_signature(T_BYTE), false, &fd);
+    assert(fd.is_multifield_base() && fd.secondary_fields_count(fd.index()) == vec_size, "");
+
+    int ffo = InlineKlass::cast(payload_kls)->first_field_offset();
+
+    if (location.is_register()) {
+      // Value was in a callee-saved register.
+      VMReg vreg = VMRegImpl::as_VMReg(location.register_number());
+      for (int i = 0; i < vec_size; i++) {
+        int vslot = i / VMRegImpl::stack_slot_size;
+        int off   = i % VMRegImpl::stack_slot_size;
+        address elem_addr = reg_map->location(vreg, vslot) + off; // assumes little endian element order
+        obj->byte_field_put(ffo + i, *(jbyte*)elem_addr);
+      }
+    } else {
+      // Value was directly saved on the stack.
+      address base_addr = ((address)fr->unextended_sp()) + location.stack_offset();
+      for (int i = 0; i < elem_size * num_elem; i++) {
+        obj->byte_field_put(ffo + i, *(jbyte*)(base_addr + i));
+      }
+    }
+    return Handle(THREAD, obj);
   }
-  return Handle(THREAD, arr);
+}
+
+Symbol* VectorSupport::get_vector_payload_field_signature(int vec_size) {
+  switch(vec_size) {
+    case  8: return vmSymbols::vector_VectorPayloadMF64_signature();
+    case 16: return vmSymbols::vector_VectorPayloadMF128_signature();
+    case 32: return vmSymbols::vector_VectorPayloadMF256_signature();
+    case 64: return vmSymbols::vector_VectorPayloadMF512_signature();
+    default: ShouldNotReachHere();
+  }
+  return NULL;
+}
+
+InstanceKlass* VectorSupport::get_vector_payload_klass(int vec_size) {
+  switch(vec_size) {
+    case  8: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF64_klass));
+    case 16: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF128_klass));
+    case 32: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF256_klass));
+    case 64: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF512_klass));
+    default: ShouldNotReachHere();
+  }
+  return NULL;
 }
 
 Handle VectorSupport::allocate_vector_payload(InstanceKlass* ik, frame* fr, RegisterMap* reg_map, ScopeValue* payload, TRAPS) {
@@ -190,11 +247,27 @@ Handle VectorSupport::allocate_vector_payload(InstanceKlass* ik, frame* fr, Regi
 instanceOop VectorSupport::allocate_vector(InstanceKlass* ik, frame* fr, RegisterMap* reg_map, ObjectValue* ov, TRAPS) {
   assert(is_vector(ik), "%s not a vector", ik->name()->as_C_string());
   assert(ov->field_size() == 1, "%s not a vector", ik->name()->as_C_string());
+  assert(ik->is_inline_klass(), "");
 
   ScopeValue* payload_value = ov->field_at(0);
   Handle payload_instance = VectorSupport::allocate_vector_payload(ik, fr, reg_map, payload_value, CHECK_NULL);
-  instanceOop vbox = ik->allocate_instance(CHECK_NULL);
-  vector_VectorPayload::set_payload(vbox, payload_instance());
+  instanceOop vbox = ik->allocate_instance(THREAD);
+  Handle vbox_h = Handle(THREAD, vbox);
+
+  fieldDescriptor fd;
+  int num_elem = klass2length(ik);
+  BasicType elem_bt = klass2bt(ik);
+  int elem_size = type2aelembytes(elem_bt);
+  Symbol* payload_sig = VectorSupport::get_vector_payload_field_signature(num_elem * elem_size);
+  Klass* def = ik->find_field(vmSymbols::payload_name(), payload_sig, false, &fd);
+  assert(def != NULL, "");
+
+  if (fd.is_inlined()) {
+    InlineKlass* field_ik = InlineKlass::cast(ik->get_inline_type_field_klass(fd.index()));
+    field_ik->write_inlined_field(vbox_h(), fd.offset(), payload_instance(), THREAD);
+  } else {
+    vbox_h()->obj_field_put(fd.offset(), payload_instance());
+  }
   return vbox;
 }
 
diff --git a/src/hotspot/share/prims/vectorSupport.hpp b/src/hotspot/share/prims/vectorSupport.hpp
index 7302e006064..5d88a0f0a14 100644
--- a/src/hotspot/share/prims/vectorSupport.hpp
+++ b/src/hotspot/share/prims/vectorSupport.hpp
@@ -145,6 +145,9 @@ class VectorSupport : AllStatic {
 
   static instanceOop allocate_vector(InstanceKlass* holder, frame* fr, RegisterMap* reg_map, ObjectValue* sv, TRAPS);
 
+  static InstanceKlass* get_vector_payload_klass(int vec_size);
+  static Symbol* get_vector_payload_field_signature(int vec_size);
+
   static bool is_vector(Klass* klass);
   static bool is_vector_mask(Klass* klass);
   static bool is_vector_shuffle(Klass* klass);
diff --git a/src/hotspot/share/runtime/deoptimization.cpp b/src/hotspot/share/runtime/deoptimization.cpp
index 98ea8c2e022..92040dc9b85 100644
--- a/src/hotspot/share/runtime/deoptimization.cpp
+++ b/src/hotspot/share/runtime/deoptimization.cpp
@@ -1390,7 +1390,7 @@ static int reassign_fields_by_klass(InstanceKlass* klass, frame* fr, RegisterMap
   InstanceKlass* ik = klass;
   while (ik != NULL) {
     for (AllFieldStream fs(ik); !fs.done(); fs.next()) {
-      if (!fs.access_flags().is_static() && (!skip_internal || !fs.access_flags().is_internal())) {
+      if (!fs.access_flags().is_static() && !fs.is_multifield() && (!skip_internal || !fs.access_flags().is_internal())) {
         ReassignedField field;
         field._offset = fs.offset();
         field._type = Signature::basic_type(fs.signature());
diff --git a/src/hotspot/share/runtime/fieldDescriptor.hpp b/src/hotspot/share/runtime/fieldDescriptor.hpp
index df15d10a6cb..a4f655f2f44 100644
--- a/src/hotspot/share/runtime/fieldDescriptor.hpp
+++ b/src/hotspot/share/runtime/fieldDescriptor.hpp
@@ -91,8 +91,11 @@ class fieldDescriptor {
   inline bool is_inlined() const;
   inline bool is_inline_type()    const;
   inline bool is_multifield()            const;
+  inline bool is_multifield_base()       const;
   inline u2   multifield_base()          const;
   inline jbyte multifield_index()        const;
+  inline int secondary_fields_count(int base_idx) const;
+
 
   bool is_synthetic()             const    { return access_flags().is_synthetic(); }
 
diff --git a/src/hotspot/share/runtime/fieldDescriptor.inline.hpp b/src/hotspot/share/runtime/fieldDescriptor.inline.hpp
index 3b321328012..37a4eb57ac0 100644
--- a/src/hotspot/share/runtime/fieldDescriptor.inline.hpp
+++ b/src/hotspot/share/runtime/fieldDescriptor.inline.hpp
@@ -85,8 +85,23 @@ inline BasicType fieldDescriptor::field_type() const {
 inline bool fieldDescriptor::is_inlined()  const  { return field()->is_inlined(); }
 inline bool fieldDescriptor::is_inline_type() const { return Signature::basic_type(field()->signature(_cp())) == T_PRIMITIVE_OBJECT; }
 
-inline bool fieldDescriptor::is_multifield() const { return field()->is_multifield(); };
+inline bool fieldDescriptor::is_multifield() const { return field()->is_multifield(); }
+inline bool fieldDescriptor::is_multifield_base() const { return field()->is_multifield_base(); }
 inline u2   fieldDescriptor::multifield_base() const { return field_holder()->multifield_info(field()->secondary_index()).base_index(); }
 inline jbyte fieldDescriptor::multifield_index() const { return  field_holder()->multifield_info(field()->secondary_index()).multifield_index(); }
 
-#endif // SHARE_RUNTIME_FIELDDESCRIPTOR_INLINE_HPP
\ No newline at end of file
+inline int fieldDescriptor::secondary_fields_count(int base_idx) const {
+  Array<MultiFieldInfo>* multifield_info = field_holder()->multifield_info();
+  if (!is_multifield_base() || NULL == multifield_info) {
+    return 1;
+  }
+  int sec_fields_count = 1;
+  for (int i = 0; i < multifield_info->length(); i++) {
+    if (field_holder()->multifield_info(i).base_index() == base_idx) {
+      sec_fields_count++;
+    }
+  }
+  return  sec_fields_count;
+}
+
+#endif // SHARE_RUNTIME_FIELDDESCRIPTOR_INLINE_HPP
diff --git a/src/java.base/share/classes/java/lang/MultiField.java b/src/java.base/share/classes/java/lang/MultiField.java
deleted file mode 100644
index db5d6b6d149..00000000000
--- a/src/java.base/share/classes/java/lang/MultiField.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
-* Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
-* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-*
-* This code is free software; you can redistribute it and/or modify it
-* under the terms of the GNU General Public License version 2 only, as
-* published by the Free Software Foundation.  Oracle designates this
-* particular file as subject to the "Classpath" exception as provided
-* by Oracle in the LICENSE file that accompanied this code.
-*
-* This code is distributed in the hope that it will be useful, but WITHOUT
-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-* version 2 for more details (a copy is included in the LICENSE file that
-* accompanied this code).
-*
-* You should have received a copy of the GNU General Public License version
-* 2 along with this work; if not, write to the Free Software Foundation,
-* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-*
-* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
-* or visit www.oracle.com if you need additional information or have any
-* questions.
-*/
-
-package jdk.internal.vm.annotation;
-
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-
-/**
-* <p>An annotation expressing that the field has to be
-* replicated several times and all replication must be
-* layed out contiguously in memory. The annotation is
-* ignored if the type of the field is not one of the
-* eight Java basic primitive types: boolean, byte, short,
-* char, int, long, float, double.
-*/
-@Retention(RetentionPolicy.RUNTIME)
-@Target({ElementType.FIELD})
-public @interface MultiField {
-
-   /**
-    * The total number of fields (initial plus replicated).
-    * This tag is only meaningful for field level annotations.
-    *
-    * @return total number of fields to layout.
-    */
-   byte value() default 0;
-}
\ No newline at end of file
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractSpecies.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractSpecies.java
index 35549609903..5301f55b938 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractSpecies.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractSpecies.java
@@ -324,6 +324,7 @@ abstract class AbstractSpecies<E> extends VectorSupport.VectorSpecies<E>
         return makeDummyVectorMF();
     }
 
+    @ForceInline
     private AbstractVector<E> makeDummyVector() {
         Object za = Array.newInstance(elementType(), laneCount);
         return dummyVector = vectorFactory.apply(za);
@@ -332,6 +333,7 @@ abstract class AbstractSpecies<E> extends VectorSupport.VectorSpecies<E>
         // through the dummy vector.
     }
 
+    @ForceInline
     VectorSupport.VectorPayloadMF createVectorMF(Object initarr) {
         VectorSupport.VectorPayloadMF za = null;
         switch (laneType.switchKey) {
@@ -360,6 +362,7 @@ abstract class AbstractSpecies<E> extends VectorSupport.VectorSpecies<E>
         return za;
     }
 
+    @ForceInline
     private AbstractVector<E> makeDummyVectorMF() {
         Object za = null;
         switch (laneType.switchKey) {
diff --git a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/testClassModifiers/AbstractClassWithFieldWithNoIdentityModifier.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/testClassModifiers/AbstractClassWithFieldWithNoIdentityModifier.java
deleted file mode 100644
index b1b36a173b4..00000000000
--- a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/testClassModifiers/AbstractClassWithFieldWithNoIdentityModifier.java
+++ /dev/null
@@ -1,4 +0,0 @@
-abstract class AbstractClassWithFieldWithNoIdentityModifier {
-    int i;
-}
-
