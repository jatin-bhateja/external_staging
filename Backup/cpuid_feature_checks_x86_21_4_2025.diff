diff --git a/src/hotspot/cpu/aarch64/vm_version_aarch64.cpp b/src/hotspot/cpu/aarch64/vm_version_aarch64.cpp
index b2d34553487..2503e0f1a70 100644
--- a/src/hotspot/cpu/aarch64/vm_version_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/vm_version_aarch64.cpp
@@ -702,6 +702,8 @@ void VM_Version::print_platform_virtualization_info(outputStream* st) {
 #endif
 }
 
+void VM_Version::pre_initialize(void) {}
+
 void VM_Version::initialize_cpu_information(void) {
   // do nothing if cpu info has been initialized
   if (_initialized) {
diff --git a/src/hotspot/cpu/arm/vm_version_arm_32.cpp b/src/hotspot/cpu/arm/vm_version_arm_32.cpp
index 148786a55da..797eaaf072a 100644
--- a/src/hotspot/cpu/arm/vm_version_arm_32.cpp
+++ b/src/hotspot/cpu/arm/vm_version_arm_32.cpp
@@ -353,6 +353,8 @@ void VM_Version::initialize() {
   _is_initialized = true;
 }
 
+void VM_Version::pre_initialize(void) {}
+
 void VM_Version::initialize_cpu_information(void) {
   // do nothing if cpu info has been initialized
   if (_initialized) {
diff --git a/src/hotspot/cpu/ppc/vm_version_ppc.cpp b/src/hotspot/cpu/ppc/vm_version_ppc.cpp
index 8ec69bffe15..3af717494eb 100644
--- a/src/hotspot/cpu/ppc/vm_version_ppc.cpp
+++ b/src/hotspot/cpu/ppc/vm_version_ppc.cpp
@@ -53,6 +53,8 @@ uint64_t VM_Version::_dscr_val = 0;
                   "warning: -XX:+" #flag " requires -XX:+UseSIGTRAP\n" \
                   "         -XX:+" #flag " will be disabled!\n");
 
+void VM_Version::pre_initialize() {}
+
 void VM_Version::initialize() {
 
   // Test which instructions are supported and measure cache line size.
diff --git a/src/hotspot/cpu/riscv/vm_version_riscv.cpp b/src/hotspot/cpu/riscv/vm_version_riscv.cpp
index 8dcffc9c646..34150a66ba8 100644
--- a/src/hotspot/cpu/riscv/vm_version_riscv.cpp
+++ b/src/hotspot/cpu/riscv/vm_version_riscv.cpp
@@ -64,6 +64,8 @@ void VM_Version::initialize() {
 #endif // COMPILER2
 }
 
+void VM_Version::pre_initialize() {}
+
 void VM_Version::common_initialize() {
   _supports_atomic_getset4 = true;
   _supports_atomic_getadd4 = true;
diff --git a/src/hotspot/cpu/s390/vm_version_s390.cpp b/src/hotspot/cpu/s390/vm_version_s390.cpp
index 157b945e6e1..58bc1b2e708 100644
--- a/src/hotspot/cpu/s390/vm_version_s390.cpp
+++ b/src/hotspot/cpu/s390/vm_version_s390.cpp
@@ -88,6 +88,8 @@ static const char* z_features[] = {"  ",
                                        "bear_enh, sort_enh, nnpa_assist, storage_key_removal, vpack_decimal_enh"
                                   };
 
+void VM_Version::pre_initialize() {}
+
 void VM_Version::initialize() {
   determine_features();      // Get processor capabilities.
   set_features_string();     // Set a descriptive feature indication.
diff --git a/src/hotspot/cpu/x86/vm_version_x86.cpp b/src/hotspot/cpu/x86/vm_version_x86.cpp
index f360d60de9a..dce1d66c68c 100644
--- a/src/hotspot/cpu/x86/vm_version_x86.cpp
+++ b/src/hotspot/cpu/x86/vm_version_x86.cpp
@@ -51,10 +51,6 @@ VM_Version::CpuidInfo VM_Version::_cpuid_info = { 0, };
 const char* VM_Version::_features_names[] = { CPU_FEATURE_FLAGS(DECLARE_CPU_FEATURE_NAME)};
 #undef DECLARE_CPU_FEATURE_FLAG
 
-#define DECLARE_EXTRA_CPU_FEATURE_NAME(id, name, bit) name,
-const char* VM_Version::_extra_features_names[] = { EXTRA_CPU_FEATURE_FLAGS(DECLARE_EXTRA_CPU_FEATURE_NAME)};
-#undef DECLARE_EXTRA_CPU_FEATURE_FLAG
-
 // Address of instruction which causes SEGV
 address VM_Version::_cpuinfo_segv_addr = nullptr;
 // Address of instruction after the one which causes SEGV
@@ -88,7 +84,7 @@ bool VM_Version::supports_clflush() {
   // up. Assembler::flush calls this routine to check that clflush
   // is allowed. So, we give the caller a free pass if Universe init
   // is still in progress.
-  assert ((!Universe::is_fully_initialized() || (_features & CPU_FLUSH) != 0), "clflush should be available");
+  assert ((!Universe::is_fully_initialized() || SUPPORTS_CPU_FEATURE(CPU_FLUSH)), "clflush should be available");
   return true;
 }
 #endif
@@ -875,7 +871,6 @@ void VM_Version::get_processor_features() {
   _cpu = 4; // 486 by default
   _model = 0;
   _stepping = 0;
-  _features = 0;
   _logical_processors_per_package = 1;
   // i486 internal cache is both I&D and has a 16-byte line size
   _L1_data_cache_line_size = 16;
@@ -890,9 +885,8 @@ void VM_Version::get_processor_features() {
   _stepping = cpu_stepping();
 
   if (cpu_family() > 4) { // it supports CPUID
-    _features = _cpuid_info.feature_flags(); // These can be changed by VM settings
-    _extra_features = _cpuid_info.extra_feature_flags(); // These can be changed by VM settings
-    _cpu_features = _features;   // Preserve features
+    _cpuid_info.feature_flags(); // These can be changed by VM settings
+    memcpy(_dynamic_cpu_features_vector, _dynamic_features_vector, sizeof(uint64_t) * _dynamic_features_vector_size);   // Preserve features
     // Logical processors are only available on P4s and above,
     // and only if hyperthreading is available.
     _logical_processors_per_package = logical_processor_count();
@@ -948,21 +942,21 @@ void VM_Version::get_processor_features() {
   }
 
   if (UseSSE < 4) {
-    _features &= ~CPU_SSE4_1;
-    _features &= ~CPU_SSE4_2;
+    CLEAR_CPU_FEATURE(CPU_SSE4_1);
+    CLEAR_CPU_FEATURE(CPU_SSE4_2);
   }
 
   if (UseSSE < 3) {
-    _features &= ~CPU_SSE3;
-    _features &= ~CPU_SSSE3;
-    _features &= ~CPU_SSE4A;
+    CLEAR_CPU_FEATURE(CPU_SSE3);
+    CLEAR_CPU_FEATURE(CPU_SSSE3);
+    CLEAR_CPU_FEATURE(CPU_SSE4A);
   }
 
   if (UseSSE < 2)
-    _features &= ~CPU_SSE2;
+    CLEAR_CPU_FEATURE(CPU_SSE2);
 
   if (UseSSE < 1)
-    _features &= ~CPU_SSE;
+    CLEAR_CPU_FEATURE(CPU_SSE);
 
   //since AVX instructions is slower than SSE in some ZX cpus, force USEAVX=0.
   if (is_zx() && ((cpu_family() == 6) || (cpu_family() == 7))) {
@@ -1028,25 +1022,25 @@ void VM_Version::get_processor_features() {
   }
 
   if (UseAVX < 3) {
-    _features &= ~CPU_AVX512F;
-    _features &= ~CPU_AVX512DQ;
-    _features &= ~CPU_AVX512CD;
-    _features &= ~CPU_AVX512BW;
-    _features &= ~CPU_AVX512ER;
-    _features &= ~CPU_AVX512PF;
-    _features &= ~CPU_AVX512VL;
-    _features &= ~CPU_AVX512_VPOPCNTDQ;
-    _features &= ~CPU_AVX512_VPCLMULQDQ;
-    _features &= ~CPU_AVX512_VAES;
-    _features &= ~CPU_AVX512_VNNI;
-    _features &= ~CPU_AVX512_VBMI;
-    _features &= ~CPU_AVX512_VBMI2;
-    _features &= ~CPU_AVX512_BITALG;
-    _features &= ~CPU_AVX512_IFMA;
-    _features &= ~CPU_APX_F;
-    _features &= ~CPU_AVX512_FP16;
-    _features &= ~CPU_AVX10_1;
-    _features &= ~EXTRA_CPU_AVX10_2;
+    CLEAR_CPU_FEATURE(CPU_AVX512F);
+    CLEAR_CPU_FEATURE(CPU_AVX512DQ);
+    CLEAR_CPU_FEATURE(CPU_AVX512CD);
+    CLEAR_CPU_FEATURE(CPU_AVX512BW);
+    CLEAR_CPU_FEATURE(CPU_AVX512ER);
+    CLEAR_CPU_FEATURE(CPU_AVX512PF);
+    CLEAR_CPU_FEATURE(CPU_AVX512VL);
+    CLEAR_CPU_FEATURE(CPU_AVX512_VPOPCNTDQ);
+    CLEAR_CPU_FEATURE(CPU_AVX512_VPCLMULQDQ);
+    CLEAR_CPU_FEATURE(CPU_AVX512_VAES);
+    CLEAR_CPU_FEATURE(CPU_AVX512_VNNI);
+    CLEAR_CPU_FEATURE(CPU_AVX512_VBMI);
+    CLEAR_CPU_FEATURE(CPU_AVX512_VBMI2);
+    CLEAR_CPU_FEATURE(CPU_AVX512_BITALG);
+    CLEAR_CPU_FEATURE(CPU_AVX512_IFMA);
+    CLEAR_CPU_FEATURE(CPU_APX_F);
+    CLEAR_CPU_FEATURE(CPU_AVX512_FP16);
+    CLEAR_CPU_FEATURE(CPU_AVX10_1);
+    CLEAR_CPU_FEATURE(CPU_AVX10_2);
   }
 
   // Currently APX support is only enabled for targets supporting AVX512VL feature.
@@ -1059,45 +1053,45 @@ void VM_Version::get_processor_features() {
   }
 
   if (!UseAPX) {
-    _features &= ~CPU_APX_F;
+    CLEAR_CPU_FEATURE(CPU_APX_F);
   }
 
   if (UseAVX < 2) {
-    _features &= ~CPU_AVX2;
-    _features &= ~CPU_AVX_IFMA;
+    CLEAR_CPU_FEATURE(CPU_AVX2);
+    CLEAR_CPU_FEATURE(CPU_AVX_IFMA);
   }
 
   if (UseAVX < 1) {
-    _features &= ~CPU_AVX;
-    _features &= ~CPU_VZEROUPPER;
-    _features &= ~CPU_F16C;
-    _features &= ~CPU_SHA512;
+    CLEAR_CPU_FEATURE(CPU_AVX);
+    CLEAR_CPU_FEATURE(CPU_VZEROUPPER);
+    CLEAR_CPU_FEATURE(CPU_F16C);
+    CLEAR_CPU_FEATURE(CPU_SHA512);
   }
 
   if (logical_processors_per_package() == 1) {
     // HT processor could be installed on a system which doesn't support HT.
-    _features &= ~CPU_HT;
+    CLEAR_CPU_FEATURE(CPU_HT);
   }
 
   if (is_intel()) { // Intel cpus specific settings
     if (is_knights_family()) {
-      _features &= ~CPU_VZEROUPPER;
-      _features &= ~CPU_AVX512BW;
-      _features &= ~CPU_AVX512VL;
-      _features &= ~CPU_AVX512DQ;
-      _features &= ~CPU_AVX512_VNNI;
-      _features &= ~CPU_AVX512_VAES;
-      _features &= ~CPU_AVX512_VPOPCNTDQ;
-      _features &= ~CPU_AVX512_VPCLMULQDQ;
-      _features &= ~CPU_AVX512_VBMI;
-      _features &= ~CPU_AVX512_VBMI2;
-      _features &= ~CPU_CLWB;
-      _features &= ~CPU_FLUSHOPT;
-      _features &= ~CPU_GFNI;
-      _features &= ~CPU_AVX512_BITALG;
-      _features &= ~CPU_AVX512_IFMA;
-      _features &= ~CPU_AVX_IFMA;
-      _features &= ~CPU_AVX512_FP16;
+      CLEAR_CPU_FEATURE(CPU_VZEROUPPER);
+      CLEAR_CPU_FEATURE(CPU_AVX512BW);
+      CLEAR_CPU_FEATURE(CPU_AVX512VL);
+      CLEAR_CPU_FEATURE(CPU_AVX512DQ);
+      CLEAR_CPU_FEATURE(CPU_AVX512_VNNI);
+      CLEAR_CPU_FEATURE(CPU_AVX512_VAES);
+      CLEAR_CPU_FEATURE(CPU_AVX512_VPOPCNTDQ);
+      CLEAR_CPU_FEATURE(CPU_AVX512_VPCLMULQDQ);
+      CLEAR_CPU_FEATURE(CPU_AVX512_VBMI);
+      CLEAR_CPU_FEATURE(CPU_AVX512_VBMI2);
+      CLEAR_CPU_FEATURE(CPU_CLWB);
+      CLEAR_CPU_FEATURE(CPU_FLUSHOPT);
+      CLEAR_CPU_FEATURE(CPU_GFNI);
+      CLEAR_CPU_FEATURE(CPU_AVX512_BITALG);
+      CLEAR_CPU_FEATURE(CPU_AVX512_IFMA);
+      CLEAR_CPU_FEATURE(CPU_AVX_IFMA);
+      CLEAR_CPU_FEATURE(CPU_AVX512_FP16);
     }
   }
 
@@ -1114,9 +1108,10 @@ void VM_Version::get_processor_features() {
               cores_per_cpu(), threads_per_core(),
               cpu_family(), _model, _stepping, os::cpu_microcode_revision());
   assert(res > 0, "not enough temporary space allocated");
-  insert_features_names(_features, buf + res, sizeof(buf) - res, _features_names);
-  res = (int)strlen(buf);
-  insert_features_names(_extra_features, buf + res, sizeof(buf) - res, _extra_features_names);
+  for (uint64_t i = 0; i < _dynamic_features_vector_size; i++) {
+    insert_features_names(_dynamic_features_vector[i], buf + res, sizeof(buf) - res, _features_names, 64 * i);
+    res = strlen(buf);
+  }
 
   _features_string = os::strdup(buf);
 
@@ -2199,6 +2194,15 @@ void VM_Version::clear_apx_test_state() {
 
 static bool _vm_version_initialized = false;
 
+void VM_Version::pre_initialize() {
+  _dynamic_features_element_shift_count = 6;
+  _dynamic_features_vector_size =  (MAX_CPU_FEATURES >> _dynamic_features_element_shift_count) + 1;
+  _dynamic_features_vector = NEW_C_HEAP_ARRAY(uint64_t, _dynamic_features_vector_size, mtInternal);
+  _dynamic_cpu_features_vector = NEW_C_HEAP_ARRAY(uint64_t, _dynamic_features_vector_size, mtInternal);
+  memset(_dynamic_features_vector, 0, sizeof(uint64_t) * _dynamic_features_vector_size);
+  memset(_dynamic_cpu_features_vector, 0, sizeof(uint64_t) * _dynamic_features_vector_size);
+}
+
 void VM_Version::initialize() {
   ResourceMark rm;
   // Making this stub must be FIRST use of assembler
@@ -2979,112 +2983,96 @@ int64_t VM_Version::maximum_qualified_cpu_frequency(void) {
   return _max_qualified_cpu_frequency;
 }
 
-uint64_t VM_Version::CpuidInfo::extra_feature_flags() const {
-  uint64_t result = 0;
-  if (is_intel()) {
-    if (sefsl1_cpuid7_edx.bits.avx10 != 0 &&
-        std_cpuid24_ebx.bits.avx10_vlen_512 !=0 &&
-        std_cpuid24_ebx.bits.avx10_converged_isa_version >= 2 &&
-        xem_xcr0_eax.bits.opmask != 0 &&
-        xem_xcr0_eax.bits.zmm512 != 0 &&
-        xem_xcr0_eax.bits.zmm32 != 0) {
-      result |= EXTRA_CPU_AVX10_2;
-    }
-  }
-  return result;
-}
-
-uint64_t VM_Version::CpuidInfo::feature_flags() const {
-  uint64_t result = 0;
+void VM_Version::CpuidInfo::feature_flags() const {
   if (std_cpuid1_edx.bits.cmpxchg8 != 0)
-    result |= CPU_CX8;
+    SET_CPU_FEATURE(CPU_CX8);
   if (std_cpuid1_edx.bits.cmov != 0)
-    result |= CPU_CMOV;
+    SET_CPU_FEATURE(CPU_CMOV);
   if (std_cpuid1_edx.bits.clflush != 0)
-    result |= CPU_FLUSH;
+    SET_CPU_FEATURE(CPU_FLUSH);
 #ifdef _LP64
   // clflush should always be available on x86_64
   // if not we are in real trouble because we rely on it
   // to flush the code cache.
-  assert ((result & CPU_FLUSH) != 0, "clflush should be available");
+  assert (SUPPORTS_CPU_FEATURE(CPU_FLUSH), "clflush should be available");
 #endif
   if (std_cpuid1_edx.bits.fxsr != 0 || (is_amd_family() &&
       ext_cpuid1_edx.bits.fxsr != 0))
-    result |= CPU_FXSR;
+    SET_CPU_FEATURE(CPU_FXSR);
   // HT flag is set for multi-core processors also.
   if (threads_per_core() > 1)
-    result |= CPU_HT;
+    SET_CPU_FEATURE(CPU_HT);
   if (std_cpuid1_edx.bits.mmx != 0 || (is_amd_family() &&
       ext_cpuid1_edx.bits.mmx != 0))
-    result |= CPU_MMX;
+    SET_CPU_FEATURE(CPU_MMX);
   if (std_cpuid1_edx.bits.sse != 0)
-    result |= CPU_SSE;
+    SET_CPU_FEATURE(CPU_SSE);
   if (std_cpuid1_edx.bits.sse2 != 0)
-    result |= CPU_SSE2;
+    SET_CPU_FEATURE(CPU_SSE2);
   if (std_cpuid1_ecx.bits.sse3 != 0)
-    result |= CPU_SSE3;
+    SET_CPU_FEATURE(CPU_SSE3);
   if (std_cpuid1_ecx.bits.ssse3 != 0)
-    result |= CPU_SSSE3;
+    SET_CPU_FEATURE(CPU_SSSE3);
   if (std_cpuid1_ecx.bits.sse4_1 != 0)
-    result |= CPU_SSE4_1;
+    SET_CPU_FEATURE(CPU_SSE4_1);
   if (std_cpuid1_ecx.bits.sse4_2 != 0)
-    result |= CPU_SSE4_2;
+    SET_CPU_FEATURE(CPU_SSE4_2);
   if (std_cpuid1_ecx.bits.popcnt != 0)
-    result |= CPU_POPCNT;
+    SET_CPU_FEATURE(CPU_POPCNT);
   if (sefsl1_cpuid7_edx.bits.apx_f != 0 &&
       xem_xcr0_eax.bits.apx_f != 0) {
-    result |= CPU_APX_F;
+    SET_CPU_FEATURE(CPU_APX_F);
   }
   if (std_cpuid1_ecx.bits.avx != 0 &&
       std_cpuid1_ecx.bits.osxsave != 0 &&
       xem_xcr0_eax.bits.sse != 0 &&
       xem_xcr0_eax.bits.ymm != 0) {
-    result |= CPU_AVX;
-    result |= CPU_VZEROUPPER;
+    SET_CPU_FEATURE(CPU_AVX);
+    SET_CPU_FEATURE(CPU_VZEROUPPER);
     if (sefsl1_cpuid7_eax.bits.sha512 != 0)
-      result |= CPU_SHA512;
+      SET_CPU_FEATURE(CPU_SHA512);
     if (std_cpuid1_ecx.bits.f16c != 0)
-      result |= CPU_F16C;
+      SET_CPU_FEATURE(CPU_F16C);
     if (sef_cpuid7_ebx.bits.avx2 != 0) {
-      result |= CPU_AVX2;
+      SET_CPU_FEATURE(CPU_AVX2);
       if (sefsl1_cpuid7_eax.bits.avx_ifma != 0)
-        result |= CPU_AVX_IFMA;
+        SET_CPU_FEATURE(CPU_AVX_IFMA);
     }
     if (sef_cpuid7_ecx.bits.gfni != 0)
-        result |= CPU_GFNI;
+        SET_CPU_FEATURE(CPU_GFNI);
     if (sef_cpuid7_ebx.bits.avx512f != 0 &&
         xem_xcr0_eax.bits.opmask != 0 &&
         xem_xcr0_eax.bits.zmm512 != 0 &&
         xem_xcr0_eax.bits.zmm32 != 0) {
-      result |= CPU_AVX512F;
+      SET_CPU_FEATURE(CPU_AVX512F);
       if (sef_cpuid7_ebx.bits.avx512cd != 0)
-        result |= CPU_AVX512CD;
+        SET_CPU_FEATURE(CPU_AVX512CD);
       if (sef_cpuid7_ebx.bits.avx512dq != 0)
-        result |= CPU_AVX512DQ;
+        SET_CPU_FEATURE(CPU_AVX512DQ);
       if (sef_cpuid7_ebx.bits.avx512ifma != 0)
-        result |= CPU_AVX512_IFMA;
+        SET_CPU_FEATURE(CPU_AVX512_IFMA);
       if (sef_cpuid7_ebx.bits.avx512pf != 0)
-        result |= CPU_AVX512PF;
+        SET_CPU_FEATURE(CPU_AVX512PF);
       if (sef_cpuid7_ebx.bits.avx512er != 0)
-        result |= CPU_AVX512ER;
+        SET_CPU_FEATURE(CPU_AVX512ER);
       if (sef_cpuid7_ebx.bits.avx512bw != 0)
-        result |= CPU_AVX512BW;
+        SET_CPU_FEATURE(CPU_AVX512BW);
       if (sef_cpuid7_ebx.bits.avx512vl != 0)
-        result |= CPU_AVX512VL;
+        SET_CPU_FEATURE(CPU_AVX512VL);
       if (sef_cpuid7_ecx.bits.avx512_vpopcntdq != 0)
-        result |= CPU_AVX512_VPOPCNTDQ;
+        SET_CPU_FEATURE(CPU_AVX512_VPOPCNTDQ);
       if (sef_cpuid7_ecx.bits.avx512_vpclmulqdq != 0)
-        result |= CPU_AVX512_VPCLMULQDQ;
+        SET_CPU_FEATURE(CPU_AVX512_VPCLMULQDQ);
       if (sef_cpuid7_ecx.bits.vaes != 0)
-        result |= CPU_AVX512_VAES;
+        SET_CPU_FEATURE(CPU_AVX512_VAES);
       if (sef_cpuid7_ecx.bits.avx512_vnni != 0)
-        result |= CPU_AVX512_VNNI;
+        SET_CPU_FEATURE(CPU_AVX512_VNNI);
       if (sef_cpuid7_ecx.bits.avx512_bitalg != 0)
-        result |= CPU_AVX512_BITALG;
+        SET_CPU_FEATURE(CPU_AVX512_BITALG);
       if (sef_cpuid7_ecx.bits.avx512_vbmi != 0)
-        result |= CPU_AVX512_VBMI;
+        SET_CPU_FEATURE(CPU_AVX512_VBMI);
       if (sef_cpuid7_ecx.bits.avx512_vbmi2 != 0)
-        result |= CPU_AVX512_VBMI2;
+        SET_CPU_FEATURE(CPU_AVX512_VBMI2);
     }
     if (is_intel()) {
       if (sefsl1_cpuid7_edx.bits.avx10 != 0 &&
@@ -3093,114 +3081,114 @@ uint64_t VM_Version::CpuidInfo::feature_flags() const {
           xem_xcr0_eax.bits.opmask != 0 &&
           xem_xcr0_eax.bits.zmm512 != 0 &&
           xem_xcr0_eax.bits.zmm32 != 0) {
-        result |= CPU_AVX10_1;
-        result |= CPU_AVX_IFMA;
-        result |= CPU_AVX512F;
-        result |= CPU_AVX512CD;
-        result |= CPU_AVX512DQ;
-        result |= CPU_AVX512PF;
-        result |= CPU_AVX512ER;
-        result |= CPU_AVX512BW;
-        result |= CPU_AVX512VL;
-        result |= CPU_AVX512_VPOPCNTDQ;
-        result |= CPU_AVX512_VPCLMULQDQ;
-        result |= CPU_AVX512_VAES;
-        result |= CPU_AVX512_VNNI;
-        result |= CPU_AVX512_BITALG;
-        result |= CPU_AVX512_VBMI;
-        result |= CPU_AVX512_VBMI2;
+        SET_CPU_FEATURE(CPU_AVX10_1);
+        SET_CPU_FEATURE(CPU_AVX512F);
+        SET_CPU_FEATURE(CPU_AVX512CD);
+        SET_CPU_FEATURE(CPU_AVX512DQ);
+        SET_CPU_FEATURE(CPU_AVX512PF);
+        SET_CPU_FEATURE(CPU_AVX512ER);
+        SET_CPU_FEATURE(CPU_AVX512BW);
+        SET_CPU_FEATURE(CPU_AVX512VL);
+        SET_CPU_FEATURE(CPU_AVX512_VPOPCNTDQ);
+        SET_CPU_FEATURE(CPU_AVX512_VPCLMULQDQ);
+        SET_CPU_FEATURE(CPU_AVX512_VAES);
+        SET_CPU_FEATURE(CPU_AVX512_VNNI);
+        SET_CPU_FEATURE(CPU_AVX512_BITALG);
+        SET_CPU_FEATURE(CPU_AVX512_VBMI);
+        SET_CPU_FEATURE(CPU_AVX512_VBMI2);
+        if (std_cpuid24_ebx.bits.avx10_converged_isa_version >= 2) {
+          SET_CPU_FEATURE(CPU_AVX10_2);
+        }
       }
     }
   }
 
   if (std_cpuid1_ecx.bits.hv != 0)
-    result |= CPU_HV;
+    SET_CPU_FEATURE(CPU_HV);
   if (sef_cpuid7_ebx.bits.bmi1 != 0)
-    result |= CPU_BMI1;
+    SET_CPU_FEATURE(CPU_BMI1);
   if (std_cpuid1_edx.bits.tsc != 0)
-    result |= CPU_TSC;
+    SET_CPU_FEATURE(CPU_TSC);
   if (ext_cpuid7_edx.bits.tsc_invariance != 0)
-    result |= CPU_TSCINV_BIT;
+    SET_CPU_FEATURE(CPU_TSCINV_BIT);
   if (std_cpuid1_ecx.bits.aes != 0)
-    result |= CPU_AES;
+    SET_CPU_FEATURE(CPU_AES);
   if (ext_cpuid1_ecx.bits.lzcnt != 0)
-    result |= CPU_LZCNT;
+    SET_CPU_FEATURE(CPU_LZCNT);
   if (ext_cpuid1_ecx.bits.prefetchw != 0)
-    result |= CPU_3DNOW_PREFETCH;
+    SET_CPU_FEATURE(CPU_3DNOW_PREFETCH);
   if (sef_cpuid7_ebx.bits.erms != 0)
-    result |= CPU_ERMS;
+    SET_CPU_FEATURE(CPU_ERMS);
   if (sef_cpuid7_edx.bits.fast_short_rep_mov != 0)
-    result |= CPU_FSRM;
+    SET_CPU_FEATURE(CPU_FSRM);
   if (std_cpuid1_ecx.bits.clmul != 0)
-    result |= CPU_CLMUL;
+    SET_CPU_FEATURE(CPU_CLMUL);
   if (sef_cpuid7_ebx.bits.rtm != 0)
-    result |= CPU_RTM;
+    SET_CPU_FEATURE(CPU_RTM);
   if (sef_cpuid7_ebx.bits.adx != 0)
-     result |= CPU_ADX;
+     SET_CPU_FEATURE(CPU_ADX);
   if (sef_cpuid7_ebx.bits.bmi2 != 0)
-    result |= CPU_BMI2;
+    SET_CPU_FEATURE(CPU_BMI2);
   if (sef_cpuid7_ebx.bits.sha != 0)
-    result |= CPU_SHA;
+    SET_CPU_FEATURE(CPU_SHA);
   if (std_cpuid1_ecx.bits.fma != 0)
-    result |= CPU_FMA;
+    SET_CPU_FEATURE(CPU_FMA);
   if (sef_cpuid7_ebx.bits.clflushopt != 0)
-    result |= CPU_FLUSHOPT;
+    SET_CPU_FEATURE(CPU_FLUSHOPT);
   if (sef_cpuid7_ebx.bits.clwb != 0)
-    result |= CPU_CLWB;
+    SET_CPU_FEATURE(CPU_CLWB);
   if (ext_cpuid1_edx.bits.rdtscp != 0)
-    result |= CPU_RDTSCP;
+    SET_CPU_FEATURE(CPU_RDTSCP);
   if (sef_cpuid7_ecx.bits.rdpid != 0)
-    result |= CPU_RDPID;
+    SET_CPU_FEATURE(CPU_RDPID);
 
   // AMD|Hygon additional features.
   if (is_amd_family()) {
     // PREFETCHW was checked above, check TDNOW here.
     if ((ext_cpuid1_edx.bits.tdnow != 0))
-      result |= CPU_3DNOW_PREFETCH;
+      SET_CPU_FEATURE(CPU_3DNOW_PREFETCH);
     if (ext_cpuid1_ecx.bits.sse4a != 0)
-      result |= CPU_SSE4A;
+      SET_CPU_FEATURE(CPU_SSE4A);
   }
 
   // Intel additional features.
   if (is_intel()) {
     if (sef_cpuid7_edx.bits.serialize != 0)
-      result |= CPU_SERIALIZE;
+      SET_CPU_FEATURE(CPU_SERIALIZE);
     if (_cpuid_info.sef_cpuid7_edx.bits.avx512_fp16 != 0)
-      result |= CPU_AVX512_FP16;
+      SET_CPU_FEATURE(CPU_AVX512_FP16);
   }
 
   // ZX additional features.
   if (is_zx()) {
     // We do not know if these are supported by ZX, so we cannot trust
     // common CPUID bit for them.
-    assert((result & CPU_CLWB) == 0, "Check if it is supported?");
-    result &= ~CPU_CLWB;
+    assert(SUPPORTS_CPU_FEATURE(CPU_CLWB), "Check if it is supported?");
+    CLEAR_CPU_FEATURE(CPU_CLWB);
   }
 
   // Protection key features.
   if (sef_cpuid7_ecx.bits.pku != 0) {
-    result |= CPU_PKU;
+    SET_CPU_FEATURE(CPU_PKU);
   }
   if (sef_cpuid7_ecx.bits.ospke != 0) {
-    result |= CPU_OSPKE;
+    SET_CPU_FEATURE(CPU_OSPKE);
   }
 
   // Control flow enforcement (CET) features.
   if (sef_cpuid7_ecx.bits.cet_ss != 0) {
-    result |= CPU_CET_SS;
+    SET_CPU_FEATURE(CPU_CET_SS);
   }
   if (sef_cpuid7_edx.bits.cet_ibt != 0) {
-    result |= CPU_CET_IBT;
+    SET_CPU_FEATURE(CPU_CET_IBT);
   }
 
   // Composite features.
   if (supports_tscinv_bit() &&
       ((is_amd_family() && !is_amd_Barcelona()) ||
        is_intel_tsc_synched_at_init())) {
-    result |= CPU_TSCINV;
+    SET_CPU_FEATURE(CPU_TSCINV);
   }
-
-  return result;
 }
 
 bool VM_Version::os_supports_avx_vectors() {
diff --git a/src/hotspot/cpu/x86/vm_version_x86.hpp b/src/hotspot/cpu/x86/vm_version_x86.hpp
index c39d186a054..f91d276bfe8 100644
--- a/src/hotspot/cpu/x86/vm_version_x86.hpp
+++ b/src/hotspot/cpu/x86/vm_version_x86.hpp
@@ -364,7 +364,7 @@ class VM_Version : public Abstract_VM_Version {
    * test/lib-test/jdk/test/whitebox/CPUInfoTest.java
    * src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/amd64/AMD64.java
    */
-  enum Feature_Flag : uint64_t {
+  enum Feature_Flag : uint32_t {
 #define CPU_FEATURE_FLAGS(decl) \
     decl(CX8,               "cx8",               0)  /*  next bits are from cpuid 1 (EDX) */ \
     decl(CMOV,              "cmov",              1)  \
@@ -441,29 +441,17 @@ class VM_Version : public Abstract_VM_Version {
     decl(APX_F,             "apx_f",             60) /* Intel Advanced Performance Extensions*/ \
     decl(SHA512,            "sha512",            61) /* SHA512 instructions*/ \
     decl(AVX512_FP16,       "avx512_fp16",       62) /* AVX512 FP16 ISA support*/ \
-    decl(AVX10_1,           "avx10_1",           63) /* AVX10 512 bit vector ISA Version 1 support*/
+    decl(AVX10_1,           "avx10_1",           63) /* AVX10 512 bit vector ISA Version 1 support*/ \
+    decl(AVX10_2,           "avx10_2",           64) /* AVX10 512 bit vector ISA Version 2 support*/
 
-#define DECLARE_CPU_FEATURE_FLAG(id, name, bit) CPU_##id = (1ULL << bit),
+#define DECLARE_CPU_FEATURE_FLAG(id, name, bit) CPU_##id = (bit),
     CPU_FEATURE_FLAGS(DECLARE_CPU_FEATURE_FLAG)
 #undef DECLARE_CPU_FEATURE_FLAG
   };
 
-  /*
-   * Update following files when declaring new flags:
-   * test/lib-test/jdk/test/whitebox/CPUInfoTest.java
-   * src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/amd64/AMD64.java
-   */
-  enum Extra_Feature_Flag : uint64_t {
-#define EXTRA_CPU_FEATURE_FLAGS(decl) \
-    decl(AVX10_2,           "avx10_2",           0) /* AVX10 512 bit vector ISA Version 2 support*/
-
-#define DECLARE_EXTRA_CPU_FEATURE_FLAG(id, name, bit) EXTRA_CPU_##id = (1ULL << bit),
-    EXTRA_CPU_FEATURE_FLAGS(DECLARE_EXTRA_CPU_FEATURE_FLAG)
-#undef DECLARE_EXTRA_CPU_FEATURE_FLAG
-  };
+#define MAX_CPU_FEATURES 64
 
   static const char* _features_names[];
-  static const char* _extra_features_names[];
 
   enum Extended_Family {
     // AMD
@@ -606,8 +594,7 @@ class VM_Version : public Abstract_VM_Version {
     // Space to save apx registers after signal handle
     jlong        apx_save[2]; // Save r16 and r31
 
-    uint64_t feature_flags() const;
-    uint64_t extra_feature_flags() const;
+    void feature_flags() const;
 
     // Asserts
     void assert_is_initialized() const {
@@ -687,13 +674,30 @@ class VM_Version : public Abstract_VM_Version {
 
   LP64_ONLY(static void clear_apx_test_state());
 
-  static void clean_cpuFeatures()   { _features = 0; }
-  static void set_avx_cpuFeatures() { _features |= (CPU_SSE | CPU_SSE2 | CPU_AVX | CPU_VZEROUPPER ); }
-  static void set_evex_cpuFeatures() { _features |= (CPU_AVX10_1 | CPU_AVX512F | CPU_SSE | CPU_SSE2 | CPU_VZEROUPPER ); }
-  static void set_apx_cpuFeatures() { _features |= CPU_APX_F; }
-  static void set_bmi_cpuFeatures() { _features |= (CPU_BMI1 | CPU_BMI2 | CPU_LZCNT | CPU_POPCNT); }
+  static void clean_cpuFeatures()   { memset(_dynamic_features_vector, 0, sizeof(uint64_t) * _dynamic_features_vector_size); }
+  static void set_avx_cpuFeatures() {
+    SET_CPU_FEATURE(CPU_SSE);
+    SET_CPU_FEATURE(CPU_SSE2);
+    SET_CPU_FEATURE(CPU_AVX);
+    SET_CPU_FEATURE(CPU_VZEROUPPER);
+  }
+  static void set_evex_cpuFeatures() {
+    SET_CPU_FEATURE(CPU_AVX10_1);
+    SET_CPU_FEATURE(CPU_AVX512F);
+    SET_CPU_FEATURE(CPU_SSE);
+    SET_CPU_FEATURE(CPU_SSE2);
+    SET_CPU_FEATURE(CPU_VZEROUPPER);
+  }
+  static void set_apx_cpuFeatures() { SET_CPU_FEATURE(CPU_APX_F); }
+  static void set_bmi_cpuFeatures() {
+    SET_CPU_FEATURE(CPU_BMI1);
+    SET_CPU_FEATURE(CPU_BMI2);
+    SET_CPU_FEATURE(CPU_LZCNT);
+    SET_CPU_FEATURE(CPU_POPCNT);
+  }
 
   // Initialization
+  static void pre_initialize();
   static void initialize();
 
   // Override Abstract_VM_Version implementation
@@ -746,40 +750,40 @@ class VM_Version : public Abstract_VM_Version {
   //
   // Feature identification which can be affected by VM settings
   //
-  static bool supports_cpuid()        { return _features  != 0; }
-  static bool supports_cmov()         { return (_features & CPU_CMOV) != 0; }
-  static bool supports_fxsr()         { return (_features & CPU_FXSR) != 0; }
-  static bool supports_ht()           { return (_features & CPU_HT) != 0; }
-  static bool supports_mmx()          { return (_features & CPU_MMX) != 0; }
-  static bool supports_sse()          { return (_features & CPU_SSE) != 0; }
-  static bool supports_sse2()         { return (_features & CPU_SSE2) != 0; }
-  static bool supports_sse3()         { return (_features & CPU_SSE3) != 0; }
-  static bool supports_ssse3()        { return (_features & CPU_SSSE3)!= 0; }
-  static bool supports_sse4_1()       { return (_features & CPU_SSE4_1) != 0; }
-  static bool supports_sse4_2()       { return (_features & CPU_SSE4_2) != 0; }
-  static bool supports_popcnt()       { return (_features & CPU_POPCNT) != 0; }
-  static bool supports_avx()          { return (_features & CPU_AVX) != 0; }
-  static bool supports_avx2()         { return (_features & CPU_AVX2) != 0; }
-  static bool supports_tsc()          { return (_features & CPU_TSC) != 0; }
-  static bool supports_rdtscp()       { return (_features & CPU_RDTSCP) != 0; }
-  static bool supports_rdpid()        { return (_features & CPU_RDPID) != 0; }
-  static bool supports_aes()          { return (_features & CPU_AES) != 0; }
-  static bool supports_erms()         { return (_features & CPU_ERMS) != 0; }
-  static bool supports_fsrm()         { return (_features & CPU_FSRM) != 0; }
-  static bool supports_clmul()        { return (_features & CPU_CLMUL) != 0; }
-  static bool supports_rtm()          { return (_features & CPU_RTM) != 0; }
-  static bool supports_bmi1()         { return (_features & CPU_BMI1) != 0; }
-  static bool supports_bmi2()         { return (_features & CPU_BMI2) != 0; }
-  static bool supports_adx()          { return (_features & CPU_ADX) != 0; }
-  static bool supports_evex()         { return (_features & CPU_AVX512F) != 0; }
-  static bool supports_avx512dq()     { return (_features & CPU_AVX512DQ) != 0; }
-  static bool supports_avx512ifma()   { return (_features & CPU_AVX512_IFMA) != 0; }
-  static bool supports_avxifma()      { return (_features & CPU_AVX_IFMA) != 0; }
-  static bool supports_avx512pf()     { return (_features & CPU_AVX512PF) != 0; }
-  static bool supports_avx512er()     { return (_features & CPU_AVX512ER) != 0; }
-  static bool supports_avx512cd()     { return (_features & CPU_AVX512CD) != 0; }
-  static bool supports_avx512bw()     { return (_features & CPU_AVX512BW) != 0; }
-  static bool supports_avx512vl()     { return (_features & CPU_AVX512VL) != 0; }
+  static bool supports_cpuid()        { return _dynamic_features_vector  != nullptr; }
+  static bool supports_cmov()         { return SUPPORTS_CPU_FEATURE(CPU_CMOV); }
+  static bool supports_fxsr()         { return SUPPORTS_CPU_FEATURE(CPU_FXSR); }
+  static bool supports_ht()           { return SUPPORTS_CPU_FEATURE(CPU_HT); }
+  static bool supports_mmx()          { return SUPPORTS_CPU_FEATURE(CPU_MMX); }
+  static bool supports_sse()          { return SUPPORTS_CPU_FEATURE(CPU_SSE); }
+  static bool supports_sse2()         { return SUPPORTS_CPU_FEATURE(CPU_SSE2); }
+  static bool supports_sse3()         { return SUPPORTS_CPU_FEATURE(CPU_SSE3); }
+  static bool supports_ssse3()        { return SUPPORTS_CPU_FEATURE(CPU_SSSE3); }
+  static bool supports_sse4_1()       { return SUPPORTS_CPU_FEATURE(CPU_SSE4_1); }
+  static bool supports_sse4_2()       { return SUPPORTS_CPU_FEATURE(CPU_SSE4_2); }
+  static bool supports_popcnt()       { return SUPPORTS_CPU_FEATURE(CPU_POPCNT); }
+  static bool supports_avx()          { return SUPPORTS_CPU_FEATURE(CPU_AVX); }
+  static bool supports_avx2()         { return SUPPORTS_CPU_FEATURE(CPU_AVX2); }
+  static bool supports_tsc()          { return SUPPORTS_CPU_FEATURE(CPU_TSC); }
+  static bool supports_rdtscp()       { return SUPPORTS_CPU_FEATURE(CPU_RDTSCP); }
+  static bool supports_rdpid()        { return SUPPORTS_CPU_FEATURE(CPU_RDPID); }
+  static bool supports_aes()          { return SUPPORTS_CPU_FEATURE(CPU_AES); }
+  static bool supports_erms()         { return SUPPORTS_CPU_FEATURE(CPU_ERMS); }
+  static bool supports_fsrm()         { return SUPPORTS_CPU_FEATURE(CPU_FSRM); }
+  static bool supports_clmul()        { return SUPPORTS_CPU_FEATURE(CPU_CLMUL); }
+  static bool supports_rtm()          { return SUPPORTS_CPU_FEATURE(CPU_RTM); }
+  static bool supports_bmi1()         { return SUPPORTS_CPU_FEATURE(CPU_BMI1); }
+  static bool supports_bmi2()         { return SUPPORTS_CPU_FEATURE(CPU_BMI2); }
+  static bool supports_adx()          { return SUPPORTS_CPU_FEATURE(CPU_ADX); }
+  static bool supports_evex()         { return SUPPORTS_CPU_FEATURE(CPU_AVX512F); }
+  static bool supports_avx512dq()     { return SUPPORTS_CPU_FEATURE(CPU_AVX512DQ); }
+  static bool supports_avx512ifma()   { return SUPPORTS_CPU_FEATURE(CPU_AVX512_IFMA); }
+  static bool supports_avxifma()      { return SUPPORTS_CPU_FEATURE(CPU_AVX_IFMA); }
+  static bool supports_avx512pf()     { return SUPPORTS_CPU_FEATURE(CPU_AVX512PF); }
+  static bool supports_avx512er()     { return SUPPORTS_CPU_FEATURE(CPU_AVX512ER); }
+  static bool supports_avx512cd()     { return SUPPORTS_CPU_FEATURE(CPU_AVX512CD); }
+  static bool supports_avx512bw()     { return SUPPORTS_CPU_FEATURE(CPU_AVX512BW); }
+  static bool supports_avx512vl()     { return SUPPORTS_CPU_FEATURE(CPU_AVX512VL); }
   static bool supports_avx512vlbw()   { return (supports_evex() && supports_avx512bw() && supports_avx512vl()); }
   static bool supports_avx512bwdq()   { return (supports_evex() && supports_avx512bw() && supports_avx512dq()); }
   static bool supports_avx512vldq()   { return (supports_evex() && supports_avx512dq() && supports_avx512vl()); }
@@ -788,39 +792,39 @@ class VM_Version : public Abstract_VM_Version {
   static bool supports_avx512novl()   { return (supports_evex() && !supports_avx512vl()); }
   static bool supports_avx512nobw()   { return (supports_evex() && !supports_avx512bw()); }
   static bool supports_avx256only()   { return (supports_avx2() && !supports_evex()); }
-  static bool supports_apx_f()        { return (_features & CPU_APX_F) != 0; }
+  static bool supports_apx_f()        { return SUPPORTS_CPU_FEATURE(CPU_APX_F); }
   static bool supports_avxonly()      { return ((supports_avx2() || supports_avx()) && !supports_evex()); }
-  static bool supports_sha()          { return (_features & CPU_SHA) != 0; }
-  static bool supports_fma()          { return (_features & CPU_FMA) != 0 && supports_avx(); }
-  static bool supports_vzeroupper()   { return (_features & CPU_VZEROUPPER) != 0; }
-  static bool supports_avx512_vpopcntdq()  { return (_features & CPU_AVX512_VPOPCNTDQ) != 0; }
-  static bool supports_avx512_vpclmulqdq() { return (_features & CPU_AVX512_VPCLMULQDQ) != 0; }
-  static bool supports_avx512_vaes()  { return (_features & CPU_AVX512_VAES) != 0; }
-  static bool supports_gfni()         { return (_features & CPU_GFNI) != 0; }
-  static bool supports_avx512_vnni()  { return (_features & CPU_AVX512_VNNI) != 0; }
-  static bool supports_avx512_bitalg()  { return (_features & CPU_AVX512_BITALG) != 0; }
-  static bool supports_avx512_vbmi()  { return (_features & CPU_AVX512_VBMI) != 0; }
-  static bool supports_avx512_vbmi2() { return (_features & CPU_AVX512_VBMI2) != 0; }
-  static bool supports_avx512_fp16()  { return (_features & CPU_AVX512_FP16) != 0; }
-  static bool supports_hv()           { return (_features & CPU_HV) != 0; }
-  static bool supports_serialize()    { return (_features & CPU_SERIALIZE) != 0; }
-  static bool supports_f16c()         { return (_features & CPU_F16C) != 0; }
-  static bool supports_pku()          { return (_features & CPU_PKU) != 0; }
-  static bool supports_ospke()        { return (_features & CPU_OSPKE) != 0; }
-  static bool supports_cet_ss()       { return (_features & CPU_CET_SS) != 0; }
-  static bool supports_cet_ibt()      { return (_features & CPU_CET_IBT) != 0; }
-  static bool supports_sha512()       { return (_features & CPU_SHA512) != 0; }
+  static bool supports_sha()          { return SUPPORTS_CPU_FEATURE(CPU_SHA); }
+  static bool supports_fma()          { return SUPPORTS_CPU_FEATURE(CPU_FMA) && supports_avx(); }
+  static bool supports_vzeroupper()   { return SUPPORTS_CPU_FEATURE(CPU_VZEROUPPER); }
+  static bool supports_avx512_vpopcntdq()  { return SUPPORTS_CPU_FEATURE(CPU_AVX512_VPOPCNTDQ); }
+  static bool supports_avx512_vpclmulqdq() { return SUPPORTS_CPU_FEATURE(CPU_AVX512_VPCLMULQDQ); }
+  static bool supports_avx512_vaes()  { return SUPPORTS_CPU_FEATURE(CPU_AVX512_VAES); }
+  static bool supports_gfni()         { return SUPPORTS_CPU_FEATURE(CPU_GFNI); }
+  static bool supports_avx512_vnni()  { return SUPPORTS_CPU_FEATURE(CPU_AVX512_VNNI); }
+  static bool supports_avx512_bitalg()  { return SUPPORTS_CPU_FEATURE(CPU_AVX512_BITALG); }
+  static bool supports_avx512_vbmi()  { return SUPPORTS_CPU_FEATURE(CPU_AVX512_VBMI); }
+  static bool supports_avx512_vbmi2() { return SUPPORTS_CPU_FEATURE(CPU_AVX512_VBMI2); }
+  static bool supports_avx512_fp16()  { return SUPPORTS_CPU_FEATURE(CPU_AVX512_FP16); }
+  static bool supports_hv()           { return SUPPORTS_CPU_FEATURE(CPU_HV); }
+  static bool supports_serialize()    { return SUPPORTS_CPU_FEATURE(CPU_SERIALIZE); }
+  static bool supports_f16c()         { return SUPPORTS_CPU_FEATURE(CPU_F16C); }
+  static bool supports_pku()          { return SUPPORTS_CPU_FEATURE(CPU_PKU); }
+  static bool supports_ospke()        { return SUPPORTS_CPU_FEATURE(CPU_OSPKE); }
+  static bool supports_cet_ss()       { return SUPPORTS_CPU_FEATURE(CPU_CET_SS); }
+  static bool supports_cet_ibt()      { return SUPPORTS_CPU_FEATURE(CPU_CET_IBT); }
+  static bool supports_sha512()       { return SUPPORTS_CPU_FEATURE(CPU_SHA512); }
 
   // IntelÂ® AVX10 introduces a versioned approach for enumeration that is monotonically increasing, inclusive,
   // and supporting all vector lengths. Feature set supported by an AVX10 vector ISA version is also supported
   // by all the versions above it.
-  static bool supports_avx10_1()      { return (_features & CPU_AVX10_1) != 0;}
-  static bool supports_avx10_2()      { return (_extra_features & EXTRA_CPU_AVX10_2) != 0;}
+  static bool supports_avx10_1()      { return SUPPORTS_CPU_FEATURE(CPU_AVX10_1);}
+  static bool supports_avx10_2()      { return SUPPORTS_CPU_FEATURE(CPU_AVX10_2);}
 
   //
   // Feature identification not affected by VM flags
   //
-  static bool cpu_supports_evex()     { return (_cpu_features & CPU_AVX512F) != 0; }
+  static bool cpu_supports_evex()     { return SUPPORTS_CPU_FEATURE_AUX(CPU_AVX512F); }
 
   static bool supports_avx512_simd_sort() {
     if (supports_avx512dq()) {
@@ -858,19 +862,19 @@ class VM_Version : public Abstract_VM_Version {
   static bool has_intel_jcc_erratum() { return _has_intel_jcc_erratum; }
 
   // AMD features
-  static bool supports_3dnow_prefetch()    { return (_features & CPU_3DNOW_PREFETCH) != 0; }
-  static bool supports_lzcnt()    { return (_features & CPU_LZCNT) != 0; }
-  static bool supports_sse4a()    { return (_features & CPU_SSE4A) != 0; }
+  static bool supports_3dnow_prefetch()    { return SUPPORTS_CPU_FEATURE(CPU_3DNOW_PREFETCH); }
+  static bool supports_lzcnt()    { return SUPPORTS_CPU_FEATURE(CPU_LZCNT); }
+  static bool supports_sse4a()    { return SUPPORTS_CPU_FEATURE(CPU_SSE4A); }
 
   static bool is_amd_Barcelona()  { return is_amd() &&
                                            extended_cpu_family() == CPU_FAMILY_AMD_11H; }
 
   // Intel and AMD newer cores support fast timestamps well
   static bool supports_tscinv_bit() {
-    return (_features & CPU_TSCINV_BIT) != 0;
+    return SUPPORTS_CPU_FEATURE(CPU_TSCINV_BIT);
   }
   static bool supports_tscinv() {
-    return (_features & CPU_TSCINV) != 0;
+    return SUPPORTS_CPU_FEATURE(CPU_TSCINV);
   }
 
   // Intel Core and newer cpus have fast IDIV instruction (excluding Atom).
@@ -931,12 +935,12 @@ class VM_Version : public Abstract_VM_Version {
 #ifdef _LP64
   static bool supports_clflush(); // Can't inline due to header file conflict
 #else
-  static bool supports_clflush() { return  ((_features & CPU_FLUSH) != 0); }
+  static bool supports_clflush() { return  (SUPPORTS_CPU_FEATURE(CPU_FLUSH)); }
 #endif // _LP64
 
   // Note: CPU_FLUSHOPT and CPU_CLWB bits should always be zero for 32-bit
-  static bool supports_clflushopt() { return ((_features & CPU_FLUSHOPT) != 0); }
-  static bool supports_clwb() { return ((_features & CPU_CLWB) != 0); }
+  static bool supports_clflushopt() { return (SUPPORTS_CPU_FEATURE(CPU_FLUSHOPT)); }
+  static bool supports_clwb() { return (SUPPORTS_CPU_FEATURE(CPU_CLWB)); }
 
   // Old CPUs perform lea on AGU which causes additional latency transferring the
   // value from/to ALU for other operations
diff --git a/src/hotspot/cpu/zero/vm_version_zero.cpp b/src/hotspot/cpu/zero/vm_version_zero.cpp
index e38561e19c5..a79b2291d55 100644
--- a/src/hotspot/cpu/zero/vm_version_zero.cpp
+++ b/src/hotspot/cpu/zero/vm_version_zero.cpp
@@ -32,6 +32,8 @@
 #include "runtime/vm_version.hpp"
 
 
+void VM_Version::pre_initialize() {}
+
 void VM_Version::initialize() {
   // This machine does not allow unaligned memory accesses
   if (! FLAG_IS_DEFAULT(UseUnalignedAccesses)) {
diff --git a/src/hotspot/share/jvmci/vmStructs_jvmci.cpp b/src/hotspot/share/jvmci/vmStructs_jvmci.cpp
index 2bc484108d6..a99221ce6f2 100644
--- a/src/hotspot/share/jvmci/vmStructs_jvmci.cpp
+++ b/src/hotspot/share/jvmci/vmStructs_jvmci.cpp
@@ -144,10 +144,12 @@
                                                                                                                                      \
   static_field(CompilerToVM::Data,             data_section_item_alignment,            int)                                          \
                                                                                                                                      \
-  JVMTI_ONLY(static_field(CompilerToVM::Data,  _should_notify_object_alloc,            int*))                                         \
+  JVMTI_ONLY(static_field(CompilerToVM::Data,  _should_notify_object_alloc,            int*))                                        \
                                                                                                                                      \
   static_field(Abstract_VM_Version,            _features,                              uint64_t)                                     \
-  static_field(Abstract_VM_Version,            _extra_features,                        uint64_t)                                     \
+  static_field(Abstract_VM_Version,            _dynamic_features_vector,               uint64_t*)                                    \
+  static_field(Abstract_VM_Version,            _dynamic_features_vector_size,          uint64_t)                                     \
+  static_field(Abstract_VM_Version,            _dynamic_features_element_shift_count,  uint64_t)                                     \
                                                                                                                                      \
   nonstatic_field(Annotations,                 _class_annotations,                     AnnotationArray*)                             \
   nonstatic_field(Annotations,                 _fields_annotations,                    Array<AnnotationArray*>*)                     \
@@ -984,10 +986,8 @@
   declare_constant(frame::interpreter_frame_last_sp_offset)
 
 #define DECLARE_LONG_CPU_FEATURE_CONSTANT(id, name, bit) GENERATE_VM_LONG_CONSTANT_ENTRY(VM_Version::CPU_##id)
-#define DECLARE_LONG_EXTRA_CPU_FEATURE_CONSTANT(id, name, bit) GENERATE_VM_LONG_CONSTANT_ENTRY(VM_Version::EXTRA_CPU_##id)
 #define VM_LONG_CPU_FEATURE_CONSTANTS \
-   CPU_FEATURE_FLAGS(DECLARE_LONG_CPU_FEATURE_CONSTANT) \
-   EXTRA_CPU_FEATURE_FLAGS(DECLARE_LONG_EXTRA_CPU_FEATURE_CONSTANT)
+   CPU_FEATURE_FLAGS(DECLARE_LONG_CPU_FEATURE_CONSTANT)
 
 #endif
 
diff --git a/src/hotspot/share/runtime/abstract_vm_version.cpp b/src/hotspot/share/runtime/abstract_vm_version.cpp
index 4ae08ab962a..ca118a5821f 100644
--- a/src/hotspot/share/runtime/abstract_vm_version.cpp
+++ b/src/hotspot/share/runtime/abstract_vm_version.cpp
@@ -33,10 +33,14 @@ const char* Abstract_VM_Version::_s_vm_release = Abstract_VM_Version::vm_release
 const char* Abstract_VM_Version::_s_internal_vm_info_string = Abstract_VM_Version::internal_vm_info_string();
 
 uint64_t Abstract_VM_Version::_features = 0;
-uint64_t Abstract_VM_Version::_extra_features = 0;
 const char* Abstract_VM_Version::_features_string = "";
 uint64_t Abstract_VM_Version::_cpu_features = 0;
 
+uint64_t* Abstract_VM_Version::_dynamic_features_vector = nullptr;
+uint64_t Abstract_VM_Version::_dynamic_features_vector_size = 0;
+uint64_t Abstract_VM_Version::_dynamic_features_element_shift_count = 0;
+uint64_t* Abstract_VM_Version::_dynamic_cpu_features_vector = nullptr;
+
 #ifndef SUPPORTS_NATIVE_CX8
 bool Abstract_VM_Version::_supports_cx8 = false;
 #endif
@@ -325,9 +329,8 @@ unsigned int Abstract_VM_Version::jvm_version() {
          (Abstract_VM_Version::vm_build_number() & 0xFF);
 }
 
-void Abstract_VM_Version::insert_features_names(uint64_t features, char* buf, size_t buflen, const char* features_names[]) {
-  uint features_names_index = 0;
-
+void Abstract_VM_Version::insert_features_names(uint64_t features, char* buf, size_t buflen, const char* features_names[],
+                                                uint features_names_index) {
   while (features != 0) {
     if (features & 1) {
       int res = jio_snprintf(buf, buflen, ", %s", features_names[features_names_index]);
diff --git a/src/hotspot/share/runtime/abstract_vm_version.hpp b/src/hotspot/share/runtime/abstract_vm_version.hpp
index 52021e715bc..5ce6494d778 100644
--- a/src/hotspot/share/runtime/abstract_vm_version.hpp
+++ b/src/hotspot/share/runtime/abstract_vm_version.hpp
@@ -56,14 +56,21 @@ class Abstract_VM_Version: AllStatic {
 
   // CPU feature flags, can be affected by VM settings.
   static uint64_t _features;
+
   // Extra CPU feature flags used when all 64 bits of _features are exhausted for
   // on a given target, currently only used for x86_64, can be affected by VM settings.
-  static uint64_t _extra_features;
   static const char* _features_string;
 
   // Original CPU feature flags, not affected by VM settings.
   static uint64_t _cpu_features;
 
+  // Dynamically sized feature flags currently only used by x86 backend,
+  // can be affected by VM settings.
+  static uint64_t* _dynamic_features_vector;
+  static uint64_t _dynamic_features_vector_size;
+  static uint64_t _dynamic_features_element_shift_count;
+  static uint64_t* _dynamic_cpu_features_vector;
+
   // These are set by machine-dependent initializations
 #ifndef SUPPORTS_NATIVE_CX8
   static bool         _supports_cx8;
@@ -129,11 +136,63 @@ class Abstract_VM_Version: AllStatic {
   static const char* jdk_debug_level();
   static const char* printable_jdk_debug_level();
 
-  static uint64_t features()           { return _features; }
-  static uint64_t extra_features()     { return _extra_features; }
+  static uint64_t features() {
+    return _features;
+  }
+
+  static void set_dynamic_feature(uint32_t feature) {
+    uint32_t index = feature >> _dynamic_features_element_shift_count;
+    uint32_t index_mask = (1 << _dynamic_features_element_shift_count) - 1;
+    assert(index < _dynamic_features_vector_size, "Features array index out of bounds");
+    _dynamic_features_vector[index] |= (1ULL << (feature & index_mask));
+  }
+
+  static void clear_dynamic_feature(uint32_t feature) {
+    uint32_t index = feature >> _dynamic_features_element_shift_count;
+    uint32_t index_mask = (1 << _dynamic_features_element_shift_count) - 1;
+    assert(index < _dynamic_features_vector_size, "Features array index out of bounds");
+    _dynamic_features_vector[index] &= ~(1ULL << (feature & index_mask));
+  }
+
+  static bool supports_dynamic_feature(uint32_t feature) {
+    uint32_t index = feature >> _dynamic_features_element_shift_count;
+    uint32_t index_mask = (1 << _dynamic_features_element_shift_count) - 1;
+    assert(index < _dynamic_features_vector_size, "Features array index out of bounds");
+    return (_dynamic_features_vector[index] & (1ULL << (feature & index_mask))) != 0;
+  }
+
+  static void set_cpu_feature_aux(uint32_t feature) {
+    uint32_t index = feature >> _dynamic_features_element_shift_count;
+    uint32_t index_mask = (1 << _dynamic_features_element_shift_count) - 1;
+    assert(index < _dynamic_features_vector_size, "Features array index out of bounds");
+    _dynamic_cpu_features_vector[index] |= (1ULL << (feature & index_mask));
+  }
+
+  static bool supports_cpu_feature_aux(uint32_t feature) {
+    uint32_t index = feature >> _dynamic_features_element_shift_count;
+    uint32_t index_mask = (1 << _dynamic_features_element_shift_count) - 1;
+    assert(index < _dynamic_features_vector_size, "Features array index out of bounds");
+    return (_dynamic_cpu_features_vector[index] & (1ULL << (feature & index_mask))) != 0;
+  }
+
+#define SET_CPU_FEATURE(feature) \
+  Abstract_VM_Version::set_dynamic_feature(feature)
+
+#define CLEAR_CPU_FEATURE(feature) \
+  Abstract_VM_Version::clear_dynamic_feature(feature)
+
+#define SUPPORTS_CPU_FEATURE(feature) \
+  Abstract_VM_Version::supports_dynamic_feature(feature)
+
+#define SET_CPU_FEATURE_AUX(feature) \
+  Abstract_VM_Version::set_cpu_feature_aux(feature)
+
+#define SUPPORTS_CPU_FEATURE_AUX(feature) \
+  Abstract_VM_Version::supports_cpu_feature_aux(feature)
+
   static const char* features_string() { return _features_string; }
 
-  static void insert_features_names(uint64_t features, char* buf, size_t buflen, const char* features_names[]);
+  static void insert_features_names(uint64_t features, char* buf, size_t buflen, const char* features_names[], uint features_names_index = 0);
 
   static VirtualizationType get_detected_virtualization() {
     return _detected_virtualization;
diff --git a/src/hotspot/share/runtime/init.cpp b/src/hotspot/share/runtime/init.cpp
index 417bba6c3fa..d5bcff402c6 100644
--- a/src/hotspot/share/runtime/init.cpp
+++ b/src/hotspot/share/runtime/init.cpp
@@ -65,6 +65,7 @@ void classLoader_init1();
 void compilationPolicy_init();
 void codeCache_init();
 void VM_Version_init();
+void VM_Version_pre_init();
 void initial_stubs_init();
 
 jint universe_init();           // depends on codeCache_init and initial_stubs_init
@@ -123,6 +124,7 @@ jint init_globals() {
   bytecodes_init();
   classLoader_init1();
   compilationPolicy_init();
+  VM_Version_pre_init();          // allocate feature flags arrays
   codeCache_init();
   VM_Version_init();              // depends on codeCache_init for emitting code
   // stub routines in initial blob are referenced by later generated code
diff --git a/src/hotspot/share/runtime/vmStructs.cpp b/src/hotspot/share/runtime/vmStructs.cpp
index f865380fdb7..0cdc98902dc 100644
--- a/src/hotspot/share/runtime/vmStructs.cpp
+++ b/src/hotspot/share/runtime/vmStructs.cpp
@@ -702,6 +702,9 @@
      static_field(Abstract_VM_Version,         _s_internal_vm_info_string,                    const char*)                           \
      static_field(Abstract_VM_Version,         _features,                                     uint64_t)                              \
      static_field(Abstract_VM_Version,         _features_string,                              const char*)                           \
+     static_field(Abstract_VM_Version,         _dynamic_features_vector,                      uint64_t*)                             \
+     static_field(Abstract_VM_Version,         _dynamic_features_vector_size,                 uint64_t)                              \
+     static_field(Abstract_VM_Version,         _dynamic_features_element_shift_count,         uint64_t)                              \
      static_field(Abstract_VM_Version,         _vm_major_version,                             int)                                   \
      static_field(Abstract_VM_Version,         _vm_minor_version,                             int)                                   \
      static_field(Abstract_VM_Version,         _vm_security_version,                          int)                                   \
diff --git a/src/hotspot/share/runtime/vm_version.cpp b/src/hotspot/share/runtime/vm_version.cpp
index 7c5b7fe3f3e..149f6f01f13 100644
--- a/src/hotspot/share/runtime/vm_version.cpp
+++ b/src/hotspot/share/runtime/vm_version.cpp
@@ -27,6 +27,10 @@
 #include "memory/resourceArea.hpp"
 #include "runtime/vm_version.hpp"
 
+void VM_Version_pre_init() {
+  VM_Version::pre_initialize();
+}
+
 void VM_Version_init() {
   VM_Version::initialize();
   guarantee(VM_Version::supports_cx8(), "Support for 64-bit atomic operations is required");
diff --git a/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/HotSpotJVMCIBackendFactory.java b/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/HotSpotJVMCIBackendFactory.java
index 1a3adae7b53..004b97b89b8 100644
--- a/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/HotSpotJVMCIBackendFactory.java
+++ b/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/HotSpotJVMCIBackendFactory.java
@@ -30,6 +30,7 @@
 
 import jdk.vm.ci.common.JVMCIError;
 import jdk.vm.ci.runtime.JVMCIBackend;
+import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
 
 public interface HotSpotJVMCIBackendFactory {
 
@@ -92,4 +93,60 @@
         }
         return outFeatures;
     }
+
+    /**
+     * Converts a dynamically sized CPU features vector into enum constants.
+     *
+     * @param <CPUFeatureType> CPU feature enum type
+     * @param enumType the class of {@code CPUFeatureType}
+     * @param constants VM constants. Each entry whose key starts with {@code "VM_Version::CPU_"}
+     *            specifies a CPU feature and its value is a mask for a bit in {@code features}
+     * @param dynamic_features_vector_pointer pointer to dyanmic feature vector specifying CPU features
+     * @param dynamic_features_vector_size dyanmic feature array size
+     * @param dynamic_features_element_shift_count log of dyanmic feature vector element size in bits
+     * @param renaming maps from VM feature names to enum constant names where the two differ
+     * @throws IllegalArgumentException if any VM CPU feature constant cannot be converted to an
+     *             enum value
+     * @return the set of converted values
+     */
+    static <CPUFeatureType extends Enum<CPUFeatureType>> EnumSet<CPUFeatureType> convertDynamicFeaturesVector(
+                    Class<CPUFeatureType> enumType,
+                    Map<String, Long> constants,
+                    long dynamic_features_vector_pointer,
+                    long dynamic_features_vector_size,
+                    long dynamic_features_element_shift_count,
+                    Map<String, String> renaming) {
+        EnumSet<CPUFeatureType> outFeatures = EnumSet.noneOf(enumType);
+        List<String> missing = new ArrayList<>();
+        for (Entry<String, Long> e : constants.entrySet()) {
+            String key = e.getKey();
+            long bitIndex = e.getValue();
+            if (key.startsWith("VM_Version::CPU_")) {
+                String name = key.substring("VM_Version::CPU_".length());
+                try {
+                    CPUFeatureType feature = Enum.valueOf(enumType, renaming.getOrDefault(name, name));
+                    long dynamic_features_vector_index = bitIndex >>> dynamic_features_element_shift_count;
+                    assert dynamic_features_vector_index < dynamic_features_vector_size;
+
+                    long  dynamic_features_element_bitsize = (1L << dynamic_features_element_shift_count);
+                    assert (dynamic_features_element_bitsize & (dynamic_features_element_bitsize - 1)) == 0;
+
+                    long  dynamic_features_element_size = dynamic_features_element_bitsize / Byte.SIZE;
+                    long features = UNSAFE.getLong(dynamic_features_vector_pointer +
+                                                   dynamic_features_vector_index * dynamic_features_element_size);
+
+                    long effective_bitMask = 1L << (bitIndex & (dynamic_features_element_bitsize - 1));
+                    if ((features & effective_bitMask) != 0) {
+                        outFeatures.add(feature);
+                    }
+                } catch (IllegalArgumentException iae) {
+                    missing.add(name);
+                }
+            }
+        }
+        if (!missing.isEmpty()) {
+            throw new JVMCIError("Missing CPU feature constants: %s", missing);
+        }
+        return outFeatures;
+    }
 }
diff --git a/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/amd64/AMD64HotSpotJVMCIBackendFactory.java b/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/amd64/AMD64HotSpotJVMCIBackendFactory.java
index bd9b60574dc..39dc95feb89 100644
--- a/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/amd64/AMD64HotSpotJVMCIBackendFactory.java
+++ b/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/amd64/AMD64HotSpotJVMCIBackendFactory.java
@@ -50,8 +50,11 @@
         Map<String, Long> constants = config.getStore().getConstants();
         Map<String, String> renaming = Map.of("3DNOW_PREFETCH", "AMD_3DNOW_PREFETCH");
         assert config.useSSE >= 2 : "minimum config for x64";
-        EnumSet<CPUFeature> features = HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, config.vmVersionFeatures,
-                                                                                  config.vmVersionExtraFeatures, renaming);
+        EnumSet<CPUFeature> features = HotSpotJVMCIBackendFactory.convertDynamicFeaturesVector(CPUFeature.class, constants,
+                                                                                               config.vmVersionFeaturesVector,
+                                                                                               config.vmVersionFeaturesVectorSize,
+                                                                                               config.vmVersionFeaturesElemShiftCnt,
+                                                                                               renaming);
         features.add(AMD64.CPUFeature.SSE);
         features.add(AMD64.CPUFeature.SSE2);
         return features;
diff --git a/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/amd64/AMD64HotSpotVMConfig.java b/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/amd64/AMD64HotSpotVMConfig.java
index 67241fffddd..e4204f5e1c8 100644
--- a/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/amd64/AMD64HotSpotVMConfig.java
+++ b/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/hotspot/amd64/AMD64HotSpotVMConfig.java
@@ -46,8 +46,9 @@
     final int useSSE = getFlag("UseSSE", Integer.class);
     final int useAVX = getFlag("UseAVX", Integer.class);
 
-    final long vmVersionFeatures = getFieldValue("Abstract_VM_Version::_features", Long.class, "uint64_t");
-    final long vmVersionExtraFeatures = getFieldValue("Abstract_VM_Version::_extra_features", Long.class, "uint64_t");
+    final long vmVersionFeaturesVector = getFieldAddress("Abstract_VM_Version::_dynamic_features_vector", "uint64_t*");
+    final long vmVersionFeaturesVectorSize = getFieldValue("Abstract_VM_Version::_dynamic_features_vector_size", Long.class, "uint64_t");
+    final long vmVersionFeaturesElemShiftCnt = getFieldValue("Abstract_VM_Version::_dynamic_features_element_shift_count", Long.class, "uint64_t");
 
     // CPU feature flags
     final long amd64CX8 = getConstant("VM_Version::CPU_CX8", Long.class);
@@ -90,5 +91,5 @@
     final long amd64CET_IBT = getConstant("VM_Version::CPU_CET_IBT", Long.class);
     final long amd64CET_SS = getConstant("VM_Version::CPU_CET_SS", Long.class);
     final long avx10_1 = getConstant("VM_Version::CPU_AVX10_1", Long.class);
-    final long avx10_2 = getConstant("VM_Version::EXTRA_CPU_AVX10_2", Long.class);
+    final long avx10_2 = getConstant("VM_Version::CPU_AVX10_2", Long.class);
 }
diff --git a/test/hotspot/jtreg/serviceability/sa/ClhsdbLongConstant.java b/test/hotspot/jtreg/serviceability/sa/ClhsdbLongConstant.java
index 1f039eb73b5..5a3336de64d 100644
--- a/test/hotspot/jtreg/serviceability/sa/ClhsdbLongConstant.java
+++ b/test/hotspot/jtreg/serviceability/sa/ClhsdbLongConstant.java
@@ -105,7 +105,7 @@ private static void checkForTruncation(String longConstantOutput) throws Excepti
             // Expected value obtained from the CPU_SHA definition in vm_version_x86.hpp
             checkLongValue("VM_Version::CPU_SHA ",
                            longConstantOutput,
-                           17179869184L);
+                           34L);
         }
     }
 
