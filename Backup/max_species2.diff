diff --git a/configure b/configure
old mode 100644
new mode 100755
diff --git a/src/hotspot/cpu/x86/vm_version_x86.cpp b/src/hotspot/cpu/x86/vm_version_x86.cpp
index 8e19c09f9b4..b5987002bef 100644
--- a/src/hotspot/cpu/x86/vm_version_x86.cpp
+++ b/src/hotspot/cpu/x86/vm_version_x86.cpp
@@ -3215,6 +3215,50 @@ intx VM_Version::allocate_prefetch_distance(bool use_watermark_prefetch) {
   }
 }
 
+// Max vector size in bytes. 0 if not supported.
+int VM_Version::max_vector_size(BasicType bt) {
+  assert(is_java_primitive(bt), "only primitive type vectors");
+  if (UseSSE < 2) return 0;
+  // SSE2 supports 128bit vectors for all types.
+  // AVX2 supports 256bit vectors for all types.
+  // AVX2/EVEX supports 512bit vectors for all types.
+  int size = (UseAVX > 1) ? (1 << UseAVX) * 8 : 16;
+  // AVX1 supports 256bit vectors only for FLOAT and DOUBLE.
+  if (UseAVX > 0 && (bt == T_FLOAT || bt == T_DOUBLE))
+    size = (UseAVX > 2) ? 64 : 32;
+  if (UseAVX > 2 && (bt == T_BYTE || bt == T_SHORT || bt == T_CHAR))
+    size = (VM_Version::supports_avx512bw()) ? 64 : 32;
+  // Use flag to limit vector size.
+  size = MIN2(size,(int)MaxVectorSize);
+  // Minimum 2 values in vector (or 4 for bytes).
+  switch (bt) {
+  case T_DOUBLE:
+  case T_LONG:
+    if (size < 16) return 0;
+    break;
+  case T_FLOAT:
+  case T_INT:
+    if (size < 8) return 0;
+    break;
+  case T_BOOLEAN:
+    if (size < 4) return 0;
+    break;
+  case T_CHAR:
+    if (size < 4) return 0;
+    break;
+  case T_BYTE:
+    if (size < 4) return 0;
+    break;
+  case T_SHORT:
+    if (size < 4) return 0;
+    break;
+  default:
+    assert(false, "Unexpected basic type");
+  }
+  return size / type2aelembytes(bt);
+}
+
+
 bool VM_Version::is_intrinsic_supported(vmIntrinsicID id) {
   assert(id != vmIntrinsics::_none, "must be a VM intrinsic");
   switch (id) {
diff --git a/src/hotspot/cpu/x86/vm_version_x86.hpp b/src/hotspot/cpu/x86/vm_version_x86.hpp
index cb9e806999b..08ffe36027e 100644
--- a/src/hotspot/cpu/x86/vm_version_x86.hpp
+++ b/src/hotspot/cpu/x86/vm_version_x86.hpp
@@ -774,6 +774,9 @@ public:
   // Check intrinsic support
   static bool is_intrinsic_supported(vmIntrinsicID id);
 
+  // Max supported vector lane count for a particular lane type.
+  static int max_vector_size(BasicType bt);
+
   // there are several insns to force cache line sync to memory which
   // we can use to ensure mapped non-volatile memory is up to date with
   // pending in-cache changes.
diff --git a/src/hotspot/cpu/x86/x86.ad b/src/hotspot/cpu/x86/x86.ad
index 20fdac3f978..1be9d9eaa09 100644
--- a/src/hotspot/cpu/x86/x86.ad
+++ b/src/hotspot/cpu/x86/x86.ad
@@ -2263,8 +2263,9 @@ int Matcher::vector_width_in_bytes(BasicType bt) {
 
 // Limits on vector size (number of elements) loaded into vector.
 int Matcher::max_vector_size(const BasicType bt) {
-  return vector_width_in_bytes(bt)/type2aelembytes(bt);
+  return VM_Version::max_vector_size(bt);
 }
+
 int Matcher::min_vector_size(const BasicType bt) {
   int max_size = max_vector_size(bt);
   // Min size which can be loaded into vector is 4 bytes.
diff --git a/src/hotspot/share/classfile/classFileParser.cpp b/src/hotspot/share/classfile/classFileParser.cpp
index 934502a087b..b79701b66aa 100644
--- a/src/hotspot/share/classfile/classFileParser.cpp
+++ b/src/hotspot/share/classfile/classFileParser.cpp
@@ -1625,7 +1625,12 @@ void ClassFileParser::parse_fields(const ClassFileStream* const cfs,
     if (parsed_annotations.is_multifield_base() && is_java_primitive(cp->basic_type_for_signature_at(signature_index))) {
       field->field_flags_addr()->update_multifield_base(true);
       char* base_name = cp->symbol_at(name_index)->as_C_string();
-      for (int i = 1; i < parsed_annotations.multifield_arg(); i++) {
+      int bundle_size = parsed_annotations.multifield_arg();
+      if (bundle_size < 0) {
+        bundle_size = VectorSupport::get_max_multifield_count(_class_name);
+      }
+      assert(bundle_size > 0, "Must be");
+      for (int i = 1; i < bundle_size; i++) {
         field_index++;
         stringStream st;
         st.print("%s", base_name);
diff --git a/src/hotspot/share/classfile/systemDictionaryShared.cpp b/src/hotspot/share/classfile/systemDictionaryShared.cpp
index 754e5543e20..9faa73345a1 100644
--- a/src/hotspot/share/classfile/systemDictionaryShared.cpp
+++ b/src/hotspot/share/classfile/systemDictionaryShared.cpp
@@ -291,6 +291,10 @@ bool SystemDictionaryShared::check_for_exclusion_impl(InstanceKlass* k) {
     return warn_excluded(k, "JFR event class");
   }
 
+  /*if (VectorSupport::is_vector_payload_mf(k)) {
+    return warn_excluded(k, "VectorPayloadMF class");
+  }*/
+
   if (!k->is_linked()) {
     if (has_class_failed_verification(k)) {
       return warn_excluded(k, "Failed verification");
diff --git a/src/hotspot/share/classfile/vmSymbols.hpp b/src/hotspot/share/classfile/vmSymbols.hpp
index a52b28b579a..16244477176 100644
--- a/src/hotspot/share/classfile/vmSymbols.hpp
+++ b/src/hotspot/share/classfile/vmSymbols.hpp
@@ -131,6 +131,20 @@ class SerializeClosure;
   template(jdk_internal_vm_vector_VectorPayloadMF128D, "jdk/internal/vm/vector/VectorSupport$VectorPayloadMF128D") \
   template(jdk_internal_vm_vector_VectorPayloadMF256D, "jdk/internal/vm/vector/VectorSupport$VectorPayloadMF256D") \
   template(jdk_internal_vm_vector_VectorPayloadMF512D, "jdk/internal/vm/vector/VectorSupport$VectorPayloadMF512D") \
+  template(jdk_internal_vm_vector_VectorPayloadMFMaxB, "jdk/internal/vm/vector/VectorSupport$VectorPayloadMFMaxB") \
+  template(jdk_internal_vm_vector_VectorPayloadMFMaxS, "jdk/internal/vm/vector/VectorSupport$VectorPayloadMFMaxS") \
+  template(jdk_internal_vm_vector_VectorPayloadMFMaxI, "jdk/internal/vm/vector/VectorSupport$VectorPayloadMFMaxI") \
+  template(jdk_internal_vm_vector_VectorPayloadMFMaxL, "jdk/internal/vm/vector/VectorSupport$VectorPayloadMFMaxL") \
+  template(jdk_internal_vm_vector_VectorPayloadMFMaxF, "jdk/internal/vm/vector/VectorSupport$VectorPayloadMFMaxF") \
+  template(jdk_internal_vm_vector_VectorPayloadMFMaxD, "jdk/internal/vm/vector/VectorSupport$VectorPayloadMFMaxD") \
+  template(jdk_internal_vm_vector_VectorPayloadMFMaxBZ, "jdk/internal/vm/vector/VectorSupport$VectorPayloadMFMaxBZ") \
+  template(jdk_internal_vm_vector_VectorPayloadMFMaxSZ, "jdk/internal/vm/vector/VectorSupport$VectorPayloadMFMaxSZ") \
+  template(jdk_internal_vm_vector_VectorPayloadMFMaxIZ, "jdk/internal/vm/vector/VectorSupport$VectorPayloadMFMaxIZ") \
+  template(jdk_internal_vm_vector_VectorPayloadMFMaxLZ, "jdk/internal/vm/vector/VectorSupport$VectorPayloadMFMaxLZ") \
+  template(jdk_internal_vm_vector_VectorPayloadMFMaxBB, "jdk/internal/vm/vector/VectorSupport$VectorPayloadMFMaxBB") \
+  template(jdk_internal_vm_vector_VectorPayloadMFMaxSB, "jdk/internal/vm/vector/VectorSupport$VectorPayloadMFMaxSB") \
+  template(jdk_internal_vm_vector_VectorPayloadMFMaxIB, "jdk/internal/vm/vector/VectorSupport$VectorPayloadMFMaxIB") \
+  template(jdk_internal_vm_vector_VectorPayloadMFMaxLB, "jdk/internal/vm/vector/VectorSupport$VectorPayloadMFMaxLB") \
   template(payload_name,                               "payload")                                                  \
   template(mfield_name,                                "mfield")                                                   \
   template(ETYPE_name,                                 "ETYPE")                                                    \
diff --git a/src/hotspot/share/prims/vectorSupport.cpp b/src/hotspot/share/prims/vectorSupport.cpp
index bc856364405..5dc4d5036a2 100644
--- a/src/hotspot/share/prims/vectorSupport.cpp
+++ b/src/hotspot/share/prims/vectorSupport.cpp
@@ -459,19 +459,50 @@ int VectorSupport::vop2ideal(jint id, BasicType bt) {
 }
 #endif // COMPILER2
 
+int VectorSupport::get_max_multifield_count(const Symbol* payload_name) {
+  assert(payload_name, "");
+  vmSymbolID sid = vmSymbols::find_sid(payload_name);
+  int size = VM_Version::max_vector_size(T_BYTE);
+  switch(sid) {
+    case vmSymbolID::jdk_internal_vm_vector_VectorPayloadMFMaxB_enum:
+    case vmSymbolID::jdk_internal_vm_vector_VectorPayloadMFMaxBZ_enum:
+    case vmSymbolID::jdk_internal_vm_vector_VectorPayloadMFMaxBB_enum:
+       return size;
+    case vmSymbolID::jdk_internal_vm_vector_VectorPayloadMFMaxS_enum:
+    case vmSymbolID::jdk_internal_vm_vector_VectorPayloadMFMaxSZ_enum:
+    case vmSymbolID::jdk_internal_vm_vector_VectorPayloadMFMaxSB_enum:
+       return size / type2aelembytes(T_SHORT);
+    case vmSymbolID::jdk_internal_vm_vector_VectorPayloadMFMaxI_enum:
+    case vmSymbolID::jdk_internal_vm_vector_VectorPayloadMFMaxIZ_enum:
+    case vmSymbolID::jdk_internal_vm_vector_VectorPayloadMFMaxIB_enum:
+       return size / type2aelembytes(T_INT);
+    case vmSymbolID::jdk_internal_vm_vector_VectorPayloadMFMaxL_enum:
+    case vmSymbolID::jdk_internal_vm_vector_VectorPayloadMFMaxLZ_enum:
+    case vmSymbolID::jdk_internal_vm_vector_VectorPayloadMFMaxLB_enum:
+       return size / type2aelembytes(T_LONG);
+    case vmSymbolID::jdk_internal_vm_vector_VectorPayloadMFMaxF_enum:
+       return size / type2aelembytes(T_FLOAT);
+    case vmSymbolID::jdk_internal_vm_vector_VectorPayloadMFMaxD_enum:
+       return size / type2aelembytes(T_DOUBLE);
+    default  : fatal("unknown symbol"); return -1;
+  }
+}
+
+int VectorSupport::max_vector_size(BasicType bt) {
+  if (is_java_primitive(bt)) {
+    return VM_Version::max_vector_size(bt);
+  }
+  return -1;
+}
+
 /**
  * Implementation of the jdk.internal.vm.vector.VectorSupport class
  */
 
 JVM_ENTRY(jint, VectorSupport_GetMaxLaneCount(JNIEnv *env, jclass vsclazz, jobject clazz)) {
-#ifdef COMPILER2
   oop mirror = JNIHandles::resolve_non_null(clazz);
-  if (java_lang_Class::is_primitive(mirror)) {
-    BasicType bt = java_lang_Class::primitive_type(mirror);
-    return Matcher::max_vector_size(bt);
-  }
-#endif // COMPILER2
-  return -1;
+  BasicType bt = java_lang_Class::primitive_type(mirror);
+  return VectorSupport::max_vector_size(bt);
 } JVM_END
 
 // JVM_RegisterVectorSupportMethods
diff --git a/src/hotspot/share/prims/vectorSupport.hpp b/src/hotspot/share/prims/vectorSupport.hpp
index 3f2977c825d..8cd203bcbca 100644
--- a/src/hotspot/share/prims/vectorSupport.hpp
+++ b/src/hotspot/share/prims/vectorSupport.hpp
@@ -138,5 +138,7 @@ class VectorSupport : AllStatic {
   static bool is_vector(Klass* klass);
   static bool is_vector_payload_mf(Klass* klass);
   static bool skip_value_scalarization(Klass* klass);
+  static int  max_vector_size(BasicType bt);
+  static int  get_max_multifield_count(const Symbol* payload_name);
 };
 #endif // SHARE_PRIMS_VECTORSUPPORT_HPP
diff --git a/src/java.base/share/classes/jdk/internal/vm/vector/VectorSupport.java b/src/java.base/share/classes/jdk/internal/vm/vector/VectorSupport.java
index a74ed1a04ce..bcb39ab2fba 100644
--- a/src/java.base/share/classes/jdk/internal/vm/vector/VectorSupport.java
+++ b/src/java.base/share/classes/jdk/internal/vm/vector/VectorSupport.java
@@ -166,8 +166,8 @@ public class VectorSupport {
         public abstract long multiFieldOffset();
 
         @ForceInline
-        public static VectorPayloadMF newInstanceFactory(Class<?> elemType, int length) {
-            if (elemType == boolean.class) {
+        public static VectorPayloadMF newMaskInstanceFactory(Class<?> elemType, int length, boolean max_payload) {
+            if (false == max_payload) {
                 switch(length) {
                     case  1: return new VectorPayloadMF8Z();
                     case  2: return new VectorPayloadMF16Z();
@@ -178,7 +178,28 @@ public class VectorSupport {
                     case 64: return new VectorPayloadMF512Z();
                     default: assert false : "Unhandled vector mask size";
                 }
-            } else if (elemType == byte.class) {
+            } else {
+                if (elemType == byte.class) {
+                   return new VectorPayloadMFMaxBZ();
+                } else if (elemType == short.class) {
+                   return new VectorPayloadMFMaxSZ();
+                } else if (elemType == int.class) {
+                   return new VectorPayloadMFMaxIZ();
+                } else if (elemType == long.class) {
+                   return new VectorPayloadMFMaxLZ();
+                } else if (elemType == float.class) {
+                   return new VectorPayloadMFMaxIZ();
+                } else {
+                   assert elemType == double.class;
+                   return new VectorPayloadMFMaxLZ();
+                }
+            }
+            return null;
+        }
+
+        @ForceInline
+        public static VectorPayloadMF newShuffleInstanceFactory(Class<?> elemType, int length, boolean max_payload) {
+            if (false == max_payload) {
                 switch(length) {
                     case  1: return new VectorPayloadMF8B();
                     case  2: return new VectorPayloadMF16B();
@@ -187,56 +208,102 @@ public class VectorSupport {
                     case 16: return new VectorPayloadMF128B();
                     case 32: return new VectorPayloadMF256B();
                     case 64: return new VectorPayloadMF512B();
-                    default: assert false : "Unhandled vector size";
+                    default: assert false : "Unhandled vector shuffle size";
                 }
-            } else if (elemType == short.class) {
-                switch(length) {
-                    case  4: return new VectorPayloadMF64S();
-                    case  8: return new VectorPayloadMF128S();
-                    case 16: return new VectorPayloadMF256S();
-                    case 32: return new VectorPayloadMF512S();
-                    default: assert false : "Unhandled vector size";
-                }
-            } else if (elemType == int.class) {
-                switch(length) {
-                    case  2: return new VectorPayloadMF64I();
-                    case  4: return new VectorPayloadMF128I();
-                    case  8: return new VectorPayloadMF256I();
-                    case 16: return new VectorPayloadMF512I();
-                    default: assert false : "Unhandled vector size";
-                }
-            } else if (elemType == long.class) {
-                switch(length) {
-                    case  1: return new VectorPayloadMF64L();
-                    case  2: return new VectorPayloadMF128L();
-                    case  4: return new VectorPayloadMF256L();
-                    case  8: return new VectorPayloadMF512L();
-                    default: assert false : "Unhandled vector size";
+            } else {
+                if (elemType == byte.class) {
+                   return new VectorPayloadMFMaxBB();
+                } else if (elemType == short.class) {
+                   return new VectorPayloadMFMaxSB();
+                } else if (elemType == int.class) {
+                   return new VectorPayloadMFMaxIB();
+                } else if (elemType == long.class) {
+                   return new VectorPayloadMFMaxLB();
+                } else if (elemType == float.class) {
+                   return new VectorPayloadMFMaxIB();
+                } else {
+                   assert elemType == double.class;
+                   return new VectorPayloadMFMaxLB();
                 }
-            } else if (elemType == float.class) {
-                switch(length) {
-                    case  2: return new VectorPayloadMF64F();
-                    case  4: return new VectorPayloadMF128F();
-                    case  8: return new VectorPayloadMF256F();
-                    case 16: return new VectorPayloadMF512F();
-                    default: assert false : "Unhandled vector size";
+            }
+            return null;
+        }
+
+        @ForceInline
+        public static VectorPayloadMF newVectorInstanceFactory(Class<?> elemType, int length, boolean max_payload) {
+            if (false == max_payload) {
+                if (elemType == byte.class) {
+                    switch(length) {
+                        case  8: return new VectorPayloadMF64B();
+                        case 16: return new VectorPayloadMF128B();
+                        case 32: return new VectorPayloadMF256B();
+                        case 64: return new VectorPayloadMF512B();
+                        default: assert false : "Unhandled vector size";
+                    }
+                } else if (elemType == short.class) {
+                    switch(length) {
+                        case  4: return new VectorPayloadMF64S();
+                        case  8: return new VectorPayloadMF128S();
+                        case 16: return new VectorPayloadMF256S();
+                        case 32: return new VectorPayloadMF512S();
+                        default: assert false : "Unhandled vector size";
+                    }
+                } else if (elemType == int.class) {
+                    switch(length) {
+                        case  2: return new VectorPayloadMF64I();
+                        case  4: return new VectorPayloadMF128I();
+                        case  8: return new VectorPayloadMF256I();
+                        case 16: return new VectorPayloadMF512I();
+                        default: assert false : "Unhandled vector size";
+                    }
+                } else if (elemType == long.class) {
+                    switch(length) {
+                        case  1: return new VectorPayloadMF64L();
+                        case  2: return new VectorPayloadMF128L();
+                        case  4: return new VectorPayloadMF256L();
+                        case  8: return new VectorPayloadMF512L();
+                        default: assert false : "Unhandled vector size";
+                    }
+                } else if (elemType == float.class) {
+                    switch(length) {
+                        case  2: return new VectorPayloadMF64F();
+                        case  4: return new VectorPayloadMF128F();
+                        case  8: return new VectorPayloadMF256F();
+                        case 16: return new VectorPayloadMF512F();
+                        default: assert false : "Unhandled vector size";
+                    }
+                } else {
+                    assert elemType == double.class;
+                    switch(length) {
+                        case  1: return new VectorPayloadMF64D();
+                        case  2: return new VectorPayloadMF128D();
+                        case  4: return new VectorPayloadMF256D();
+                        case  8: return new VectorPayloadMF512D();
+                        default: assert false : "Unhandled vector size";
+                    }
                 }
             } else {
-                assert elemType == double.class;
-                switch(length) {
-                    case  1: return new VectorPayloadMF64D();
-                    case  2: return new VectorPayloadMF128D();
-                    case  4: return new VectorPayloadMF256D();
-                    case  8: return new VectorPayloadMF512D();
-                    default: assert false : "Unhandled vector size";
+                if (elemType == byte.class) {
+                    return new VectorPayloadMFMaxB();
+                } else if (elemType == short.class) {
+                    return new VectorPayloadMFMaxS();
+                } else if (elemType == int.class) {
+                    return new VectorPayloadMFMaxI();
+                } else if (elemType == long.class) {
+                    return new VectorPayloadMFMaxL();
+                } else if (elemType == float.class) {
+                    return new VectorPayloadMFMaxF();
+                } else {
+                    assert elemType == double.class;
+                    return new VectorPayloadMFMaxD();
                 }
             }
             return null;
         }
 
         @ForceInline
-        public static VectorPayloadMF createVectPayloadInstanceB(int length, byte [] init) {
-            VectorPayloadMF obj = newInstanceFactory(byte.class, length);
+        public static VectorPayloadMF createVectPayloadInstanceB(int length, byte [] init, boolean max_payload) {
+            VectorPayloadMF obj = newVectorInstanceFactory(byte.class, length, max_payload);
             obj = Unsafe.getUnsafe().makePrivateBuffer(obj);
             long start_offset = obj.multiFieldOffset();
             for (int i = 0; i < length; i++) {
@@ -247,8 +314,8 @@ public class VectorSupport {
         }
 
         @ForceInline
-        public static VectorPayloadMF createVectPayloadInstanceS(int length, short [] init) {
-            VectorPayloadMF obj = newInstanceFactory(short.class, length);
+        public static VectorPayloadMF createVectPayloadInstanceS(int length, short [] init, boolean max_payload) {
+            VectorPayloadMF obj = newVectorInstanceFactory(short.class, length, max_payload);
             obj = Unsafe.getUnsafe().makePrivateBuffer(obj);
             long start_offset = obj.multiFieldOffset();
             for (int i = 0; i < length; i++) {
@@ -259,8 +326,8 @@ public class VectorSupport {
         }
 
         @ForceInline
-        public static VectorPayloadMF createVectPayloadInstanceI(int length, int [] init) {
-            VectorPayloadMF obj = newInstanceFactory(int.class, length);
+        public static VectorPayloadMF createVectPayloadInstanceI(int length, int [] init, boolean max_payload) {
+            VectorPayloadMF obj = newVectorInstanceFactory(int.class, length, max_payload);
             obj = Unsafe.getUnsafe().makePrivateBuffer(obj);
             long start_offset = obj.multiFieldOffset();
             for (int i = 0; i < length; i++) {
@@ -271,8 +338,8 @@ public class VectorSupport {
         }
 
         @ForceInline
-        public static VectorPayloadMF createVectPayloadInstanceL(int length, long [] init) {
-            VectorPayloadMF obj = newInstanceFactory(long.class, length);
+        public static VectorPayloadMF createVectPayloadInstanceL(int length, long [] init, boolean max_payload) {
+            VectorPayloadMF obj = newVectorInstanceFactory(long.class, length, max_payload);
             obj = Unsafe.getUnsafe().makePrivateBuffer(obj);
             long start_offset = obj.multiFieldOffset();
             for (int i = 0; i < length; i++) {
@@ -283,8 +350,8 @@ public class VectorSupport {
         }
 
         @ForceInline
-        public static VectorPayloadMF createVectPayloadInstanceF(int length, float [] init) {
-            VectorPayloadMF obj = newInstanceFactory(float.class, length);
+        public static VectorPayloadMF createVectPayloadInstanceF(int length, float [] init, boolean max_payload) {
+            VectorPayloadMF obj = newVectorInstanceFactory(float.class, length, max_payload);
             obj = Unsafe.getUnsafe().makePrivateBuffer(obj);
             long start_offset = obj.multiFieldOffset();
             for (int i = 0; i < length; i++) {
@@ -295,8 +362,8 @@ public class VectorSupport {
         }
 
         @ForceInline
-        public static VectorPayloadMF createVectPayloadInstanceD(int length, double [] init) {
-            VectorPayloadMF obj = newInstanceFactory(double.class, length);
+        public static VectorPayloadMF createVectPayloadInstanceD(int length, double [] init, boolean max_payload) {
+            VectorPayloadMF obj = newVectorInstanceFactory(double.class, length, max_payload);
             obj = Unsafe.getUnsafe().makePrivateBuffer(obj);
             long start_offset = obj.multiFieldOffset();
             for (int i = 0; i < length; i++) {
@@ -307,18 +374,7 @@ public class VectorSupport {
         }
 
         public int length() {
-            try {
-                var field = this.getClass().getDeclaredField("mfield");
-                var msanno = field.getAnnotationsByType(MultiField.class);
-
-                Objects.nonNull(msanno);
-
-                assert msanno.length == 1;
-                return msanno[0].value();
-            } catch (Exception e) {
-                System.out.println(e);
-            }
-            return -1;
+            return getClass().getDeclaredFields().length - 1;
         }
 
         public static long multiFieldOffset(Class<? extends VectorPayloadMF> cls) {
@@ -332,10 +388,64 @@ public class VectorSupport {
         }
     }
 
+    public primitive static class VectorPayloadMFMaxB extends VectorPayloadMF {
+        @MultiField(value = -1)
+        byte mfield = 0;
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMFMaxB.class);
+
+        @Override
+        public long multiFieldOffset() { return MFOFFSET; }
+    }
+
+    public primitive static class VectorPayloadMFMaxS extends VectorPayloadMF {
+        @MultiField(value = -1)
+        short mfield = 0;
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMFMaxS.class);
+
+        @Override
+        public long multiFieldOffset() { return MFOFFSET; }
+    }
+
+    public primitive static class VectorPayloadMFMaxI extends VectorPayloadMF {
+        @MultiField(value = -1)
+        int mfield = 0;
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMFMaxI.class);
+
+        @Override
+        public long multiFieldOffset() { return MFOFFSET; }
+    }
+
+    public primitive static class VectorPayloadMFMaxL extends VectorPayloadMF {
+        @MultiField(value = -1)
+        long mfield = 0;
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMFMaxL.class);
+
+        @Override
+        public long multiFieldOffset() { return MFOFFSET; }
+    }
+
+    public primitive static class VectorPayloadMFMaxF extends VectorPayloadMF {
+        @MultiField(value = -1)
+        float mfield = 0.0f;
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMFMaxF.class);
+
+        @Override
+        public long multiFieldOffset() { return MFOFFSET; }
+    }
+
+    public primitive static class VectorPayloadMFMaxD extends VectorPayloadMF {
+        @MultiField(value = -1)
+        double mfield = 0.0;
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMFMaxD.class);
+
+        @Override
+        public long multiFieldOffset() { return MFOFFSET; }
+    }
+
     public primitive static class VectorPayloadMF8Z extends VectorPayloadMF {
         @MultiField(value = 1)
         boolean mfield = false;
-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF8Z.class);
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF8Z.class);
 
         @Override
         public long multiFieldOffset() { return MFOFFSET; }
@@ -344,7 +454,7 @@ public class VectorSupport {
     public primitive static class VectorPayloadMF16Z extends VectorPayloadMF {
         @MultiField(value = 2)
         boolean mfield = false;
-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF16Z.class);
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF16Z.class);
 
         @Override
         public long multiFieldOffset() { return MFOFFSET; }
@@ -353,7 +463,7 @@ public class VectorSupport {
     public primitive static class VectorPayloadMF32Z extends VectorPayloadMF {
         @MultiField(value = 4)
         boolean mfield = false;
-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF32Z.class);
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF32Z.class);
 
         @Override
         public long multiFieldOffset() { return MFOFFSET; }
@@ -362,7 +472,7 @@ public class VectorSupport {
     public primitive static class VectorPayloadMF64Z extends VectorPayloadMF {
         @MultiField(value = 8)
         boolean mfield = false;
-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64Z.class);
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF64Z.class);
 
         @Override
         public long multiFieldOffset() { return MFOFFSET; }
@@ -371,7 +481,7 @@ public class VectorSupport {
     public primitive static class VectorPayloadMF128Z extends VectorPayloadMF {
         @MultiField(value = 16)
         boolean mfield = false;
-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128Z.class);
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF128Z.class);
 
         @Override
         public long multiFieldOffset() { return MFOFFSET; }
@@ -380,7 +490,7 @@ public class VectorSupport {
     public primitive static class VectorPayloadMF256Z extends VectorPayloadMF {
         @MultiField(value = 32)
         boolean mfield = false;
-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256Z.class);
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF256Z.class);
 
         @Override
         public long multiFieldOffset() { return MFOFFSET; }
@@ -389,7 +499,43 @@ public class VectorSupport {
     public primitive static class VectorPayloadMF512Z extends VectorPayloadMF {
         @MultiField(value = 64)
         boolean mfield = false;
-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512Z.class);
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF512Z.class);
+
+        @Override
+        public long multiFieldOffset() { return MFOFFSET; }
+    }
+
+    public primitive static class VectorPayloadMFMaxBZ extends VectorPayloadMF {
+        @MultiField(value = -1)
+        boolean mfield = false;
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMFMaxBZ.class);
+
+        @Override
+        public long multiFieldOffset() { return MFOFFSET; }
+    }
+
+    public primitive static class VectorPayloadMFMaxSZ extends VectorPayloadMF {
+        @MultiField(value = -1)
+        boolean mfield = false;
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMFMaxSZ.class);
+
+        @Override
+        public long multiFieldOffset() { return MFOFFSET; }
+    }
+
+    public primitive static class VectorPayloadMFMaxIZ extends VectorPayloadMF {
+        @MultiField(value = -1)
+        boolean mfield = false;
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMFMaxIZ.class);
+
+        @Override
+        public long multiFieldOffset() { return MFOFFSET; }
+    }
+
+    public primitive static class VectorPayloadMFMaxLZ extends VectorPayloadMF {
+        @MultiField(value = -1)
+        boolean mfield = false;
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMFMaxLZ.class);
 
         @Override
         public long multiFieldOffset() { return MFOFFSET; }
@@ -398,7 +544,7 @@ public class VectorSupport {
     public primitive static class VectorPayloadMF8B extends VectorPayloadMF {
         @MultiField(value = 1)
         byte mfield = 0;
-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF8B.class);
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF8B.class);
 
         @Override
         public long multiFieldOffset() { return MFOFFSET; }
@@ -407,7 +553,7 @@ public class VectorSupport {
     public primitive static class VectorPayloadMF16B extends VectorPayloadMF {
         @MultiField(value = 2)
         byte mfield = 0;
-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF16B.class);
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF16B.class);
 
         @Override
         public long multiFieldOffset() { return MFOFFSET; }
@@ -416,7 +562,7 @@ public class VectorSupport {
     public primitive static class VectorPayloadMF32B extends VectorPayloadMF {
         @MultiField(value = 4)
         byte mfield = 0;
-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF32B.class);
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF32B.class);
 
         @Override
         public long multiFieldOffset() { return MFOFFSET; }
@@ -425,7 +571,7 @@ public class VectorSupport {
     public primitive static class VectorPayloadMF64B extends VectorPayloadMF {
         @MultiField(value = 8)
         byte mfield = 0;
-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64B.class);
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF64B.class);
 
         @Override
         public long multiFieldOffset() { return MFOFFSET; }
@@ -434,7 +580,7 @@ public class VectorSupport {
     public primitive static class VectorPayloadMF128B extends VectorPayloadMF {
         @MultiField(value = 16)
         byte mfield = 0;
-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128B.class);
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF128B.class);
 
         @Override
         public long multiFieldOffset() { return MFOFFSET; }
@@ -443,7 +589,7 @@ public class VectorSupport {
     public primitive static class VectorPayloadMF256B extends VectorPayloadMF {
         @MultiField(value = 32)
         byte mfield = 0;
-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256B.class);
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF256B.class);
 
         @Override
         public long multiFieldOffset() { return MFOFFSET; }
@@ -452,7 +598,43 @@ public class VectorSupport {
     public primitive static class VectorPayloadMF512B extends VectorPayloadMF {
         @MultiField(value = 64)
         byte mfield = 0;
-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512B.class);
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF512B.class);
+
+        @Override
+        public long multiFieldOffset() { return MFOFFSET; }
+    }
+
+    public primitive static class VectorPayloadMFMaxBB extends VectorPayloadMF {
+        @MultiField(value = -1)
+        byte mfield = 0;
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMFMaxBB.class);
+
+        @Override
+        public long multiFieldOffset() { return MFOFFSET; }
+    }
+
+    public primitive static class VectorPayloadMFMaxSB extends VectorPayloadMF {
+        @MultiField(value = -1)
+        byte mfield = 0;
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMFMaxSB.class);
+
+        @Override
+        public long multiFieldOffset() { return MFOFFSET; }
+    }
+
+    public primitive static class VectorPayloadMFMaxIB extends VectorPayloadMF {
+        @MultiField(value = -1)
+        byte mfield = 0;
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMFMaxIB.class);
+
+        @Override
+        public long multiFieldOffset() { return MFOFFSET; }
+    }
+
+    public primitive static class VectorPayloadMFMaxLB extends VectorPayloadMF {
+        @MultiField(value = -1)
+        byte mfield = 0;
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMFMaxLB.class);
 
         @Override
         public long multiFieldOffset() { return MFOFFSET; }
@@ -461,7 +643,7 @@ public class VectorSupport {
     public primitive static class VectorPayloadMF64S extends VectorPayloadMF {
         @MultiField(value = 4)
         short mfield = 0;
-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64S.class);
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF64S.class);
 
         @Override
         public long multiFieldOffset() { return MFOFFSET; }
@@ -470,7 +652,7 @@ public class VectorSupport {
     public primitive static class VectorPayloadMF128S extends VectorPayloadMF {
         @MultiField(value = 8)
         short mfield = 0;
-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128S.class);
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF128S.class);
 
         @Override
         public long multiFieldOffset() { return MFOFFSET; }
@@ -479,7 +661,7 @@ public class VectorSupport {
     public primitive static class VectorPayloadMF256S extends VectorPayloadMF {
         @MultiField(value = 16)
         short mfield = 0;
-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256S.class);
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF256S.class);
 
         @Override
         public long multiFieldOffset() { return MFOFFSET; }
@@ -488,7 +670,7 @@ public class VectorSupport {
     public primitive static class VectorPayloadMF512S extends VectorPayloadMF {
         @MultiField(value = 32)
         short mfield = 0;
-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512S.class);
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF512S.class);
 
         @Override
         public long multiFieldOffset() { return MFOFFSET; }
@@ -497,7 +679,7 @@ public class VectorSupport {
     public primitive static class VectorPayloadMF64I extends VectorPayloadMF {
         @MultiField(value = 2)
         int mfield = 0;
-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64I.class);
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF64I.class);
 
         @Override
         public long multiFieldOffset() { return MFOFFSET; }
@@ -506,7 +688,7 @@ public class VectorSupport {
     public primitive static class VectorPayloadMF128I extends VectorPayloadMF {
         @MultiField(value = 4)
         int mfield = 0;
-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128I.class);
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF128I.class);
 
         @Override
         public long multiFieldOffset() { return MFOFFSET; }
@@ -515,7 +697,7 @@ public class VectorSupport {
     public primitive static class VectorPayloadMF256I extends VectorPayloadMF {
         @MultiField(value = 8)
         int mfield = 0;
-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256I.class);
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF256I.class);
 
         @Override
         public long multiFieldOffset() { return MFOFFSET; }
@@ -524,7 +706,7 @@ public class VectorSupport {
     public primitive static class VectorPayloadMF512I extends VectorPayloadMF {
         @MultiField(value = 16)
         int mfield = 0;
-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512I.class);
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF512I.class);
 
         @Override
         public long multiFieldOffset() { return MFOFFSET; }
@@ -532,8 +714,8 @@ public class VectorSupport {
 
     public primitive static class VectorPayloadMF64L extends VectorPayloadMF {
         @MultiField(value = 1)
-        long mfield = 0;
-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64L.class);
+        final long mfield = 0;
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF64L.class);
 
         @Override
         public long multiFieldOffset() { return MFOFFSET; }
@@ -541,8 +723,8 @@ public class VectorSupport {
 
     public primitive static class VectorPayloadMF128L extends VectorPayloadMF {
         @MultiField(value = 2)
-        long mfield = 0;
-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128L.class);
+        final long mfield = 0;
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF128L.class);
 
         @Override
         public long multiFieldOffset() { return MFOFFSET; }
@@ -550,8 +732,8 @@ public class VectorSupport {
 
     public primitive static class VectorPayloadMF256L extends VectorPayloadMF {
         @MultiField(value = 4)
-        long mfield = 0;
-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256L.class);
+        final long mfield = 0;
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF256L.class);
 
         @Override
         public long multiFieldOffset() { return MFOFFSET; }
@@ -559,8 +741,8 @@ public class VectorSupport {
 
     public primitive static class VectorPayloadMF512L extends VectorPayloadMF {
         @MultiField(value = 8)
-        long mfield = 0;
-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512L.class);
+        final long mfield = 0;
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF512L.class);
 
         @Override
         public long multiFieldOffset() { return MFOFFSET; }
@@ -569,7 +751,7 @@ public class VectorSupport {
     public primitive static class VectorPayloadMF64F extends VectorPayloadMF {
         @MultiField(value = 2)
         float mfield = 0.0f;
-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64F.class);
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF64F.class);
 
         @Override
         public long multiFieldOffset() { return MFOFFSET; }
@@ -578,7 +760,7 @@ public class VectorSupport {
     public primitive static class VectorPayloadMF128F extends VectorPayloadMF {
         @MultiField(value = 4)
         float mfield = 0.0f;
-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128F.class);
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF128F.class);
 
         @Override
         public long multiFieldOffset() { return MFOFFSET; }
@@ -587,7 +769,7 @@ public class VectorSupport {
     public primitive static class VectorPayloadMF256F extends VectorPayloadMF {
         @MultiField(value = 8)
         float mfield = 0.0f;
-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256F.class);
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF256F.class);
 
         @Override
         public long multiFieldOffset() { return MFOFFSET; }
@@ -596,7 +778,7 @@ public class VectorSupport {
     public primitive static class VectorPayloadMF512F extends VectorPayloadMF {
         @MultiField(value = 16)
         float mfield = 0.0f;
-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512F.class);
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF512F.class);
 
         @Override
         public long multiFieldOffset() { return MFOFFSET; }
@@ -605,7 +787,7 @@ public class VectorSupport {
     public primitive static class VectorPayloadMF64D extends VectorPayloadMF {
         @MultiField(value = 1)
         double mfield = 0.0;
-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64D.class);
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF64D.class);
 
         @Override
         public long multiFieldOffset() { return MFOFFSET; }
@@ -614,7 +796,7 @@ public class VectorSupport {
     public primitive static class VectorPayloadMF128D extends VectorPayloadMF {
         @MultiField(value = 2)
         double mfield = 0.0;
-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128D.class);
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF128D.class);
 
         @Override
         public long multiFieldOffset() { return MFOFFSET; }
@@ -623,7 +805,7 @@ public class VectorSupport {
     public primitive static class VectorPayloadMF256D extends VectorPayloadMF {
         @MultiField(value = 4)
         double mfield = 0.0;
-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256D.class);
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF256D.class);
 
         @Override
         public long multiFieldOffset() { return MFOFFSET; }
@@ -632,7 +814,7 @@ public class VectorSupport {
     public primitive static class VectorPayloadMF512D extends VectorPayloadMF {
         @MultiField(value = 8)
         double mfield = 0.0;
-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512D.class);
+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF512D.class);
 
         @Override
         public long multiFieldOffset() { return MFOFFSET; }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractMask.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractMask.java
index c5c9cc24a2e..7d065bc371c 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractMask.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractMask.java
@@ -41,8 +41,8 @@ abstract class AbstractMask<E> extends VectorMask<E> {
     /*package-private*/
     abstract VectorPayloadMF getBits();
 
-    static VectorPayloadMF prepare(VectorPayloadMF payload, int offset, int length) {
-        VectorPayloadMF res = VectorPayloadMF.newInstanceFactory(boolean.class, length);
+    static VectorPayloadMF prepare(VectorPayloadMF payload, int offset, Class<?> elementType, int length, boolean is_max_species) {
+        VectorPayloadMF res = VectorPayloadMF.newMaskInstanceFactory(elementType, length, is_max_species);
         res = Unsafe.getUnsafe().makePrivateBuffer(res);
         long mOffset = res.multiFieldOffset();
         for (int i = 0; i < length; i++) {
@@ -53,8 +53,8 @@ abstract class AbstractMask<E> extends VectorMask<E> {
         return res;
     }
 
-    static VectorPayloadMF prepare(boolean val, int length) {
-        VectorPayloadMF res = VectorPayloadMF.newInstanceFactory(boolean.class, length);
+    static VectorPayloadMF prepare(boolean val, Class<?> elementType, int length, boolean is_max_species) {
+        VectorPayloadMF res = VectorPayloadMF.newMaskInstanceFactory(elementType, length, is_max_species);
         res = Unsafe.getUnsafe().makePrivateBuffer(res);
         long mOffset = res.multiFieldOffset();
         for (int i = 0; i < length; i++) {
@@ -73,7 +73,8 @@ abstract class AbstractMask<E> extends VectorMask<E> {
     AbstractMask<E> uOpMF(MUnOp f) {
         int length = vspecies().laneCount();
         VectorPayloadMF bits = getBits();
-        VectorPayloadMF res = VectorPayloadMF.newInstanceFactory(boolean.class, length);
+        boolean is_max_species = ((AbstractSpecies)(vspecies())).is_max_species();
+        VectorPayloadMF res = VectorPayloadMF.newMaskInstanceFactory(vspecies().elementType(), length, is_max_species);
         res = Unsafe.getUnsafe().makePrivateBuffer(res);
         long mOffset = res.multiFieldOffset();
         for (int i = 0; i < length; i++) {
@@ -94,7 +95,8 @@ abstract class AbstractMask<E> extends VectorMask<E> {
         int length = vspecies().laneCount();
         VectorPayloadMF bits = getBits();
         VectorPayloadMF mbits = m.getBits();
-        VectorPayloadMF res = VectorPayloadMF.newInstanceFactory(boolean.class, length);
+        boolean is_max_species = ((AbstractSpecies)(vspecies())).is_max_species();
+        VectorPayloadMF res = VectorPayloadMF.newMaskInstanceFactory(vspecies().elementType(), length, is_max_species);
         res = Unsafe.getUnsafe().makePrivateBuffer(res);
         long mOffset = res.multiFieldOffset();
         for (int i = 0; i < length; i++) {
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractShuffle.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractShuffle.java
index 1568575ccf6..7e0b8758281 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractShuffle.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractShuffle.java
@@ -39,8 +39,8 @@ abstract class AbstractShuffle<E> extends VectorShuffle<E> {
     /*package-private*/
     abstract VectorPayloadMF indices();
 
-    static VectorPayloadMF prepare(int length, int[] indices, int offset) {
-        VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(byte.class, length);
+    static VectorPayloadMF prepare(Class<?> elemType, int length, int[] indices, int offset, boolean is_max_species) {
+        VectorPayloadMF payload = VectorPayloadMF.newShuffleInstanceFactory(elemType, length, is_max_species);
         payload = Unsafe.getUnsafe().makePrivateBuffer(payload);
         long mf_offset = payload.multiFieldOffset();
         for (int i = 0; i < length; i++) {
@@ -52,8 +52,8 @@ abstract class AbstractShuffle<E> extends VectorShuffle<E> {
         return payload;
     }
 
-    static VectorPayloadMF prepare(int length, IntUnaryOperator f) {
-        VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(byte.class, length);
+    static VectorPayloadMF prepare(Class<?> elemType, int length, IntUnaryOperator f, boolean is_max_species) {
+        VectorPayloadMF payload = VectorPayloadMF.newShuffleInstanceFactory(elemType, length, is_max_species);
         payload = Unsafe.getUnsafe().makePrivateBuffer(payload);
         long offset = payload.multiFieldOffset();
         for (int i = 0; i < length; i++) {
@@ -139,7 +139,8 @@ abstract class AbstractShuffle<E> extends VectorShuffle<E> {
     @ForceInline
     public final VectorShuffle<E> wrapAndRebuild(VectorPayloadMF oldIndices) {
         int length = oldIndices.length();
-        VectorPayloadMF indices = VectorPayloadMF.newInstanceFactory(byte.class, length);
+        boolean is_max_species = ((AbstractSpecies)(vspecies())).is_max_species();
+        VectorPayloadMF indices = VectorPayloadMF.newShuffleInstanceFactory(vspecies().elementType(), length, is_max_species);
         long offset = oldIndices.multiFieldOffset();
         indices = Unsafe.getUnsafe().makePrivateBuffer(indices);
         for (int i = 0; i < length; i++) {
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractSpecies.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractSpecies.java
index eba296e6fdf..1f340c9e5e8 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractSpecies.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractSpecies.java
@@ -298,6 +298,8 @@ abstract class AbstractSpecies<E> extends VectorSupport.VectorSpecies<E>
     /*package-private*/
     abstract Vector<E> fromIntValues(int[] values);
 
+    boolean is_max_species() { return vectorShape().switchKey == VectorShape.SK_Max_BIT; }
+
     /**
      * Do not use a dummy except to call methods on it when you don't
      * care about the lane values.  The main benefit of it is to
@@ -320,22 +322,22 @@ abstract class AbstractSpecies<E> extends VectorSupport.VectorSpecies<E>
         VectorSupport.VectorPayloadMF za = null;
         switch (laneType.switchKey) {
         case LaneType.SK_FLOAT:
-            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceF(laneCount, (float[])initarr);
+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceF(laneCount, (float[])initarr, is_max_species());
             break;
         case LaneType.SK_DOUBLE:
-            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceD(laneCount, (double[])initarr);
+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceD(laneCount, (double[])initarr, is_max_species());
             break;
         case LaneType.SK_BYTE:
-            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceB(laneCount, (byte[])initarr);
+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceB(laneCount, (byte[])initarr, is_max_species());
             break;
         case LaneType.SK_SHORT:
-            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceS(laneCount, (short[])initarr);
+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceS(laneCount, (short[])initarr, is_max_species());
             break;
         case LaneType.SK_INT:
-            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceI(laneCount, (int[])initarr);
+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceI(laneCount, (int[])initarr, is_max_species());
             break;
         case LaneType.SK_LONG:
-            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceL(laneCount, (long[])initarr);
+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceL(laneCount, (long[])initarr, is_max_species());
             break;
         default:
             assert false : "Unsupported elemType in createVectorMF";
@@ -354,7 +356,7 @@ abstract class AbstractSpecies<E> extends VectorSupport.VectorSpecies<E>
         case LaneType.SK_SHORT:
         case LaneType.SK_INT:
         case LaneType.SK_LONG:
-            za = VectorPayloadMF.newInstanceFactory(elementType(), laneCount);
+            za = VectorPayloadMF.newVectorInstanceFactory(elementType(), laneCount, is_max_species());
             break;
         default:
             assert false : "Unsupported elemType in makeDummyVectorMF";
@@ -508,7 +510,7 @@ abstract class AbstractSpecies<E> extends VectorSupport.VectorSpecies<E>
     }
 
     AbstractMask<E> opm(FOpm f) {
-        VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(boolean.class, laneCount);
+        VectorPayloadMF payload = VectorPayloadMF.newMaskInstanceFactory(elementType(), laneCount, is_max_species());
         payload = Unsafe.getUnsafe().makePrivateBuffer(payload);
         long mOffset = payload.multiFieldOffset();
         for (int i = 0; i < laneCount; i++) {
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte128Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte128Vector.java
index 2b686f57c8e..3eb060b63be 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte128Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte128Vector.java
@@ -69,8 +69,8 @@ value class Byte128Vector extends ByteVector {
         return payload;
     }
 
-    static final Byte128Vector ZERO = new Byte128Vector(VectorPayloadMF.newInstanceFactory(byte.class, 16));
-    static final Byte128Vector IOTA = new Byte128Vector(VectorPayloadMF.createVectPayloadInstanceB(16, (byte[])(VSPECIES.iotaArray())));
+    static final Byte128Vector ZERO = new Byte128Vector(VectorPayloadMF.newVectorInstanceFactory(byte.class, 16, ((AbstractSpecies)VSPECIES).is_max_species()));
+    static final Byte128Vector IOTA = new Byte128Vector(VectorPayloadMF.createVectPayloadInstanceB(16, (byte[])(VSPECIES.iotaArray()), ((AbstractSpecies)VSPECIES).is_max_species()));
 
     static {
         // Warm up a few species caches.
@@ -588,16 +588,17 @@ value class Byte128Vector extends ByteVector {
 
         private final VectorPayloadMF128Z payload;
 
+
         Byte128Mask(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF128Z) payload;
         }
 
         Byte128Mask(VectorPayloadMF payload, int offset) {
-            this(prepare(payload, offset, VLENGTH));
+            this(prepare(payload, offset, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         Byte128Mask(boolean val) {
-            this(prepare(val, VLENGTH));
+            this(prepare(val, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -761,6 +762,7 @@ value class Byte128Vector extends ByteVector {
 
         private final VectorPayloadMF128B payload;
 
+
         Byte128Shuffle(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF128B) payload;
             assert(VLENGTH == payload.length());
@@ -772,11 +774,11 @@ value class Byte128Vector extends ByteVector {
         }
 
         public Byte128Shuffle(int[] indexes, int i) {
-            this(prepare(VLENGTH, indexes, i));
+            this(prepare(ETYPE, VLENGTH, indexes, i, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         public Byte128Shuffle(IntUnaryOperator fn) {
-            this(prepare(VLENGTH, fn));
+            this(prepare(ETYPE, VLENGTH, fn, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -821,7 +823,7 @@ value class Byte128Vector extends ByteVector {
             Byte128Shuffle s = (Byte128Shuffle) shuffle;
             VectorPayloadMF indices1 = indices();
             VectorPayloadMF indices2 = s.indices();
-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);
+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, ((AbstractSpecies)VSPECIES).is_max_species());
             r = Unsafe.getUnsafe().makePrivateBuffer(r);
             long offset = r.multiFieldOffset();
             for (int i = 0; i < VLENGTH; i++) {
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte256Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte256Vector.java
index 2069f06e11e..7fca391633a 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte256Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte256Vector.java
@@ -69,8 +69,8 @@ value class Byte256Vector extends ByteVector {
         return payload;
     }
 
-    static final Byte256Vector ZERO = new Byte256Vector(VectorPayloadMF.newInstanceFactory(byte.class, 32));
-    static final Byte256Vector IOTA = new Byte256Vector(VectorPayloadMF.createVectPayloadInstanceB(32, (byte[])(VSPECIES.iotaArray())));
+    static final Byte256Vector ZERO = new Byte256Vector(VectorPayloadMF.newVectorInstanceFactory(byte.class, 32, ((AbstractSpecies)VSPECIES).is_max_species()));
+    static final Byte256Vector IOTA = new Byte256Vector(VectorPayloadMF.createVectPayloadInstanceB(32, (byte[])(VSPECIES.iotaArray()), ((AbstractSpecies)VSPECIES).is_max_species()));
 
     static {
         // Warm up a few species caches.
@@ -620,16 +620,17 @@ value class Byte256Vector extends ByteVector {
 
         private final VectorPayloadMF256Z payload;
 
+
         Byte256Mask(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF256Z) payload;
         }
 
         Byte256Mask(VectorPayloadMF payload, int offset) {
-            this(prepare(payload, offset, VLENGTH));
+            this(prepare(payload, offset, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         Byte256Mask(boolean val) {
-            this(prepare(val, VLENGTH));
+            this(prepare(val, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -793,6 +794,7 @@ value class Byte256Vector extends ByteVector {
 
         private final VectorPayloadMF256B payload;
 
+
         Byte256Shuffle(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF256B) payload;
             assert(VLENGTH == payload.length());
@@ -804,11 +806,11 @@ value class Byte256Vector extends ByteVector {
         }
 
         public Byte256Shuffle(int[] indexes, int i) {
-            this(prepare(VLENGTH, indexes, i));
+            this(prepare(ETYPE, VLENGTH, indexes, i, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         public Byte256Shuffle(IntUnaryOperator fn) {
-            this(prepare(VLENGTH, fn));
+            this(prepare(ETYPE, VLENGTH, fn, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -853,7 +855,7 @@ value class Byte256Vector extends ByteVector {
             Byte256Shuffle s = (Byte256Shuffle) shuffle;
             VectorPayloadMF indices1 = indices();
             VectorPayloadMF indices2 = s.indices();
-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);
+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, ((AbstractSpecies)VSPECIES).is_max_species());
             r = Unsafe.getUnsafe().makePrivateBuffer(r);
             long offset = r.multiFieldOffset();
             for (int i = 0; i < VLENGTH; i++) {
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte512Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte512Vector.java
index 893c8e31f8d..2a7d3d72bd6 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte512Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte512Vector.java
@@ -69,8 +69,8 @@ value class Byte512Vector extends ByteVector {
         return payload;
     }
 
-    static final Byte512Vector ZERO = new Byte512Vector(VectorPayloadMF.newInstanceFactory(byte.class, 64));
-    static final Byte512Vector IOTA = new Byte512Vector(VectorPayloadMF.createVectPayloadInstanceB(64, (byte[])(VSPECIES.iotaArray())));
+    static final Byte512Vector ZERO = new Byte512Vector(VectorPayloadMF.newVectorInstanceFactory(byte.class, 64, ((AbstractSpecies)VSPECIES).is_max_species()));
+    static final Byte512Vector IOTA = new Byte512Vector(VectorPayloadMF.createVectPayloadInstanceB(64, (byte[])(VSPECIES.iotaArray()), ((AbstractSpecies)VSPECIES).is_max_species()));
 
     static {
         // Warm up a few species caches.
@@ -684,16 +684,17 @@ value class Byte512Vector extends ByteVector {
 
         private final VectorPayloadMF512Z payload;
 
+
         Byte512Mask(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF512Z) payload;
         }
 
         Byte512Mask(VectorPayloadMF payload, int offset) {
-            this(prepare(payload, offset, VLENGTH));
+            this(prepare(payload, offset, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         Byte512Mask(boolean val) {
-            this(prepare(val, VLENGTH));
+            this(prepare(val, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -857,6 +858,7 @@ value class Byte512Vector extends ByteVector {
 
         private final VectorPayloadMF512B payload;
 
+
         Byte512Shuffle(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF512B) payload;
             assert(VLENGTH == payload.length());
@@ -868,11 +870,11 @@ value class Byte512Vector extends ByteVector {
         }
 
         public Byte512Shuffle(int[] indexes, int i) {
-            this(prepare(VLENGTH, indexes, i));
+            this(prepare(ETYPE, VLENGTH, indexes, i, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         public Byte512Shuffle(IntUnaryOperator fn) {
-            this(prepare(VLENGTH, fn));
+            this(prepare(ETYPE, VLENGTH, fn, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -917,7 +919,7 @@ value class Byte512Vector extends ByteVector {
             Byte512Shuffle s = (Byte512Shuffle) shuffle;
             VectorPayloadMF indices1 = indices();
             VectorPayloadMF indices2 = s.indices();
-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);
+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, ((AbstractSpecies)VSPECIES).is_max_species());
             r = Unsafe.getUnsafe().makePrivateBuffer(r);
             long offset = r.multiFieldOffset();
             for (int i = 0; i < VLENGTH; i++) {
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte64Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte64Vector.java
index a2b91de9f4f..19bc953117e 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte64Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte64Vector.java
@@ -69,8 +69,8 @@ value class Byte64Vector extends ByteVector {
         return payload;
     }
 
-    static final Byte64Vector ZERO = new Byte64Vector(VectorPayloadMF.newInstanceFactory(byte.class, 8));
-    static final Byte64Vector IOTA = new Byte64Vector(VectorPayloadMF.createVectPayloadInstanceB(8, (byte[])(VSPECIES.iotaArray())));
+    static final Byte64Vector ZERO = new Byte64Vector(VectorPayloadMF.newVectorInstanceFactory(byte.class, 8, ((AbstractSpecies)VSPECIES).is_max_species()));
+    static final Byte64Vector IOTA = new Byte64Vector(VectorPayloadMF.createVectPayloadInstanceB(8, (byte[])(VSPECIES.iotaArray()), ((AbstractSpecies)VSPECIES).is_max_species()));
 
     static {
         // Warm up a few species caches.
@@ -572,16 +572,17 @@ value class Byte64Vector extends ByteVector {
 
         private final VectorPayloadMF64Z payload;
 
+
         Byte64Mask(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF64Z) payload;
         }
 
         Byte64Mask(VectorPayloadMF payload, int offset) {
-            this(prepare(payload, offset, VLENGTH));
+            this(prepare(payload, offset, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         Byte64Mask(boolean val) {
-            this(prepare(val, VLENGTH));
+            this(prepare(val, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -745,6 +746,7 @@ value class Byte64Vector extends ByteVector {
 
         private final VectorPayloadMF64B payload;
 
+
         Byte64Shuffle(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF64B) payload;
             assert(VLENGTH == payload.length());
@@ -756,11 +758,11 @@ value class Byte64Vector extends ByteVector {
         }
 
         public Byte64Shuffle(int[] indexes, int i) {
-            this(prepare(VLENGTH, indexes, i));
+            this(prepare(ETYPE, VLENGTH, indexes, i, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         public Byte64Shuffle(IntUnaryOperator fn) {
-            this(prepare(VLENGTH, fn));
+            this(prepare(ETYPE, VLENGTH, fn, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -805,7 +807,7 @@ value class Byte64Vector extends ByteVector {
             Byte64Shuffle s = (Byte64Shuffle) shuffle;
             VectorPayloadMF indices1 = indices();
             VectorPayloadMF indices2 = s.indices();
-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);
+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, ((AbstractSpecies)VSPECIES).is_max_species());
             r = Unsafe.getUnsafe().makePrivateBuffer(r);
             long offset = r.multiFieldOffset();
             for (int i = 0; i < VLENGTH; i++) {
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ByteVector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ByteVector.java
index 3662bcfbd19..943e65828de 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ByteVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ByteVector.java
@@ -372,9 +372,10 @@ public abstract class ByteVector extends AbstractVector<Byte> {
     <M> ByteVector ldOpMF(M memory, int offset,
                                   FLdOp<M> f) {
         int length = vspecies().length();
+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();
         VectorPayloadMF tpayload =
-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(
-                byte.class, length));
+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(
+                byte.class, length, is_max_species));
         long vOffset = this.multiFieldOffset();
         for (int i = 0; i < length; i++) {
             Unsafe.getUnsafe().putByte(tpayload, vOffset + i * Byte.BYTES, f.apply(memory, offset, i));
@@ -390,9 +391,10 @@ public abstract class ByteVector extends AbstractVector<Byte> {
                                   VectorMask<Byte> m,
                                   FLdOp<M> f) {
         int length = vspecies().length();
+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();
         VectorPayloadMF tpayload =
-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(
-                byte.class, length));
+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(
+                byte.class, length, is_max_species));
         VectorPayloadMF mbits = ((AbstractMask<Byte>)m).getBits();
         long vOffset = this.multiFieldOffset();
         long mOffset = mbits.multiFieldOffset();
@@ -417,9 +419,10 @@ public abstract class ByteVector extends AbstractVector<Byte> {
     ByteVector ldLongOpMF(MemorySegment memory, long offset,
                                   FLdLongOp f) {
         int length = vspecies().length();
+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();
         VectorPayloadMF tpayload =
-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(
-                byte.class, length));
+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(
+                byte.class, length, is_max_species));
         long vOffset = this.multiFieldOffset();
         for (int i = 0; i < length; i++) {
             Unsafe.getUnsafe().putByte(tpayload, vOffset + i * Byte.BYTES, f.apply(memory, offset, i));
@@ -435,9 +438,10 @@ public abstract class ByteVector extends AbstractVector<Byte> {
                                   VectorMask<Byte> m,
                                   FLdLongOp f) {
         int length = vspecies().length();
+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();
         VectorPayloadMF tpayload =
-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(
-                byte.class, length));
+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(
+                byte.class, length, is_max_species));
         VectorPayloadMF mbits = ((AbstractMask<Byte>)m).getBits();
         long vOffset = this.multiFieldOffset();
         long mOffset = mbits.multiFieldOffset();
@@ -543,9 +547,10 @@ public abstract class ByteVector extends AbstractVector<Byte> {
                                   Vector<Byte> o,
                                   FBinTest f) {
         int length = vspecies().length();
+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();
         VectorPayloadMF vec1 = vec();
         VectorPayloadMF vec2 = ((ByteVector)o).vec();
-        VectorPayloadMF mbits = VectorPayloadMF.newInstanceFactory(boolean.class, length);
+        VectorPayloadMF mbits = VectorPayloadMF.newMaskInstanceFactory(vspecies().elementType(), length, is_max_species);
         mbits = Unsafe.getUnsafe().makePrivateBuffer(mbits);
         long vOffset = this.multiFieldOffset();
         long mOffset = mbits.multiFieldOffset();
@@ -4431,9 +4436,8 @@ public abstract class ByteVector extends AbstractVector<Byte> {
         @Override
         @ForceInline
         public final ByteVector zero() {
-            // FIXME: Enable once multi-field based MaxVector is supported.
-            //if ((Class<?>) vectorType() == ByteMaxVector.class)
-            //    return ByteMaxVector.ZERO;
+            if ((Class<?>) vectorType() == ByteMaxVector.class)
+               return ByteMaxVector.ZERO;
             switch (vectorBitSize()) {
                 case 64: return Byte64Vector.ZERO;
                 case 128: return Byte128Vector.ZERO;
@@ -4446,9 +4450,8 @@ public abstract class ByteVector extends AbstractVector<Byte> {
         @Override
         @ForceInline
         public final ByteVector iota() {
-            // FIXME: Enable once multi-field based MaxVector is supported.
-            //if ((Class<?>) vectorType() == ByteMaxVector.class)
-            //    return ByteMaxVector.IOTA;
+            if ((Class<?>) vectorType() == ByteMaxVector.class)
+                return ByteMaxVector.IOTA;
             switch (vectorBitSize()) {
                 case 64: return Byte64Vector.IOTA;
                 case 128: return Byte128Vector.IOTA;
@@ -4462,9 +4465,8 @@ public abstract class ByteVector extends AbstractVector<Byte> {
         @Override
         @ForceInline
         public final VectorMask<Byte> maskAll(boolean bit) {
-            // FIXME: Enable once multi-field based MaxVector is supported.
-            //if ((Class<?>) vectorType() == ByteMaxVector.class)
-            //    return ByteMaxVector.ByteMaxMask.maskAll(bit);
+            if ((Class<?>) vectorType() == ByteMaxVector.class)
+                return ByteMaxVector.ByteMaxMask.maskAll(bit);
             switch (vectorBitSize()) {
                 case 64: return Byte64Vector.Byte64Mask.maskAll(bit);
                 case 128: return Byte128Vector.Byte128Mask.maskAll(bit);
@@ -4499,8 +4501,7 @@ public abstract class ByteVector extends AbstractVector<Byte> {
             case VectorShape.SK_128_BIT: return (ByteSpecies) SPECIES_128;
             case VectorShape.SK_256_BIT: return (ByteSpecies) SPECIES_256;
             case VectorShape.SK_512_BIT: return (ByteSpecies) SPECIES_512;
-            // FIXME: Enable once multi-field based MaxVector is supported.
-            //case VectorShape.SK_Max_BIT: return (ByteSpecies) SPECIES_MAX;
+            case VectorShape.SK_Max_BIT: return (ByteSpecies) SPECIES_MAX;
             default: throw new IllegalArgumentException("Bad shape: " + s);
         }
     }
@@ -4534,13 +4535,11 @@ public abstract class ByteVector extends AbstractVector<Byte> {
                             Byte512Vector::new);
 
     /** Species representing {@link ByteVector}s of {@link VectorShape#S_Max_BIT VectorShape.S_Max_BIT}. */
-    // FIXME: Enable once multi-field based MaxVector is supported.
-    /*public static final VectorSpecies<Byte> SPECIES_MAX
+    public static final VectorSpecies<Byte> SPECIES_MAX
         = new ByteSpecies(VectorShape.S_Max_BIT,
                             ByteMaxVector.class,
                             ByteMaxVector.ByteMaxMask.class,
                             ByteMaxVector::new);
-     */
 
     /**
      * Preferred species for {@link ByteVector}s.
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double128Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double128Vector.java
index 39fec22c277..6aa58e088a1 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double128Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double128Vector.java
@@ -69,8 +69,8 @@ value class Double128Vector extends DoubleVector {
         return payload;
     }
 
-    static final Double128Vector ZERO = new Double128Vector(VectorPayloadMF.newInstanceFactory(double.class, 2));
-    static final Double128Vector IOTA = new Double128Vector(VectorPayloadMF.createVectPayloadInstanceD(2, (double[])(VSPECIES.iotaArray())));
+    static final Double128Vector ZERO = new Double128Vector(VectorPayloadMF.newVectorInstanceFactory(double.class, 2, ((AbstractSpecies)VSPECIES).is_max_species()));
+    static final Double128Vector IOTA = new Double128Vector(VectorPayloadMF.createVectPayloadInstanceD(2, (double[])(VSPECIES.iotaArray()), ((AbstractSpecies)VSPECIES).is_max_species()));
 
     static {
         // Warm up a few species caches.
@@ -549,16 +549,17 @@ value class Double128Vector extends DoubleVector {
 
         private final VectorPayloadMF16Z payload;
 
+
         Double128Mask(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF16Z) payload;
         }
 
         Double128Mask(VectorPayloadMF payload, int offset) {
-            this(prepare(payload, offset, VLENGTH));
+            this(prepare(payload, offset, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         Double128Mask(boolean val) {
-            this(prepare(val, VLENGTH));
+            this(prepare(val, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -722,6 +723,7 @@ value class Double128Vector extends DoubleVector {
 
         private final VectorPayloadMF16B payload;
 
+
         Double128Shuffle(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF16B) payload;
             assert(VLENGTH == payload.length());
@@ -733,11 +735,11 @@ value class Double128Vector extends DoubleVector {
         }
 
         public Double128Shuffle(int[] indexes, int i) {
-            this(prepare(VLENGTH, indexes, i));
+            this(prepare(ETYPE, VLENGTH, indexes, i, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         public Double128Shuffle(IntUnaryOperator fn) {
-            this(prepare(VLENGTH, fn));
+            this(prepare(ETYPE, VLENGTH, fn, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -782,7 +784,7 @@ value class Double128Vector extends DoubleVector {
             Double128Shuffle s = (Double128Shuffle) shuffle;
             VectorPayloadMF indices1 = indices();
             VectorPayloadMF indices2 = s.indices();
-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);
+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, ((AbstractSpecies)VSPECIES).is_max_species());
             r = Unsafe.getUnsafe().makePrivateBuffer(r);
             long offset = r.multiFieldOffset();
             for (int i = 0; i < VLENGTH; i++) {
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double256Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double256Vector.java
index f62b6aae50f..959c8e14cfa 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double256Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double256Vector.java
@@ -69,8 +69,8 @@ value class Double256Vector extends DoubleVector {
         return payload;
     }
 
-    static final Double256Vector ZERO = new Double256Vector(VectorPayloadMF.newInstanceFactory(double.class, 4));
-    static final Double256Vector IOTA = new Double256Vector(VectorPayloadMF.createVectPayloadInstanceD(4, (double[])(VSPECIES.iotaArray())));
+    static final Double256Vector ZERO = new Double256Vector(VectorPayloadMF.newVectorInstanceFactory(double.class, 4, ((AbstractSpecies)VSPECIES).is_max_species()));
+    static final Double256Vector IOTA = new Double256Vector(VectorPayloadMF.createVectPayloadInstanceD(4, (double[])(VSPECIES.iotaArray()), ((AbstractSpecies)VSPECIES).is_max_species()));
 
     static {
         // Warm up a few species caches.
@@ -553,16 +553,17 @@ value class Double256Vector extends DoubleVector {
 
         private final VectorPayloadMF32Z payload;
 
+
         Double256Mask(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF32Z) payload;
         }
 
         Double256Mask(VectorPayloadMF payload, int offset) {
-            this(prepare(payload, offset, VLENGTH));
+            this(prepare(payload, offset, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         Double256Mask(boolean val) {
-            this(prepare(val, VLENGTH));
+            this(prepare(val, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -726,6 +727,7 @@ value class Double256Vector extends DoubleVector {
 
         private final VectorPayloadMF32B payload;
 
+
         Double256Shuffle(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF32B) payload;
             assert(VLENGTH == payload.length());
@@ -737,11 +739,11 @@ value class Double256Vector extends DoubleVector {
         }
 
         public Double256Shuffle(int[] indexes, int i) {
-            this(prepare(VLENGTH, indexes, i));
+            this(prepare(ETYPE, VLENGTH, indexes, i, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         public Double256Shuffle(IntUnaryOperator fn) {
-            this(prepare(VLENGTH, fn));
+            this(prepare(ETYPE, VLENGTH, fn, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -786,7 +788,7 @@ value class Double256Vector extends DoubleVector {
             Double256Shuffle s = (Double256Shuffle) shuffle;
             VectorPayloadMF indices1 = indices();
             VectorPayloadMF indices2 = s.indices();
-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);
+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, ((AbstractSpecies)VSPECIES).is_max_species());
             r = Unsafe.getUnsafe().makePrivateBuffer(r);
             long offset = r.multiFieldOffset();
             for (int i = 0; i < VLENGTH; i++) {
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double512Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double512Vector.java
index f146ec91c59..ccd643f85b5 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double512Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double512Vector.java
@@ -69,8 +69,8 @@ value class Double512Vector extends DoubleVector {
         return payload;
     }
 
-    static final Double512Vector ZERO = new Double512Vector(VectorPayloadMF.newInstanceFactory(double.class, 8));
-    static final Double512Vector IOTA = new Double512Vector(VectorPayloadMF.createVectPayloadInstanceD(8, (double[])(VSPECIES.iotaArray())));
+    static final Double512Vector ZERO = new Double512Vector(VectorPayloadMF.newVectorInstanceFactory(double.class, 8, ((AbstractSpecies)VSPECIES).is_max_species()));
+    static final Double512Vector IOTA = new Double512Vector(VectorPayloadMF.createVectPayloadInstanceD(8, (double[])(VSPECIES.iotaArray()), ((AbstractSpecies)VSPECIES).is_max_species()));
 
     static {
         // Warm up a few species caches.
@@ -561,16 +561,17 @@ value class Double512Vector extends DoubleVector {
 
         private final VectorPayloadMF64Z payload;
 
+
         Double512Mask(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF64Z) payload;
         }
 
         Double512Mask(VectorPayloadMF payload, int offset) {
-            this(prepare(payload, offset, VLENGTH));
+            this(prepare(payload, offset, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         Double512Mask(boolean val) {
-            this(prepare(val, VLENGTH));
+            this(prepare(val, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -734,6 +735,7 @@ value class Double512Vector extends DoubleVector {
 
         private final VectorPayloadMF64B payload;
 
+
         Double512Shuffle(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF64B) payload;
             assert(VLENGTH == payload.length());
@@ -745,11 +747,11 @@ value class Double512Vector extends DoubleVector {
         }
 
         public Double512Shuffle(int[] indexes, int i) {
-            this(prepare(VLENGTH, indexes, i));
+            this(prepare(ETYPE, VLENGTH, indexes, i, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         public Double512Shuffle(IntUnaryOperator fn) {
-            this(prepare(VLENGTH, fn));
+            this(prepare(ETYPE, VLENGTH, fn, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -794,7 +796,7 @@ value class Double512Vector extends DoubleVector {
             Double512Shuffle s = (Double512Shuffle) shuffle;
             VectorPayloadMF indices1 = indices();
             VectorPayloadMF indices2 = s.indices();
-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);
+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, ((AbstractSpecies)VSPECIES).is_max_species());
             r = Unsafe.getUnsafe().makePrivateBuffer(r);
             long offset = r.multiFieldOffset();
             for (int i = 0; i < VLENGTH; i++) {
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double64Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double64Vector.java
index eb33cd677f8..75e92d8faec 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double64Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double64Vector.java
@@ -69,8 +69,8 @@ value class Double64Vector extends DoubleVector {
         return payload;
     }
 
-    static final Double64Vector ZERO = new Double64Vector(VectorPayloadMF.newInstanceFactory(double.class, 1));
-    static final Double64Vector IOTA = new Double64Vector(VectorPayloadMF.createVectPayloadInstanceD(1, (double[])(VSPECIES.iotaArray())));
+    static final Double64Vector ZERO = new Double64Vector(VectorPayloadMF.newVectorInstanceFactory(double.class, 1, ((AbstractSpecies)VSPECIES).is_max_species()));
+    static final Double64Vector IOTA = new Double64Vector(VectorPayloadMF.createVectPayloadInstanceD(1, (double[])(VSPECIES.iotaArray()), ((AbstractSpecies)VSPECIES).is_max_species()));
 
     static {
         // Warm up a few species caches.
@@ -547,16 +547,17 @@ value class Double64Vector extends DoubleVector {
 
         private final VectorPayloadMF8Z payload;
 
+
         Double64Mask(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF8Z) payload;
         }
 
         Double64Mask(VectorPayloadMF payload, int offset) {
-            this(prepare(payload, offset, VLENGTH));
+            this(prepare(payload, offset, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         Double64Mask(boolean val) {
-            this(prepare(val, VLENGTH));
+            this(prepare(val, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -720,6 +721,7 @@ value class Double64Vector extends DoubleVector {
 
         private final VectorPayloadMF8B payload;
 
+
         Double64Shuffle(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF8B) payload;
             assert(VLENGTH == payload.length());
@@ -731,11 +733,11 @@ value class Double64Vector extends DoubleVector {
         }
 
         public Double64Shuffle(int[] indexes, int i) {
-            this(prepare(VLENGTH, indexes, i));
+            this(prepare(ETYPE, VLENGTH, indexes, i, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         public Double64Shuffle(IntUnaryOperator fn) {
-            this(prepare(VLENGTH, fn));
+            this(prepare(ETYPE, VLENGTH, fn, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -780,7 +782,7 @@ value class Double64Vector extends DoubleVector {
             Double64Shuffle s = (Double64Shuffle) shuffle;
             VectorPayloadMF indices1 = indices();
             VectorPayloadMF indices2 = s.indices();
-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);
+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, ((AbstractSpecies)VSPECIES).is_max_species());
             r = Unsafe.getUnsafe().makePrivateBuffer(r);
             long offset = r.multiFieldOffset();
             for (int i = 0; i < VLENGTH; i++) {
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/DoubleVector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/DoubleVector.java
index 1c6829426f5..d4e1578a3b3 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/DoubleVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/DoubleVector.java
@@ -372,9 +372,10 @@ public abstract class DoubleVector extends AbstractVector<Double> {
     <M> DoubleVector ldOpMF(M memory, int offset,
                                   FLdOp<M> f) {
         int length = vspecies().length();
+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();
         VectorPayloadMF tpayload =
-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(
-                double.class, length));
+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(
+                double.class, length, is_max_species));
         long vOffset = this.multiFieldOffset();
         for (int i = 0; i < length; i++) {
             Unsafe.getUnsafe().putDouble(tpayload, vOffset + i * Double.BYTES, f.apply(memory, offset, i));
@@ -390,9 +391,10 @@ public abstract class DoubleVector extends AbstractVector<Double> {
                                   VectorMask<Double> m,
                                   FLdOp<M> f) {
         int length = vspecies().length();
+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();
         VectorPayloadMF tpayload =
-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(
-                double.class, length));
+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(
+                double.class, length, is_max_species));
         VectorPayloadMF mbits = ((AbstractMask<Double>)m).getBits();
         long vOffset = this.multiFieldOffset();
         long mOffset = mbits.multiFieldOffset();
@@ -417,9 +419,10 @@ public abstract class DoubleVector extends AbstractVector<Double> {
     DoubleVector ldLongOpMF(MemorySegment memory, long offset,
                                   FLdLongOp f) {
         int length = vspecies().length();
+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();
         VectorPayloadMF tpayload =
-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(
-                double.class, length));
+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(
+                double.class, length, is_max_species));
         long vOffset = this.multiFieldOffset();
         for (int i = 0; i < length; i++) {
             Unsafe.getUnsafe().putDouble(tpayload, vOffset + i * Double.BYTES, f.apply(memory, offset, i));
@@ -435,9 +438,10 @@ public abstract class DoubleVector extends AbstractVector<Double> {
                                   VectorMask<Double> m,
                                   FLdLongOp f) {
         int length = vspecies().length();
+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();
         VectorPayloadMF tpayload =
-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(
-                double.class, length));
+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(
+                double.class, length, is_max_species));
         VectorPayloadMF mbits = ((AbstractMask<Double>)m).getBits();
         long vOffset = this.multiFieldOffset();
         long mOffset = mbits.multiFieldOffset();
@@ -543,9 +547,10 @@ public abstract class DoubleVector extends AbstractVector<Double> {
                                   Vector<Double> o,
                                   FBinTest f) {
         int length = vspecies().length();
+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();
         VectorPayloadMF vec1 = vec();
         VectorPayloadMF vec2 = ((DoubleVector)o).vec();
-        VectorPayloadMF mbits = VectorPayloadMF.newInstanceFactory(boolean.class, length);
+        VectorPayloadMF mbits = VectorPayloadMF.newMaskInstanceFactory(vspecies().elementType(), length, is_max_species);
         mbits = Unsafe.getUnsafe().makePrivateBuffer(mbits);
         long vOffset = this.multiFieldOffset();
         long mOffset = mbits.multiFieldOffset();
@@ -2973,11 +2978,9 @@ public abstract class DoubleVector extends AbstractVector<Double> {
             // indexShape is still S_MAX_BIT, but the lane count of int vector
             // is 64. So when loading index vector (IntVector), only lower half
             // of index data is needed.
-            /*vix = IntVector
+            vix = IntVector
                 .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)
                 .add(offset);
-             */
-             assert false : "Unhandled case for Multi-field based MaxVector";
         } else {
             vix = IntVector
                 .fromArray(isp, indexMap, mapOffset)
@@ -3268,11 +3271,9 @@ public abstract class DoubleVector extends AbstractVector<Double> {
             // indexShape is still S_MAX_BIT, but the lane count of int vector
             // is 64. So when loading index vector (IntVector), only lower half
             // of index data is needed.
-            /*vix = IntVector
+            vix = IntVector
                 .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)
                 .add(offset);
-             */
-             assert false : "Unhandled case for Multi-field based MaxVector";
         } else {
             vix = IntVector
                 .fromArray(isp, indexMap, mapOffset)
@@ -3464,11 +3465,9 @@ public abstract class DoubleVector extends AbstractVector<Double> {
             // indexShape is still S_MAX_BIT, but the lane count of int vector
             // is 64. So when loading index vector (IntVector), only lower half
             // of index data is needed.
-            /*vix = IntVector
+            vix = IntVector
                 .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)
                 .add(offset);
-             */
-            assert false : "Unhandled case for Multi-field based MaxVector";
         } else {
             vix = IntVector
                 .fromArray(isp, indexMap, mapOffset)
@@ -3581,12 +3580,9 @@ public abstract class DoubleVector extends AbstractVector<Double> {
             // indexShape is still S_MAX_BIT, but the lane count of int vector
             // is 64. So when loading index vector (IntVector), only lower half
             // of index data is needed.
-            /*vix = IntVector
+            vix = IntVector
                 .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)
                 .add(offset);
-             */
-             assert false : "Unhandled case for Multi-field based MaxVector";
-
         } else {
             vix = IntVector
                 .fromArray(isp, indexMap, mapOffset)
@@ -4035,9 +4031,8 @@ public abstract class DoubleVector extends AbstractVector<Double> {
         @Override
         @ForceInline
         public final DoubleVector zero() {
-            // FIXME: Enable once multi-field based MaxVector is supported.
-            //if ((Class<?>) vectorType() == DoubleMaxVector.class)
-            //    return DoubleMaxVector.ZERO;
+            if ((Class<?>) vectorType() == DoubleMaxVector.class)
+               return DoubleMaxVector.ZERO;
             switch (vectorBitSize()) {
                 case 64: return Double64Vector.ZERO;
                 case 128: return Double128Vector.ZERO;
@@ -4050,9 +4045,8 @@ public abstract class DoubleVector extends AbstractVector<Double> {
         @Override
         @ForceInline
         public final DoubleVector iota() {
-            // FIXME: Enable once multi-field based MaxVector is supported.
-            //if ((Class<?>) vectorType() == DoubleMaxVector.class)
-            //    return DoubleMaxVector.IOTA;
+            if ((Class<?>) vectorType() == DoubleMaxVector.class)
+                return DoubleMaxVector.IOTA;
             switch (vectorBitSize()) {
                 case 64: return Double64Vector.IOTA;
                 case 128: return Double128Vector.IOTA;
@@ -4066,9 +4060,8 @@ public abstract class DoubleVector extends AbstractVector<Double> {
         @Override
         @ForceInline
         public final VectorMask<Double> maskAll(boolean bit) {
-            // FIXME: Enable once multi-field based MaxVector is supported.
-            //if ((Class<?>) vectorType() == DoubleMaxVector.class)
-            //    return DoubleMaxVector.DoubleMaxMask.maskAll(bit);
+            if ((Class<?>) vectorType() == DoubleMaxVector.class)
+                return DoubleMaxVector.DoubleMaxMask.maskAll(bit);
             switch (vectorBitSize()) {
                 case 64: return Double64Vector.Double64Mask.maskAll(bit);
                 case 128: return Double128Vector.Double128Mask.maskAll(bit);
@@ -4103,8 +4096,7 @@ public abstract class DoubleVector extends AbstractVector<Double> {
             case VectorShape.SK_128_BIT: return (DoubleSpecies) SPECIES_128;
             case VectorShape.SK_256_BIT: return (DoubleSpecies) SPECIES_256;
             case VectorShape.SK_512_BIT: return (DoubleSpecies) SPECIES_512;
-            // FIXME: Enable once multi-field based MaxVector is supported.
-            //case VectorShape.SK_Max_BIT: return (DoubleSpecies) SPECIES_MAX;
+            case VectorShape.SK_Max_BIT: return (DoubleSpecies) SPECIES_MAX;
             default: throw new IllegalArgumentException("Bad shape: " + s);
         }
     }
@@ -4138,13 +4130,11 @@ public abstract class DoubleVector extends AbstractVector<Double> {
                             Double512Vector::new);
 
     /** Species representing {@link DoubleVector}s of {@link VectorShape#S_Max_BIT VectorShape.S_Max_BIT}. */
-    // FIXME: Enable once multi-field based MaxVector is supported.
-    /*public static final VectorSpecies<Double> SPECIES_MAX
+    public static final VectorSpecies<Double> SPECIES_MAX
         = new DoubleSpecies(VectorShape.S_Max_BIT,
                             DoubleMaxVector.class,
                             DoubleMaxVector.DoubleMaxMask.class,
                             DoubleMaxVector::new);
-     */
 
     /**
      * Preferred species for {@link DoubleVector}s.
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float128Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float128Vector.java
index baec930570a..4d7b08cfd32 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float128Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float128Vector.java
@@ -69,8 +69,8 @@ value class Float128Vector extends FloatVector {
         return payload;
     }
 
-    static final Float128Vector ZERO = new Float128Vector(VectorPayloadMF.newInstanceFactory(float.class, 4));
-    static final Float128Vector IOTA = new Float128Vector(VectorPayloadMF.createVectPayloadInstanceF(4, (float[])(VSPECIES.iotaArray())));
+    static final Float128Vector ZERO = new Float128Vector(VectorPayloadMF.newVectorInstanceFactory(float.class, 4, ((AbstractSpecies)VSPECIES).is_max_species()));
+    static final Float128Vector IOTA = new Float128Vector(VectorPayloadMF.createVectPayloadInstanceF(4, (float[])(VSPECIES.iotaArray()), ((AbstractSpecies)VSPECIES).is_max_species()));
 
     static {
         // Warm up a few species caches.
@@ -553,16 +553,17 @@ value class Float128Vector extends FloatVector {
 
         private final VectorPayloadMF32Z payload;
 
+
         Float128Mask(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF32Z) payload;
         }
 
         Float128Mask(VectorPayloadMF payload, int offset) {
-            this(prepare(payload, offset, VLENGTH));
+            this(prepare(payload, offset, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         Float128Mask(boolean val) {
-            this(prepare(val, VLENGTH));
+            this(prepare(val, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -726,6 +727,7 @@ value class Float128Vector extends FloatVector {
 
         private final VectorPayloadMF32B payload;
 
+
         Float128Shuffle(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF32B) payload;
             assert(VLENGTH == payload.length());
@@ -737,11 +739,11 @@ value class Float128Vector extends FloatVector {
         }
 
         public Float128Shuffle(int[] indexes, int i) {
-            this(prepare(VLENGTH, indexes, i));
+            this(prepare(ETYPE, VLENGTH, indexes, i, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         public Float128Shuffle(IntUnaryOperator fn) {
-            this(prepare(VLENGTH, fn));
+            this(prepare(ETYPE, VLENGTH, fn, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -786,7 +788,7 @@ value class Float128Vector extends FloatVector {
             Float128Shuffle s = (Float128Shuffle) shuffle;
             VectorPayloadMF indices1 = indices();
             VectorPayloadMF indices2 = s.indices();
-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);
+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, ((AbstractSpecies)VSPECIES).is_max_species());
             r = Unsafe.getUnsafe().makePrivateBuffer(r);
             long offset = r.multiFieldOffset();
             for (int i = 0; i < VLENGTH; i++) {
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float256Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float256Vector.java
index deccc6158fd..de1a0d30816 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float256Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float256Vector.java
@@ -69,8 +69,8 @@ value class Float256Vector extends FloatVector {
         return payload;
     }
 
-    static final Float256Vector ZERO = new Float256Vector(VectorPayloadMF.newInstanceFactory(float.class, 8));
-    static final Float256Vector IOTA = new Float256Vector(VectorPayloadMF.createVectPayloadInstanceF(8, (float[])(VSPECIES.iotaArray())));
+    static final Float256Vector ZERO = new Float256Vector(VectorPayloadMF.newVectorInstanceFactory(float.class, 8, ((AbstractSpecies)VSPECIES).is_max_species()));
+    static final Float256Vector IOTA = new Float256Vector(VectorPayloadMF.createVectPayloadInstanceF(8, (float[])(VSPECIES.iotaArray()), ((AbstractSpecies)VSPECIES).is_max_species()));
 
     static {
         // Warm up a few species caches.
@@ -561,16 +561,17 @@ value class Float256Vector extends FloatVector {
 
         private final VectorPayloadMF64Z payload;
 
+
         Float256Mask(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF64Z) payload;
         }
 
         Float256Mask(VectorPayloadMF payload, int offset) {
-            this(prepare(payload, offset, VLENGTH));
+            this(prepare(payload, offset, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         Float256Mask(boolean val) {
-            this(prepare(val, VLENGTH));
+            this(prepare(val, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -734,6 +735,7 @@ value class Float256Vector extends FloatVector {
 
         private final VectorPayloadMF64B payload;
 
+
         Float256Shuffle(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF64B) payload;
             assert(VLENGTH == payload.length());
@@ -745,11 +747,11 @@ value class Float256Vector extends FloatVector {
         }
 
         public Float256Shuffle(int[] indexes, int i) {
-            this(prepare(VLENGTH, indexes, i));
+            this(prepare(ETYPE, VLENGTH, indexes, i, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         public Float256Shuffle(IntUnaryOperator fn) {
-            this(prepare(VLENGTH, fn));
+            this(prepare(ETYPE, VLENGTH, fn, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -794,7 +796,7 @@ value class Float256Vector extends FloatVector {
             Float256Shuffle s = (Float256Shuffle) shuffle;
             VectorPayloadMF indices1 = indices();
             VectorPayloadMF indices2 = s.indices();
-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);
+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, ((AbstractSpecies)VSPECIES).is_max_species());
             r = Unsafe.getUnsafe().makePrivateBuffer(r);
             long offset = r.multiFieldOffset();
             for (int i = 0; i < VLENGTH; i++) {
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float512Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float512Vector.java
index 0d8d1b765bd..8429f1d08a3 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float512Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float512Vector.java
@@ -69,8 +69,8 @@ value class Float512Vector extends FloatVector {
         return payload;
     }
 
-    static final Float512Vector ZERO = new Float512Vector(VectorPayloadMF.newInstanceFactory(float.class, 16));
-    static final Float512Vector IOTA = new Float512Vector(VectorPayloadMF.createVectPayloadInstanceF(16, (float[])(VSPECIES.iotaArray())));
+    static final Float512Vector ZERO = new Float512Vector(VectorPayloadMF.newVectorInstanceFactory(float.class, 16, ((AbstractSpecies)VSPECIES).is_max_species()));
+    static final Float512Vector IOTA = new Float512Vector(VectorPayloadMF.createVectPayloadInstanceF(16, (float[])(VSPECIES.iotaArray()), ((AbstractSpecies)VSPECIES).is_max_species()));
 
     static {
         // Warm up a few species caches.
@@ -577,16 +577,17 @@ value class Float512Vector extends FloatVector {
 
         private final VectorPayloadMF128Z payload;
 
+
         Float512Mask(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF128Z) payload;
         }
 
         Float512Mask(VectorPayloadMF payload, int offset) {
-            this(prepare(payload, offset, VLENGTH));
+            this(prepare(payload, offset, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         Float512Mask(boolean val) {
-            this(prepare(val, VLENGTH));
+            this(prepare(val, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -750,6 +751,7 @@ value class Float512Vector extends FloatVector {
 
         private final VectorPayloadMF128B payload;
 
+
         Float512Shuffle(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF128B) payload;
             assert(VLENGTH == payload.length());
@@ -761,11 +763,11 @@ value class Float512Vector extends FloatVector {
         }
 
         public Float512Shuffle(int[] indexes, int i) {
-            this(prepare(VLENGTH, indexes, i));
+            this(prepare(ETYPE, VLENGTH, indexes, i, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         public Float512Shuffle(IntUnaryOperator fn) {
-            this(prepare(VLENGTH, fn));
+            this(prepare(ETYPE, VLENGTH, fn, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -810,7 +812,7 @@ value class Float512Vector extends FloatVector {
             Float512Shuffle s = (Float512Shuffle) shuffle;
             VectorPayloadMF indices1 = indices();
             VectorPayloadMF indices2 = s.indices();
-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);
+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, ((AbstractSpecies)VSPECIES).is_max_species());
             r = Unsafe.getUnsafe().makePrivateBuffer(r);
             long offset = r.multiFieldOffset();
             for (int i = 0; i < VLENGTH; i++) {
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float64Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float64Vector.java
index 9eed57674ad..c71ed3d1e58 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float64Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float64Vector.java
@@ -69,8 +69,8 @@ value class Float64Vector extends FloatVector {
         return payload;
     }
 
-    static final Float64Vector ZERO = new Float64Vector(VectorPayloadMF.newInstanceFactory(float.class, 2));
-    static final Float64Vector IOTA = new Float64Vector(VectorPayloadMF.createVectPayloadInstanceF(2, (float[])(VSPECIES.iotaArray())));
+    static final Float64Vector ZERO = new Float64Vector(VectorPayloadMF.newVectorInstanceFactory(float.class, 2, ((AbstractSpecies)VSPECIES).is_max_species()));
+    static final Float64Vector IOTA = new Float64Vector(VectorPayloadMF.createVectPayloadInstanceF(2, (float[])(VSPECIES.iotaArray()), ((AbstractSpecies)VSPECIES).is_max_species()));
 
     static {
         // Warm up a few species caches.
@@ -549,16 +549,17 @@ value class Float64Vector extends FloatVector {
 
         private final VectorPayloadMF16Z payload;
 
+
         Float64Mask(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF16Z) payload;
         }
 
         Float64Mask(VectorPayloadMF payload, int offset) {
-            this(prepare(payload, offset, VLENGTH));
+            this(prepare(payload, offset, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         Float64Mask(boolean val) {
-            this(prepare(val, VLENGTH));
+            this(prepare(val, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -722,6 +723,7 @@ value class Float64Vector extends FloatVector {
 
         private final VectorPayloadMF16B payload;
 
+
         Float64Shuffle(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF16B) payload;
             assert(VLENGTH == payload.length());
@@ -733,11 +735,11 @@ value class Float64Vector extends FloatVector {
         }
 
         public Float64Shuffle(int[] indexes, int i) {
-            this(prepare(VLENGTH, indexes, i));
+            this(prepare(ETYPE, VLENGTH, indexes, i, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         public Float64Shuffle(IntUnaryOperator fn) {
-            this(prepare(VLENGTH, fn));
+            this(prepare(ETYPE, VLENGTH, fn, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -782,7 +784,7 @@ value class Float64Vector extends FloatVector {
             Float64Shuffle s = (Float64Shuffle) shuffle;
             VectorPayloadMF indices1 = indices();
             VectorPayloadMF indices2 = s.indices();
-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);
+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, ((AbstractSpecies)VSPECIES).is_max_species());
             r = Unsafe.getUnsafe().makePrivateBuffer(r);
             long offset = r.multiFieldOffset();
             for (int i = 0; i < VLENGTH; i++) {
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/FloatVector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/FloatVector.java
index 4013428ff1a..1110cf4cf01 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/FloatVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/FloatVector.java
@@ -372,9 +372,10 @@ public abstract class FloatVector extends AbstractVector<Float> {
     <M> FloatVector ldOpMF(M memory, int offset,
                                   FLdOp<M> f) {
         int length = vspecies().length();
+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();
         VectorPayloadMF tpayload =
-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(
-                float.class, length));
+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(
+                float.class, length, is_max_species));
         long vOffset = this.multiFieldOffset();
         for (int i = 0; i < length; i++) {
             Unsafe.getUnsafe().putFloat(tpayload, vOffset + i * Float.BYTES, f.apply(memory, offset, i));
@@ -390,9 +391,10 @@ public abstract class FloatVector extends AbstractVector<Float> {
                                   VectorMask<Float> m,
                                   FLdOp<M> f) {
         int length = vspecies().length();
+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();
         VectorPayloadMF tpayload =
-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(
-                float.class, length));
+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(
+                float.class, length, is_max_species));
         VectorPayloadMF mbits = ((AbstractMask<Float>)m).getBits();
         long vOffset = this.multiFieldOffset();
         long mOffset = mbits.multiFieldOffset();
@@ -417,9 +419,10 @@ public abstract class FloatVector extends AbstractVector<Float> {
     FloatVector ldLongOpMF(MemorySegment memory, long offset,
                                   FLdLongOp f) {
         int length = vspecies().length();
+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();
         VectorPayloadMF tpayload =
-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(
-                float.class, length));
+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(
+                float.class, length, is_max_species));
         long vOffset = this.multiFieldOffset();
         for (int i = 0; i < length; i++) {
             Unsafe.getUnsafe().putFloat(tpayload, vOffset + i * Float.BYTES, f.apply(memory, offset, i));
@@ -435,9 +438,10 @@ public abstract class FloatVector extends AbstractVector<Float> {
                                   VectorMask<Float> m,
                                   FLdLongOp f) {
         int length = vspecies().length();
+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();
         VectorPayloadMF tpayload =
-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(
-                float.class, length));
+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(
+                float.class, length, is_max_species));
         VectorPayloadMF mbits = ((AbstractMask<Float>)m).getBits();
         long vOffset = this.multiFieldOffset();
         long mOffset = mbits.multiFieldOffset();
@@ -543,9 +547,10 @@ public abstract class FloatVector extends AbstractVector<Float> {
                                   Vector<Float> o,
                                   FBinTest f) {
         int length = vspecies().length();
+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();
         VectorPayloadMF vec1 = vec();
         VectorPayloadMF vec2 = ((FloatVector)o).vec();
-        VectorPayloadMF mbits = VectorPayloadMF.newInstanceFactory(boolean.class, length);
+        VectorPayloadMF mbits = VectorPayloadMF.newMaskInstanceFactory(vspecies().elementType(), length, is_max_species);
         mbits = Unsafe.getUnsafe().makePrivateBuffer(mbits);
         long vOffset = this.multiFieldOffset();
         long mOffset = mbits.multiFieldOffset();
@@ -3976,9 +3981,8 @@ public abstract class FloatVector extends AbstractVector<Float> {
         @Override
         @ForceInline
         public final FloatVector zero() {
-            // FIXME: Enable once multi-field based MaxVector is supported.
-            //if ((Class<?>) vectorType() == FloatMaxVector.class)
-            //    return FloatMaxVector.ZERO;
+            if ((Class<?>) vectorType() == FloatMaxVector.class)
+               return FloatMaxVector.ZERO;
             switch (vectorBitSize()) {
                 case 64: return Float64Vector.ZERO;
                 case 128: return Float128Vector.ZERO;
@@ -3991,9 +3995,8 @@ public abstract class FloatVector extends AbstractVector<Float> {
         @Override
         @ForceInline
         public final FloatVector iota() {
-            // FIXME: Enable once multi-field based MaxVector is supported.
-            //if ((Class<?>) vectorType() == FloatMaxVector.class)
-            //    return FloatMaxVector.IOTA;
+            if ((Class<?>) vectorType() == FloatMaxVector.class)
+                return FloatMaxVector.IOTA;
             switch (vectorBitSize()) {
                 case 64: return Float64Vector.IOTA;
                 case 128: return Float128Vector.IOTA;
@@ -4007,9 +4010,8 @@ public abstract class FloatVector extends AbstractVector<Float> {
         @Override
         @ForceInline
         public final VectorMask<Float> maskAll(boolean bit) {
-            // FIXME: Enable once multi-field based MaxVector is supported.
-            //if ((Class<?>) vectorType() == FloatMaxVector.class)
-            //    return FloatMaxVector.FloatMaxMask.maskAll(bit);
+            if ((Class<?>) vectorType() == FloatMaxVector.class)
+                return FloatMaxVector.FloatMaxMask.maskAll(bit);
             switch (vectorBitSize()) {
                 case 64: return Float64Vector.Float64Mask.maskAll(bit);
                 case 128: return Float128Vector.Float128Mask.maskAll(bit);
@@ -4044,8 +4046,7 @@ public abstract class FloatVector extends AbstractVector<Float> {
             case VectorShape.SK_128_BIT: return (FloatSpecies) SPECIES_128;
             case VectorShape.SK_256_BIT: return (FloatSpecies) SPECIES_256;
             case VectorShape.SK_512_BIT: return (FloatSpecies) SPECIES_512;
-            // FIXME: Enable once multi-field based MaxVector is supported.
-            //case VectorShape.SK_Max_BIT: return (FloatSpecies) SPECIES_MAX;
+            case VectorShape.SK_Max_BIT: return (FloatSpecies) SPECIES_MAX;
             default: throw new IllegalArgumentException("Bad shape: " + s);
         }
     }
@@ -4079,13 +4080,11 @@ public abstract class FloatVector extends AbstractVector<Float> {
                             Float512Vector::new);
 
     /** Species representing {@link FloatVector}s of {@link VectorShape#S_Max_BIT VectorShape.S_Max_BIT}. */
-    // FIXME: Enable once multi-field based MaxVector is supported.
-    /*public static final VectorSpecies<Float> SPECIES_MAX
+    public static final VectorSpecies<Float> SPECIES_MAX
         = new FloatSpecies(VectorShape.S_Max_BIT,
                             FloatMaxVector.class,
                             FloatMaxVector.FloatMaxMask.class,
                             FloatMaxVector::new);
-     */
 
     /**
      * Preferred species for {@link FloatVector}s.
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int128Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int128Vector.java
index 5b2121f8583..df2192d41cc 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int128Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int128Vector.java
@@ -69,8 +69,8 @@ value class Int128Vector extends IntVector {
         return payload;
     }
 
-    static final Int128Vector ZERO = new Int128Vector(VectorPayloadMF.newInstanceFactory(int.class, 4));
-    static final Int128Vector IOTA = new Int128Vector(VectorPayloadMF.createVectPayloadInstanceI(4, (int[])(VSPECIES.iotaArray())));
+    static final Int128Vector ZERO = new Int128Vector(VectorPayloadMF.newVectorInstanceFactory(int.class, 4, ((AbstractSpecies)VSPECIES).is_max_species()));
+    static final Int128Vector IOTA = new Int128Vector(VectorPayloadMF.createVectPayloadInstanceI(4, (int[])(VSPECIES.iotaArray()), ((AbstractSpecies)VSPECIES).is_max_species()));
 
     static {
         // Warm up a few species caches.
@@ -564,16 +564,17 @@ value class Int128Vector extends IntVector {
 
         private final VectorPayloadMF32Z payload;
 
+
         Int128Mask(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF32Z) payload;
         }
 
         Int128Mask(VectorPayloadMF payload, int offset) {
-            this(prepare(payload, offset, VLENGTH));
+            this(prepare(payload, offset, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         Int128Mask(boolean val) {
-            this(prepare(val, VLENGTH));
+            this(prepare(val, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -737,6 +738,7 @@ value class Int128Vector extends IntVector {
 
         private final VectorPayloadMF32B payload;
 
+
         Int128Shuffle(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF32B) payload;
             assert(VLENGTH == payload.length());
@@ -748,11 +750,11 @@ value class Int128Vector extends IntVector {
         }
 
         public Int128Shuffle(int[] indexes, int i) {
-            this(prepare(VLENGTH, indexes, i));
+            this(prepare(ETYPE, VLENGTH, indexes, i, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         public Int128Shuffle(IntUnaryOperator fn) {
-            this(prepare(VLENGTH, fn));
+            this(prepare(ETYPE, VLENGTH, fn, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -797,7 +799,7 @@ value class Int128Vector extends IntVector {
             Int128Shuffle s = (Int128Shuffle) shuffle;
             VectorPayloadMF indices1 = indices();
             VectorPayloadMF indices2 = s.indices();
-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);
+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, ((AbstractSpecies)VSPECIES).is_max_species());
             r = Unsafe.getUnsafe().makePrivateBuffer(r);
             long offset = r.multiFieldOffset();
             for (int i = 0; i < VLENGTH; i++) {
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int256Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int256Vector.java
index d988904df75..f0f2a895f77 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int256Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int256Vector.java
@@ -69,8 +69,8 @@ value class Int256Vector extends IntVector {
         return payload;
     }
 
-    static final Int256Vector ZERO = new Int256Vector(VectorPayloadMF.newInstanceFactory(int.class, 8));
-    static final Int256Vector IOTA = new Int256Vector(VectorPayloadMF.createVectPayloadInstanceI(8, (int[])(VSPECIES.iotaArray())));
+    static final Int256Vector ZERO = new Int256Vector(VectorPayloadMF.newVectorInstanceFactory(int.class, 8, ((AbstractSpecies)VSPECIES).is_max_species()));
+    static final Int256Vector IOTA = new Int256Vector(VectorPayloadMF.createVectPayloadInstanceI(8, (int[])(VSPECIES.iotaArray()), ((AbstractSpecies)VSPECIES).is_max_species()));
 
     static {
         // Warm up a few species caches.
@@ -572,16 +572,17 @@ value class Int256Vector extends IntVector {
 
         private final VectorPayloadMF64Z payload;
 
+
         Int256Mask(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF64Z) payload;
         }
 
         Int256Mask(VectorPayloadMF payload, int offset) {
-            this(prepare(payload, offset, VLENGTH));
+            this(prepare(payload, offset, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         Int256Mask(boolean val) {
-            this(prepare(val, VLENGTH));
+            this(prepare(val, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -745,6 +746,7 @@ value class Int256Vector extends IntVector {
 
         private final VectorPayloadMF64B payload;
 
+
         Int256Shuffle(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF64B) payload;
             assert(VLENGTH == payload.length());
@@ -756,11 +758,11 @@ value class Int256Vector extends IntVector {
         }
 
         public Int256Shuffle(int[] indexes, int i) {
-            this(prepare(VLENGTH, indexes, i));
+            this(prepare(ETYPE, VLENGTH, indexes, i, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         public Int256Shuffle(IntUnaryOperator fn) {
-            this(prepare(VLENGTH, fn));
+            this(prepare(ETYPE, VLENGTH, fn, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -805,7 +807,7 @@ value class Int256Vector extends IntVector {
             Int256Shuffle s = (Int256Shuffle) shuffle;
             VectorPayloadMF indices1 = indices();
             VectorPayloadMF indices2 = s.indices();
-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);
+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, ((AbstractSpecies)VSPECIES).is_max_species());
             r = Unsafe.getUnsafe().makePrivateBuffer(r);
             long offset = r.multiFieldOffset();
             for (int i = 0; i < VLENGTH; i++) {
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int512Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int512Vector.java
index 25032a5bb2c..13c19083b67 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int512Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int512Vector.java
@@ -69,8 +69,8 @@ value class Int512Vector extends IntVector {
         return payload;
     }
 
-    static final Int512Vector ZERO = new Int512Vector(VectorPayloadMF.newInstanceFactory(int.class, 16));
-    static final Int512Vector IOTA = new Int512Vector(VectorPayloadMF.createVectPayloadInstanceI(16, (int[])(VSPECIES.iotaArray())));
+    static final Int512Vector ZERO = new Int512Vector(VectorPayloadMF.newVectorInstanceFactory(int.class, 16, ((AbstractSpecies)VSPECIES).is_max_species()));
+    static final Int512Vector IOTA = new Int512Vector(VectorPayloadMF.createVectPayloadInstanceI(16, (int[])(VSPECIES.iotaArray()), ((AbstractSpecies)VSPECIES).is_max_species()));
 
     static {
         // Warm up a few species caches.
@@ -588,16 +588,17 @@ value class Int512Vector extends IntVector {
 
         private final VectorPayloadMF128Z payload;
 
+
         Int512Mask(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF128Z) payload;
         }
 
         Int512Mask(VectorPayloadMF payload, int offset) {
-            this(prepare(payload, offset, VLENGTH));
+            this(prepare(payload, offset, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         Int512Mask(boolean val) {
-            this(prepare(val, VLENGTH));
+            this(prepare(val, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -761,6 +762,7 @@ value class Int512Vector extends IntVector {
 
         private final VectorPayloadMF128B payload;
 
+
         Int512Shuffle(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF128B) payload;
             assert(VLENGTH == payload.length());
@@ -772,11 +774,11 @@ value class Int512Vector extends IntVector {
         }
 
         public Int512Shuffle(int[] indexes, int i) {
-            this(prepare(VLENGTH, indexes, i));
+            this(prepare(ETYPE, VLENGTH, indexes, i, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         public Int512Shuffle(IntUnaryOperator fn) {
-            this(prepare(VLENGTH, fn));
+            this(prepare(ETYPE, VLENGTH, fn, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -821,7 +823,7 @@ value class Int512Vector extends IntVector {
             Int512Shuffle s = (Int512Shuffle) shuffle;
             VectorPayloadMF indices1 = indices();
             VectorPayloadMF indices2 = s.indices();
-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);
+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, ((AbstractSpecies)VSPECIES).is_max_species());
             r = Unsafe.getUnsafe().makePrivateBuffer(r);
             long offset = r.multiFieldOffset();
             for (int i = 0; i < VLENGTH; i++) {
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int64Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int64Vector.java
index 0e25470517d..b8b529644a8 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int64Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int64Vector.java
@@ -69,8 +69,8 @@ value class Int64Vector extends IntVector {
         return payload;
     }
 
-    static final Int64Vector ZERO = new Int64Vector(VectorPayloadMF.newInstanceFactory(int.class, 2));
-    static final Int64Vector IOTA = new Int64Vector(VectorPayloadMF.createVectPayloadInstanceI(2, (int[])(VSPECIES.iotaArray())));
+    static final Int64Vector ZERO = new Int64Vector(VectorPayloadMF.newVectorInstanceFactory(int.class, 2, ((AbstractSpecies)VSPECIES).is_max_species()));
+    static final Int64Vector IOTA = new Int64Vector(VectorPayloadMF.createVectPayloadInstanceI(2, (int[])(VSPECIES.iotaArray()), ((AbstractSpecies)VSPECIES).is_max_species()));
 
     static {
         // Warm up a few species caches.
@@ -560,16 +560,17 @@ value class Int64Vector extends IntVector {
 
         private final VectorPayloadMF16Z payload;
 
+
         Int64Mask(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF16Z) payload;
         }
 
         Int64Mask(VectorPayloadMF payload, int offset) {
-            this(prepare(payload, offset, VLENGTH));
+            this(prepare(payload, offset, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         Int64Mask(boolean val) {
-            this(prepare(val, VLENGTH));
+            this(prepare(val, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -733,6 +734,7 @@ value class Int64Vector extends IntVector {
 
         private final VectorPayloadMF16B payload;
 
+
         Int64Shuffle(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF16B) payload;
             assert(VLENGTH == payload.length());
@@ -744,11 +746,11 @@ value class Int64Vector extends IntVector {
         }
 
         public Int64Shuffle(int[] indexes, int i) {
-            this(prepare(VLENGTH, indexes, i));
+            this(prepare(ETYPE, VLENGTH, indexes, i, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         public Int64Shuffle(IntUnaryOperator fn) {
-            this(prepare(VLENGTH, fn));
+            this(prepare(ETYPE, VLENGTH, fn, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -793,7 +795,7 @@ value class Int64Vector extends IntVector {
             Int64Shuffle s = (Int64Shuffle) shuffle;
             VectorPayloadMF indices1 = indices();
             VectorPayloadMF indices2 = s.indices();
-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);
+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, ((AbstractSpecies)VSPECIES).is_max_species());
             r = Unsafe.getUnsafe().makePrivateBuffer(r);
             long offset = r.multiFieldOffset();
             for (int i = 0; i < VLENGTH; i++) {
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/IntVector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/IntVector.java
index b250ee794df..06e409e80d3 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/IntVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/IntVector.java
@@ -372,9 +372,10 @@ public abstract class IntVector extends AbstractVector<Integer> {
     <M> IntVector ldOpMF(M memory, int offset,
                                   FLdOp<M> f) {
         int length = vspecies().length();
+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();
         VectorPayloadMF tpayload =
-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(
-                int.class, length));
+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(
+                int.class, length, is_max_species));
         long vOffset = this.multiFieldOffset();
         for (int i = 0; i < length; i++) {
             Unsafe.getUnsafe().putInt(tpayload, vOffset + i * Integer.BYTES, f.apply(memory, offset, i));
@@ -390,9 +391,10 @@ public abstract class IntVector extends AbstractVector<Integer> {
                                   VectorMask<Integer> m,
                                   FLdOp<M> f) {
         int length = vspecies().length();
+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();
         VectorPayloadMF tpayload =
-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(
-                int.class, length));
+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(
+                int.class, length, is_max_species));
         VectorPayloadMF mbits = ((AbstractMask<Integer>)m).getBits();
         long vOffset = this.multiFieldOffset();
         long mOffset = mbits.multiFieldOffset();
@@ -417,9 +419,10 @@ public abstract class IntVector extends AbstractVector<Integer> {
     IntVector ldLongOpMF(MemorySegment memory, long offset,
                                   FLdLongOp f) {
         int length = vspecies().length();
+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();
         VectorPayloadMF tpayload =
-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(
-                int.class, length));
+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(
+                int.class, length, is_max_species));
         long vOffset = this.multiFieldOffset();
         for (int i = 0; i < length; i++) {
             Unsafe.getUnsafe().putInt(tpayload, vOffset + i * Integer.BYTES, f.apply(memory, offset, i));
@@ -435,9 +438,10 @@ public abstract class IntVector extends AbstractVector<Integer> {
                                   VectorMask<Integer> m,
                                   FLdLongOp f) {
         int length = vspecies().length();
+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();
         VectorPayloadMF tpayload =
-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(
-                int.class, length));
+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(
+                int.class, length, is_max_species));
         VectorPayloadMF mbits = ((AbstractMask<Integer>)m).getBits();
         long vOffset = this.multiFieldOffset();
         long mOffset = mbits.multiFieldOffset();
@@ -543,9 +547,10 @@ public abstract class IntVector extends AbstractVector<Integer> {
                                   Vector<Integer> o,
                                   FBinTest f) {
         int length = vspecies().length();
+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();
         VectorPayloadMF vec1 = vec();
         VectorPayloadMF vec2 = ((IntVector)o).vec();
-        VectorPayloadMF mbits = VectorPayloadMF.newInstanceFactory(boolean.class, length);
+        VectorPayloadMF mbits = VectorPayloadMF.newMaskInstanceFactory(vspecies().elementType(), length, is_max_species);
         mbits = Unsafe.getUnsafe().makePrivateBuffer(mbits);
         long vOffset = this.multiFieldOffset();
         long mOffset = mbits.multiFieldOffset();
@@ -4144,9 +4149,8 @@ public abstract class IntVector extends AbstractVector<Integer> {
         @Override
         @ForceInline
         public final IntVector zero() {
-            // FIXME: Enable once multi-field based MaxVector is supported.
-            //if ((Class<?>) vectorType() == IntMaxVector.class)
-            //    return IntMaxVector.ZERO;
+            if ((Class<?>) vectorType() == IntMaxVector.class)
+               return IntMaxVector.ZERO;
             switch (vectorBitSize()) {
                 case 64: return Int64Vector.ZERO;
                 case 128: return Int128Vector.ZERO;
@@ -4159,9 +4163,8 @@ public abstract class IntVector extends AbstractVector<Integer> {
         @Override
         @ForceInline
         public final IntVector iota() {
-            // FIXME: Enable once multi-field based MaxVector is supported.
-            //if ((Class<?>) vectorType() == IntMaxVector.class)
-            //    return IntMaxVector.IOTA;
+            if ((Class<?>) vectorType() == IntMaxVector.class)
+                return IntMaxVector.IOTA;
             switch (vectorBitSize()) {
                 case 64: return Int64Vector.IOTA;
                 case 128: return Int128Vector.IOTA;
@@ -4175,9 +4178,8 @@ public abstract class IntVector extends AbstractVector<Integer> {
         @Override
         @ForceInline
         public final VectorMask<Integer> maskAll(boolean bit) {
-            // FIXME: Enable once multi-field based MaxVector is supported.
-            //if ((Class<?>) vectorType() == IntMaxVector.class)
-            //    return IntMaxVector.IntMaxMask.maskAll(bit);
+            if ((Class<?>) vectorType() == IntMaxVector.class)
+                return IntMaxVector.IntMaxMask.maskAll(bit);
             switch (vectorBitSize()) {
                 case 64: return Int64Vector.Int64Mask.maskAll(bit);
                 case 128: return Int128Vector.Int128Mask.maskAll(bit);
@@ -4212,8 +4214,7 @@ public abstract class IntVector extends AbstractVector<Integer> {
             case VectorShape.SK_128_BIT: return (IntSpecies) SPECIES_128;
             case VectorShape.SK_256_BIT: return (IntSpecies) SPECIES_256;
             case VectorShape.SK_512_BIT: return (IntSpecies) SPECIES_512;
-            // FIXME: Enable once multi-field based MaxVector is supported.
-            //case VectorShape.SK_Max_BIT: return (IntSpecies) SPECIES_MAX;
+            case VectorShape.SK_Max_BIT: return (IntSpecies) SPECIES_MAX;
             default: throw new IllegalArgumentException("Bad shape: " + s);
         }
     }
@@ -4247,13 +4248,11 @@ public abstract class IntVector extends AbstractVector<Integer> {
                             Int512Vector::new);
 
     /** Species representing {@link IntVector}s of {@link VectorShape#S_Max_BIT VectorShape.S_Max_BIT}. */
-    // FIXME: Enable once multi-field based MaxVector is supported.
-    /*public static final VectorSpecies<Integer> SPECIES_MAX
+    public static final VectorSpecies<Integer> SPECIES_MAX
         = new IntSpecies(VectorShape.S_Max_BIT,
                             IntMaxVector.class,
                             IntMaxVector.IntMaxMask.class,
                             IntMaxVector::new);
-     */
 
     /**
      * Preferred species for {@link IntVector}s.
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long128Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long128Vector.java
index 689ca9c8ac5..28f8fe10262 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long128Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long128Vector.java
@@ -69,8 +69,8 @@ value class Long128Vector extends LongVector {
         return payload;
     }
 
-    static final Long128Vector ZERO = new Long128Vector(VectorPayloadMF.newInstanceFactory(long.class, 2));
-    static final Long128Vector IOTA = new Long128Vector(VectorPayloadMF.createVectPayloadInstanceL(2, (long[])(VSPECIES.iotaArray())));
+    static final Long128Vector ZERO = new Long128Vector(VectorPayloadMF.newVectorInstanceFactory(long.class, 2, ((AbstractSpecies)VSPECIES).is_max_species()));
+    static final Long128Vector IOTA = new Long128Vector(VectorPayloadMF.createVectPayloadInstanceL(2, (long[])(VSPECIES.iotaArray()), ((AbstractSpecies)VSPECIES).is_max_species()));
 
     static {
         // Warm up a few species caches.
@@ -550,16 +550,17 @@ value class Long128Vector extends LongVector {
 
         private final VectorPayloadMF16Z payload;
 
+
         Long128Mask(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF16Z) payload;
         }
 
         Long128Mask(VectorPayloadMF payload, int offset) {
-            this(prepare(payload, offset, VLENGTH));
+            this(prepare(payload, offset, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         Long128Mask(boolean val) {
-            this(prepare(val, VLENGTH));
+            this(prepare(val, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -723,6 +724,7 @@ value class Long128Vector extends LongVector {
 
         private final VectorPayloadMF16B payload;
 
+
         Long128Shuffle(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF16B) payload;
             assert(VLENGTH == payload.length());
@@ -734,11 +736,11 @@ value class Long128Vector extends LongVector {
         }
 
         public Long128Shuffle(int[] indexes, int i) {
-            this(prepare(VLENGTH, indexes, i));
+            this(prepare(ETYPE, VLENGTH, indexes, i, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         public Long128Shuffle(IntUnaryOperator fn) {
-            this(prepare(VLENGTH, fn));
+            this(prepare(ETYPE, VLENGTH, fn, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -783,7 +785,7 @@ value class Long128Vector extends LongVector {
             Long128Shuffle s = (Long128Shuffle) shuffle;
             VectorPayloadMF indices1 = indices();
             VectorPayloadMF indices2 = s.indices();
-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);
+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, ((AbstractSpecies)VSPECIES).is_max_species());
             r = Unsafe.getUnsafe().makePrivateBuffer(r);
             long offset = r.multiFieldOffset();
             for (int i = 0; i < VLENGTH; i++) {
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long256Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long256Vector.java
index 351b0d900b8..5c485c96b75 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long256Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long256Vector.java
@@ -69,8 +69,8 @@ value class Long256Vector extends LongVector {
         return payload;
     }
 
-    static final Long256Vector ZERO = new Long256Vector(VectorPayloadMF.newInstanceFactory(long.class, 4));
-    static final Long256Vector IOTA = new Long256Vector(VectorPayloadMF.createVectPayloadInstanceL(4, (long[])(VSPECIES.iotaArray())));
+    static final Long256Vector ZERO = new Long256Vector(VectorPayloadMF.newVectorInstanceFactory(long.class, 4, ((AbstractSpecies)VSPECIES).is_max_species()));
+    static final Long256Vector IOTA = new Long256Vector(VectorPayloadMF.createVectPayloadInstanceL(4, (long[])(VSPECIES.iotaArray()), ((AbstractSpecies)VSPECIES).is_max_species()));
 
     static {
         // Warm up a few species caches.
@@ -554,16 +554,17 @@ value class Long256Vector extends LongVector {
 
         private final VectorPayloadMF32Z payload;
 
+
         Long256Mask(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF32Z) payload;
         }
 
         Long256Mask(VectorPayloadMF payload, int offset) {
-            this(prepare(payload, offset, VLENGTH));
+            this(prepare(payload, offset, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         Long256Mask(boolean val) {
-            this(prepare(val, VLENGTH));
+            this(prepare(val, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -727,6 +728,7 @@ value class Long256Vector extends LongVector {
 
         private final VectorPayloadMF32B payload;
 
+
         Long256Shuffle(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF32B) payload;
             assert(VLENGTH == payload.length());
@@ -738,11 +740,11 @@ value class Long256Vector extends LongVector {
         }
 
         public Long256Shuffle(int[] indexes, int i) {
-            this(prepare(VLENGTH, indexes, i));
+            this(prepare(ETYPE, VLENGTH, indexes, i, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         public Long256Shuffle(IntUnaryOperator fn) {
-            this(prepare(VLENGTH, fn));
+            this(prepare(ETYPE, VLENGTH, fn, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -787,7 +789,7 @@ value class Long256Vector extends LongVector {
             Long256Shuffle s = (Long256Shuffle) shuffle;
             VectorPayloadMF indices1 = indices();
             VectorPayloadMF indices2 = s.indices();
-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);
+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, ((AbstractSpecies)VSPECIES).is_max_species());
             r = Unsafe.getUnsafe().makePrivateBuffer(r);
             long offset = r.multiFieldOffset();
             for (int i = 0; i < VLENGTH; i++) {
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long512Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long512Vector.java
index 064176815ab..a5f23b10c4f 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long512Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long512Vector.java
@@ -69,8 +69,8 @@ value class Long512Vector extends LongVector {
         return payload;
     }
 
-    static final Long512Vector ZERO = new Long512Vector(VectorPayloadMF.newInstanceFactory(long.class, 8));
-    static final Long512Vector IOTA = new Long512Vector(VectorPayloadMF.createVectPayloadInstanceL(8, (long[])(VSPECIES.iotaArray())));
+    static final Long512Vector ZERO = new Long512Vector(VectorPayloadMF.newVectorInstanceFactory(long.class, 8, ((AbstractSpecies)VSPECIES).is_max_species()));
+    static final Long512Vector IOTA = new Long512Vector(VectorPayloadMF.createVectPayloadInstanceL(8, (long[])(VSPECIES.iotaArray()), ((AbstractSpecies)VSPECIES).is_max_species()));
 
     static {
         // Warm up a few species caches.
@@ -562,16 +562,17 @@ value class Long512Vector extends LongVector {
 
         private final VectorPayloadMF64Z payload;
 
+
         Long512Mask(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF64Z) payload;
         }
 
         Long512Mask(VectorPayloadMF payload, int offset) {
-            this(prepare(payload, offset, VLENGTH));
+            this(prepare(payload, offset, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         Long512Mask(boolean val) {
-            this(prepare(val, VLENGTH));
+            this(prepare(val, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -735,6 +736,7 @@ value class Long512Vector extends LongVector {
 
         private final VectorPayloadMF64B payload;
 
+
         Long512Shuffle(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF64B) payload;
             assert(VLENGTH == payload.length());
@@ -746,11 +748,11 @@ value class Long512Vector extends LongVector {
         }
 
         public Long512Shuffle(int[] indexes, int i) {
-            this(prepare(VLENGTH, indexes, i));
+            this(prepare(ETYPE, VLENGTH, indexes, i, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         public Long512Shuffle(IntUnaryOperator fn) {
-            this(prepare(VLENGTH, fn));
+            this(prepare(ETYPE, VLENGTH, fn, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -795,7 +797,7 @@ value class Long512Vector extends LongVector {
             Long512Shuffle s = (Long512Shuffle) shuffle;
             VectorPayloadMF indices1 = indices();
             VectorPayloadMF indices2 = s.indices();
-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);
+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, ((AbstractSpecies)VSPECIES).is_max_species());
             r = Unsafe.getUnsafe().makePrivateBuffer(r);
             long offset = r.multiFieldOffset();
             for (int i = 0; i < VLENGTH; i++) {
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long64Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long64Vector.java
index 09ae2dbb07e..0c5a663b072 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long64Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long64Vector.java
@@ -69,8 +69,8 @@ value class Long64Vector extends LongVector {
         return payload;
     }
 
-    static final Long64Vector ZERO = new Long64Vector(VectorPayloadMF.newInstanceFactory(long.class, 1));
-    static final Long64Vector IOTA = new Long64Vector(VectorPayloadMF.createVectPayloadInstanceL(1, (long[])(VSPECIES.iotaArray())));
+    static final Long64Vector ZERO = new Long64Vector(VectorPayloadMF.newVectorInstanceFactory(long.class, 1, ((AbstractSpecies)VSPECIES).is_max_species()));
+    static final Long64Vector IOTA = new Long64Vector(VectorPayloadMF.createVectPayloadInstanceL(1, (long[])(VSPECIES.iotaArray()), ((AbstractSpecies)VSPECIES).is_max_species()));
 
     static {
         // Warm up a few species caches.
@@ -548,16 +548,17 @@ value class Long64Vector extends LongVector {
 
         private final VectorPayloadMF8Z payload;
 
+
         Long64Mask(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF8Z) payload;
         }
 
         Long64Mask(VectorPayloadMF payload, int offset) {
-            this(prepare(payload, offset, VLENGTH));
+            this(prepare(payload, offset, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         Long64Mask(boolean val) {
-            this(prepare(val, VLENGTH));
+            this(prepare(val, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -721,6 +722,7 @@ value class Long64Vector extends LongVector {
 
         private final VectorPayloadMF8B payload;
 
+
         Long64Shuffle(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF8B) payload;
             assert(VLENGTH == payload.length());
@@ -732,11 +734,11 @@ value class Long64Vector extends LongVector {
         }
 
         public Long64Shuffle(int[] indexes, int i) {
-            this(prepare(VLENGTH, indexes, i));
+            this(prepare(ETYPE, VLENGTH, indexes, i, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         public Long64Shuffle(IntUnaryOperator fn) {
-            this(prepare(VLENGTH, fn));
+            this(prepare(ETYPE, VLENGTH, fn, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -781,7 +783,7 @@ value class Long64Vector extends LongVector {
             Long64Shuffle s = (Long64Shuffle) shuffle;
             VectorPayloadMF indices1 = indices();
             VectorPayloadMF indices2 = s.indices();
-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);
+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, ((AbstractSpecies)VSPECIES).is_max_species());
             r = Unsafe.getUnsafe().makePrivateBuffer(r);
             long offset = r.multiFieldOffset();
             for (int i = 0; i < VLENGTH; i++) {
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/LongVector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/LongVector.java
index c0ab9dfaf8d..3fa75085bd8 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/LongVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/LongVector.java
@@ -372,9 +372,10 @@ public abstract class LongVector extends AbstractVector<Long> {
     <M> LongVector ldOpMF(M memory, int offset,
                                   FLdOp<M> f) {
         int length = vspecies().length();
+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();
         VectorPayloadMF tpayload =
-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(
-                long.class, length));
+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(
+                long.class, length, is_max_species));
         long vOffset = this.multiFieldOffset();
         for (int i = 0; i < length; i++) {
             Unsafe.getUnsafe().putLong(tpayload, vOffset + i * Long.BYTES, f.apply(memory, offset, i));
@@ -390,9 +391,10 @@ public abstract class LongVector extends AbstractVector<Long> {
                                   VectorMask<Long> m,
                                   FLdOp<M> f) {
         int length = vspecies().length();
+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();
         VectorPayloadMF tpayload =
-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(
-                long.class, length));
+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(
+                long.class, length, is_max_species));
         VectorPayloadMF mbits = ((AbstractMask<Long>)m).getBits();
         long vOffset = this.multiFieldOffset();
         long mOffset = mbits.multiFieldOffset();
@@ -417,9 +419,10 @@ public abstract class LongVector extends AbstractVector<Long> {
     LongVector ldLongOpMF(MemorySegment memory, long offset,
                                   FLdLongOp f) {
         int length = vspecies().length();
+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();
         VectorPayloadMF tpayload =
-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(
-                long.class, length));
+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(
+                long.class, length, is_max_species));
         long vOffset = this.multiFieldOffset();
         for (int i = 0; i < length; i++) {
             Unsafe.getUnsafe().putLong(tpayload, vOffset + i * Long.BYTES, f.apply(memory, offset, i));
@@ -435,9 +438,10 @@ public abstract class LongVector extends AbstractVector<Long> {
                                   VectorMask<Long> m,
                                   FLdLongOp f) {
         int length = vspecies().length();
+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();
         VectorPayloadMF tpayload =
-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(
-                long.class, length));
+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(
+                long.class, length, is_max_species));
         VectorPayloadMF mbits = ((AbstractMask<Long>)m).getBits();
         long vOffset = this.multiFieldOffset();
         long mOffset = mbits.multiFieldOffset();
@@ -543,9 +547,10 @@ public abstract class LongVector extends AbstractVector<Long> {
                                   Vector<Long> o,
                                   FBinTest f) {
         int length = vspecies().length();
+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();
         VectorPayloadMF vec1 = vec();
         VectorPayloadMF vec2 = ((LongVector)o).vec();
-        VectorPayloadMF mbits = VectorPayloadMF.newInstanceFactory(boolean.class, length);
+        VectorPayloadMF mbits = VectorPayloadMF.newMaskInstanceFactory(vspecies().elementType(), length, is_max_species);
         mbits = Unsafe.getUnsafe().makePrivateBuffer(mbits);
         long vOffset = this.multiFieldOffset();
         long mOffset = mbits.multiFieldOffset();
@@ -3026,11 +3031,9 @@ public abstract class LongVector extends AbstractVector<Long> {
             // indexShape is still S_MAX_BIT, but the lane count of int vector
             // is 64. So when loading index vector (IntVector), only lower half
             // of index data is needed.
-            /*vix = IntVector
+            vix = IntVector
                 .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)
                 .add(offset);
-             */
-             assert false : "Unhandled case for Multi-field based MaxVector";
         } else {
             vix = IntVector
                 .fromArray(isp, indexMap, mapOffset)
@@ -3321,11 +3324,9 @@ public abstract class LongVector extends AbstractVector<Long> {
             // indexShape is still S_MAX_BIT, but the lane count of int vector
             // is 64. So when loading index vector (IntVector), only lower half
             // of index data is needed.
-            /*vix = IntVector
+            vix = IntVector
                 .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)
                 .add(offset);
-             */
-             assert false : "Unhandled case for Multi-field based MaxVector";
         } else {
             vix = IntVector
                 .fromArray(isp, indexMap, mapOffset)
@@ -3517,11 +3518,9 @@ public abstract class LongVector extends AbstractVector<Long> {
             // indexShape is still S_MAX_BIT, but the lane count of int vector
             // is 64. So when loading index vector (IntVector), only lower half
             // of index data is needed.
-            /*vix = IntVector
+            vix = IntVector
                 .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)
                 .add(offset);
-             */
-            assert false : "Unhandled case for Multi-field based MaxVector";
         } else {
             vix = IntVector
                 .fromArray(isp, indexMap, mapOffset)
@@ -3634,12 +3633,9 @@ public abstract class LongVector extends AbstractVector<Long> {
             // indexShape is still S_MAX_BIT, but the lane count of int vector
             // is 64. So when loading index vector (IntVector), only lower half
             // of index data is needed.
-            /*vix = IntVector
+            vix = IntVector
                 .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)
                 .add(offset);
-             */
-             assert false : "Unhandled case for Multi-field based MaxVector";
-
         } else {
             vix = IntVector
                 .fromArray(isp, indexMap, mapOffset)
@@ -4079,9 +4075,8 @@ public abstract class LongVector extends AbstractVector<Long> {
         @Override
         @ForceInline
         public final LongVector zero() {
-            // FIXME: Enable once multi-field based MaxVector is supported.
-            //if ((Class<?>) vectorType() == LongMaxVector.class)
-            //    return LongMaxVector.ZERO;
+            if ((Class<?>) vectorType() == LongMaxVector.class)
+               return LongMaxVector.ZERO;
             switch (vectorBitSize()) {
                 case 64: return Long64Vector.ZERO;
                 case 128: return Long128Vector.ZERO;
@@ -4094,9 +4089,8 @@ public abstract class LongVector extends AbstractVector<Long> {
         @Override
         @ForceInline
         public final LongVector iota() {
-            // FIXME: Enable once multi-field based MaxVector is supported.
-            //if ((Class<?>) vectorType() == LongMaxVector.class)
-            //    return LongMaxVector.IOTA;
+            if ((Class<?>) vectorType() == LongMaxVector.class)
+                return LongMaxVector.IOTA;
             switch (vectorBitSize()) {
                 case 64: return Long64Vector.IOTA;
                 case 128: return Long128Vector.IOTA;
@@ -4110,9 +4104,8 @@ public abstract class LongVector extends AbstractVector<Long> {
         @Override
         @ForceInline
         public final VectorMask<Long> maskAll(boolean bit) {
-            // FIXME: Enable once multi-field based MaxVector is supported.
-            //if ((Class<?>) vectorType() == LongMaxVector.class)
-            //    return LongMaxVector.LongMaxMask.maskAll(bit);
+            if ((Class<?>) vectorType() == LongMaxVector.class)
+                return LongMaxVector.LongMaxMask.maskAll(bit);
             switch (vectorBitSize()) {
                 case 64: return Long64Vector.Long64Mask.maskAll(bit);
                 case 128: return Long128Vector.Long128Mask.maskAll(bit);
@@ -4147,8 +4140,7 @@ public abstract class LongVector extends AbstractVector<Long> {
             case VectorShape.SK_128_BIT: return (LongSpecies) SPECIES_128;
             case VectorShape.SK_256_BIT: return (LongSpecies) SPECIES_256;
             case VectorShape.SK_512_BIT: return (LongSpecies) SPECIES_512;
-            // FIXME: Enable once multi-field based MaxVector is supported.
-            //case VectorShape.SK_Max_BIT: return (LongSpecies) SPECIES_MAX;
+            case VectorShape.SK_Max_BIT: return (LongSpecies) SPECIES_MAX;
             default: throw new IllegalArgumentException("Bad shape: " + s);
         }
     }
@@ -4182,13 +4174,11 @@ public abstract class LongVector extends AbstractVector<Long> {
                             Long512Vector::new);
 
     /** Species representing {@link LongVector}s of {@link VectorShape#S_Max_BIT VectorShape.S_Max_BIT}. */
-    // FIXME: Enable once multi-field based MaxVector is supported.
-    /*public static final VectorSpecies<Long> SPECIES_MAX
+    public static final VectorSpecies<Long> SPECIES_MAX
         = new LongSpecies(VectorShape.S_Max_BIT,
                             LongMaxVector.class,
                             LongMaxVector.LongMaxMask.class,
                             LongMaxVector::new);
-     */
 
     /**
      * Preferred species for {@link LongVector}s.
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short128Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short128Vector.java
index 4772b072b23..cb361c8d8f4 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short128Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short128Vector.java
@@ -69,8 +69,8 @@ value class Short128Vector extends ShortVector {
         return payload;
     }
 
-    static final Short128Vector ZERO = new Short128Vector(VectorPayloadMF.newInstanceFactory(short.class, 8));
-    static final Short128Vector IOTA = new Short128Vector(VectorPayloadMF.createVectPayloadInstanceS(8, (short[])(VSPECIES.iotaArray())));
+    static final Short128Vector ZERO = new Short128Vector(VectorPayloadMF.newVectorInstanceFactory(short.class, 8, ((AbstractSpecies)VSPECIES).is_max_species()));
+    static final Short128Vector IOTA = new Short128Vector(VectorPayloadMF.createVectPayloadInstanceS(8, (short[])(VSPECIES.iotaArray()), ((AbstractSpecies)VSPECIES).is_max_species()));
 
     static {
         // Warm up a few species caches.
@@ -572,16 +572,17 @@ value class Short128Vector extends ShortVector {
 
         private final VectorPayloadMF64Z payload;
 
+
         Short128Mask(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF64Z) payload;
         }
 
         Short128Mask(VectorPayloadMF payload, int offset) {
-            this(prepare(payload, offset, VLENGTH));
+            this(prepare(payload, offset, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         Short128Mask(boolean val) {
-            this(prepare(val, VLENGTH));
+            this(prepare(val, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -745,6 +746,7 @@ value class Short128Vector extends ShortVector {
 
         private final VectorPayloadMF64B payload;
 
+
         Short128Shuffle(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF64B) payload;
             assert(VLENGTH == payload.length());
@@ -756,11 +758,11 @@ value class Short128Vector extends ShortVector {
         }
 
         public Short128Shuffle(int[] indexes, int i) {
-            this(prepare(VLENGTH, indexes, i));
+            this(prepare(ETYPE, VLENGTH, indexes, i, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         public Short128Shuffle(IntUnaryOperator fn) {
-            this(prepare(VLENGTH, fn));
+            this(prepare(ETYPE, VLENGTH, fn, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -805,7 +807,7 @@ value class Short128Vector extends ShortVector {
             Short128Shuffle s = (Short128Shuffle) shuffle;
             VectorPayloadMF indices1 = indices();
             VectorPayloadMF indices2 = s.indices();
-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);
+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, ((AbstractSpecies)VSPECIES).is_max_species());
             r = Unsafe.getUnsafe().makePrivateBuffer(r);
             long offset = r.multiFieldOffset();
             for (int i = 0; i < VLENGTH; i++) {
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short256Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short256Vector.java
index 96ed38e78eb..0fed4d30d76 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short256Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short256Vector.java
@@ -69,8 +69,8 @@ value class Short256Vector extends ShortVector {
         return payload;
     }
 
-    static final Short256Vector ZERO = new Short256Vector(VectorPayloadMF.newInstanceFactory(short.class, 16));
-    static final Short256Vector IOTA = new Short256Vector(VectorPayloadMF.createVectPayloadInstanceS(16, (short[])(VSPECIES.iotaArray())));
+    static final Short256Vector ZERO = new Short256Vector(VectorPayloadMF.newVectorInstanceFactory(short.class, 16, ((AbstractSpecies)VSPECIES).is_max_species()));
+    static final Short256Vector IOTA = new Short256Vector(VectorPayloadMF.createVectPayloadInstanceS(16, (short[])(VSPECIES.iotaArray()), ((AbstractSpecies)VSPECIES).is_max_species()));
 
     static {
         // Warm up a few species caches.
@@ -588,16 +588,17 @@ value class Short256Vector extends ShortVector {
 
         private final VectorPayloadMF128Z payload;
 
+
         Short256Mask(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF128Z) payload;
         }
 
         Short256Mask(VectorPayloadMF payload, int offset) {
-            this(prepare(payload, offset, VLENGTH));
+            this(prepare(payload, offset, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         Short256Mask(boolean val) {
-            this(prepare(val, VLENGTH));
+            this(prepare(val, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -761,6 +762,7 @@ value class Short256Vector extends ShortVector {
 
         private final VectorPayloadMF128B payload;
 
+
         Short256Shuffle(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF128B) payload;
             assert(VLENGTH == payload.length());
@@ -772,11 +774,11 @@ value class Short256Vector extends ShortVector {
         }
 
         public Short256Shuffle(int[] indexes, int i) {
-            this(prepare(VLENGTH, indexes, i));
+            this(prepare(ETYPE, VLENGTH, indexes, i, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         public Short256Shuffle(IntUnaryOperator fn) {
-            this(prepare(VLENGTH, fn));
+            this(prepare(ETYPE, VLENGTH, fn, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -821,7 +823,7 @@ value class Short256Vector extends ShortVector {
             Short256Shuffle s = (Short256Shuffle) shuffle;
             VectorPayloadMF indices1 = indices();
             VectorPayloadMF indices2 = s.indices();
-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);
+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, ((AbstractSpecies)VSPECIES).is_max_species());
             r = Unsafe.getUnsafe().makePrivateBuffer(r);
             long offset = r.multiFieldOffset();
             for (int i = 0; i < VLENGTH; i++) {
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short512Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short512Vector.java
index 50804f8df5b..2e34de54233 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short512Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short512Vector.java
@@ -69,8 +69,8 @@ value class Short512Vector extends ShortVector {
         return payload;
     }
 
-    static final Short512Vector ZERO = new Short512Vector(VectorPayloadMF.newInstanceFactory(short.class, 32));
-    static final Short512Vector IOTA = new Short512Vector(VectorPayloadMF.createVectPayloadInstanceS(32, (short[])(VSPECIES.iotaArray())));
+    static final Short512Vector ZERO = new Short512Vector(VectorPayloadMF.newVectorInstanceFactory(short.class, 32, ((AbstractSpecies)VSPECIES).is_max_species()));
+    static final Short512Vector IOTA = new Short512Vector(VectorPayloadMF.createVectPayloadInstanceS(32, (short[])(VSPECIES.iotaArray()), ((AbstractSpecies)VSPECIES).is_max_species()));
 
     static {
         // Warm up a few species caches.
@@ -620,16 +620,17 @@ value class Short512Vector extends ShortVector {
 
         private final VectorPayloadMF256Z payload;
 
+
         Short512Mask(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF256Z) payload;
         }
 
         Short512Mask(VectorPayloadMF payload, int offset) {
-            this(prepare(payload, offset, VLENGTH));
+            this(prepare(payload, offset, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         Short512Mask(boolean val) {
-            this(prepare(val, VLENGTH));
+            this(prepare(val, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -793,6 +794,7 @@ value class Short512Vector extends ShortVector {
 
         private final VectorPayloadMF256B payload;
 
+
         Short512Shuffle(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF256B) payload;
             assert(VLENGTH == payload.length());
@@ -804,11 +806,11 @@ value class Short512Vector extends ShortVector {
         }
 
         public Short512Shuffle(int[] indexes, int i) {
-            this(prepare(VLENGTH, indexes, i));
+            this(prepare(ETYPE, VLENGTH, indexes, i, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         public Short512Shuffle(IntUnaryOperator fn) {
-            this(prepare(VLENGTH, fn));
+            this(prepare(ETYPE, VLENGTH, fn, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -853,7 +855,7 @@ value class Short512Vector extends ShortVector {
             Short512Shuffle s = (Short512Shuffle) shuffle;
             VectorPayloadMF indices1 = indices();
             VectorPayloadMF indices2 = s.indices();
-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);
+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, ((AbstractSpecies)VSPECIES).is_max_species());
             r = Unsafe.getUnsafe().makePrivateBuffer(r);
             long offset = r.multiFieldOffset();
             for (int i = 0; i < VLENGTH; i++) {
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short64Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short64Vector.java
index ff98aa63aeb..a1be2b18a00 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short64Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short64Vector.java
@@ -69,8 +69,8 @@ value class Short64Vector extends ShortVector {
         return payload;
     }
 
-    static final Short64Vector ZERO = new Short64Vector(VectorPayloadMF.newInstanceFactory(short.class, 4));
-    static final Short64Vector IOTA = new Short64Vector(VectorPayloadMF.createVectPayloadInstanceS(4, (short[])(VSPECIES.iotaArray())));
+    static final Short64Vector ZERO = new Short64Vector(VectorPayloadMF.newVectorInstanceFactory(short.class, 4, ((AbstractSpecies)VSPECIES).is_max_species()));
+    static final Short64Vector IOTA = new Short64Vector(VectorPayloadMF.createVectPayloadInstanceS(4, (short[])(VSPECIES.iotaArray()), ((AbstractSpecies)VSPECIES).is_max_species()));
 
     static {
         // Warm up a few species caches.
@@ -564,16 +564,17 @@ value class Short64Vector extends ShortVector {
 
         private final VectorPayloadMF32Z payload;
 
+
         Short64Mask(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF32Z) payload;
         }
 
         Short64Mask(VectorPayloadMF payload, int offset) {
-            this(prepare(payload, offset, VLENGTH));
+            this(prepare(payload, offset, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         Short64Mask(boolean val) {
-            this(prepare(val, VLENGTH));
+            this(prepare(val, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -737,6 +738,7 @@ value class Short64Vector extends ShortVector {
 
         private final VectorPayloadMF32B payload;
 
+
         Short64Shuffle(VectorPayloadMF payload) {
             this.payload = (VectorPayloadMF32B) payload;
             assert(VLENGTH == payload.length());
@@ -748,11 +750,11 @@ value class Short64Vector extends ShortVector {
         }
 
         public Short64Shuffle(int[] indexes, int i) {
-            this(prepare(VLENGTH, indexes, i));
+            this(prepare(ETYPE, VLENGTH, indexes, i, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         public Short64Shuffle(IntUnaryOperator fn) {
-            this(prepare(VLENGTH, fn));
+            this(prepare(ETYPE, VLENGTH, fn, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -797,7 +799,7 @@ value class Short64Vector extends ShortVector {
             Short64Shuffle s = (Short64Shuffle) shuffle;
             VectorPayloadMF indices1 = indices();
             VectorPayloadMF indices2 = s.indices();
-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);
+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, ((AbstractSpecies)VSPECIES).is_max_species());
             r = Unsafe.getUnsafe().makePrivateBuffer(r);
             long offset = r.multiFieldOffset();
             for (int i = 0; i < VLENGTH; i++) {
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ShortVector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ShortVector.java
index 64f9fecb16d..ae8dc6b40f1 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ShortVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ShortVector.java
@@ -372,9 +372,10 @@ public abstract class ShortVector extends AbstractVector<Short> {
     <M> ShortVector ldOpMF(M memory, int offset,
                                   FLdOp<M> f) {
         int length = vspecies().length();
+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();
         VectorPayloadMF tpayload =
-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(
-                short.class, length));
+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(
+                short.class, length, is_max_species));
         long vOffset = this.multiFieldOffset();
         for (int i = 0; i < length; i++) {
             Unsafe.getUnsafe().putShort(tpayload, vOffset + i * Short.BYTES, f.apply(memory, offset, i));
@@ -390,9 +391,10 @@ public abstract class ShortVector extends AbstractVector<Short> {
                                   VectorMask<Short> m,
                                   FLdOp<M> f) {
         int length = vspecies().length();
+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();
         VectorPayloadMF tpayload =
-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(
-                short.class, length));
+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(
+                short.class, length, is_max_species));
         VectorPayloadMF mbits = ((AbstractMask<Short>)m).getBits();
         long vOffset = this.multiFieldOffset();
         long mOffset = mbits.multiFieldOffset();
@@ -417,9 +419,10 @@ public abstract class ShortVector extends AbstractVector<Short> {
     ShortVector ldLongOpMF(MemorySegment memory, long offset,
                                   FLdLongOp f) {
         int length = vspecies().length();
+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();
         VectorPayloadMF tpayload =
-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(
-                short.class, length));
+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(
+                short.class, length, is_max_species));
         long vOffset = this.multiFieldOffset();
         for (int i = 0; i < length; i++) {
             Unsafe.getUnsafe().putShort(tpayload, vOffset + i * Short.BYTES, f.apply(memory, offset, i));
@@ -435,9 +438,10 @@ public abstract class ShortVector extends AbstractVector<Short> {
                                   VectorMask<Short> m,
                                   FLdLongOp f) {
         int length = vspecies().length();
+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();
         VectorPayloadMF tpayload =
-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(
-                short.class, length));
+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(
+                short.class, length, is_max_species));
         VectorPayloadMF mbits = ((AbstractMask<Short>)m).getBits();
         long vOffset = this.multiFieldOffset();
         long mOffset = mbits.multiFieldOffset();
@@ -543,9 +547,10 @@ public abstract class ShortVector extends AbstractVector<Short> {
                                   Vector<Short> o,
                                   FBinTest f) {
         int length = vspecies().length();
+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();
         VectorPayloadMF vec1 = vec();
         VectorPayloadMF vec2 = ((ShortVector)o).vec();
-        VectorPayloadMF mbits = VectorPayloadMF.newInstanceFactory(boolean.class, length);
+        VectorPayloadMF mbits = VectorPayloadMF.newMaskInstanceFactory(vspecies().elementType(), length, is_max_species);
         mbits = Unsafe.getUnsafe().makePrivateBuffer(mbits);
         long vOffset = this.multiFieldOffset();
         long mOffset = mbits.multiFieldOffset();
@@ -4425,9 +4430,8 @@ public abstract class ShortVector extends AbstractVector<Short> {
         @Override
         @ForceInline
         public final ShortVector zero() {
-            // FIXME: Enable once multi-field based MaxVector is supported.
-            //if ((Class<?>) vectorType() == ShortMaxVector.class)
-            //    return ShortMaxVector.ZERO;
+            if ((Class<?>) vectorType() == ShortMaxVector.class)
+               return ShortMaxVector.ZERO;
             switch (vectorBitSize()) {
                 case 64: return Short64Vector.ZERO;
                 case 128: return Short128Vector.ZERO;
@@ -4440,9 +4444,8 @@ public abstract class ShortVector extends AbstractVector<Short> {
         @Override
         @ForceInline
         public final ShortVector iota() {
-            // FIXME: Enable once multi-field based MaxVector is supported.
-            //if ((Class<?>) vectorType() == ShortMaxVector.class)
-            //    return ShortMaxVector.IOTA;
+            if ((Class<?>) vectorType() == ShortMaxVector.class)
+                return ShortMaxVector.IOTA;
             switch (vectorBitSize()) {
                 case 64: return Short64Vector.IOTA;
                 case 128: return Short128Vector.IOTA;
@@ -4456,9 +4459,8 @@ public abstract class ShortVector extends AbstractVector<Short> {
         @Override
         @ForceInline
         public final VectorMask<Short> maskAll(boolean bit) {
-            // FIXME: Enable once multi-field based MaxVector is supported.
-            //if ((Class<?>) vectorType() == ShortMaxVector.class)
-            //    return ShortMaxVector.ShortMaxMask.maskAll(bit);
+            if ((Class<?>) vectorType() == ShortMaxVector.class)
+                return ShortMaxVector.ShortMaxMask.maskAll(bit);
             switch (vectorBitSize()) {
                 case 64: return Short64Vector.Short64Mask.maskAll(bit);
                 case 128: return Short128Vector.Short128Mask.maskAll(bit);
@@ -4493,8 +4495,7 @@ public abstract class ShortVector extends AbstractVector<Short> {
             case VectorShape.SK_128_BIT: return (ShortSpecies) SPECIES_128;
             case VectorShape.SK_256_BIT: return (ShortSpecies) SPECIES_256;
             case VectorShape.SK_512_BIT: return (ShortSpecies) SPECIES_512;
-            // FIXME: Enable once multi-field based MaxVector is supported.
-            //case VectorShape.SK_Max_BIT: return (ShortSpecies) SPECIES_MAX;
+            case VectorShape.SK_Max_BIT: return (ShortSpecies) SPECIES_MAX;
             default: throw new IllegalArgumentException("Bad shape: " + s);
         }
     }
@@ -4528,13 +4529,11 @@ public abstract class ShortVector extends AbstractVector<Short> {
                             Short512Vector::new);
 
     /** Species representing {@link ShortVector}s of {@link VectorShape#S_Max_BIT VectorShape.S_Max_BIT}. */
-    // FIXME: Enable once multi-field based MaxVector is supported.
-    /*public static final VectorSpecies<Short> SPECIES_MAX
+    public static final VectorSpecies<Short> SPECIES_MAX
         = new ShortSpecies(VectorShape.S_Max_BIT,
                             ShortMaxVector.class,
                             ShortMaxVector.ShortMaxMask.class,
                             ShortMaxVector::new);
-     */
 
     /**
      * Preferred species for {@link ShortVector}s.
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/X-Vector.java.template b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/X-Vector.java.template
index 318279848f5..c0bdc9422d6 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/X-Vector.java.template
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/X-Vector.java.template
@@ -376,9 +376,10 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
     <M> $abstractvectortype$ ldOpMF(M memory, int offset,
                                   FLdOp<M> f) {
         int length = vspecies().length();
+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();
         VectorPayloadMF tpayload =
-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(
-                $type$.class, length));
+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(
+                $type$.class, length, is_max_species));
         long vOffset = this.multiFieldOffset();
         for (int i = 0; i < length; i++) {
             Unsafe.getUnsafe().put$Type$(tpayload, vOffset + i * $Boxtype$.BYTES, f.apply(memory, offset, i));
@@ -394,9 +395,10 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
                                   VectorMask<$Boxtype$> m,
                                   FLdOp<M> f) {
         int length = vspecies().length();
+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();
         VectorPayloadMF tpayload =
-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(
-                $type$.class, length));
+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(
+                $type$.class, length, is_max_species));
         VectorPayloadMF mbits = ((AbstractMask<$Boxtype$>)m).getBits();
         long vOffset = this.multiFieldOffset();
         long mOffset = mbits.multiFieldOffset();
@@ -421,9 +423,10 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
     $abstractvectortype$ ldLongOpMF(MemorySegment memory, long offset,
                                   FLdLongOp f) {
         int length = vspecies().length();
+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();
         VectorPayloadMF tpayload =
-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(
-                $type$.class, length));
+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(
+                $type$.class, length, is_max_species));
         long vOffset = this.multiFieldOffset();
         for (int i = 0; i < length; i++) {
             Unsafe.getUnsafe().put$Type$(tpayload, vOffset + i * $Boxtype$.BYTES, f.apply(memory, offset, i));
@@ -439,9 +442,10 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
                                   VectorMask<$Boxtype$> m,
                                   FLdLongOp f) {
         int length = vspecies().length();
+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();
         VectorPayloadMF tpayload =
-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(
-                $type$.class, length));
+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(
+                $type$.class, length, is_max_species));
         VectorPayloadMF mbits = ((AbstractMask<$Boxtype$>)m).getBits();
         long vOffset = this.multiFieldOffset();
         long mOffset = mbits.multiFieldOffset();
@@ -547,9 +551,10 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
                                   Vector<$Boxtype$> o,
                                   FBinTest f) {
         int length = vspecies().length();
+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();
         VectorPayloadMF vec1 = vec();
         VectorPayloadMF vec2 = (($abstractvectortype$)o).vec();
-        VectorPayloadMF mbits = VectorPayloadMF.newInstanceFactory(boolean.class, length);
+        VectorPayloadMF mbits = VectorPayloadMF.newMaskInstanceFactory(vspecies().elementType(), length, is_max_species);
         mbits = Unsafe.getUnsafe().makePrivateBuffer(mbits);
         long vOffset = this.multiFieldOffset();
         long mOffset = mbits.multiFieldOffset();
@@ -3784,11 +3789,9 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
             // indexShape is still S_MAX_BIT, but the lane count of int vector
             // is 64. So when loading index vector (IntVector), only lower half
             // of index data is needed.
-            /*vix = IntVector
+            vix = IntVector
                 .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)
                 .add(offset);
-             */
-             assert false : "Unhandled case for Multi-field based MaxVector";
         } else {
             vix = IntVector
                 .fromArray(isp, indexMap, mapOffset)
@@ -4424,11 +4427,9 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
             // indexShape is still S_MAX_BIT, but the lane count of int vector
             // is 64. So when loading index vector (IntVector), only lower half
             // of index data is needed.
-            /*vix = IntVector
+            vix = IntVector
                 .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)
                 .add(offset);
-             */
-             assert false : "Unhandled case for Multi-field based MaxVector";
         } else {
             vix = IntVector
                 .fromArray(isp, indexMap, mapOffset)
@@ -4968,11 +4969,9 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
             // indexShape is still S_MAX_BIT, but the lane count of int vector
             // is 64. So when loading index vector (IntVector), only lower half
             // of index data is needed.
-            /*vix = IntVector
+            vix = IntVector
                 .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)
                 .add(offset);
-             */
-            assert false : "Unhandled case for Multi-field based MaxVector";
         } else {
             vix = IntVector
                 .fromArray(isp, indexMap, mapOffset)
@@ -5160,12 +5159,9 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
             // indexShape is still S_MAX_BIT, but the lane count of int vector
             // is 64. So when loading index vector (IntVector), only lower half
             // of index data is needed.
-            /*vix = IntVector
+            vix = IntVector
                 .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)
                 .add(offset);
-             */
-             assert false : "Unhandled case for Multi-field based MaxVector";
-
         } else {
             vix = IntVector
                 .fromArray(isp, indexMap, mapOffset)
@@ -5717,9 +5713,8 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         @Override
         @ForceInline
         public final $abstractvectortype$ zero() {
-            // FIXME: Enable once multi-field based MaxVector is supported.
-            //if ((Class<?>) vectorType() == $Type$MaxVector.class)
-            //    return $Type$MaxVector.ZERO;
+            if ((Class<?>) vectorType() == $Type$MaxVector.class)
+               return $Type$MaxVector.ZERO;
             switch (vectorBitSize()) {
                 case 64: return $Type$64Vector.ZERO;
                 case 128: return $Type$128Vector.ZERO;
@@ -5732,9 +5727,8 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         @Override
         @ForceInline
         public final $abstractvectortype$ iota() {
-            // FIXME: Enable once multi-field based MaxVector is supported.
-            //if ((Class<?>) vectorType() == $Type$MaxVector.class)
-            //    return $Type$MaxVector.IOTA;
+            if ((Class<?>) vectorType() == $Type$MaxVector.class)
+                return $Type$MaxVector.IOTA;
             switch (vectorBitSize()) {
                 case 64: return $Type$64Vector.IOTA;
                 case 128: return $Type$128Vector.IOTA;
@@ -5748,9 +5742,8 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         @Override
         @ForceInline
         public final VectorMask<$Boxtype$> maskAll(boolean bit) {
-            // FIXME: Enable once multi-field based MaxVector is supported.
-            //if ((Class<?>) vectorType() == $Type$MaxVector.class)
-            //    return $Type$MaxVector.$Type$MaxMask.maskAll(bit);
+            if ((Class<?>) vectorType() == $Type$MaxVector.class)
+                return $Type$MaxVector.$Type$MaxMask.maskAll(bit);
             switch (vectorBitSize()) {
                 case 64: return $Type$64Vector.$Type$64Mask.maskAll(bit);
                 case 128: return $Type$128Vector.$Type$128Mask.maskAll(bit);
@@ -5785,8 +5778,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
             case VectorShape.SK_128_BIT: return ($Type$Species) SPECIES_128;
             case VectorShape.SK_256_BIT: return ($Type$Species) SPECIES_256;
             case VectorShape.SK_512_BIT: return ($Type$Species) SPECIES_512;
-            // FIXME: Enable once multi-field based MaxVector is supported.
-            //case VectorShape.SK_Max_BIT: return ($Type$Species) SPECIES_MAX;
+            case VectorShape.SK_Max_BIT: return ($Type$Species) SPECIES_MAX;
             default: throw new IllegalArgumentException("Bad shape: " + s);
         }
     }
@@ -5820,13 +5812,11 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
                             $Type$512Vector::new);
 
     /** Species representing {@link $Type$Vector}s of {@link VectorShape#S_Max_BIT VectorShape.S_Max_BIT}. */
-    // FIXME: Enable once multi-field based MaxVector is supported.
-    /*public static final VectorSpecies<$Boxtype$> SPECIES_MAX
+    public static final VectorSpecies<$Boxtype$> SPECIES_MAX
         = new $Type$Species(VectorShape.S_Max_BIT,
                             $Type$MaxVector.class,
                             $Type$MaxVector.$Type$MaxMask.class,
                             $Type$MaxVector::new);
-     */
 
     /**
      * Preferred species for {@link $Type$Vector}s.
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/X-VectorBits.java.template b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/X-VectorBits.java.template
index a60ee3950df..0c2528b33a0 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/X-VectorBits.java.template
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/X-VectorBits.java.template
@@ -69,8 +69,8 @@ value class $vectortype$ extends $abstractvectortype$ {
         return payload;
     }
 
-    static final $vectortype$ ZERO = new $vectortype$(VectorPayloadMF.newInstanceFactory($type$.class, $numLanes$));
-    static final $vectortype$ IOTA = new $vectortype$(VectorPayloadMF.createVectPayloadInstance$Boxinitials$($numLanes$, ($type$[])(VSPECIES.iotaArray())));
+    static final $vectortype$ ZERO = new $vectortype$(VectorPayloadMF.newVectorInstanceFactory($type$.class, $numLanes$, ((AbstractSpecies)VSPECIES).is_max_species()));
+    static final $vectortype$ IOTA = new $vectortype$(VectorPayloadMF.createVectPayloadInstance$Boxinitials$($numLanes$, ($type$[])(VSPECIES.iotaArray()), ((AbstractSpecies)VSPECIES).is_max_species()));
 
     static {
         // Warm up a few species caches.
@@ -833,18 +833,27 @@ value class $vectortype$ extends $abstractvectortype$ {
         static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
         static final Class<$Boxtype$> ETYPE = $type$.class; // used by the JVM
 
+#if[Max]
+        private final VectorPayloadMF$vectorsizeinbytes$$Boxbitsinitials$Z payload;
+#else[Max]
         private final VectorPayloadMF$vectorsizeinbytes$Z payload;
+#end[Max]
+
 
         $masktype$(VectorPayloadMF payload) {
+#if[Max]
+            this.payload = (VectorPayloadMF$vectorsizeinbytes$$Boxbitsinitials$Z) payload;
+#else[Max]
             this.payload = (VectorPayloadMF$vectorsizeinbytes$Z) payload;
+#end[Max]
         }
 
         $masktype$(VectorPayloadMF payload, int offset) {
-            this(prepare(payload, offset, VLENGTH));
+            this(prepare(payload, offset, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         $masktype$(boolean val) {
-            this(prepare(val, VLENGTH));
+            this(prepare(val, ETYPE, VLENGTH, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -1001,7 +1010,7 @@ value class $vectortype$ extends $abstractvectortype$ {
 #if[intAndMax]
 
         static VectorPayloadMF maskLowerHalf() {
-            VectorPayloadMF newObj = VectorPayloadMF.newInstanceFactory(boolean.class, VLENGTH);
+            VectorPayloadMF newObj = VectorPayloadMF.newMaskInstanceFactory(ETYPE, VLENGTH, ((AbstractSpecies)VSPECIES).is_max_species());
             newObj = Unsafe.getUnsafe().makePrivateBuffer(newObj);
             long mf_offset = newObj.multiFieldOffset();
             int len = VLENGTH >> 1;
@@ -1024,10 +1033,19 @@ value class $vectortype$ extends $abstractvectortype$ {
         static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
         static final Class<$Boxtype$> ETYPE = $type$.class; // used by the JVM
 
+#if[Max]
+        private final VectorPayloadMF$vectorsizeinbytes$$Boxbitsinitials$B payload;
+#else[Max]
         private final VectorPayloadMF$vectorsizeinbytes$B payload;
+#end[Max]
+
 
         $shuffletype$(VectorPayloadMF payload) {
+#if[Max]
+            this.payload = (VectorPayloadMF$vectorsizeinbytes$$Boxbitsinitials$B) payload;
+#else[Max]
             this.payload = (VectorPayloadMF$vectorsizeinbytes$B) payload;
+#end[Max]
             assert(VLENGTH == payload.length());
             assert(indexesInRange(payload));
         }
@@ -1037,11 +1055,11 @@ value class $vectortype$ extends $abstractvectortype$ {
         }
 
         public $shuffletype$(int[] indexes, int i) {
-            this(prepare(VLENGTH, indexes, i));
+            this(prepare(ETYPE, VLENGTH, indexes, i, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         public $shuffletype$(IntUnaryOperator fn) {
-            this(prepare(VLENGTH, fn));
+            this(prepare(ETYPE, VLENGTH, fn, ((AbstractSpecies)(VSPECIES)).is_max_species()));
         }
 
         @ForceInline
@@ -1086,7 +1104,7 @@ value class $vectortype$ extends $abstractvectortype$ {
             $shuffletype$ s = ($shuffletype$) shuffle;
             VectorPayloadMF indices1 = indices();
             VectorPayloadMF indices2 = s.indices();
-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);
+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, ((AbstractSpecies)VSPECIES).is_max_species());
             r = Unsafe.getUnsafe().makePrivateBuffer(r);
             long offset = r.multiFieldOffset();
             for (int i = 0; i < VLENGTH; i++) {
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/gen-src.sh b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/gen-src.sh
old mode 100644
new mode 100755
index c3a9f19bd18..e08b2cd11a1
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/gen-src.sh
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/gen-src.sh
@@ -148,8 +148,7 @@ do
   esac
 
   old_args="$args"
-  # for bits in 64 128 256 512 Max
-  for bits in 64 128 256 512
+  for bits in 64 128 256 512 Max
   do
     vectortype=${typeprefix}${Type}${bits}Vector
     masktype=${typeprefix}${Type}${bits}Mask
@@ -178,6 +177,7 @@ do
 
     if [[ "${bits}" == "Max" ]]; then
         vectorindextype="vix.getClass()"
+        vectorsizeinbytes="${bits}"
     else
         vectorindextype="Int${vectorindexbits}Vector.class"
     fi;
