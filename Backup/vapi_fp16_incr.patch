diff --git a/src/hotspot/share/classfile/vmIntrinsics.hpp b/src/hotspot/share/classfile/vmIntrinsics.hpp
index 24324405bbe..359b634fbca 100644
--- a/src/hotspot/share/classfile/vmIntrinsics.hpp
+++ b/src/hotspot/share/classfile/vmIntrinsics.hpp
@@ -1004,7 +1004,6 @@ class methodHandle;
                                       "Ljava/lang/Class;"                                                                                      \
                                       "Ljava/lang/Class;"                                                                                      \
                                       "Ljava/lang/Class;"                                                                                      \
-                                      "Ljava/lang/Class;"                                                                                      \
                                       "I"                                                                                                      \
                                       "I"                                                                                                      \
                                       "Ljdk/internal/vm/vector/VectorSupport$Vector;"                                                          \
@@ -1018,7 +1017,6 @@ class methodHandle;
                                        "Ljava/lang/Class;"                                                                                     \
                                        "Ljava/lang/Class;"                                                                                     \
                                        "Ljava/lang/Class;"                                                                                     \
-                                       "Ljava/lang/Class;"                                                                                     \
                                        "I"                                                                                                     \
                                        "I"                                                                                                     \
                                        "Ljdk/internal/vm/vector/VectorSupport$VectorPayload;"                                                  \
@@ -1056,7 +1054,6 @@ class methodHandle;
                                         "Ljava/lang/Class;"                                                                                    \
                                         "Ljava/lang/Class;"                                                                                    \
                                         "Ljava/lang/Class;"                                                                                    \
-                                        "Ljava/lang/Class;"                                                                                    \
                                         "I"                                                                                                    \
                                         "I"                                                                                                    \
                                         "Ljdk/internal/vm/vector/VectorSupport$Vector;"                                                        \
@@ -1069,7 +1066,6 @@ class methodHandle;
                                                                                                                                                \
   do_intrinsic(_VectorSelectFromTwoVectorOp, jdk_internal_vm_vector_VectorSupport, vector_select_from_op_name, vector_select_from_op_sig, F_S) \
    do_signature(vector_select_from_op_sig, "(Ljava/lang/Class;"                                                                                \
-                                            "Ljava/lang/Class;"                                                                                \
                                             "Ljava/lang/Class;"                                                                                \
                                             "I"                                                                                                \
                                             "I"                                                                                                \
@@ -1082,7 +1078,6 @@ class methodHandle;
                                                                                                                                                \
   do_intrinsic(_VectorFromBitsCoerced, jdk_internal_vm_vector_VectorSupport, vector_frombits_coerced_name, vector_frombits_coerced_sig, F_S)   \
    do_signature(vector_frombits_coerced_sig, "(Ljava/lang/Class;"                                                                              \
-                                               "Ljava/lang/Class;"                                                                             \
                                                "Ljava/lang/Class;"                                                                             \
                                                "I"                                                                                             \
                                                "I"                                                                                             \
@@ -1095,7 +1090,6 @@ class methodHandle;
                                                                                                                                                \
   do_intrinsic(_VectorLoadOp, jdk_internal_vm_vector_VectorSupport, vector_load_op_name, vector_load_op_sig, F_S)                              \
    do_signature(vector_load_op_sig, "(Ljava/lang/Class;"                                                                                       \
-                                     "Ljava/lang/Class;"                                                                                       \
                                      "Ljava/lang/Class;"                                                                                       \
                                      "I"                                                                                                       \
                                      "I"                                                                                                       \
@@ -1111,7 +1105,6 @@ class methodHandle;
                                                                                                                                                \
   do_intrinsic(_VectorLoadMaskedOp, jdk_internal_vm_vector_VectorSupport, vector_load_masked_op_name, vector_load_masked_op_sig, F_S)          \
    do_signature(vector_load_masked_op_sig, "(Ljava/lang/Class;"                                                                                \
-                                            "Ljava/lang/Class;"                                                                                \
                                             "Ljava/lang/Class;"                                                                                \
                                             "Ljava/lang/Class;"                                                                                \
                                             "I"                                                                                                \
@@ -1130,7 +1123,6 @@ class methodHandle;
                                                                                                                                                \
   do_intrinsic(_VectorStoreOp, jdk_internal_vm_vector_VectorSupport, vector_store_op_name, vector_store_op_sig, F_S)                           \
    do_signature(vector_store_op_sig, "(Ljava/lang/Class;"                                                                                      \
-                                      "Ljava/lang/Class;"                                                                                      \
                                       "Ljava/lang/Class;"                                                                                      \
                                       "I"                                                                                                      \
                                       "I"                                                                                                      \
@@ -1146,7 +1138,6 @@ class methodHandle;
                                                                                                                                                \
   do_intrinsic(_VectorStoreMaskedOp, jdk_internal_vm_vector_VectorSupport, vector_store_masked_op_name, vector_store_masked_op_sig, F_S)       \
    do_signature(vector_store_masked_op_sig, "(Ljava/lang/Class;"                                                                               \
-                                             "Ljava/lang/Class;"                                                                               \
                                              "Ljava/lang/Class;"                                                                               \
                                              "Ljava/lang/Class;"                                                                               \
                                              "I"                                                                                               \
@@ -1167,7 +1158,6 @@ class methodHandle;
                                                "Ljava/lang/Class;"                                                                             \
                                                "Ljava/lang/Class;"                                                                             \
                                                "Ljava/lang/Class;"                                                                             \
-                                               "Ljava/lang/Class;"                                                                             \
                                                "I"                                                                                             \
                                                "I"                                                                                             \
                                                "Ljdk/internal/vm/vector/VectorSupport$Vector;"                                                 \
@@ -1178,7 +1168,6 @@ class methodHandle;
                                                                                                                                                \
   do_intrinsic(_VectorTest, jdk_internal_vm_vector_VectorSupport, vector_test_name, vector_test_sig, F_S)                                      \
    do_signature(vector_test_sig, "(I"                                                                                                          \
-                                  "Ljava/lang/Class;"                                                                                          \
                                   "Ljava/lang/Class;"                                                                                          \
                                   "Ljava/lang/Class;"                                                                                          \
                                   "I"                                                                                                          \
@@ -1191,7 +1180,6 @@ class methodHandle;
                                                                                                                                                \
   do_intrinsic(_VectorBlend, jdk_internal_vm_vector_VectorSupport, vector_blend_name, vector_blend_sig, F_S)                                   \
    do_signature(vector_blend_sig, "(Ljava/lang/Class;"                                                                                         \
-                                   "Ljava/lang/Class;"                                                                                         \
                                    "Ljava/lang/Class;"                                                                                         \
                                    "Ljava/lang/Class;"                                                                                         \
                                    "I"                                                                                                         \
@@ -1208,7 +1196,6 @@ class methodHandle;
                                      "Ljava/lang/Class;"                                                                                       \
                                      "Ljava/lang/Class;"                                                                                       \
                                      "Ljava/lang/Class;"                                                                                       \
-                                     "Ljava/lang/Class;"                                                                                       \
                                      "I"                                                                                                       \
                                      "I"                                                                                                       \
                                      "Ljdk/internal/vm/vector/VectorSupport$Vector;"                                                           \
@@ -1223,7 +1210,6 @@ class methodHandle;
                                        "Ljava/lang/Class;"                                                                                     \
                                        "Ljava/lang/Class;"                                                                                     \
                                        "Ljava/lang/Class;"                                                                                     \
-                                       "Ljava/lang/Class;"                                                                                     \
                                        "I"                                                                                                     \
                                        "I"                                                                                                     \
                                        "Ljdk/internal/vm/vector/VectorSupport$Vector;"                                                         \
@@ -1235,7 +1221,6 @@ class methodHandle;
                                                                                                                                                \
   do_intrinsic(_VectorSelectFrom, jdk_internal_vm_vector_VectorSupport, vector_select_from_name, vector_select_from_sig, F_S)                  \
    do_signature(vector_select_from_sig, "(Ljava/lang/Class;"                                                                                   \
-                                        "Ljava/lang/Class;"                                                                                     \
                                         "Ljava/lang/Class;"                                                                                     \
                                         "Ljava/lang/Class;"                                                                                     \
                                         "I"                                                                                                     \
@@ -1249,7 +1234,6 @@ class methodHandle;
                                                                                                                                                \
   do_intrinsic(_VectorExtract, jdk_internal_vm_vector_VectorSupport, vector_extract_name, vector_extract_sig, F_S)                             \
    do_signature(vector_extract_sig, "(Ljava/lang/Class;"                                                                                       \
-                                     "Ljava/lang/Class;"                                                                                       \
                                      "Ljava/lang/Class;"                                                                                       \
                                      "I"                                                                                                       \
                                      "I"                                                                                                       \
@@ -1261,7 +1245,6 @@ class methodHandle;
                                                                                                                                                \
  do_intrinsic(_VectorInsert, jdk_internal_vm_vector_VectorSupport, vector_insert_name, vector_insert_sig, F_S)                                 \
    do_signature(vector_insert_sig, "(Ljava/lang/Class;"                                                                                        \
-                                    "Ljava/lang/Class;"                                                                                        \
                                     "Ljava/lang/Class;"                                                                                        \
                                     "I"                                                                                                        \
                                     "I"                                                                                                        \
@@ -1276,7 +1259,6 @@ class methodHandle;
                                            "Ljava/lang/Class;"                                                                                 \
                                            "Ljava/lang/Class;"                                                                                 \
                                            "Ljava/lang/Class;"                                                                                 \
-                                           "Ljava/lang/Class;"                                                                                 \
                                            "I"                                                                                                 \
                                            "I"                                                                                                 \
                                            "Ljdk/internal/vm/vector/VectorSupport$Vector;"                                                     \
@@ -1302,7 +1284,6 @@ class methodHandle;
                                                                                                                                                \
    do_intrinsic(_VectorGatherOp, jdk_internal_vm_vector_VectorSupport, vector_gather_name, vector_gather_sig, F_S)                             \
     do_signature(vector_gather_sig, "(Ljava/lang/Class;"                                                                                       \
-                                     "Ljava/lang/Class;"                                                                                       \
                                      "Ljava/lang/Class;"                                                                                       \
                                      "Ljava/lang/Class;"                                                                                       \
                                      "I"                                                                                                       \
@@ -1325,7 +1306,6 @@ class methodHandle;
                                                                                                                                                \
    do_intrinsic(_VectorScatterOp, jdk_internal_vm_vector_VectorSupport, vector_scatter_name, vector_scatter_sig, F_S)                          \
     do_signature(vector_scatter_sig, "(Ljava/lang/Class;"                                                                                      \
-                                      "Ljava/lang/Class;"                                                                                      \
                                       "Ljava/lang/Class;"                                                                                      \
                                       "Ljava/lang/Class;"                                                                                      \
                                       "I"                                                                                                      \
@@ -1349,7 +1329,6 @@ class methodHandle;
                                                                                                                                                \
   do_intrinsic(_VectorMaskOp, jdk_internal_vm_vector_VectorSupport, vector_mask_oper_name, vector_mask_oper_sig, F_S)                          \
     do_signature(vector_mask_oper_sig, "(I"                                                                                                    \
-                                        "Ljava/lang/Class;"                                                                                    \
                                         "Ljava/lang/Class;"                                                                                    \
                                         "Ljava/lang/Class;"                                                                                    \
                                         "I"                                                                                                    \
@@ -1364,7 +1343,6 @@ class methodHandle;
                                       "Ljava/lang/Class;"                                                                                      \
                                       "Ljava/lang/Class;"                                                                                      \
                                       "Ljava/lang/Class;"                                                                                      \
-                                      "Ljava/lang/Class;"                                                                                      \
                                       "I"                                                                                                      \
                                       "I"                                                                                                      \
                                       "Ljdk/internal/vm/vector/VectorSupport$Vector;"                                                          \
@@ -1375,7 +1353,6 @@ class methodHandle;
                                                                                                                                                \
   do_intrinsic(_IndexVector, jdk_internal_vm_vector_VectorSupport, index_vector_op_name, index_vector_op_sig, F_S)                             \
     do_signature(index_vector_op_sig, "(Ljava/lang/Class;"                                                                                     \
-                                       "Ljava/lang/Class;"                                                                                     \
                                        "Ljava/lang/Class;"                                                                                     \
                                        "I"                                                                                                     \
                                        "I"                                                                                                     \
@@ -1388,7 +1365,6 @@ class methodHandle;
                                                                                                                                                \
   do_intrinsic(_IndexPartiallyInUpperRange, jdk_internal_vm_vector_VectorSupport, index_partially_in_upper_range_name, index_partially_in_upper_range_sig, F_S)\
     do_signature(index_partially_in_upper_range_sig, "(Ljava/lang/Class;"                                                                                      \
-                                                     "Ljava/lang/Class;"                                                                                       \
                                                      "Ljava/lang/Class;"                                                                                       \
                                                      "I"                                                                                                       \
                                                      "I"                                                                                                       \
diff --git a/src/hotspot/share/opto/vectorIntrinsics.cpp b/src/hotspot/share/opto/vectorIntrinsics.cpp
index c4da08b65bf..6fa2ade909b 100644
--- a/src/hotspot/share/opto/vectorIntrinsics.cpp
+++ b/src/hotspot/share/opto/vectorIntrinsics.cpp
@@ -35,6 +35,18 @@ static bool is_vector(ciKlass* klass) {
   return klass->is_subclass_of(ciEnv::current()->vector_VectorPayload_klass());
 }
 
+static const char* get_opertype_string(int operType) {
+  switch(operType) {
+    case VectorSupport::VECTOR_TYPE_PRIM:
+      return "VECTOR_TYPE_PRIM";
+    case VectorSupport::VECTOR_TYPE_FP16:
+      return "VECTOR_TYPE_FP16";
+    default:
+      ShouldNotReachHere();
+      return nullptr;
+  }
+}
+
 static bool check_vbox(const TypeInstPtr* vbox_type) {
   assert(vbox_type->klass_is_exact(), "");
 
@@ -293,7 +305,7 @@ static bool is_klass_initialized(const TypeInstPtr* vec_klass) {
 //   M extends VectorMask<E>,
 //   E>
 //  V unaryOp(int oprId,
-//            Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,
+//            Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, int operType,
 //            int length,
 //            V v, M m,
 //            UnaryOperation<V, M> defaultImpl) {
@@ -303,7 +315,7 @@ static bool is_klass_initialized(const TypeInstPtr* vec_klass) {
 //   M extends VectorMask<E>,
 //   E>
 //  VM binaryOp(int oprId,
-//              Class<? extends VM> vmClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,
+//              Class<? extends VM> vmClass, Class<? extends M> mClass, Class<?> cClass, int operType,
 //              int length,
 //              VM v1, VM v2, M m,
 //              BinaryOperation<VM, M> defaultImpl) {
@@ -314,7 +326,7 @@ static bool is_klass_initialized(const TypeInstPtr* vec_klass) {
 //   M extends VectorMask<E>,
 //   E>
 //  V ternaryOp(int oprId,
-//              Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,
+//              Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, int operType,
 //              int length,
 //              V v1, V v2, V v3, M m,
 //              TernaryOperation<V, M> defaultImpl) {
@@ -325,19 +337,20 @@ bool LibraryCallKit::inline_vector_nary_operation(int n) {
   const TypeInstPtr* vector_klass = gvn().type(argument(1))->isa_instptr();
   const TypeInstPtr* mask_klass   = gvn().type(argument(2))->isa_instptr();
   const TypeInstPtr* elem_klass   = gvn().type(argument(3))->isa_instptr();
-  const TypeInt*     opr_type     = gvn().type(argument(5))->isa_int();
-  const TypeInt*     vlen         = gvn().type(argument(6))->isa_int();
+  const TypeInt*     operType     = gvn().type(argument(4))->isa_int();
+  const TypeInt*     vlen         = gvn().type(argument(5))->isa_int();
 
-  if (opr          == nullptr || !opr->is_con() || !opr_type->is_con() ||
+  if (opr          == nullptr || !opr->is_con() ||
+      operType     == nullptr || !operType->is_con() ||
       vector_klass == nullptr || vector_klass->const_oop() == nullptr ||
       elem_klass   == nullptr || elem_klass->const_oop()   == nullptr ||
       vlen         == nullptr || !vlen->is_con()) {
-    log_if_needed("  ** missing constant: opr=%s vclass=%s etype=%s opr_type=%s vlen=%s",
+    log_if_needed("  ** missing constant: opr=%s vclass=%s etype=%s operType=%s vlen=%s",
                     NodeClassNames[argument(0)->Opcode()],
                     NodeClassNames[argument(1)->Opcode()],
                     NodeClassNames[argument(3)->Opcode()],
-                    NodeClassNames[argument(5)->Opcode()],
-                    NodeClassNames[argument(6)->Opcode()]);
+                    NodeClassNames[argument(4)->Opcode()],
+                    NodeClassNames[argument(5)->Opcode()]);
     return false; // not enough info for intrinsification
   }
 
@@ -353,7 +366,7 @@ bool LibraryCallKit::inline_vector_nary_operation(int n) {
 
   // "argument(n + 5)" should be the mask object. We assume it is "null" when no mask
   // is used to control this operation.
-  const Type* vmask_type = gvn().type(argument(n + 7));
+  const Type* vmask_type = gvn().type(argument(n + 6));
   bool is_masked_op = vmask_type != TypePtr::NULL_PTR;
   if (is_masked_op) {
     if (mask_klass == nullptr || mask_klass->const_oop() == nullptr) {
@@ -377,7 +390,7 @@ bool LibraryCallKit::inline_vector_nary_operation(int n) {
   bool is_unsigned = VectorSupport::is_unsigned_op(opr->get_con());
 
   int num_elem = vlen->get_con();
-  int opc = VectorSupport::vop2ideal(opr->get_con(), elem_bt, opr_type->get_con());
+  int opc = VectorSupport::vop2ideal(opr->get_con(), elem_bt, operType->get_con());
   int sopc = has_scalar_op ? VectorNode::opcode(opc, elem_bt) : opc;
   if (sopc == 0 || num_elem == 1) {
     log_if_needed("  ** operation not supported: arity=%d opc=%s[%d] vlen=%d etype=%s",
@@ -412,28 +425,28 @@ bool LibraryCallKit::inline_vector_nary_operation(int n) {
   Node* opd1 = nullptr; Node* opd2 = nullptr; Node* opd3 = nullptr;
   switch (n) {
     case 3: {
-      opd3 = unbox_vector(argument(9), vbox_type, elem_bt, num_elem);
+      opd3 = unbox_vector(argument(8), vbox_type, elem_bt, num_elem);
       if (opd3 == nullptr) {
         log_if_needed("  ** unbox failed v3=%s",
-                        NodeClassNames[argument(7)->Opcode()]);
+                        NodeClassNames[argument(8)->Opcode()]);
         return false;
       }
       // fall-through
     }
     case 2: {
-      opd2 = unbox_vector(argument(8), vbox_type, elem_bt, num_elem);
+      opd2 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);
       if (opd2 == nullptr) {
         log_if_needed("  ** unbox failed v2=%s",
-                        NodeClassNames[argument(6)->Opcode()]);
+                        NodeClassNames[argument(7)->Opcode()]);
         return false;
       }
       // fall-through
     }
     case 1: {
-      opd1 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);
+      opd1 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);
       if (opd1 == nullptr) {
         log_if_needed("  ** unbox failed v1=%s",
-                        NodeClassNames[argument(5)->Opcode()]);
+                        NodeClassNames[argument(6)->Opcode()]);
         return false;
       }
       break;
@@ -446,10 +459,10 @@ bool LibraryCallKit::inline_vector_nary_operation(int n) {
     ciKlass* mbox_klass = mask_klass->const_oop()->as_instance()->java_lang_Class_klass();
     assert(is_vector_mask(mbox_klass), "argument(2) should be a mask class");
     const TypeInstPtr* mbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, mbox_klass);
-    mask = unbox_vector(argument(n + 7), mbox_type, elem_bt, num_elem);
+    mask = unbox_vector(argument(n + 6), mbox_type, elem_bt, num_elem);
     if (mask == nullptr) {
       log_if_needed("  ** unbox failed mask=%s",
-                      NodeClassNames[argument(n + 7)->Opcode()]);
+                      NodeClassNames[argument(n + 6)->Opcode()]);
       return false;
     }
   }
@@ -491,13 +504,13 @@ bool LibraryCallKit::inline_vector_nary_operation(int n) {
 //
 //  public static
 //  <V extends Vector<E>, E>
-//  V libraryUnaryOp(long addr, Class<? extends V> vClass, Class<?> cClass, Class<E> eClass, int operType, int length, String debugName,
+//  V libraryUnaryOp(long addr, Class<? extends V> vClass, Class<?> cClass, int operType, int length, String debugName,
 //                   V v,
 //                   UnaryOperation<V,?> defaultImpl)
 //
 //  public static
 //  <V extends VectorPayload, E>
-//  V libraryBinaryOp(long addr, Class<? extends V> vClass, Class<?> cClass, Class<E> eClass, int operType, int length, String debugName,
+//  V libraryBinaryOp(long addr, Class<? extends V> vClass, Class<?> cClass, int operType, int length, String debugName,
 //                    V v1, V v2,
 //                    BinaryOperation<V,?> defaultImpl)
 //
@@ -507,20 +520,23 @@ bool LibraryCallKit::inline_vector_call(int arity) {
   const TypeLong*    entry          = gvn().type(argument(0))->isa_long();
   const TypeInstPtr* vector_klass   = gvn().type(argument(2))->isa_instptr();
   const TypeInstPtr* elem_klass     = gvn().type(argument(3))->isa_instptr();
-  const TypeInt*     vlen           = gvn().type(argument(6))->isa_int();
-  const TypeInstPtr* debug_name_oop = gvn().type(argument(7))->isa_instptr();
+  const TypeInt*     operType       = gvn().type(argument(4))->isa_int();
+  const TypeInt*     vlen           = gvn().type(argument(5))->isa_int();
+  const TypeInstPtr* debug_name_oop = gvn().type(argument(6))->isa_instptr();
 
   if (entry        == nullptr   || !entry->is_con() ||
       vector_klass == nullptr   || vector_klass->const_oop() == nullptr ||
       elem_klass   == nullptr   || elem_klass->const_oop() == nullptr ||
-      vlen         == nullptr   || !vlen->is_con() ||
+      operType     == nullptr   || !operType->is_con() ||
+      vlen  == nullptr   || !vlen->is_con() ||
       debug_name_oop == nullptr || debug_name_oop->const_oop() == nullptr) {
-    log_if_needed("  ** missing constant: opr=%s vclass=%s etype=%s vlen=%s debug_name=%s",
+    log_if_needed("  ** missing constant: opr=%s vclass=%s etype=%s operType=%s vlen=%s debug_name=%s",
                   NodeClassNames[argument(0)->Opcode()],
                   NodeClassNames[argument(2)->Opcode()],
                   NodeClassNames[argument(3)->Opcode()],
-                  NodeClassNames[argument(6)->Opcode()],
-                  NodeClassNames[argument(7)->Opcode()]);
+                  NodeClassNames[argument(4)->Opcode()],
+                  NodeClassNames[argument(5)->Opcode()],
+                  NodeClassNames[argument(6)->Opcode()]);
     return false; // not enough info for intrinsification
   }
 
@@ -529,6 +545,11 @@ bool LibraryCallKit::inline_vector_call(int arity) {
     return false;
   }
 
+  if (operType->get_con() != VectorSupport::VECTOR_TYPE_PRIM) {
+    log_if_needed("  ** unhandled operType=%s", get_opertype_string(operType->get_con()));
+    return false;
+  }
+
   ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();
   if (!elem_type->is_primitive_type()) {
     log_if_needed("  ** not a primitive bt=%d", elem_type->basic_type());
@@ -550,17 +571,17 @@ bool LibraryCallKit::inline_vector_call(int arity) {
   ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();
   const TypeInstPtr* vbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);
 
-  Node* opd1 = unbox_vector(argument(8), vbox_type, elem_bt, num_elem);
+  Node* opd1 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);
   if (opd1 == nullptr) {
-    log_if_needed("  ** unbox failed v1=%s", NodeClassNames[argument(8)->Opcode()]);
+    log_if_needed("  ** unbox failed v1=%s", NodeClassNames[argument(7)->Opcode()]);
     return false;
   }
 
   Node* opd2 = nullptr;
   if (arity > 1) {
-    opd2 = unbox_vector(argument(9), vbox_type, elem_bt, num_elem);
+    opd2 = unbox_vector(argument(8), vbox_type, elem_bt, num_elem);
     if (opd2 == nullptr) {
-      log_if_needed("  ** unbox failed v2=%s", NodeClassNames[argument(9)->Opcode()]);
+      log_if_needed("  ** unbox failed v2=%s", NodeClassNames[argument(8)->Opcode()]);
       return false;
     }
   }
@@ -597,7 +618,7 @@ bool LibraryCallKit::inline_vector_call(int arity) {
 //  <M extends VectorMask<E>,
 //   E>
 //  long maskReductionCoerced(int oper,
-//                            Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,
+//                            Class<? extends M> mClass, Class<?> cClass, int operType,
 //                            int length,
 //                            M m,
 //                            VectorMaskOp<M> defaultImpl)
@@ -606,17 +627,24 @@ bool LibraryCallKit::inline_vector_mask_operation() {
   const TypeInt*     oper       = gvn().type(argument(0))->isa_int();
   const TypeInstPtr* mask_klass = gvn().type(argument(1))->isa_instptr();
   const TypeInstPtr* elem_klass = gvn().type(argument(2))->isa_instptr();
-  const TypeInt*     vlen       = gvn().type(argument(5))->isa_int();
-  Node*              mask       = argument(6);
+  const TypeInt*     operType   = gvn().type(argument(3))->isa_int();
+  const TypeInt*     vlen       = gvn().type(argument(4))->isa_int();
+  Node*              mask       = argument(5);
 
   if (mask_klass == nullptr || mask_klass->const_oop() == nullptr ||
       elem_klass == nullptr || elem_klass->const_oop() == nullptr ||
+      operType   == nullptr || !operType->is_con() ||
       vlen       == nullptr || !vlen->is_con() ||
       oper       == nullptr || !oper->is_con() ||
       mask->is_top()) {
     return false; // dead code
   }
 
+  if (operType->get_con() != VectorSupport::VECTOR_TYPE_PRIM) {
+    log_if_needed("  ** unhandled operType=%s", get_opertype_string(operType->get_con()));
+    return false;
+  }
+
   if (!is_klass_initialized(mask_klass)) {
     log_if_needed("  ** klass argument not initialized");
     return false;
@@ -644,7 +672,7 @@ bool LibraryCallKit::inline_vector_mask_operation() {
   Node* mask_vec = unbox_vector(mask, mask_box_type, elem_bt, num_elem);
   if (mask_vec == nullptr) {
     log_if_needed("  ** unbox failed mask=%s",
-                      NodeClassNames[argument(6)->Opcode()]);
+                      NodeClassNames[argument(5)->Opcode()]);
     return false;
   }
 
@@ -667,7 +695,7 @@ bool LibraryCallKit::inline_vector_mask_operation() {
 //  <VM extends VectorPayload,
 //   S extends VectorSpecies<E>,
 //   E>
-//  VM fromBitsCoerced(Class<? extends VM> vmClass, Class<?> cClass, Class<E> eClass, int operType,
+//  VM fromBitsCoerced(Class<? extends VM> vmClass, Class<?> cClass, int operType,
 //                     int length,
 //                     long bits, int mode, S s,
 //                     FromBitsCoercedOperation<VM, S> defaultImpl)
@@ -675,26 +703,35 @@ bool LibraryCallKit::inline_vector_mask_operation() {
 bool LibraryCallKit::inline_vector_frombits_coerced() {
   const TypeInstPtr* vector_klass = gvn().type(argument(0))->isa_instptr();
   const TypeInstPtr* elem_klass   = gvn().type(argument(1))->isa_instptr();
-  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();
-  const TypeLong*    bits_type    = gvn().type(argument(5))->isa_long();
+  const TypeInt*     operType     = gvn().type(argument(2))->isa_int();
+  const TypeInt*     vlen         = gvn().type(argument(3))->isa_int();
+  const TypeLong*    bits_type    = gvn().type(argument(4))->isa_long();
   // Mode argument determines the mode of operation it can take following values:-
   // MODE_BROADCAST for vector Vector.broadcast and VectorMask.maskAll operations.
   // MODE_BITS_COERCED_LONG_TO_MASK for VectorMask.fromLong operation.
-  const TypeInt*     mode         = gvn().type(argument(7))->isa_int();
+  const TypeInt*     mode         = gvn().type(argument(6))->isa_int();
 
   if (vector_klass == nullptr || vector_klass->const_oop() == nullptr ||
       elem_klass   == nullptr || elem_klass->const_oop()   == nullptr ||
+      operType     == nullptr || !operType->is_con() ||
       vlen         == nullptr || !vlen->is_con() ||
       bits_type    == nullptr ||
       mode         == nullptr || !mode->is_con()) {
-    log_if_needed("  ** missing constant: vclass=%s etype=%s vlen=%s bitwise=%s",
+    log_if_needed("  ** missing constant: vclass=%s etype=%s operType=%s vlen=%s bitwise=%s",
                     NodeClassNames[argument(0)->Opcode()],
                     NodeClassNames[argument(1)->Opcode()],
-                    NodeClassNames[argument(4)->Opcode()],
-                    NodeClassNames[argument(7)->Opcode()]);
+                    NodeClassNames[argument(2)->Opcode()],
+                    NodeClassNames[argument(3)->Opcode()],
+                    NodeClassNames[argument(6)->Opcode()]);
     return false; // not enough info for intrinsification
   }
 
+
+  if (operType->get_con() != VectorSupport::VECTOR_TYPE_PRIM) {
+    log_if_needed("  ** unhandled operType=%s", get_opertype_string(operType->get_con()));
+    return false;
+  }
+
   if (!is_klass_initialized(vector_klass)) {
     log_if_needed("  ** klass argument not initialized");
     return false;
@@ -732,7 +769,7 @@ bool LibraryCallKit::inline_vector_frombits_coerced() {
   }
 
   Node* broadcast = nullptr;
-  Node* bits = argument(5);
+  Node* bits = argument(4);
   Node* elem = bits;
 
   if (opc == Op_VectorLongToMask) {
@@ -801,7 +838,7 @@ static bool elem_consistent_with_arr(BasicType elem_bt, const TypeAryPtr* arr_ty
 //   VM extends VectorPayload,
 //   E,
 //   S extends VectorSpecies<E>>
-//  VM load(Class<? extends VM> vmClass, Class<?> cClass, Class<E> eClass, int operType,
+//  VM load(Class<? extends VM> vmClass, Class<?> cClass, int operType,
 //          int length,
 //          Object base, long offset, boolean fromSegment,
 //          C container, long index, S s,
@@ -811,7 +848,7 @@ static bool elem_consistent_with_arr(BasicType elem_bt, const TypeAryPtr* arr_ty
 //  public static
 //  <C,
 //   V extends VectorPayload>
-//  void store(Class<?> vClass, Class<?> cClass, Class<?> eClass, int operType,
+//  void store(Class<?> vClass, Class<?> cClass, int operType,
 //             int length,
 //             Object base, long offset, boolean fromSegment,
 //             V v, C container, long index,
@@ -820,18 +857,21 @@ static bool elem_consistent_with_arr(BasicType elem_bt, const TypeAryPtr* arr_ty
 bool LibraryCallKit::inline_vector_mem_operation(bool is_store) {
   const TypeInstPtr* vector_klass = gvn().type(argument(0))->isa_instptr();
   const TypeInstPtr* elem_klass   = gvn().type(argument(1))->isa_instptr();
-  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();
-  const TypeInt*     from_ms      = gvn().type(argument(8))->isa_int();
+  const TypeInt*     operType     = gvn().type(argument(2))->isa_int();
+  const TypeInt*     vlen         = gvn().type(argument(3))->isa_int();
+  const TypeInt*     from_ms      = gvn().type(argument(7))->isa_int();
 
   if (vector_klass == nullptr || vector_klass->const_oop() == nullptr ||
       elem_klass   == nullptr || elem_klass->const_oop()   == nullptr ||
+      operType     == nullptr || !operType->is_con() ||
       vlen         == nullptr || !vlen->is_con() ||
       from_ms      == nullptr || !from_ms->is_con()) {
-    log_if_needed("  ** missing constant: vclass=%s etype=%s vlen=%s from_ms=%s",
+    log_if_needed("  ** missing constant: vclass=%s etype=%s operType=%s vlen=%s from_ms=%s",
                     NodeClassNames[argument(0)->Opcode()],
                     NodeClassNames[argument(1)->Opcode()],
-                    NodeClassNames[argument(4)->Opcode()],
-                    NodeClassNames[argument(8)->Opcode()]);
+                    NodeClassNames[argument(2)->Opcode()],
+                    NodeClassNames[argument(3)->Opcode()],
+                    NodeClassNames[argument(7)->Opcode()]);
     return false; // not enough info for intrinsification
   }
   if (!is_klass_initialized(vector_klass)) {
@@ -858,8 +898,8 @@ bool LibraryCallKit::inline_vector_mem_operation(bool is_store) {
   ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();
   bool is_mask = is_vector_mask(vbox_klass);
 
-  Node* base = argument(5);
-  Node* offset = ConvL2X(argument(6));
+  Node* base = argument(4);
+  Node* offset = ConvL2X(argument(5));
 
   // Save state and restore on bailout
   SavedState old_state(this);
@@ -941,7 +981,7 @@ bool LibraryCallKit::inline_vector_mem_operation(bool is_store) {
   }
 
   if (is_store) {
-    Node* val = unbox_vector(argument(9), vbox_type, elem_bt, num_elem);
+    Node* val = unbox_vector(argument(8), vbox_type, elem_bt, num_elem);
     if (val == nullptr) {
       return false; // operand unboxing failed
     }
@@ -996,7 +1036,7 @@ bool LibraryCallKit::inline_vector_mem_operation(bool is_store) {
 //   E,
 //   S extends VectorSpecies<E>,
 //   M extends VectorMask<E>>
-//  V loadMasked(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,
+//  V loadMasked(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, int operType,
 //               int length, Object base, long offset, boolean fromSegment,
 //               M m, int offsetInRange,
 //               C container, long index, S s,
@@ -1007,7 +1047,7 @@ bool LibraryCallKit::inline_vector_mem_operation(bool is_store) {
 //   V extends Vector<E>,
 //   M extends VectorMask<E>,
 //   E>
-//  void storeMasked(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,
+//  void storeMasked(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, int operType,
 //                   int length,
 //                   Object base, long offset, boolean fromSegment,
 //                   V v, M m, C container, long index,
@@ -1018,22 +1058,26 @@ bool LibraryCallKit::inline_vector_mem_masked_operation(bool is_store) {
   const TypeInstPtr* vector_klass = gvn().type(argument(0))->isa_instptr();
   const TypeInstPtr* mask_klass   = gvn().type(argument(1))->isa_instptr();
   const TypeInstPtr* elem_klass   = gvn().type(argument(2))->isa_instptr();
-  const TypeInt*     vlen         = gvn().type(argument(5))->isa_int();
-  const TypeInt*     from_ms      = gvn().type(argument(9))->isa_int();
+  const TypeInt*     operType     = gvn().type(argument(3))->isa_int();
+  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();
+  const TypeInt*     from_ms      = gvn().type(argument(8))->isa_int();
 
   if (vector_klass == nullptr || vector_klass->const_oop() == nullptr ||
       mask_klass   == nullptr || mask_klass->const_oop()   == nullptr ||
       elem_klass   == nullptr || elem_klass->const_oop()   == nullptr ||
+      operType     == nullptr || !operType->is_con() ||
       vlen         == nullptr || !vlen->is_con() ||
       from_ms      == nullptr || !from_ms->is_con()) {
-    log_if_needed("  ** missing constant: vclass=%s mclass=%s etype=%s vlen=%s from_ms=%s",
+    log_if_needed("  ** missing constant: vclass=%s mclass=%s etype=%s operType=%s vlen=%s from_ms=%s",
                     NodeClassNames[argument(0)->Opcode()],
                     NodeClassNames[argument(1)->Opcode()],
                     NodeClassNames[argument(2)->Opcode()],
-                    NodeClassNames[argument(5)->Opcode()],
-                    NodeClassNames[argument(9)->Opcode()]);
+                    NodeClassNames[argument(3)->Opcode()],
+                    NodeClassNames[argument(4)->Opcode()],
+                    NodeClassNames[argument(8)->Opcode()]);
     return false; // not enough info for intrinsification
   }
+
   if (!is_klass_initialized(vector_klass)) {
     log_if_needed("  ** klass argument not initialized");
     return false;
@@ -1053,8 +1097,8 @@ bool LibraryCallKit::inline_vector_mem_masked_operation(bool is_store) {
   BasicType elem_bt = elem_type->basic_type();
   int num_elem = vlen->get_con();
 
-  Node* base = argument(6);
-  Node* offset = ConvL2X(argument(7));
+  Node* base = argument(5);
+  Node* offset = ConvL2X(argument(6));
 
   // Save state and restore on bailout
   SavedState old_state(this);
@@ -1087,7 +1131,7 @@ bool LibraryCallKit::inline_vector_mem_masked_operation(bool is_store) {
       needs_predicate = true;
     } else {
       // Masked vector load with IOOBE always uses the predicated load.
-      const TypeInt* offset_in_range = gvn().type(argument(11))->isa_int();
+      const TypeInt* offset_in_range = gvn().type(argument(10))->isa_int();
       if (!offset_in_range->is_con()) {
         log_if_needed("  ** missing constant: offsetInRange=%s",
                         NodeClassNames[argument(10)->Opcode()]);
@@ -1145,19 +1189,19 @@ bool LibraryCallKit::inline_vector_mem_masked_operation(bool is_store) {
   const TypeInstPtr* vbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);
   const TypeInstPtr* mbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, mbox_klass);
 
-  Node* mask = unbox_vector(is_store ? argument(11) : argument(10), mbox_type, elem_bt, num_elem);
+  Node* mask = unbox_vector(is_store ? argument(10) : argument(9), mbox_type, elem_bt, num_elem);
   if (mask == nullptr) {
     log_if_needed("  ** unbox failed mask=%s",
-                    is_store ? NodeClassNames[argument(11)->Opcode()]
-                             : NodeClassNames[argument(10)->Opcode()]);
+                    is_store ? NodeClassNames[argument(10)->Opcode()]
+                             : NodeClassNames[argument(9)->Opcode()]);
     return false;
   }
 
   if (is_store) {
-    Node* val = unbox_vector(argument(10), vbox_type, elem_bt, num_elem);
+    Node* val = unbox_vector(argument(9), vbox_type, elem_bt, num_elem);
     if (val == nullptr) {
       log_if_needed("  ** unbox failed vector=%s",
-                      NodeClassNames[argument(10)->Opcode()]);
+                      NodeClassNames[argument(9)->Opcode()]);
       return false; // operand unboxing failed
     }
     set_all_memory(reset_memory());
@@ -1222,7 +1266,7 @@ bool LibraryCallKit::inline_vector_mem_masked_operation(bool is_store) {
 //   S extends VectorSpecies<E>,
 //   M extends VectorMask<E>,
 //   E>
-//  V loadWithMap(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,
+//  V loadWithMap(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, int operType,
 //                int length,
 //                Class<? extends Vector<Integer>> vectorIndexClass,
 //                int indexLength, Object base, long offset,
@@ -1235,7 +1279,7 @@ bool LibraryCallKit::inline_vector_mem_masked_operation(bool is_store) {
 //   W extends Vector<Integer>,
 //   M extends VectorMask<E>,
 //   E>
-//  void storeWithMap(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,
+//  void storeWithMap(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, int operType,
 //                    int length,
 //                    Class<? extends Vector<Integer>> vectorIndexClass,
 //                    int indexLength, Object base, long offset,
@@ -1248,21 +1292,24 @@ bool LibraryCallKit::inline_vector_gather_scatter(bool is_scatter) {
   const TypeInstPtr* vector_klass     = gvn().type(argument(0))->isa_instptr();
   const TypeInstPtr* mask_klass       = gvn().type(argument(1))->isa_instptr();
   const TypeInstPtr* elem_klass       = gvn().type(argument(2))->isa_instptr();
-  const TypeInt*     vlen             = gvn().type(argument(5))->isa_int();
-  const TypeInstPtr* vector_idx_klass = gvn().type(argument(6))->isa_instptr();
-  const TypeInt*     idx_vlen         = gvn().type(argument(7))->isa_int();
+  const TypeInt*     operType         = gvn().type(argument(3))->isa_int();
+  const TypeInt*     vlen             = gvn().type(argument(4))->isa_int();
+  const TypeInstPtr* vector_idx_klass = gvn().type(argument(5))->isa_instptr();
+  const TypeInt*     idx_vlen         = gvn().type(argument(6))->isa_int();
 
   if (vector_klass     == nullptr || vector_klass->const_oop()     == nullptr ||
       elem_klass       == nullptr || elem_klass->const_oop()       == nullptr ||
+      operType         == nullptr || !operType->is_con() ||
       vlen             == nullptr || !vlen->is_con() ||
       vector_idx_klass == nullptr || vector_idx_klass->const_oop() == nullptr ||
       idx_vlen         == nullptr || !idx_vlen->is_con()) {
-    log_if_needed("  ** missing constant: vclass=%s etype=%s vlen=%s viclass=%s idx_vlen=%s",
+    log_if_needed("  ** missing constant: vclass=%s etype=%s operType=%s vlen=%s viclass=%s idx_vlen=%s",
                     NodeClassNames[argument(0)->Opcode()],
                     NodeClassNames[argument(2)->Opcode()],
+                    NodeClassNames[argument(3)->Opcode()],
+                    NodeClassNames[argument(4)->Opcode()],
                     NodeClassNames[argument(5)->Opcode()],
-                    NodeClassNames[argument(6)->Opcode()],
-                    NodeClassNames[argument(7)->Opcode()]);
+                    NodeClassNames[argument(6)->Opcode()]);
     return false; // not enough info for intrinsification
   }
 
@@ -1281,7 +1328,7 @@ bool LibraryCallKit::inline_vector_gather_scatter(bool is_scatter) {
   int num_elem = vlen->get_con();
   int idx_num_elem = idx_vlen->get_con();
 
-  Node* m = is_scatter ? argument(13) : argument(15);
+  Node* m = is_scatter ? argument(12) : argument(14);
   const Type* vmask_type = gvn().type(m);
   bool is_masked_op = vmask_type != TypePtr::NULL_PTR;
   if (is_masked_op) {
@@ -1327,8 +1374,8 @@ bool LibraryCallKit::inline_vector_gather_scatter(bool is_scatter) {
     return false; // not supported
   }
 
-  Node* base = argument(8);
-  Node* offset = ConvL2X(argument(9));
+  Node* base = argument(7);
+  Node* offset = ConvL2X(argument(8));
 
   // Save state and restore on bailout
   SavedState old_state(this);
@@ -1341,7 +1388,7 @@ bool LibraryCallKit::inline_vector_gather_scatter(bool is_scatter) {
     uint header = arrayOopDesc::base_offset_in_bytes(elem_bt);
     assert(offset->is_Con() && offset->bottom_type()->is_long()->get_con() == header,
            "offset must be the array base offset");
-    Node* index = argument(17);
+    Node* index = argument(16);
     addr = array_element_address(base, index, elem_bt);
   }
 
@@ -1367,12 +1414,12 @@ bool LibraryCallKit::inline_vector_gather_scatter(bool is_scatter) {
   Node* indexes = nullptr;
   const TypeInstPtr* vbox_idx_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_idx_klass);
   if (is_subword_type(elem_bt)) {
-    Node* indexMap = argument(18);
-    Node* indexM   = argument(19);
+    Node* indexMap = argument(17);
+    Node* indexM   = argument(18);
     indexes = array_element_address(indexMap, indexM, T_INT);
   } else {
     // Get the first index vector.
-    indexes = unbox_vector(argument(11), vbox_idx_type, T_INT, idx_num_elem);
+    indexes = unbox_vector(argument(10), vbox_idx_type, T_INT, idx_num_elem);
     if (indexes == nullptr) {
       return false;
     }
@@ -1392,7 +1439,7 @@ bool LibraryCallKit::inline_vector_gather_scatter(bool is_scatter) {
 
   const TypeVect* vector_type = TypeVect::make(elem_bt, num_elem);
   if (is_scatter) {
-    Node* val = unbox_vector(argument(12), vbox_type, elem_bt, num_elem);
+    Node* val = unbox_vector(argument(11), vbox_type, elem_bt, num_elem);
     if (val == nullptr) {
       return false; // operand unboxing failed
     }
@@ -1427,7 +1474,7 @@ bool LibraryCallKit::inline_vector_gather_scatter(bool is_scatter) {
 //   M extends VectorMask<E>,
 //   E>
 //  long reductionCoerced(int oprId,
-//                        Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,
+//                        Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, int operType,
 //                        int length,
 //                        V v, M m,
 //                        ReductionOperation<V, M> defaultImpl)
@@ -1437,17 +1484,19 @@ bool LibraryCallKit::inline_vector_reduction() {
   const TypeInstPtr* vector_klass = gvn().type(argument(1))->isa_instptr();
   const TypeInstPtr* mask_klass   = gvn().type(argument(2))->isa_instptr();
   const TypeInstPtr* elem_klass   = gvn().type(argument(3))->isa_instptr();
-  const TypeInt*     vlen         = gvn().type(argument(6))->isa_int();
+  const TypeInt*     operType     = gvn().type(argument(4))->isa_int();
+  const TypeInt*     vlen         = gvn().type(argument(5))->isa_int();
 
-  if (opr          == nullptr || !opr->is_con() ||
+  if (opr          == nullptr || !opr->is_con() || !operType->is_con() ||
       vector_klass == nullptr || vector_klass->const_oop() == nullptr ||
       elem_klass   == nullptr || elem_klass->const_oop()   == nullptr ||
       vlen         == nullptr || !vlen->is_con()) {
-    log_if_needed("  ** missing constant: opr=%s vclass=%s etype=%s vlen=%s",
+    log_if_needed("  ** missing constant: opr=%s vclass=%s etype=%s operType=%s vlen=%s",
                     NodeClassNames[argument(0)->Opcode()],
                     NodeClassNames[argument(1)->Opcode()],
                     NodeClassNames[argument(3)->Opcode()],
-                    NodeClassNames[argument(4)->Opcode()]);
+                    NodeClassNames[argument(4)->Opcode()],
+                    NodeClassNames[argument(5)->Opcode()]);
     return false; // not enough info for intrinsification
   }
   if (!is_klass_initialized(vector_klass)) {
@@ -1459,12 +1508,16 @@ bool LibraryCallKit::inline_vector_reduction() {
     log_if_needed("  ** not a primitive bt=%d", elem_type->basic_type());
     return false; // should be primitive type
   }
+  if (operType->get_con() != VectorSupport::VECTOR_TYPE_PRIM) {
+    log_if_needed("  ** unhandled operType=%s", get_opertype_string(operType->get_con()));
+    return false;
+  }
 
-  const Type* vmask_type = gvn().type(argument(8));
+  const Type* vmask_type = gvn().type(argument(7));
   bool is_masked_op = vmask_type != TypePtr::NULL_PTR;
   if (is_masked_op) {
     if (mask_klass == nullptr || mask_klass->const_oop() == nullptr) {
-      log_if_needed("  ** missing constant: maskclass=%s", NodeClassNames[argument(4)->Opcode()]);
+      log_if_needed("  ** missing constant: maskclass=%s", NodeClassNames[argument(2)->Opcode()]);
       return false; // not enough info for intrinsification
     }
 
@@ -1503,7 +1556,7 @@ bool LibraryCallKit::inline_vector_reduction() {
   ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();
   const TypeInstPtr* vbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);
 
-  Node* opd = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);
+  Node* opd = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);
   if (opd == nullptr) {
     return false; // operand unboxing failed
   }
@@ -1513,10 +1566,10 @@ bool LibraryCallKit::inline_vector_reduction() {
     ciKlass* mbox_klass = mask_klass->const_oop()->as_instance()->java_lang_Class_klass();
     assert(is_vector_mask(mbox_klass), "argument(2) should be a mask class");
     const TypeInstPtr* mbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, mbox_klass);
-    mask = unbox_vector(argument(8), mbox_type, elem_bt, num_elem);
+    mask = unbox_vector(argument(7), mbox_type, elem_bt, num_elem);
     if (mask == nullptr) {
       log_if_needed("  ** unbox failed mask=%s",
-                      NodeClassNames[argument(8)->Opcode()]);
+                      NodeClassNames[argument(7)->Opcode()]);
       return false;
     }
   }
@@ -1576,7 +1629,7 @@ bool LibraryCallKit::inline_vector_reduction() {
 //  <M extends VectorMask<E>,
 //   E>
 //  boolean test(int cond,
-//               Class<?> mClass, Class<?> cClass, Class<E> eClass, int opType,
+//               Class<?> mClass, Class<?> cClass, int operType,
 //               int length,
 //               M m1, M m2,
 //               BiFunction<M, M, Boolean> defaultImpl)
@@ -1586,19 +1639,28 @@ bool LibraryCallKit::inline_vector_test() {
   const TypeInt*     cond         = gvn().type(argument(0))->isa_int();
   const TypeInstPtr* vector_klass = gvn().type(argument(1))->isa_instptr();
   const TypeInstPtr* elem_klass   = gvn().type(argument(2))->isa_instptr();
-  const TypeInt*     vlen         = gvn().type(argument(5))->isa_int();
+  const TypeInt*     operType     = gvn().type(argument(3))->isa_int();
+  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();
 
   if (cond         == nullptr || !cond->is_con() ||
       vector_klass == nullptr || vector_klass->const_oop() == nullptr ||
       elem_klass   == nullptr || elem_klass->const_oop()   == nullptr ||
+      operType     == nullptr || !operType->is_con() ||
       vlen         == nullptr || !vlen->is_con()) {
-    log_if_needed("  ** missing constant: cond=%s vclass=%s etype=%s vlen=%s",
+    log_if_needed("  ** missing constant: cond=%s vclass=%s etype=%s operType=%s vlen=%s",
                     NodeClassNames[argument(0)->Opcode()],
                     NodeClassNames[argument(1)->Opcode()],
                     NodeClassNames[argument(2)->Opcode()],
-                    NodeClassNames[argument(5)->Opcode()]);
+                    NodeClassNames[argument(3)->Opcode()],
+                    NodeClassNames[argument(4)->Opcode()]);
     return false; // not enough info for intrinsification
   }
+
+  if (operType->get_con() != VectorSupport::VECTOR_TYPE_PRIM) {
+    log_if_needed("  ** unhandled operType=%s", get_opertype_string(operType->get_con()));
+    return false;
+  }
+
   if (!is_klass_initialized(vector_klass)) {
     log_if_needed("  ** klass argument not initialized");
     return false;
@@ -1621,11 +1683,11 @@ bool LibraryCallKit::inline_vector_test() {
     return false;
   }
 
-  Node* opd1 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);
+  Node* opd1 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);
   Node* opd2;
   if (Matcher::vectortest_needs_second_argument(booltest == BoolTest::overflow,
                                                 opd1->bottom_type()->isa_vectmask())) {
-    opd2 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);
+    opd2 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);
   } else {
     opd2 = opd1;
   }
@@ -1649,7 +1711,7 @@ bool LibraryCallKit::inline_vector_test() {
 //  <V extends Vector<E>,
 //   M extends VectorMask<E>,
 //   E>
-//  V blend(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,
+//  V blend(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, int operType,
 //          int length,
 //          V v1, V v2, M m,
 //          VectorBlendOp<V, M> defaultImpl)
@@ -1658,20 +1720,23 @@ bool LibraryCallKit::inline_vector_blend() {
   const TypeInstPtr* vector_klass = gvn().type(argument(0))->isa_instptr();
   const TypeInstPtr* mask_klass   = gvn().type(argument(1))->isa_instptr();
   const TypeInstPtr* elem_klass   = gvn().type(argument(2))->isa_instptr();
-  const TypeInt*     vlen         = gvn().type(argument(5))->isa_int();
+  const TypeInt*     operType     = gvn().type(argument(3))->isa_int();
+  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();
 
-  if (mask_klass == nullptr || vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr) {
+  if (mask_klass == nullptr || vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr || operType == nullptr) {
     return false; // dead code
   }
   if (mask_klass->const_oop() == nullptr || vector_klass->const_oop() == nullptr ||
-      elem_klass->const_oop() == nullptr || !vlen->is_con()) {
-    log_if_needed("  ** missing constant: vclass=%s mclass=%s etype=%s vlen=%s",
+      elem_klass->const_oop() == nullptr || !vlen->is_con() || !operType->is_con()) {
+    log_if_needed("  ** missing constant: vclass=%s mclass=%s etype=%s operType=%s vlen=%s",
                     NodeClassNames[argument(0)->Opcode()],
                     NodeClassNames[argument(1)->Opcode()],
                     NodeClassNames[argument(2)->Opcode()],
-                    NodeClassNames[argument(5)->Opcode()]);
+                    NodeClassNames[argument(3)->Opcode()],
+                    NodeClassNames[argument(4)->Opcode()]);
     return false; // not enough info for intrinsification
   }
+
   if (!is_klass_initialized(vector_klass) || !is_klass_initialized(mask_klass)) {
     log_if_needed("  ** klass argument not initialized");
     return false;
@@ -1696,9 +1761,9 @@ bool LibraryCallKit::inline_vector_blend() {
   ciKlass* mbox_klass = mask_klass->const_oop()->as_instance()->java_lang_Class_klass();
   const TypeInstPtr* mbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, mbox_klass);
 
-  Node* v1   = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);
-  Node* v2   = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);
-  Node* mask = unbox_vector(argument(8), mbox_type, mask_bt, num_elem);
+  Node* v1   = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);
+  Node* v2   = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);
+  Node* mask = unbox_vector(argument(7), mbox_type, mask_bt, num_elem);
 
   if (v1 == nullptr || v2 == nullptr || mask == nullptr) {
     return false; // operand unboxing failed
@@ -1719,7 +1784,7 @@ bool LibraryCallKit::inline_vector_blend() {
 //   M extends VectorMask<E>,
 //   E>
 //  M compare(int cond,
-//            Class<? extends V> vectorClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,
+//            Class<? extends V> vectorClass, Class<M> mClass, Class<?> cClass, int operType,
 //            int length,
 //            V v1, V v2, M m,
 //            VectorCompareOp<V, M> defaultImpl)
@@ -1729,21 +1794,29 @@ bool LibraryCallKit::inline_vector_compare() {
   const TypeInstPtr* vector_klass = gvn().type(argument(1))->isa_instptr();
   const TypeInstPtr* mask_klass   = gvn().type(argument(2))->isa_instptr();
   const TypeInstPtr* elem_klass   = gvn().type(argument(3))->isa_instptr();
-  const TypeInt*     vlen         = gvn().type(argument(6))->isa_int();
+  const TypeInt*     operType     = gvn().type(argument(4))->isa_int();
+  const TypeInt*     vlen         = gvn().type(argument(5))->isa_int();
 
-  if (cond == nullptr || vector_klass == nullptr || mask_klass == nullptr || elem_klass == nullptr || vlen == nullptr) {
+  if (cond == nullptr || vector_klass == nullptr || mask_klass == nullptr || elem_klass == nullptr || operType == nullptr || vlen == nullptr) {
     return false; // dead code
   }
   if (!cond->is_con() || vector_klass->const_oop() == nullptr || mask_klass->const_oop() == nullptr ||
-      elem_klass->const_oop() == nullptr || !vlen->is_con()) {
-    log_if_needed("  ** missing constant: cond=%s vclass=%s mclass=%s etype=%s vlen=%s",
+      elem_klass->const_oop() == nullptr || !operType->is_con() || !vlen->is_con()) {
+    log_if_needed("  ** missing constant: cond=%s vclass=%s mclass=%s etype=%s operType=%s vlen=%s",
                     NodeClassNames[argument(0)->Opcode()],
                     NodeClassNames[argument(1)->Opcode()],
                     NodeClassNames[argument(2)->Opcode()],
                     NodeClassNames[argument(3)->Opcode()],
-                    NodeClassNames[argument(6)->Opcode()]);
+                    NodeClassNames[argument(4)->Opcode()],
+                    NodeClassNames[argument(5)->Opcode()]);
     return false; // not enough info for intrinsification
   }
+
+  if (operType->get_con() != VectorSupport::VECTOR_TYPE_PRIM) {
+    log_if_needed("  ** unhandled operType=%s", get_opertype_string(operType->get_con()));
+    return false;
+  }
+
   if (!is_klass_initialized(vector_klass) || !is_klass_initialized(mask_klass)) {
     log_if_needed("  ** klass argument not initialized");
     return false;
@@ -1778,11 +1851,11 @@ bool LibraryCallKit::inline_vector_compare() {
   ciKlass* mbox_klass = mask_klass->const_oop()->as_instance()->java_lang_Class_klass();
   const TypeInstPtr* mbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, mbox_klass);
 
-  Node* v1 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);
-  Node* v2 = unbox_vector(argument(8), vbox_type, elem_bt, num_elem);
+  Node* v1 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);
+  Node* v2 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);
 
-  bool is_masked_op = argument(9)->bottom_type() != TypePtr::NULL_PTR;
-  Node* mask = is_masked_op ? unbox_vector(argument(9), mbox_type, elem_bt, num_elem) : nullptr;
+  bool is_masked_op = argument(8)->bottom_type() != TypePtr::NULL_PTR;
+  Node* mask = is_masked_op ? unbox_vector(argument(8), mbox_type, elem_bt, num_elem) : nullptr;
   if (is_masked_op && mask == nullptr) {
     log_if_needed("  ** not supported: mask = null arity=2 op=comp/%d vlen=%d etype=%s ismask=usestore is_masked_op=1",
                     cond->get_con(), num_elem, type2name(elem_bt));
@@ -1829,7 +1902,7 @@ bool LibraryCallKit::inline_vector_compare() {
 //   SH extends VectorShuffle<E>,
 //   M  extends VectorMask<E>,
 //   E>
-//  V rearrangeOp(Class<? extends V> vClass, Class<SH> shClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,
+//  V rearrangeOp(Class<? extends V> vClass, Class<SH> shClass, Class<M> mClass, Class<?> cClass, int operType,
 //                int length,
 //                V v, SH sh, M m,
 //                VectorRearrangeOp<V, SH, M> defaultImpl)
@@ -1839,20 +1912,23 @@ bool LibraryCallKit::inline_vector_rearrange() {
   const TypeInstPtr* shuffle_klass = gvn().type(argument(1))->isa_instptr();
   const TypeInstPtr* mask_klass    = gvn().type(argument(2))->isa_instptr();
   const TypeInstPtr* elem_klass    = gvn().type(argument(3))->isa_instptr();
-  const TypeInt*     vlen          = gvn().type(argument(6))->isa_int();
+  const TypeInt*     operType      = gvn().type(argument(4))->isa_int();
+  const TypeInt*     vlen          = gvn().type(argument(5))->isa_int();
 
-  if (vector_klass == nullptr  || shuffle_klass == nullptr ||  elem_klass == nullptr || vlen == nullptr) {
+  if (vector_klass == nullptr  || shuffle_klass == nullptr ||  elem_klass == nullptr || operType == nullptr || vlen == nullptr) {
     return false; // dead code
   }
   if (shuffle_klass->const_oop() == nullptr ||
       vector_klass->const_oop()  == nullptr ||
       elem_klass->const_oop()    == nullptr ||
+      !operType->is_con() ||
       !vlen->is_con()) {
-    log_if_needed("  ** missing constant: vclass=%s sclass=%s etype=%s vlen=%s",
+    log_if_needed("  ** missing constant: vclass=%s sclass=%s etype=%s operType=%s vlen=%s",
                     NodeClassNames[argument(0)->Opcode()],
                     NodeClassNames[argument(1)->Opcode()],
                     NodeClassNames[argument(3)->Opcode()],
-                    NodeClassNames[argument(6)->Opcode()]);
+                    NodeClassNames[argument(4)->Opcode()],
+                    NodeClassNames[argument(5)->Opcode()]);
     return false; // not enough info for intrinsification
   }
   if (!is_klass_initialized(vector_klass)  ||
@@ -1885,7 +1961,7 @@ bool LibraryCallKit::inline_vector_rearrange() {
     return false; // not supported
   }
 
-  bool is_masked_op = argument(9)->bottom_type() != TypePtr::NULL_PTR;
+  bool is_masked_op = argument(8)->bottom_type() != TypePtr::NULL_PTR;
   bool use_predicate = is_masked_op;
   if (is_masked_op &&
       (mask_klass == nullptr ||
@@ -1916,8 +1992,8 @@ bool LibraryCallKit::inline_vector_rearrange() {
   ciKlass* shbox_klass = shuffle_klass->const_oop()->as_instance()->java_lang_Class_klass();
   const TypeInstPtr* shbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, shbox_klass);
 
-  Node* v1 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);
-  Node* shuffle = unbox_vector(argument(8), shbox_type, shuffle_bt, num_elem);
+  Node* v1 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);
+  Node* shuffle = unbox_vector(argument(7), shbox_type, shuffle_bt, num_elem);
   const TypeVect* st = TypeVect::make(shuffle_bt, num_elem);
 
   if (v1 == nullptr || shuffle == nullptr) {
@@ -1933,7 +2009,7 @@ bool LibraryCallKit::inline_vector_rearrange() {
   if (is_masked_op) {
     ciKlass* mbox_klass = mask_klass->const_oop()->as_instance()->java_lang_Class_klass();
     const TypeInstPtr* mbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, mbox_klass);
-    mask = unbox_vector(argument(9), mbox_type, elem_bt, num_elem);
+    mask = unbox_vector(argument(8), mbox_type, elem_bt, num_elem);
     if (mask == nullptr) {
       log_if_needed("  ** not supported: arity=3 op=shuffle/rearrange vlen=%d etype=%s ismask=useload is_masked_op=1",
                       num_elem, type2name(elem_bt));
@@ -1970,7 +2046,7 @@ bool LibraryCallKit::inline_vector_rearrange() {
 //  <V extends Vector<E>,
 //   M  extends VectorMask<E>,
 //   E>
-//  V selectFromOp(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,
+//  V selectFromOp(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, int operType,
 //                 int length, V v1, V v2, M m,
 //                 VectorSelectFromOp<V, M> defaultImpl)
 //
@@ -1978,22 +2054,29 @@ bool LibraryCallKit::inline_vector_select_from() {
   const TypeInstPtr* vector_klass  = gvn().type(argument(0))->isa_instptr();
   const TypeInstPtr* mask_klass    = gvn().type(argument(1))->isa_instptr();
   const TypeInstPtr* elem_klass    = gvn().type(argument(2))->isa_instptr();
-  const TypeInt*     vlen          = gvn().type(argument(5))->isa_int();
+  const TypeInt*     operType      = gvn().type(argument(3))->isa_int();
+  const TypeInt*     vlen          = gvn().type(argument(4))->isa_int();
 
-  if (vector_klass == nullptr  || elem_klass == nullptr || vlen == nullptr ||
+  if (vector_klass == nullptr  || elem_klass == nullptr || operType == nullptr || vlen == nullptr ||
       vector_klass->const_oop()  == nullptr ||
       elem_klass->const_oop()    == nullptr ||
+      !operType->is_con() ||
       !vlen->is_con()) {
-    log_if_needed("  ** missing constant: vclass=%s etype=%s vlen=%s",
+    log_if_needed("  ** missing constant: vclass=%s etype=%s operType=%s vlen=%s",
                     NodeClassNames[argument(0)->Opcode()],
                     NodeClassNames[argument(2)->Opcode()],
-                    NodeClassNames[argument(5)->Opcode()]);
+                    NodeClassNames[argument(3)->Opcode()],
+                    NodeClassNames[argument(4)->Opcode()]);
     return false; // not enough info for intrinsification
   }
   if (!is_klass_initialized(vector_klass)) {
     log_if_needed("  ** klass argument not initialized");
     return false;
   }
+  if (operType->get_con() != VectorSupport::VECTOR_TYPE_PRIM) {
+    log_if_needed("  ** unhandled operType=%s", get_opertype_string(operType->get_con()));
+    return false;
+  }
   ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();
   if (!elem_type->is_primitive_type()) {
     log_if_needed("  ** not a primitive bt=%d", elem_type->basic_type());
@@ -2024,7 +2107,7 @@ bool LibraryCallKit::inline_vector_select_from() {
     return false; // not supported
   }
 
-  bool is_masked_op = argument(8)->bottom_type() != TypePtr::NULL_PTR;
+  bool is_masked_op = argument(7)->bottom_type() != TypePtr::NULL_PTR;
   bool use_predicate = is_masked_op;
   if (is_masked_op &&
       (mask_klass == nullptr ||
@@ -2049,9 +2132,9 @@ bool LibraryCallKit::inline_vector_select_from() {
   const TypeInstPtr* vbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);
 
   // v1 is the index vector
-  Node* v1 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);
+  Node* v1 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);
   // v2 is the vector being rearranged
-  Node* v2 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);
+  Node* v2 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);
 
   if (v1 == nullptr) {
     log_if_needed("  ** unbox failed v1=%s", NodeClassNames[argument(6)->Opcode()]);
@@ -2067,7 +2150,7 @@ bool LibraryCallKit::inline_vector_select_from() {
   if (is_masked_op) {
     ciKlass* mbox_klass = mask_klass->const_oop()->as_instance()->java_lang_Class_klass();
     const TypeInstPtr* mbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, mbox_klass);
-    mask = unbox_vector(argument(8), mbox_type, elem_bt, num_elem);
+    mask = unbox_vector(argument(7), mbox_type, elem_bt, num_elem);
     if (mask == nullptr) {
       log_if_needed("  ** unbox failed mask=%s", NodeClassNames[argument(8)->Opcode()]);
       return false;
@@ -2129,7 +2212,7 @@ bool LibraryCallKit::inline_vector_select_from() {
 //     M extends VectorMask<E>,
 //     E>
 //    V broadcastInt(int opr,
-//                   Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,
+//                   Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, int operType,
 //                   int length,
 //                   V v, int n, M m,
 //                   VectorBroadcastIntOp<V, M> defaultImpl) {
@@ -2139,7 +2222,7 @@ bool LibraryCallKit::inline_vector_broadcast_int() {
   const TypeInstPtr* vector_klass = gvn().type(argument(1))->isa_instptr();
   const TypeInstPtr* mask_klass   = gvn().type(argument(2))->isa_instptr();
   const TypeInstPtr* elem_klass   = gvn().type(argument(3))->isa_instptr();
-  const TypeInt*     vlen         = gvn().type(argument(6))->isa_int();
+  const TypeInt*     vlen         = gvn().type(argument(5))->isa_int();
 
   if (opr == nullptr || vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr) {
     return false; // dead code
@@ -2149,7 +2232,7 @@ bool LibraryCallKit::inline_vector_broadcast_int() {
                     NodeClassNames[argument(0)->Opcode()],
                     NodeClassNames[argument(1)->Opcode()],
                     NodeClassNames[argument(3)->Opcode()],
-                    NodeClassNames[argument(6)->Opcode()]);
+                    NodeClassNames[argument(5)->Opcode()]);
     return false; // not enough info for intrinsification
   }
   if (!is_klass_initialized(vector_klass)) {
@@ -2157,7 +2240,7 @@ bool LibraryCallKit::inline_vector_broadcast_int() {
     return false;
   }
 
-  const Type* vmask_type = gvn().type(argument(8));
+  const Type* vmask_type = gvn().type(argument(7));
   bool is_masked_op = vmask_type != TypePtr::NULL_PTR;
   if (is_masked_op) {
     if (mask_klass == nullptr || mask_klass->const_oop() == nullptr) {
@@ -2200,7 +2283,7 @@ bool LibraryCallKit::inline_vector_broadcast_int() {
     return false; // operation not supported
   }
 
-  Node* cnt  = argument(8);
+  Node* cnt  = argument(7);
   const TypeInt* cnt_type = cnt->bottom_type()->isa_int();
 
   ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();
@@ -2226,7 +2309,7 @@ bool LibraryCallKit::inline_vector_broadcast_int() {
     }
   }
 
-  Node* opd1 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);
+  Node* opd1 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);
   Node* opd2 = nullptr;
   if (is_shift) {
     opd2 = vector_shift_count(cnt, opc, elem_bt, num_elem);
@@ -2249,9 +2332,9 @@ bool LibraryCallKit::inline_vector_broadcast_int() {
   if (is_masked_op) {
     ciKlass* mbox_klass = mask_klass->const_oop()->as_instance()->java_lang_Class_klass();
     const TypeInstPtr* mbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, mbox_klass);
-    mask = unbox_vector(argument(9), mbox_type, elem_bt, num_elem);
+    mask = unbox_vector(argument(8), mbox_type, elem_bt, num_elem);
     if (mask == nullptr) {
-      log_if_needed("  ** unbox failed mask=%s", NodeClassNames[argument(9)->Opcode()]);
+      log_if_needed("  ** unbox failed mask=%s", NodeClassNames[argument(8)->Opcode()]);
       return false;
     }
   }
@@ -2472,7 +2555,7 @@ bool LibraryCallKit::inline_vector_convert() {
 //  public static
 //  <V extends Vector<E>,
 //   E>
-//  V insert(Class<? extends V> vClass, Class<?> cClass, Class<E> eClass, int operType,
+//  V insert(Class<? extends V> vClass, Class<?> cClass, int operType,
 //           int length,
 //           V v, int i, long val,
 //           VecInsertOp<V> defaultImpl)
@@ -2480,20 +2563,29 @@ bool LibraryCallKit::inline_vector_convert() {
 bool LibraryCallKit::inline_vector_insert() {
   const TypeInstPtr* vector_klass = gvn().type(argument(0))->isa_instptr();
   const TypeInstPtr* elem_klass   = gvn().type(argument(1))->isa_instptr();
-  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();
-  const TypeInt*     idx          = gvn().type(argument(6))->isa_int();
+  const TypeInt*     operType     = gvn().type(argument(2))->isa_int();
+  const TypeInt*     vlen         = gvn().type(argument(3))->isa_int();
+  const TypeInt*     idx          = gvn().type(argument(5))->isa_int();
 
-  if (vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr || idx == nullptr) {
+  if (vector_klass == nullptr || elem_klass == nullptr || operType == nullptr || vlen == nullptr || idx == nullptr) {
     return false; // dead code
   }
-  if (vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !vlen->is_con() || !idx->is_con()) {
-    log_if_needed("  ** missing constant: vclass=%s etype=%s vlen=%s idx=%s",
+  if (vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !operType->is_con() ||
+      !vlen->is_con() || !idx->is_con()) {
+    log_if_needed("  ** missing constant: vclass=%s etype=%s operType=%s vlen=%s idx=%s",
                     NodeClassNames[argument(0)->Opcode()],
                     NodeClassNames[argument(1)->Opcode()],
-                    NodeClassNames[argument(4)->Opcode()],
-                    NodeClassNames[argument(6)->Opcode()]);
+                    NodeClassNames[argument(2)->Opcode()],
+                    NodeClassNames[argument(3)->Opcode()],
+                    NodeClassNames[argument(5)->Opcode()]);
     return false; // not enough info for intrinsification
   }
+
+  if (operType->get_con() != VectorSupport::VECTOR_TYPE_PRIM) {
+    log_if_needed("  ** unhandled operType=%s", get_opertype_string(operType->get_con()));
+    return false;
+  }
+
   if (!is_klass_initialized(vector_klass)) {
     log_if_needed("  ** klass argument not initialized");
     return false;
@@ -2514,12 +2606,12 @@ bool LibraryCallKit::inline_vector_insert() {
   ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();
   const TypeInstPtr* vbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);
 
-  Node* opd = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);
+  Node* opd = unbox_vector(argument(4), vbox_type, elem_bt, num_elem);
   if (opd == nullptr) {
     return false;
   }
 
-  Node* insert_val = argument(7);
+  Node* insert_val = argument(6);
   assert(gvn().type(insert_val)->isa_long() != nullptr, "expected to be long");
 
   // Convert insert value back to its appropriate type.
@@ -2558,7 +2650,7 @@ bool LibraryCallKit::inline_vector_insert() {
 //  public static
 //  <VM extends VectorPayload,
 //   E>
-//  long extract(Class<? extends VM> vClass, Class<?> cClass, Class<E> eClass, int operType,
+//  long extract(Class<? extends VM> vClass, Class<?> cClass, int operType,
 //               int length,
 //               VM vm, int i,
 //               VecExtractOp<VM> defaultImpl)
@@ -2566,19 +2658,28 @@ bool LibraryCallKit::inline_vector_insert() {
 bool LibraryCallKit::inline_vector_extract() {
   const TypeInstPtr* vector_klass = gvn().type(argument(0))->isa_instptr();
   const TypeInstPtr* elem_klass   = gvn().type(argument(1))->isa_instptr();
-  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();
-  const TypeInt*     idx          = gvn().type(argument(6))->isa_int();
+  const TypeInt*     operType     = gvn().type(argument(2))->isa_int();
+  const TypeInt*     vlen         = gvn().type(argument(3))->isa_int();
+  const TypeInt*     idx          = gvn().type(argument(5))->isa_int();
 
   if (vector_klass == nullptr || vector_klass->const_oop() == nullptr ||
       elem_klass   == nullptr || elem_klass->const_oop()   == nullptr ||
+      operType     == nullptr || !operType->is_con() ||
       vlen         == nullptr || !vlen->is_con() ||
       idx          == nullptr) {
-    log_if_needed("  ** missing constant: vclass=%s etype=%s vlen=%s",
+    log_if_needed("  ** missing constant: vclass=%s etype=%s operType=%s vlen=%s",
                     NodeClassNames[argument(0)->Opcode()],
                     NodeClassNames[argument(1)->Opcode()],
-                    NodeClassNames[argument(2)->Opcode()]);
+                    NodeClassNames[argument(2)->Opcode()],
+                    NodeClassNames[argument(3)->Opcode()]);
     return false; // not enough info for intrinsification
   }
+
+  if (operType->get_con() != VectorSupport::VECTOR_TYPE_PRIM) {
+    log_if_needed("  ** unhandled operType=%s", get_opertype_string(operType->get_con()));
+    return false;
+  }
+
   if (!is_klass_initialized(vector_klass)) {
     log_if_needed("  ** klass argument not initialized");
     return false;
@@ -2599,10 +2700,10 @@ bool LibraryCallKit::inline_vector_extract() {
   if (is_vector_mask(vbox_klass)) {
     // vbox_klass is mask. This is used for VectorMask.laneIsSet(int).
 
-    Node* pos = argument(6); // can be variable
+    Node* pos = argument(5); // can be variable
     if (arch_supports_vector(Op_ExtractUB, num_elem, elem_bt, VecMaskUseAll)) {
       // Transform mask to vector with type of boolean and utilize ExtractUB node.
-      opd = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);
+      opd = unbox_vector(argument(4), vbox_type, elem_bt, num_elem);
       if (opd == nullptr) {
         return false;
       }
@@ -2610,7 +2711,7 @@ bool LibraryCallKit::inline_vector_extract() {
       opd = gvn().transform(new ExtractUBNode(opd, pos));
       opd = gvn().transform(new ConvI2LNode(opd));
     } else if (arch_supports_vector(Op_VectorMaskToLong, num_elem, elem_bt, VecMaskUseLoad)) {
-      opd = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);
+      opd = unbox_vector(argument(4), vbox_type, elem_bt, num_elem);
       if (opd == nullptr) {
         return false;
       }
@@ -2629,7 +2730,7 @@ bool LibraryCallKit::inline_vector_extract() {
   } else {
     // vbox_klass is vector. This is used for Vector.lane(int).
     if (!idx->is_con()) {
-      log_if_needed("  ** missing constant: idx=%s", NodeClassNames[argument(6)->Opcode()]);
+      log_if_needed("  ** missing constant: idx=%s", NodeClassNames[argument(5)->Opcode()]);
       return false; // not enough info for intrinsification
     }
 
@@ -2640,7 +2741,7 @@ bool LibraryCallKit::inline_vector_extract() {
       return false; // not supported
     }
 
-    opd = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);
+    opd = unbox_vector(argument(4), vbox_type, elem_bt, num_elem);
     if (opd == nullptr) {
       return false;
     }
@@ -2744,24 +2845,32 @@ static Node* LowerSelectFromTwoVectorOperation(PhaseGVN& phase, Node* index_vec,
 //  public static
 //  <V extends Vector<E>,
 //   E>
-//  V selectFromTwoVectorOp(Class<? extends V> vClass, Class<?> cClass, Class<E> eClass, int operType, int length,
+//  V selectFromTwoVectorOp(Class<? extends V> vClass, Class<?> cClass, int operType, int length,
 //                          V v1, V v2, V v3,
 //                          SelectFromTwoVector<V> defaultImpl)
 //
 bool LibraryCallKit::inline_vector_select_from_two_vectors() {
   const TypeInstPtr* vector_klass = gvn().type(argument(0))->isa_instptr();
   const TypeInstPtr* elem_klass = gvn().type(argument(1))->isa_instptr();
-  const TypeInt* vlen = gvn().type(argument(4))->isa_int();
+  const TypeInt* operType = gvn().type(argument(2))->isa_int();
+  const TypeInt* vlen = gvn().type(argument(3))->isa_int();
 
-  if (vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr || vector_klass->const_oop() == nullptr ||
-      elem_klass->const_oop() == nullptr ||!vlen->is_con()) {
-    log_if_needed("  ** missing constant: vclass=%s etype=%s vlen=%s",
+  if (vector_klass == nullptr || elem_klass == nullptr || operType == nullptr || vlen == nullptr ||
+      vector_klass->const_oop() == nullptr ||
+      elem_klass->const_oop() == nullptr || !operType->is_con() || !vlen->is_con()) {
+    log_if_needed("  ** missing constant: vclass=%s etype=%s operType=%s vlen=%s",
                     NodeClassNames[argument(0)->Opcode()],
                     NodeClassNames[argument(1)->Opcode()],
-                    NodeClassNames[argument(4)->Opcode()]);
+                    NodeClassNames[argument(2)->Opcode()],
+                    NodeClassNames[argument(3)->Opcode()]);
     return false; // not enough info for intrinsification
   }
 
+  if (operType->get_con() != VectorSupport::VECTOR_TYPE_PRIM) {
+    log_if_needed("  ** unhandled operType=%s", get_opertype_string(operType->get_con()));
+    return false;
+  }
+
   if (!is_klass_initialized(vector_klass)) {
     log_if_needed("  ** klass argument not initialized");
     return false;
@@ -2823,22 +2932,22 @@ bool LibraryCallKit::inline_vector_select_from_two_vectors() {
   ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();
   const TypeInstPtr* vbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);
 
-  Node* opd1 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);
+  Node* opd1 = unbox_vector(argument(4), vbox_type, elem_bt, num_elem);
   if (opd1 == nullptr) {
     log_if_needed("  ** unbox failed v1=%s",
-                  NodeClassNames[argument(5)->Opcode()]);
+                  NodeClassNames[argument(4)->Opcode()]);
     return false;
   }
-  Node* opd2 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);
+  Node* opd2 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);
   if (opd2 == nullptr) {
     log_if_needed("  ** unbox failed v2=%s",
-                  NodeClassNames[argument(6)->Opcode()]);
+                  NodeClassNames[argument(5)->Opcode()]);
     return false;
   }
-  Node* opd3 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);
+  Node* opd3 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);
   if (opd3 == nullptr) {
     log_if_needed("  ** unbox failed v3=%s",
-                  NodeClassNames[argument(7)->Opcode()]);
+                  NodeClassNames[argument(6)->Opcode()]);
     return false;
   }
 
@@ -2871,7 +2980,7 @@ bool LibraryCallKit::inline_vector_select_from_two_vectors() {
 //   M extends VectorMask<E>,
 //   E>
 //  VectorPayload compressExpandOp(int opr,
-//                                 Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,
+//                                 Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, int operType,
 //                                 int length, V v, M m,
 //                                 CompressExpandOperation<V, M> defaultImpl)
 //
@@ -2880,7 +2989,7 @@ bool LibraryCallKit::inline_vector_compress_expand() {
   const TypeInstPtr* vector_klass = gvn().type(argument(1))->isa_instptr();
   const TypeInstPtr* mask_klass   = gvn().type(argument(2))->isa_instptr();
   const TypeInstPtr* elem_klass   = gvn().type(argument(3))->isa_instptr();
-  const TypeInt*     vlen         = gvn().type(argument(6))->isa_int();
+  const TypeInt*     vlen         = gvn().type(argument(5))->isa_int();
 
   if (opr          == nullptr || !opr->is_con() ||
       vector_klass == nullptr || vector_klass->const_oop() == nullptr ||
@@ -2892,7 +3001,7 @@ bool LibraryCallKit::inline_vector_compress_expand() {
                     NodeClassNames[argument(1)->Opcode()],
                     NodeClassNames[argument(2)->Opcode()],
                     NodeClassNames[argument(3)->Opcode()],
-                    NodeClassNames[argument(6)->Opcode()]);
+                    NodeClassNames[argument(5)->Opcode()]);
     return false; // not enough info for intrinsification
   }
 
@@ -2922,22 +3031,22 @@ bool LibraryCallKit::inline_vector_compress_expand() {
   if (opc != Op_CompressM) {
     ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();
     vbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);
-    opd1 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);
+    opd1 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);
     if (opd1 == nullptr) {
       log_if_needed("  ** unbox failed vector=%s",
-                      NodeClassNames[argument(7)->Opcode()]);
+                      NodeClassNames[argument(6)->Opcode()]);
       return false;
     }
   }
 
   ciKlass* mbox_klass = mask_klass->const_oop()->as_instance()->java_lang_Class_klass();
-  assert(is_vector_mask(mbox_klass), "argument(8) should be a mask class");
+  assert(is_vector_mask(mbox_klass), "argument(7) should be a mask class");
   const TypeInstPtr* mbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, mbox_klass);
 
-  Node* mask = unbox_vector(argument(8), mbox_type, elem_bt, num_elem);
+  Node* mask = unbox_vector(argument(7), mbox_type, elem_bt, num_elem);
   if (mask == nullptr) {
     log_if_needed("  ** unbox failed mask=%s",
-                    NodeClassNames[argument(8)->Opcode()]);
+                    NodeClassNames[argument(7)->Opcode()]);
     return false;
   }
 
@@ -2957,7 +3066,7 @@ bool LibraryCallKit::inline_vector_compress_expand() {
 //  <V extends Vector<E>,
 //   E,
 //   S extends VectorSpecies<E>>
-//  V indexVector(Class<? extends V> vClass, Class<?> cClass, Class<E> eClass, int operType,
+//  V indexVector(Class<? extends V> vClass, Class<?> cClass, int operType,
 //                int length,
 //                V v, int step, S s,
 //                IndexOperation<V, S> defaultImpl) {
@@ -2965,18 +3074,26 @@ bool LibraryCallKit::inline_vector_compress_expand() {
 bool LibraryCallKit::inline_index_vector() {
   const TypeInstPtr* vector_klass = gvn().type(argument(0))->isa_instptr();
   const TypeInstPtr* elem_klass   = gvn().type(argument(1))->isa_instptr();
-  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();
+  const TypeInt*     operType     = gvn().type(argument(2))->isa_int();
+  const TypeInt*     vlen         = gvn().type(argument(3))->isa_int();
 
   if (vector_klass == nullptr || vector_klass->const_oop() == nullptr ||
       elem_klass   == nullptr || elem_klass->const_oop()   == nullptr ||
+      operType     == nullptr || !operType->is_con() ||
       vlen         == nullptr || !vlen->is_con() ) {
-    log_if_needed("  ** missing constant: vclass=%s etype=%s vlen=%s",
+    log_if_needed("  ** missing constant: vclass=%s etype=%s operType=%s vlen=%s",
                     NodeClassNames[argument(0)->Opcode()],
                     NodeClassNames[argument(1)->Opcode()],
-                    NodeClassNames[argument(4)->Opcode()]);
+                    NodeClassNames[argument(2)->Opcode()],
+                    NodeClassNames[argument(3)->Opcode()]);
     return false; // not enough info for intrinsification
   }
 
+  if (operType->get_con() != VectorSupport::VECTOR_TYPE_PRIM) {
+    log_if_needed("  ** unhandled operType=%s", get_opertype_string(operType->get_con()));
+    return false;
+  }
+
   if (!is_klass_initialized(vector_klass)) {
     log_if_needed("  ** klass argument not initialized");
     return false;
@@ -3000,7 +3117,7 @@ bool LibraryCallKit::inline_index_vector() {
   int mul_op = VectorSupport::vop2ideal(VectorSupport::VECTOR_OP_MUL, elem_bt);
   int vmul_op = VectorNode::opcode(mul_op, elem_bt);
   bool needs_mul = true;
-  Node* scale = argument(6);
+  Node* scale = argument(5);
   const TypeInt* scale_type = gvn().type(scale)->isa_int();
   // Multiply is not needed if the scale is a constant "1".
   if (scale_type && scale_type->is_con() && scale_type->get_con() == 1) {
@@ -3026,10 +3143,10 @@ bool LibraryCallKit::inline_index_vector() {
 
   ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();
   const TypeInstPtr* vbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);
-  Node* opd = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);
+  Node* opd = unbox_vector(argument(4), vbox_type, elem_bt, num_elem);
   if (opd == nullptr) {
     log_if_needed("  ** unbox failed vector=%s",
-                    NodeClassNames[argument(5)->Opcode()]);
+                    NodeClassNames[argument(4)->Opcode()]);
     return false;
   }
 
@@ -3094,25 +3211,33 @@ bool LibraryCallKit::inline_index_vector() {
 //  public static
 //  <E,
 //   M extends VectorMask<E>>
-//  M indexPartiallyInUpperRange(Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,
+//  M indexPartiallyInUpperRange(Class<? extends M> mClass, Class<?> cClass, int operType,
 //                               int length, long offset, long limit,
 //                               IndexPartiallyInUpperRangeOperation<E, M> defaultImpl)
 //
 bool LibraryCallKit::inline_index_partially_in_upper_range() {
   const TypeInstPtr* mask_klass   = gvn().type(argument(0))->isa_instptr();
   const TypeInstPtr* elem_klass   = gvn().type(argument(1))->isa_instptr();
-  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();
+  const TypeInt*     operType     = gvn().type(argument(2))->isa_int();
+  const TypeInt*     vlen         = gvn().type(argument(3))->isa_int();
 
   if (mask_klass == nullptr || mask_klass->const_oop() == nullptr ||
       elem_klass == nullptr || elem_klass->const_oop() == nullptr ||
+      operType   == nullptr || !operType->is_con() ||
       vlen       == nullptr || !vlen->is_con()) {
-    log_if_needed("  ** missing constant: mclass=%s etype=%s vlen=%s",
+    log_if_needed("  ** missing constant: mclass=%s etype=%s operType=%s vlen=%s",
                     NodeClassNames[argument(0)->Opcode()],
                     NodeClassNames[argument(1)->Opcode()],
-                    NodeClassNames[argument(4)->Opcode()]);
+                    NodeClassNames[argument(2)->Opcode()],
+                    NodeClassNames[argument(3)->Opcode()]);
     return false; // not enough info for intrinsification
   }
 
+  if (operType->get_con() != VectorSupport::VECTOR_TYPE_PRIM) {
+    log_if_needed("  ** unhandled operType=%s", get_opertype_string(operType->get_con()));
+    return false;
+  }
+
   if (!is_klass_initialized(mask_klass)) {
     log_if_needed("  ** klass argument not initialized");
     return false;
@@ -3149,8 +3274,8 @@ bool LibraryCallKit::inline_index_partially_in_upper_range() {
     }
   }
 
-  Node* offset = argument(5);
-  Node* limit = argument(7);
+  Node* offset = argument(4);
+  Node* limit = argument(6);
   if (offset == nullptr || limit == nullptr) {
     log_if_needed("  ** offset or limit argument is null");
     return false; // not supported
diff --git a/src/java.base/share/classes/jdk/internal/misc/X-ScopedMemoryAccess.java.template b/src/java.base/share/classes/jdk/internal/misc/X-ScopedMemoryAccess.java.template
index 7a6bd66ca25..b7cb8d1fcaf 100644
--- a/src/java.base/share/classes/jdk/internal/misc/X-ScopedMemoryAccess.java.template
+++ b/src/java.base/share/classes/jdk/internal/misc/X-ScopedMemoryAccess.java.template
@@ -326,7 +326,7 @@ public final class ScopedMemoryAccess {
     @ForceInline
     public static
     <V extends VectorSupport.Vector<E>, E, S extends VectorSupport.VectorSpecies<E>>
-    V loadFromMemorySegment(Class<? extends V> vmClass, Class<?> c, Class<E> e, int operType, int length,
+    V loadFromMemorySegment(Class<? extends V> vmClass, Class<?> c, int operType, int length,
                          AbstractMemorySegmentImpl msp, long offset,
                          S s,
                          VectorSupport.LoadOperation<AbstractMemorySegmentImpl, V, S> defaultImpl) {
@@ -334,7 +334,7 @@ public final class ScopedMemoryAccess {
         try {
             return loadFromMemorySegmentScopedInternal(
                     msp.sessionImpl(),
-                    vmClass, c, e, operType, length,
+                    vmClass, c, operType, length,
                     msp, offset,
                     s,
                     defaultImpl);
@@ -348,14 +348,14 @@ public final class ScopedMemoryAccess {
     private static
     <V extends VectorSupport.Vector<E>, E, S extends VectorSupport.VectorSpecies<E>>
     V loadFromMemorySegmentScopedInternal(MemorySessionImpl session,
-                                          Class<? extends V> vmClass, Class<?> c, Class<E> e, int operType, int length,
+                                          Class<? extends V> vmClass, Class<?> c, int operType, int length,
                                           AbstractMemorySegmentImpl msp, long offset,
                                           S s,
                                           VectorSupport.LoadOperation<AbstractMemorySegmentImpl, V, S> defaultImpl) {
         try {
             session.checkValidStateRaw();
 
-            return VectorSupport.load(vmClass, c, e, operType, length,
+            return VectorSupport.load(vmClass, c, operType, length,
                     msp.unsafeGetBase(), msp.unsafeGetOffset() + offset, true,
                     msp, offset, s,
                     defaultImpl);
@@ -368,14 +368,14 @@ public final class ScopedMemoryAccess {
     public static
     <V extends VectorSupport.Vector<E>, E, S extends VectorSupport.VectorSpecies<E>,
      M extends VectorSupport.VectorMask<E>>
-    V loadFromMemorySegmentMasked(Class<? extends V> vmClass, Class<M> maskClass, Class<?> c, Class<E> e, int operType,
+    V loadFromMemorySegmentMasked(Class<? extends V> vmClass, Class<M> maskClass, Class<?> c, int operType,
                                   int length, AbstractMemorySegmentImpl msp, long offset, M m, S s, int offsetInRange,
                                   VectorSupport.LoadVectorMaskedOperation<AbstractMemorySegmentImpl, V, S, M> defaultImpl) {
 
         try {
             return loadFromMemorySegmentMaskedScopedInternal(
                     msp.sessionImpl(),
-                    vmClass, maskClass, c, e, operType, length,
+                    vmClass, maskClass, c, operType, length,
                     msp, offset, m,
                     s, offsetInRange,
                     defaultImpl);
@@ -390,14 +390,14 @@ public final class ScopedMemoryAccess {
     <V extends VectorSupport.Vector<E>, E, S extends VectorSupport.VectorSpecies<E>,
      M extends VectorSupport.VectorMask<E>>
     V loadFromMemorySegmentMaskedScopedInternal(MemorySessionImpl session, Class<? extends V> vmClass,
-                                                Class<M> maskClass, Class<?> c, Class<E> e, int operType, int length,
+                                                Class<M> maskClass, Class<?> c, int operType, int length,
                                                 AbstractMemorySegmentImpl msp, long offset, M m,
                                                 S s, int offsetInRange,
                                                 VectorSupport.LoadVectorMaskedOperation<AbstractMemorySegmentImpl, V, S, M> defaultImpl) {
         try {
             session.checkValidStateRaw();
 
-            return VectorSupport.loadMasked(vmClass, maskClass, c, e, operType, length,
+            return VectorSupport.loadMasked(vmClass, maskClass, c, operType, length,
                     msp.unsafeGetBase(), msp.unsafeGetOffset() + offset, true, m, offsetInRange,
                     msp, offset, s,
                     defaultImpl);
@@ -409,7 +409,7 @@ public final class ScopedMemoryAccess {
     @ForceInline
     public static
     <V extends VectorSupport.Vector<E>, E>
-    void storeIntoMemorySegment(Class<? extends V> vmClass, Class<?> c, Class<E> e, int operType, int length,
+    void storeIntoMemorySegment(Class<? extends V> vmClass, Class<?> c, int operType, int length,
                                 V v,
                                 AbstractMemorySegmentImpl msp, long offset,
                                 VectorSupport.StoreVectorOperation<AbstractMemorySegmentImpl, V> defaultImpl) {
@@ -417,7 +417,7 @@ public final class ScopedMemoryAccess {
         try {
             storeIntoMemorySegmentScopedInternal(
                     msp.sessionImpl(),
-                    vmClass, c, e, operType, length,
+                    vmClass, c, operType, length,
                     v,
                     msp, offset,
                     defaultImpl);
@@ -431,14 +431,14 @@ public final class ScopedMemoryAccess {
     private static
     <V extends VectorSupport.Vector<E>, E>
     void storeIntoMemorySegmentScopedInternal(MemorySessionImpl session,
-                                              Class<? extends V> vmClass, Class<?> c, Class<E> e, int operType, int length,
+                                              Class<? extends V> vmClass, Class<?> c, int operType, int length,
                                               V v,
                                               AbstractMemorySegmentImpl msp, long offset,
                                               VectorSupport.StoreVectorOperation<AbstractMemorySegmentImpl, V> defaultImpl) {
         try {
             session.checkValidStateRaw();
 
-            VectorSupport.store(vmClass, c, e, operType, length,
+            VectorSupport.store(vmClass, c, operType, length,
                     msp.unsafeGetBase(), msp.unsafeGetOffset() + offset, true,
                     v,
                     msp, offset,
@@ -451,7 +451,7 @@ public final class ScopedMemoryAccess {
     @ForceInline
     public static
     <V extends VectorSupport.Vector<E>, E, M extends VectorSupport.VectorMask<E>>
-    void storeIntoMemorySegmentMasked(Class<? extends V> vmClass, Class<M> maskClass, Class<?> c, Class<E> e,
+    void storeIntoMemorySegmentMasked(Class<? extends V> vmClass, Class<M> maskClass, Class<?> c,
                                       int operType, int length, V v, M m,
                                       AbstractMemorySegmentImpl msp, long offset,
                                       VectorSupport.StoreVectorMaskedOperation<AbstractMemorySegmentImpl, V, M> defaultImpl) {
@@ -459,7 +459,7 @@ public final class ScopedMemoryAccess {
         try {
             storeIntoMemorySegmentMaskedScopedInternal(
                     msp.sessionImpl(),
-                    vmClass, maskClass, c, e, operType, length,
+                    vmClass, maskClass, c, operType, length,
                     v, m,
                     msp, offset,
                     defaultImpl);
@@ -474,13 +474,13 @@ public final class ScopedMemoryAccess {
     <V extends VectorSupport.Vector<E>, E, M extends VectorSupport.VectorMask<E>>
     void storeIntoMemorySegmentMaskedScopedInternal(MemorySessionImpl session,
                                                     Class<? extends V> vmClass, Class<M> maskClass,
-                                                    Class<?> c, Class<E> e, int operType, int length, V v, M m,
+                                                    Class<?> c, int operType, int length, V v, M m,
                                                     AbstractMemorySegmentImpl msp, long offset,
                                                     VectorSupport.StoreVectorMaskedOperation<AbstractMemorySegmentImpl, V, M> defaultImpl) {
         try {
             session.checkValidStateRaw();
 
-            VectorSupport.storeMasked(vmClass, maskClass, c, e, operType, length,
+            VectorSupport.storeMasked(vmClass, maskClass, c, operType, length,
                     msp.unsafeGetBase(), msp.unsafeGetOffset() + offset, true,
                     v, m,
                     msp, offset,
diff --git a/src/java.base/share/classes/jdk/internal/vm/vector/VectorSupport.java b/src/java.base/share/classes/jdk/internal/vm/vector/VectorSupport.java
index b8bb054e756..3efddcbcdf0 100644
--- a/src/java.base/share/classes/jdk/internal/vm/vector/VectorSupport.java
+++ b/src/java.base/share/classes/jdk/internal/vm/vector/VectorSupport.java
@@ -210,7 +210,7 @@ public interface FromBitsCoercedOperation<VM extends VectorPayload,
     <VM extends VectorPayload,
      S extends VectorSpecies<E>,
      E>
-    VM fromBitsCoerced(Class<? extends VM> vmClass, Class<?> cClass, Class<E> eClass, int operType,
+    VM fromBitsCoerced(Class<? extends VM> vmClass, Class<?> cClass, int operType,
                        int length,
                        long bits, int mode, S s,
                        FromBitsCoercedOperation<VM, S> defaultImpl) {
@@ -228,7 +228,7 @@ public interface IndexPartiallyInUpperRangeOperation<E,
     public static
     <E,
      M extends VectorMask<E>>
-    M indexPartiallyInUpperRange(Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,
+    M indexPartiallyInUpperRange(Class<? extends M> mClass, Class<?> cClass, int operType,
                                  int length, long offset, long limit,
                                  IndexPartiallyInUpperRangeOperation<E, M> defaultImpl) {
         assert isNonCapturingLambda(defaultImpl) : defaultImpl;
@@ -246,7 +246,7 @@ public interface IndexOperation<V extends Vector<?>,
     <V extends Vector<E>,
      E,
      S extends VectorSpecies<E>>
-    V indexVector(Class<? extends V> vClass, Class<?> cClass, Class<E> eClass, int operType,
+    V indexVector(Class<? extends V> vClass, Class<?> cClass, int operType,
                   int length,
                   V v, int step, S s,
                   IndexOperation<V, S> defaultImpl) {
@@ -267,7 +267,7 @@ public interface ReductionOperation<V extends Vector<?>,
      M extends VectorMask<E>,
      E>
     long reductionCoerced(int oprId,
-                          Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,
+                          Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, int operType,
                           int length,
                           V v, M m,
                           ReductionOperation<V, M> defaultImpl) {
@@ -286,7 +286,7 @@ public interface VecExtractOp<VM extends VectorPayload> {
     public static
     <VM extends VectorPayload,
      E>
-    long extract(Class<? extends VM> vClass, Class<?> cClass, Class<E> eClass, int operType,
+    long extract(Class<? extends VM> vClass, Class<?> cClass, int operType,
                  int length,
                  VM vm, int i,
                  VecExtractOp<VM> defaultImpl) {
@@ -304,7 +304,7 @@ public interface VecInsertOp<V extends Vector<?>> {
     public static
     <V extends Vector<E>,
      E>
-    V insert(Class<? extends V> vClass, Class<?> cClass, Class<E> eClass, int operType,
+    V insert(Class<? extends V> vClass, Class<?> cClass, int operType,
              int length,
              V v, int i, long val,
              VecInsertOp<V> defaultImpl) {
@@ -325,7 +325,7 @@ public interface UnaryOperation<V extends Vector<?>,
      M extends VectorMask<E>,
      E>
     V unaryOp(int oprId,
-              Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,
+              Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, int operType,
               int length,
               V v, M m,
               UnaryOperation<V, M> defaultImpl) {
@@ -363,7 +363,7 @@ public interface BinaryOperation<VM extends VectorPayload,
      M extends VectorMask<E>,
      E>
     VM binaryOp(int oprId,
-                Class<? extends VM> vmClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,
+                Class<? extends VM> vmClass, Class<? extends M> mClass, Class<?> cClass, int operType,
                 int length,
                 VM v1, VM v2, M m,
                 BinaryOperation<VM, M> defaultImpl) {
@@ -398,7 +398,7 @@ public interface SelectFromTwoVector<V extends Vector<?>> {
     public static
     <V extends Vector<E>,
      E>
-    V selectFromTwoVectorOp(Class<? extends V> vClass, Class<?> cClass, Class<E> eClass, int operType, int length,
+    V selectFromTwoVectorOp(Class<? extends V> vClass, Class<?> cClass, int operType, int length,
                             V v1, V v2, V v3,
                             SelectFromTwoVector<V> defaultImpl) {
         assert isNonCapturingLambda(defaultImpl) : defaultImpl;
@@ -420,7 +420,7 @@ public interface TernaryOperation<V extends Vector<?>,
      M extends VectorMask<E>,
      E>
     V ternaryOp(int oprId,
-                Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,
+                Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, int operType,
                 int length,
                 V v1, V v2, V v3, M m,
                 TernaryOperation<V, M> defaultImpl) {
@@ -444,7 +444,7 @@ public interface LoadOperation<C,
      VM extends VectorPayload,
      E,
      S extends VectorSpecies<E>>
-    VM load(Class<? extends VM> vmClass, Class<?> cClass, Class<E> eClass, int operType,
+    VM load(Class<? extends VM> vmClass, Class<?> cClass, int operType,
             int length,
             Object base, long offset, boolean fromSegment,
             C container, long index, S s,
@@ -469,7 +469,7 @@ public interface LoadVectorMaskedOperation<C,
      E,
      S extends VectorSpecies<E>,
      M extends VectorMask<E>>
-    V loadMasked(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,
+    V loadMasked(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, int operType,
                  int length, Object base, long offset, boolean fromSegment,
                  M m, int offsetInRange,
                  C container, long index, S s,
@@ -495,7 +495,7 @@ public interface LoadVectorOperationWithMap<C,
      S extends VectorSpecies<E>,
      M extends VectorMask<E>,
      E>
-    V loadWithMap(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,
+    V loadWithMap(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, int operType,
                   int length,
                   Class<? extends Vector<Integer>> vectorIndexClass,
                   int indexLength, Object base, long offset,
@@ -517,7 +517,7 @@ public interface StoreVectorOperation<C,
     public static
     <C,
      V extends VectorPayload>
-    void store(Class<?> vClass, Class<?> cClass, Class<?> eClass, int operType,
+    void store(Class<?> vClass, Class<?> cClass, int operType,
                int length,
                Object base, long offset, boolean fromSegment,
                V v, C container, long index,
@@ -538,7 +538,7 @@ public interface StoreVectorMaskedOperation<C,
      V extends Vector<E>,
      M extends VectorMask<E>,
      E>
-    void storeMasked(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,
+    void storeMasked(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, int operType,
                      int length,
                      Object base, long offset, boolean fromSegment,
                      V v, M m, C container, long index,
@@ -562,7 +562,7 @@ public interface StoreVectorOperationWithMap<C,
      W extends Vector<Integer>,
      M extends VectorMask<E>,
      E>
-    void storeWithMap(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,
+    void storeWithMap(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, int operType,
                       int length,
                       Class<? extends Vector<Integer>> vectorIndexClass,
                       int indexLength, Object base, long offset,
@@ -580,7 +580,7 @@ void storeWithMap(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, C
     <M extends VectorMask<E>,
      E>
     boolean test(int cond,
-                 Class<?> mClass, Class<?> cClass, Class<E> eClass, int opType,
+                 Class<?> mClass, Class<?> cClass, int operType,
                  int length,
                  M m1, M m2,
                  BiFunction<M, M, Boolean> defaultImpl) {
@@ -601,7 +601,7 @@ public interface VectorCompareOp<V extends Vector<?>,
      M extends VectorMask<E>,
      E>
     M compare(int cond,
-              Class<? extends V> vectorClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,
+              Class<? extends V> vectorClass, Class<M> mClass, Class<?> cClass, int operType,
               int length,
               V v1, V v2, M m,
               VectorCompareOp<V, M> defaultImpl) {
@@ -622,7 +622,7 @@ public interface VectorRearrangeOp<V extends Vector<?>,
      SH extends VectorShuffle<E>,
      M  extends VectorMask<E>,
      E>
-    V rearrangeOp(Class<? extends V> vClass, Class<SH> shClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,
+    V rearrangeOp(Class<? extends V> vClass, Class<SH> shClass, Class<M> mClass, Class<?> cClass, int operType,
                   int length,
                   V v, SH sh, M m,
                   VectorRearrangeOp<V, SH, M> defaultImpl) {
@@ -640,7 +640,7 @@ public interface VectorSelectFromOp<V extends Vector<?>,
     <V extends Vector<E>,
      M  extends VectorMask<E>,
      E>
-    V selectFromOp(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,
+    V selectFromOp(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, int operType,
                    int length, V v1, V v2, M m,
                    VectorSelectFromOp<V, M> defaultImpl) {
         assert isNonCapturingLambda(defaultImpl) : defaultImpl;
@@ -659,7 +659,7 @@ public interface VectorBlendOp<V extends Vector<?>,
     <V extends Vector<E>,
      M extends VectorMask<E>,
      E>
-    V blend(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,
+    V blend(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, int operType,
             int length,
             V v1, V v2, M m,
             VectorBlendOp<V, M> defaultImpl) {
@@ -680,7 +680,7 @@ public interface VectorBroadcastIntOp<V extends Vector<?>,
      M extends VectorMask<E>,
      E>
     V broadcastInt(int opr,
-                   Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,
+                   Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, int operType,
                    int length,
                    V v, int n, M m,
                    VectorBroadcastIntOp<V, M> defaultImpl) {
@@ -726,7 +726,7 @@ public interface CompressExpandOperation<V extends Vector<?>,
      M extends VectorMask<E>,
      E>
     VectorPayload compressExpandOp(int opr,
-                                   Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,
+                                   Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, int operType,
                                    int length, V v, M m,
                                    CompressExpandOperation<V, M> defaultImpl) {
         assert isNonCapturingLambda(defaultImpl) : defaultImpl;
@@ -755,7 +755,7 @@ public interface VectorMaskOp<M extends VectorMask<?>> {
     <M extends VectorMask<E>,
      E>
     long maskReductionCoerced(int oper,
-                              Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,
+                              Class<? extends M> mClass, Class<?> cClass, int operType,
                               int length,
                               M m,
                               VectorMaskOp<M> defaultImpl) {
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractMask.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractMask.java
index 730d7e0f43a..96e0712e187 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractMask.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractMask.java
@@ -73,10 +73,10 @@ public void intoArray(boolean[] bits, int i) {
         int laneCount = vsp.laneCount();
         i = VectorIntrinsics.checkFromIndexSize(i, laneCount, bits.length);
         VectorSupport.store(
-            vsp.maskType(), vsp.carrierType(), vsp.elementType(), vsp.operType(), laneCount,
+            vsp.maskType(), vsp.carrierType(), vsp.operType(), laneCount,
             bits, (long) i + Unsafe.ARRAY_BOOLEAN_BASE_OFFSET, false,
             this, bits, i,
-            (c, idx, s) -> System.arraycopy(s.getBits(), 0, c, (int) idx, s.length()));
+            (c, idx, s) -> System.arraycopy(s.getBits(), 0, c, (int)idx, s.length()));
 
     }
 
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractSpecies.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractSpecies.java
index 68f0ff3fcf7..f0d37da3ac6 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractSpecies.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractSpecies.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractVector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractVector.java
index 7c740dd9887..7de60e6ffb2 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractVector.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte128Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte128Vector.java
index aef787495d2..884b16485fc 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte128Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte128Vector.java
@@ -548,7 +548,7 @@ public byte lane(int i) {
     @ForceInline
     public byte laneHelper(int i) {
         return (byte) VectorSupport.extract(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i,
                                 (vec, ix) -> {
                                     byte[] vecarr = vec.vec();
@@ -583,7 +583,7 @@ public Byte128Vector withLane(int i, byte e) {
     @ForceInline
     public Byte128Vector withLaneHelper(int i, byte e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)e,
                                 (v, ix, bits) -> {
                                     byte[] res = v.vec().clone();
@@ -698,7 +698,7 @@ public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
         /*package-private*/
         Byte128Mask indexPartiallyInUpperRange(long offset, long limit) {
             return (Byte128Mask) VectorSupport.indexPartiallyInUpperRange(
-                Byte128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                Byte128Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> (Byte128Mask) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -714,7 +714,7 @@ public Byte128Mask not() {
         @ForceInline
         public Byte128Mask compress() {
             return (Byte128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                Byte128Vector.class, Byte128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                Byte128Vector.class, Byte128Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 m1.trueCount()));
         }
@@ -727,7 +727,7 @@ public Byte128Mask compress() {
         public Byte128Mask and(VectorMask<Byte> mask) {
             Objects.requireNonNull(mask);
             Byte128Mask m = (Byte128Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte128Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte128Mask.class, null, byte.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -737,7 +737,7 @@ public Byte128Mask and(VectorMask<Byte> mask) {
         public Byte128Mask or(VectorMask<Byte> mask) {
             Objects.requireNonNull(mask);
             Byte128Mask m = (Byte128Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte128Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte128Mask.class, null, byte.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -747,7 +747,7 @@ public Byte128Mask or(VectorMask<Byte> mask) {
         public Byte128Mask xor(VectorMask<Byte> mask) {
             Objects.requireNonNull(mask);
             Byte128Mask m = (Byte128Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte128Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte128Mask.class, null, byte.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -757,7 +757,7 @@ public Byte128Mask xor(VectorMask<Byte> mask) {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte128Mask.class, byte.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte128Mask.class, byte.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -765,7 +765,7 @@ public int trueCount() {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte128Mask.class, byte.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte128Mask.class, byte.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -773,7 +773,7 @@ public int firstTrue() {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte128Mask.class, byte.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte128Mask.class, byte.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -784,7 +784,7 @@ public long toLong() {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Byte128Mask.class, byte.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Byte128Mask.class, byte.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -795,7 +795,7 @@ public long toLong() {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract(Byte128Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract(Byte128Mask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -804,7 +804,7 @@ public boolean laneIsSet(int i) {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, Byte128Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, Byte128Mask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper(((Byte128Mask)m).getBits()));
         }
@@ -812,7 +812,7 @@ this, vspecies().maskAll(true),
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, Byte128Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, Byte128Mask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper(((Byte128Mask)m).getBits()));
         }
@@ -820,7 +820,7 @@ this, vspecies().maskAll(true),
         @ForceInline
         /*package-private*/
         static Byte128Mask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(Byte128Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced(Byte128Mask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte256Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte256Vector.java
index 7c1c8a04c15..be2e76b2486 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte256Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte256Vector.java
@@ -564,7 +564,7 @@ public byte lane(int i) {
     @ForceInline
     public byte laneHelper(int i) {
         return (byte) VectorSupport.extract(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i,
                                 (vec, ix) -> {
                                     byte[] vecarr = vec.vec();
@@ -615,7 +615,7 @@ public Byte256Vector withLane(int i, byte e) {
     @ForceInline
     public Byte256Vector withLaneHelper(int i, byte e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)e,
                                 (v, ix, bits) -> {
                                     byte[] res = v.vec().clone();
@@ -730,7 +730,7 @@ public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
         /*package-private*/
         Byte256Mask indexPartiallyInUpperRange(long offset, long limit) {
             return (Byte256Mask) VectorSupport.indexPartiallyInUpperRange(
-                Byte256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                Byte256Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> (Byte256Mask) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -746,7 +746,7 @@ public Byte256Mask not() {
         @ForceInline
         public Byte256Mask compress() {
             return (Byte256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                Byte256Vector.class, Byte256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                Byte256Vector.class, Byte256Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 m1.trueCount()));
         }
@@ -759,7 +759,7 @@ public Byte256Mask compress() {
         public Byte256Mask and(VectorMask<Byte> mask) {
             Objects.requireNonNull(mask);
             Byte256Mask m = (Byte256Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte256Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte256Mask.class, null, byte.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -769,7 +769,7 @@ public Byte256Mask and(VectorMask<Byte> mask) {
         public Byte256Mask or(VectorMask<Byte> mask) {
             Objects.requireNonNull(mask);
             Byte256Mask m = (Byte256Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte256Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte256Mask.class, null, byte.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -779,7 +779,7 @@ public Byte256Mask or(VectorMask<Byte> mask) {
         public Byte256Mask xor(VectorMask<Byte> mask) {
             Objects.requireNonNull(mask);
             Byte256Mask m = (Byte256Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte256Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte256Mask.class, null, byte.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -789,7 +789,7 @@ public Byte256Mask xor(VectorMask<Byte> mask) {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte256Mask.class, byte.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte256Mask.class, byte.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -797,7 +797,7 @@ public int trueCount() {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte256Mask.class, byte.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte256Mask.class, byte.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -805,7 +805,7 @@ public int firstTrue() {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte256Mask.class, byte.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte256Mask.class, byte.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -816,7 +816,7 @@ public long toLong() {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Byte256Mask.class, byte.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Byte256Mask.class, byte.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -827,7 +827,7 @@ public long toLong() {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract(Byte256Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract(Byte256Mask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -836,7 +836,7 @@ public boolean laneIsSet(int i) {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, Byte256Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, Byte256Mask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper(((Byte256Mask)m).getBits()));
         }
@@ -844,7 +844,7 @@ this, vspecies().maskAll(true),
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, Byte256Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, Byte256Mask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper(((Byte256Mask)m).getBits()));
         }
@@ -852,7 +852,7 @@ this, vspecies().maskAll(true),
         @ForceInline
         /*package-private*/
         static Byte256Mask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(Byte256Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced(Byte256Mask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte512Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte512Vector.java
index ebe2995b292..dedab8422fc 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte512Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte512Vector.java
@@ -596,7 +596,7 @@ public byte lane(int i) {
     @ForceInline
     public byte laneHelper(int i) {
         return (byte) VectorSupport.extract(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i,
                                 (vec, ix) -> {
                                     byte[] vecarr = vec.vec();
@@ -679,7 +679,7 @@ public Byte512Vector withLane(int i, byte e) {
     @ForceInline
     public Byte512Vector withLaneHelper(int i, byte e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)e,
                                 (v, ix, bits) -> {
                                     byte[] res = v.vec().clone();
@@ -794,7 +794,7 @@ public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
         /*package-private*/
         Byte512Mask indexPartiallyInUpperRange(long offset, long limit) {
             return (Byte512Mask) VectorSupport.indexPartiallyInUpperRange(
-                Byte512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                Byte512Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> (Byte512Mask) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -810,7 +810,7 @@ public Byte512Mask not() {
         @ForceInline
         public Byte512Mask compress() {
             return (Byte512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                Byte512Vector.class, Byte512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                Byte512Vector.class, Byte512Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 m1.trueCount()));
         }
@@ -823,7 +823,7 @@ public Byte512Mask compress() {
         public Byte512Mask and(VectorMask<Byte> mask) {
             Objects.requireNonNull(mask);
             Byte512Mask m = (Byte512Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte512Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte512Mask.class, null, byte.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -833,7 +833,7 @@ public Byte512Mask and(VectorMask<Byte> mask) {
         public Byte512Mask or(VectorMask<Byte> mask) {
             Objects.requireNonNull(mask);
             Byte512Mask m = (Byte512Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte512Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte512Mask.class, null, byte.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -843,7 +843,7 @@ public Byte512Mask or(VectorMask<Byte> mask) {
         public Byte512Mask xor(VectorMask<Byte> mask) {
             Objects.requireNonNull(mask);
             Byte512Mask m = (Byte512Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte512Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte512Mask.class, null, byte.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -853,7 +853,7 @@ public Byte512Mask xor(VectorMask<Byte> mask) {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte512Mask.class, byte.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte512Mask.class, byte.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -861,7 +861,7 @@ public int trueCount() {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte512Mask.class, byte.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte512Mask.class, byte.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -869,7 +869,7 @@ public int firstTrue() {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte512Mask.class, byte.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte512Mask.class, byte.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -880,7 +880,7 @@ public long toLong() {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Byte512Mask.class, byte.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Byte512Mask.class, byte.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -891,7 +891,7 @@ public long toLong() {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract(Byte512Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract(Byte512Mask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -900,7 +900,7 @@ public boolean laneIsSet(int i) {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, Byte512Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, Byte512Mask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper(((Byte512Mask)m).getBits()));
         }
@@ -908,7 +908,7 @@ this, vspecies().maskAll(true),
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, Byte512Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, Byte512Mask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper(((Byte512Mask)m).getBits()));
         }
@@ -916,7 +916,7 @@ this, vspecies().maskAll(true),
         @ForceInline
         /*package-private*/
         static Byte512Mask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(Byte512Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced(Byte512Mask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte64Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte64Vector.java
index 92bf6316e96..3791917cc45 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte64Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte64Vector.java
@@ -540,7 +540,7 @@ public byte lane(int i) {
     @ForceInline
     public byte laneHelper(int i) {
         return (byte) VectorSupport.extract(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i,
                                 (vec, ix) -> {
                                     byte[] vecarr = vec.vec();
@@ -567,7 +567,7 @@ public Byte64Vector withLane(int i, byte e) {
     @ForceInline
     public Byte64Vector withLaneHelper(int i, byte e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)e,
                                 (v, ix, bits) -> {
                                     byte[] res = v.vec().clone();
@@ -682,7 +682,7 @@ public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
         /*package-private*/
         Byte64Mask indexPartiallyInUpperRange(long offset, long limit) {
             return (Byte64Mask) VectorSupport.indexPartiallyInUpperRange(
-                Byte64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                Byte64Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> (Byte64Mask) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -698,7 +698,7 @@ public Byte64Mask not() {
         @ForceInline
         public Byte64Mask compress() {
             return (Byte64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                Byte64Vector.class, Byte64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                Byte64Vector.class, Byte64Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 m1.trueCount()));
         }
@@ -711,7 +711,7 @@ public Byte64Mask compress() {
         public Byte64Mask and(VectorMask<Byte> mask) {
             Objects.requireNonNull(mask);
             Byte64Mask m = (Byte64Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte64Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte64Mask.class, null, byte.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -721,7 +721,7 @@ public Byte64Mask and(VectorMask<Byte> mask) {
         public Byte64Mask or(VectorMask<Byte> mask) {
             Objects.requireNonNull(mask);
             Byte64Mask m = (Byte64Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte64Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte64Mask.class, null, byte.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -731,7 +731,7 @@ public Byte64Mask or(VectorMask<Byte> mask) {
         public Byte64Mask xor(VectorMask<Byte> mask) {
             Objects.requireNonNull(mask);
             Byte64Mask m = (Byte64Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte64Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte64Mask.class, null, byte.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -741,7 +741,7 @@ public Byte64Mask xor(VectorMask<Byte> mask) {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte64Mask.class, byte.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte64Mask.class, byte.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -749,7 +749,7 @@ public int trueCount() {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte64Mask.class, byte.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte64Mask.class, byte.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -757,7 +757,7 @@ public int firstTrue() {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte64Mask.class, byte.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte64Mask.class, byte.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -768,7 +768,7 @@ public long toLong() {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Byte64Mask.class, byte.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Byte64Mask.class, byte.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -779,7 +779,7 @@ public long toLong() {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract(Byte64Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract(Byte64Mask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -788,7 +788,7 @@ public boolean laneIsSet(int i) {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, Byte64Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, Byte64Mask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper(((Byte64Mask)m).getBits()));
         }
@@ -796,7 +796,7 @@ this, vspecies().maskAll(true),
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, Byte64Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, Byte64Mask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper(((Byte64Mask)m).getBits()));
         }
@@ -804,7 +804,7 @@ this, vspecies().maskAll(true),
         @ForceInline
         /*package-private*/
         static Byte64Mask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(Byte64Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced(Byte64Mask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ByteMaxVector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ByteMaxVector.java
index e74cc31cae5..75fd8d1589b 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ByteMaxVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ByteMaxVector.java
@@ -533,7 +533,7 @@ public byte lane(int i) {
     @ForceInline
     public byte laneHelper(int i) {
         return (byte) VectorSupport.extract(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i,
                                 (vec, ix) -> {
                                     byte[] vecarr = vec.vec();
@@ -553,7 +553,7 @@ public ByteMaxVector withLane(int i, byte e) {
     @ForceInline
     public ByteMaxVector withLaneHelper(int i, byte e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)e,
                                 (v, ix, bits) -> {
                                     byte[] res = v.vec().clone();
@@ -668,7 +668,7 @@ public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
         /*package-private*/
         ByteMaxMask indexPartiallyInUpperRange(long offset, long limit) {
             return (ByteMaxMask) VectorSupport.indexPartiallyInUpperRange(
-                ByteMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                ByteMaxMask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> (ByteMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -684,7 +684,7 @@ public ByteMaxMask not() {
         @ForceInline
         public ByteMaxMask compress() {
             return (ByteMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                ByteMaxVector.class, ByteMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                ByteMaxVector.class, ByteMaxMask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 m1.trueCount()));
         }
@@ -697,7 +697,7 @@ public ByteMaxMask compress() {
         public ByteMaxMask and(VectorMask<Byte> mask) {
             Objects.requireNonNull(mask);
             ByteMaxMask m = (ByteMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, ByteMaxMask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, ByteMaxMask.class, null, byte.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -707,7 +707,7 @@ public ByteMaxMask and(VectorMask<Byte> mask) {
         public ByteMaxMask or(VectorMask<Byte> mask) {
             Objects.requireNonNull(mask);
             ByteMaxMask m = (ByteMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, ByteMaxMask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, ByteMaxMask.class, null, byte.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -717,7 +717,7 @@ public ByteMaxMask or(VectorMask<Byte> mask) {
         public ByteMaxMask xor(VectorMask<Byte> mask) {
             Objects.requireNonNull(mask);
             ByteMaxMask m = (ByteMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, ByteMaxMask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, ByteMaxMask.class, null, byte.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -727,7 +727,7 @@ public ByteMaxMask xor(VectorMask<Byte> mask) {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, ByteMaxMask.class, byte.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, ByteMaxMask.class, byte.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -735,7 +735,7 @@ public int trueCount() {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, ByteMaxMask.class, byte.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, ByteMaxMask.class, byte.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -743,7 +743,7 @@ public int firstTrue() {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, ByteMaxMask.class, byte.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, ByteMaxMask.class, byte.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -754,7 +754,7 @@ public long toLong() {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, ByteMaxMask.class, byte.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, ByteMaxMask.class, byte.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -765,7 +765,7 @@ public long toLong() {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract(ByteMaxMask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract(ByteMaxMask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -774,7 +774,7 @@ public boolean laneIsSet(int i) {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, ByteMaxMask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, ByteMaxMask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper(((ByteMaxMask)m).getBits()));
         }
@@ -782,7 +782,7 @@ this, vspecies().maskAll(true),
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, ByteMaxMask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, ByteMaxMask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper(((ByteMaxMask)m).getBits()));
         }
@@ -790,7 +790,7 @@ this, vspecies().maskAll(true),
         @ForceInline
         /*package-private*/
         static ByteMaxMask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(ByteMaxMask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced(ByteMaxMask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ByteVector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ByteVector.java
index 8651fa70763..ab250b46b9b 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ByteVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ByteVector.java
@@ -575,7 +575,7 @@ static ByteVector selectFromTwoVectorHelper(Vector<Byte> indexes, Vector<Byte> s
     @ForceInline
     public static ByteVector zero(VectorSpecies<Byte> species) {
         ByteSpecies vsp = (ByteSpecies) species;
-        return VectorSupport.fromBitsCoerced(vsp.vectorType(), byte.class, byte.class, VECTOR_OPER_TYPE, species.length(),
+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), byte.class, VECTOR_OPER_TYPE, species.length(),
                                 0, MODE_BROADCAST, vsp,
                                 ((bits_, s_) -> s_.rvOp(i -> bits_)));
     }
@@ -697,7 +697,7 @@ else if (op == NOT) {
         }
         int opc = opCode(op);
         return VectorSupport.unaryOp(
-            opc, getClass(), null, byte.class, byte.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, byte.class, VECTOR_OPER_TYPE, length(),
             this, null,
             UN_IMPL.find(op, opc, ByteVector::unaryOperations));
     }
@@ -725,7 +725,7 @@ else if (op == NOT) {
         }
         int opc = opCode(op);
         return VectorSupport.unaryOp(
-            opc, getClass(), maskClass, byte.class, byte.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, byte.class, VECTOR_OPER_TYPE, length(),
             this, m,
             UN_IMPL.find(op, opc, ByteVector::unaryOperations));
     }
@@ -798,7 +798,7 @@ ByteVector lanewiseTemplate(VectorOperators.Binary op,
 
         int opc = opCode(op);
         return VectorSupport.binaryOp(
-            opc, getClass(), null, byte.class, byte.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, byte.class, VECTOR_OPER_TYPE, length(),
             this, that, null,
             BIN_IMPL.find(op, opc, ByteVector::binaryOperations));
     }
@@ -849,7 +849,7 @@ ByteVector lanewiseTemplate(VectorOperators.Binary op,
 
         int opc = opCode(op);
         return VectorSupport.binaryOp(
-            opc, getClass(), maskClass, byte.class, byte.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, byte.class, VECTOR_OPER_TYPE, length(),
             this, that, m,
             BIN_IMPL.find(op, opc, ByteVector::binaryOperations));
     }
@@ -1036,7 +1036,7 @@ ByteVector lanewise(VectorOperators.Binary op,
         e &= SHIFT_MASK;
         int opc = opCode(op);
         return VectorSupport.broadcastInt(
-            opc, getClass(), null, byte.class, byte.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, byte.class, VECTOR_OPER_TYPE, length(),
             this, e, null,
             BIN_INT_IMPL.find(op, opc, ByteVector::broadcastIntOperations));
     }
@@ -1057,7 +1057,7 @@ opc, getClass(), null, byte.class, byte.class, VECTOR_OPER_TYPE, length(),
         e &= SHIFT_MASK;
         int opc = opCode(op);
         return VectorSupport.broadcastInt(
-            opc, getClass(), maskClass, byte.class, byte.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, byte.class, VECTOR_OPER_TYPE, length(),
             this, e, m,
             BIN_INT_IMPL.find(op, opc, ByteVector::broadcastIntOperations));
     }
@@ -1134,7 +1134,7 @@ ByteVector lanewiseTemplate(VectorOperators.Ternary op,
         }
         int opc = opCode(op);
         return VectorSupport.ternaryOp(
-            opc, getClass(), null, byte.class, byte.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, byte.class, VECTOR_OPER_TYPE, length(),
             this, that, tother, null,
             TERN_IMPL.find(op, opc, ByteVector::ternaryOperations));
     }
@@ -1174,7 +1174,7 @@ ByteVector lanewiseTemplate(VectorOperators.Ternary op,
         }
         int opc = opCode(op);
         return VectorSupport.ternaryOp(
-            opc, getClass(), maskClass, byte.class, byte.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, byte.class, VECTOR_OPER_TYPE, length(),
             this, that, tother, m,
             TERN_IMPL.find(op, opc, ByteVector::ternaryOperations));
     }
@@ -2072,7 +2072,7 @@ M compareTemplate(Class<M> maskType, Comparison op, Vector<Byte> v) {
         that.check(this);
         int opc = opCode(op);
         return VectorSupport.compare(
-            opc, getClass(), maskType, byte.class, byte.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskType, byte.class, VECTOR_OPER_TYPE, length(),
             this, that, null,
             (cond, v0, v1, m1) -> {
                 AbstractMask<Byte> m
@@ -2094,7 +2094,7 @@ M compareTemplate(Class<M> maskType, Comparison op, Vector<Byte> v, M m) {
         m.check(maskType, this);
         int opc = opCode(op);
         return VectorSupport.compare(
-            opc, getClass(), maskType, byte.class, byte.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskType, byte.class, VECTOR_OPER_TYPE, length(),
             this, that, m,
             (cond, v0, v1, m1) -> {
                 AbstractMask<Byte> cmpM
@@ -2225,7 +2225,7 @@ VectorMask<Byte> compare(Comparison op, long e, VectorMask<Byte> m) {
     blendTemplate(Class<M> maskType, ByteVector v, M m) {
         v.check(this);
         return VectorSupport.blend(
-            getClass(), maskType, byte.class, byte.class, VECTOR_OPER_TYPE, length(),
+            getClass(), maskType, byte.class, VECTOR_OPER_TYPE, length(),
             this, v, m,
             (v0, v1, m_) -> v0.bOp(v1, m_, (i, a, b) -> b));
     }
@@ -2242,7 +2242,7 @@ final ByteVector addIndexTemplate(int scale) {
         // make sure VLENGTH*scale doesn't overflow:
         vsp.checkScale(scale);
         return VectorSupport.indexVector(
-            getClass(), byte.class, byte.class, VECTOR_OPER_TYPE, length(),
+            getClass(), byte.class, VECTOR_OPER_TYPE, length(),
             this, scale, vsp,
             (v, scale_, s)
             -> {
@@ -2434,7 +2434,7 @@ ByteVector sliceTemplate(int origin) {
     ByteVector rearrangeTemplate(Class<S> shuffletype, S shuffle) {
         Objects.requireNonNull(shuffle);
         return VectorSupport.rearrangeOp(
-            getClass(), shuffletype, null, byte.class, byte.class, VECTOR_OPER_TYPE, length(),
+            getClass(), shuffletype, null, byte.class, VECTOR_OPER_TYPE, length(),
             this, shuffle, null,
             (v1, s_, m_) -> v1.uOp((i, a) -> {
                 int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
@@ -2461,7 +2461,7 @@ ByteVector rearrangeTemplate(Class<S> shuffletype,
         Objects.requireNonNull(shuffle);
         m.check(masktype, this);
         return VectorSupport.rearrangeOp(
-                   getClass(), shuffletype, masktype, byte.class, byte.class, VECTOR_OPER_TYPE, length(),
+                   getClass(), shuffletype, masktype, byte.class, VECTOR_OPER_TYPE, length(),
                    this, shuffle, m,
                    (v1, s_, m_) -> v1.uOp((i, a) -> {
                         int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
@@ -2487,7 +2487,7 @@ ByteVector rearrangeTemplate(Class<S> shuffletype,
         VectorMask<Byte> valid = shuffle.laneIsValid();
         ByteVector r0 =
             VectorSupport.rearrangeOp(
-                getClass(), shuffletype, null, byte.class, byte.class, VECTOR_OPER_TYPE, length(),
+                getClass(), shuffletype, null, byte.class, VECTOR_OPER_TYPE, length(),
                 this, shuffle, null,
                 (v0, s_, m_) -> v0.uOp((i, a) -> {
                     int ei = Integer.remainderUnsigned(s_.laneSource(i), v0.length());
@@ -2495,7 +2495,7 @@ ByteVector rearrangeTemplate(Class<S> shuffletype,
                 }));
         ByteVector r1 =
             VectorSupport.rearrangeOp(
-                getClass(), shuffletype, null, byte.class, byte.class, VECTOR_OPER_TYPE, length(),
+                getClass(), shuffletype, null, byte.class, VECTOR_OPER_TYPE, length(),
                 v, shuffle, null,
                 (v1, s_, m_) -> v1.uOp((i, a) -> {
                     int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
@@ -2545,7 +2545,7 @@ VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp, boolean wrap) {
     ByteVector compressTemplate(Class<M> masktype, M m) {
       m.check(masktype, this);
       return (ByteVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,
-                                                        byte.class, byte.class, VECTOR_OPER_TYPE, length(), this, m,
+                                                        byte.class, VECTOR_OPER_TYPE, length(), this, m,
                                                         (v1, m1) -> compressHelper(v1, m1));
     }
 
@@ -2564,7 +2564,7 @@ byte.class, byte.class, VECTOR_OPER_TYPE, length(), this, m,
     ByteVector expandTemplate(Class<M> masktype, M m) {
       m.check(masktype, this);
       return (ByteVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,
-                                                        byte.class, byte.class, VECTOR_OPER_TYPE, length(), this, m,
+                                                        byte.class, VECTOR_OPER_TYPE, length(), this, m,
                                                         (v1, m1) -> expandHelper(v1, m1));
     }
 
@@ -2579,7 +2579,7 @@ byte.class, byte.class, VECTOR_OPER_TYPE, length(), this, m,
     /*package-private*/
     @ForceInline
     final ByteVector selectFromTemplate(ByteVector v) {
-        return (ByteVector)VectorSupport.selectFromOp(getClass(), null, byte.class, byte.class, VECTOR_OPER_TYPE,
+        return (ByteVector)VectorSupport.selectFromOp(getClass(), null, byte.class, VECTOR_OPER_TYPE,
                                                         length(), this, v, null,
                                                         (v1, v2, _m) ->
                                                          v2.rearrange(v1.toShuffle()));
@@ -2599,7 +2599,7 @@ final ByteVector selectFromTemplate(ByteVector v) {
     ByteVector selectFromTemplate(ByteVector v,
                                             Class<M> masktype, M m) {
         m.check(masktype, this);
-        return (ByteVector)VectorSupport.selectFromOp(getClass(), masktype, byte.class, byte.class, VECTOR_OPER_TYPE,
+        return (ByteVector)VectorSupport.selectFromOp(getClass(), masktype, byte.class, VECTOR_OPER_TYPE,
                                                         length(), this, v, m,
                                                         (v1, v2, _m) ->
                                                          v2.rearrange(v1.toShuffle(), _m));
@@ -2617,7 +2617,7 @@ ByteVector selectFromTemplate(ByteVector v,
     /*package-private*/
     @ForceInline
     final ByteVector selectFromTemplate(ByteVector v1, ByteVector v2) {
-        return VectorSupport.selectFromTwoVectorOp(getClass(), byte.class, byte.class, VECTOR_OPER_TYPE, length(), this, v1, v2,
+        return VectorSupport.selectFromTwoVectorOp(getClass(), byte.class, VECTOR_OPER_TYPE, length(), this, v1, v2,
                                                    (vec1, vec2, vec3) -> selectFromTwoVectorHelper(vec1, vec2, vec3));
     }
 
@@ -2837,7 +2837,7 @@ byte reduceLanesTemplate(VectorOperators.Associative op,
         }
         int opc = opCode(op);
         return fromBits(VectorSupport.reductionCoerced(
-            opc, getClass(), maskClass, byte.class, byte.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, byte.class, VECTOR_OPER_TYPE, length(),
             this, m,
             REDUCE_IMPL.find(op, opc, ByteVector::reductionOperations)));
     }
@@ -2855,7 +2855,7 @@ byte reduceLanesTemplate(VectorOperators.Associative op) {
         }
         int opc = opCode(op);
         return fromBits(VectorSupport.reductionCoerced(
-            opc, getClass(), null, byte.class, byte.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, byte.class, VECTOR_OPER_TYPE, length(),
             this, null,
             REDUCE_IMPL.find(op, opc, ByteVector::reductionOperations)));
     }
@@ -3145,7 +3145,7 @@ ByteVector fromArray(VectorSpecies<Byte> species,
         }
 
         return VectorSupport.loadWithMap(
-            vectorType, null, byte.class, byte.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+            vectorType, null, byte.class, VECTOR_OPER_TYPE, vsp.laneCount(),
             lsp.vectorType(), lsp.length(),
             a, ARRAY_BASE, vix0, vix1, vix2, vix3, null,
             a, offset, indexMap, mapOffset, vsp,
@@ -3480,7 +3480,7 @@ void intoArray(byte[] a, int offset) {
         offset = checkFromIndexSize(offset, length(), a.length);
         ByteSpecies vsp = vspecies();
         VectorSupport.store(
-            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false,
             this,
             a, offset,
@@ -3634,7 +3634,7 @@ void intoBooleanArray(boolean[] a, int offset) {
         ByteSpecies vsp = vspecies();
         ByteVector normalized = this.and((byte) 1);
         VectorSupport.store(
-            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, booleanArrayAddress(a, offset), false,
             normalized,
             a, offset,
@@ -3847,7 +3847,7 @@ void intoMemorySegment(MemorySegment ms, long offset,
     ByteVector fromArray0Template(byte[] a, int offset) {
         ByteSpecies vsp = vspecies();
         return VectorSupport.load(
-            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false,
             a, offset, vsp,
             (arr, off, s) -> s.ldOp(arr, (int) off,
@@ -3864,7 +3864,7 @@ ByteVector fromArray0Template(Class<M> maskClass, byte[] a, int offset, M m, int
         m.check(species());
         ByteSpecies vsp = vspecies();
         return VectorSupport.loadMasked(
-            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false, m, offsetInRange,
             a, offset, vsp,
             (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,
@@ -3920,7 +3920,7 @@ ByteVector fromArray0Template(Class<M> maskClass, byte[] a, int offset,
         }
 
         return VectorSupport.loadWithMap(
-            vectorType, maskClass, byte.class, byte.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+            vectorType, maskClass, byte.class, VECTOR_OPER_TYPE, vsp.laneCount(),
             lsp.vectorType(), lsp.length(),
             a, ARRAY_BASE, vix0, vix1, vix2, vix3, m,
             a, offset, indexMap, mapOffset, vsp,
@@ -3937,7 +3937,7 @@ ByteVector fromArray0Template(Class<M> maskClass, byte[] a, int offset,
     ByteVector fromBooleanArray0Template(boolean[] a, int offset) {
         ByteSpecies vsp = vspecies();
         return VectorSupport.load(
-            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, booleanArrayAddress(a, offset), false,
             a, offset, vsp,
             (arr, off, s) -> s.ldOp(arr, (int) off,
@@ -3954,7 +3954,7 @@ ByteVector fromBooleanArray0Template(Class<M> maskClass, boolean[] a, int offset
         m.check(species());
         ByteSpecies vsp = vspecies();
         return VectorSupport.loadMasked(
-            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, booleanArrayAddress(a, offset), false, m, offsetInRange,
             a, offset, vsp,
             (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,
@@ -3968,7 +3968,7 @@ a, booleanArrayAddress(a, offset), false, m, offsetInRange,
     ByteVector fromMemorySegment0Template(MemorySegment ms, long offset) {
         ByteSpecies vsp = vspecies();
         return ScopedMemoryAccess.loadFromMemorySegment(
-                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                 (AbstractMemorySegmentImpl) ms, offset, vsp,
                 (msp, off, s) -> {
                     return s.ldLongOp((MemorySegment) msp, off, ByteVector::memorySegmentGet);
@@ -3984,7 +3984,7 @@ ByteVector fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long
         ByteSpecies vsp = vspecies();
         m.check(vsp);
         return ScopedMemoryAccess.loadFromMemorySegmentMasked(
-                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                 (AbstractMemorySegmentImpl) ms, offset, m, vsp, offsetInRange,
                 (msp, off, s, vm) -> {
                     return s.ldLongOp((MemorySegment) msp, off, vm, ByteVector::memorySegmentGet);
@@ -4002,7 +4002,7 @@ ByteVector fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long
     void intoArray0Template(byte[] a, int offset) {
         ByteSpecies vsp = vspecies();
         VectorSupport.store(
-            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false,
             this, a, offset,
             (arr, off, v)
@@ -4019,7 +4019,7 @@ void intoArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {
         m.check(species());
         ByteSpecies vsp = vspecies();
         VectorSupport.storeMasked(
-            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false,
             this, m, a, offset,
             (arr, off, v, vm)
@@ -4038,7 +4038,7 @@ void intoBooleanArray0Template(Class<M> maskClass, boolean[] a, int offset, M m)
         ByteSpecies vsp = vspecies();
         ByteVector normalized = this.and((byte) 1);
         VectorSupport.storeMasked(
-            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, booleanArrayAddress(a, offset), false,
             normalized, m, a, offset,
             (arr, off, v, vm)
@@ -4051,7 +4051,7 @@ a, booleanArrayAddress(a, offset), false,
     void intoMemorySegment0(MemorySegment ms, long offset) {
         ByteSpecies vsp = vspecies();
         ScopedMemoryAccess.storeIntoMemorySegment(
-                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                 this,
                 (AbstractMemorySegmentImpl) ms, offset,
                 (msp, off, v) -> {
@@ -4068,7 +4068,7 @@ void intoMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offse
         ByteSpecies vsp = vspecies();
         m.check(vsp);
         ScopedMemoryAccess.storeIntoMemorySegmentMasked(
-                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                 this, m,
                 (AbstractMemorySegmentImpl) ms, offset,
                 (msp, off, v, vm) -> {
@@ -4294,7 +4294,7 @@ public final long checkValue(long e) {
         final ByteVector broadcastBits(long bits) {
             return (ByteVector)
                 VectorSupport.fromBitsCoerced(
-                    vectorType, byte.class, byte.class, VECTOR_OPER_TYPE, laneCount,
+                    vectorType, byte.class, VECTOR_OPER_TYPE, laneCount,
                     bits, MODE_BROADCAST, this,
                     (bits_, s_) -> s_.rvOp(i -> bits_));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double128Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double128Vector.java
index f9b600c48e8..4f15c96b6d4 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double128Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double128Vector.java
@@ -523,7 +523,7 @@ public double lane(int i) {
     @ForceInline
     public long laneHelper(int i) {
         return (long) VectorSupport.extract(
-                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                     VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                      this, i,
                      (vec, ix) -> {
                      double[] vecarr = vec.vec();
@@ -544,7 +544,7 @@ public Double128Vector withLane(int i, double e) {
     @ForceInline
     public Double128Vector withLaneHelper(int i, double e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)Double.doubleToRawLongBits(e),
                                 (v, ix, bits) -> {
                                     double[] res = v.vec().clone();
@@ -659,7 +659,7 @@ public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
         /*package-private*/
         Double128Mask indexPartiallyInUpperRange(long offset, long limit) {
             return (Double128Mask) VectorSupport.indexPartiallyInUpperRange(
-                Double128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                Double128Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> (Double128Mask) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -675,7 +675,7 @@ public Double128Mask not() {
         @ForceInline
         public Double128Mask compress() {
             return (Double128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                Double128Vector.class, Double128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                Double128Vector.class, Double128Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 m1.trueCount()));
         }
@@ -688,7 +688,7 @@ public Double128Mask compress() {
         public Double128Mask and(VectorMask<Double> mask) {
             Objects.requireNonNull(mask);
             Double128Mask m = (Double128Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, Double128Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, Double128Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -698,7 +698,7 @@ public Double128Mask and(VectorMask<Double> mask) {
         public Double128Mask or(VectorMask<Double> mask) {
             Objects.requireNonNull(mask);
             Double128Mask m = (Double128Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, Double128Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, Double128Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -708,7 +708,7 @@ public Double128Mask or(VectorMask<Double> mask) {
         public Double128Mask xor(VectorMask<Double> mask) {
             Objects.requireNonNull(mask);
             Double128Mask m = (Double128Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double128Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double128Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -718,7 +718,7 @@ public Double128Mask xor(VectorMask<Double> mask) {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double128Mask.class, long.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double128Mask.class, long.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -726,7 +726,7 @@ public int trueCount() {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double128Mask.class, long.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double128Mask.class, long.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -734,7 +734,7 @@ public int firstTrue() {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double128Mask.class, long.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double128Mask.class, long.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -745,7 +745,7 @@ public long toLong() {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Double128Mask.class, long.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Double128Mask.class, long.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -756,7 +756,7 @@ public long toLong() {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract(Double128Mask.class, double.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract(Double128Mask.class, double.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -765,7 +765,7 @@ public boolean laneIsSet(int i) {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, Double128Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, Double128Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper(((Double128Mask)m).getBits()));
         }
@@ -773,7 +773,7 @@ this, vspecies().maskAll(true),
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, Double128Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, Double128Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper(((Double128Mask)m).getBits()));
         }
@@ -781,7 +781,7 @@ this, vspecies().maskAll(true),
         @ForceInline
         /*package-private*/
         static Double128Mask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(Double128Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced(Double128Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double256Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double256Vector.java
index f364343b09b..e179d0c9665 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double256Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double256Vector.java
@@ -525,7 +525,7 @@ public double lane(int i) {
     @ForceInline
     public long laneHelper(int i) {
         return (long) VectorSupport.extract(
-                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                     VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                      this, i,
                      (vec, ix) -> {
                      double[] vecarr = vec.vec();
@@ -548,7 +548,7 @@ public Double256Vector withLane(int i, double e) {
     @ForceInline
     public Double256Vector withLaneHelper(int i, double e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)Double.doubleToRawLongBits(e),
                                 (v, ix, bits) -> {
                                     double[] res = v.vec().clone();
@@ -663,7 +663,7 @@ public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
         /*package-private*/
         Double256Mask indexPartiallyInUpperRange(long offset, long limit) {
             return (Double256Mask) VectorSupport.indexPartiallyInUpperRange(
-                Double256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                Double256Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> (Double256Mask) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -679,7 +679,7 @@ public Double256Mask not() {
         @ForceInline
         public Double256Mask compress() {
             return (Double256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                Double256Vector.class, Double256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                Double256Vector.class, Double256Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 m1.trueCount()));
         }
@@ -692,7 +692,7 @@ public Double256Mask compress() {
         public Double256Mask and(VectorMask<Double> mask) {
             Objects.requireNonNull(mask);
             Double256Mask m = (Double256Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, Double256Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, Double256Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -702,7 +702,7 @@ public Double256Mask and(VectorMask<Double> mask) {
         public Double256Mask or(VectorMask<Double> mask) {
             Objects.requireNonNull(mask);
             Double256Mask m = (Double256Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, Double256Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, Double256Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -712,7 +712,7 @@ public Double256Mask or(VectorMask<Double> mask) {
         public Double256Mask xor(VectorMask<Double> mask) {
             Objects.requireNonNull(mask);
             Double256Mask m = (Double256Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double256Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double256Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -722,7 +722,7 @@ public Double256Mask xor(VectorMask<Double> mask) {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double256Mask.class, long.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double256Mask.class, long.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -730,7 +730,7 @@ public int trueCount() {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double256Mask.class, long.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double256Mask.class, long.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -738,7 +738,7 @@ public int firstTrue() {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double256Mask.class, long.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double256Mask.class, long.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -749,7 +749,7 @@ public long toLong() {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Double256Mask.class, long.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Double256Mask.class, long.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -760,7 +760,7 @@ public long toLong() {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract(Double256Mask.class, double.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract(Double256Mask.class, double.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -769,7 +769,7 @@ public boolean laneIsSet(int i) {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, Double256Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, Double256Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper(((Double256Mask)m).getBits()));
         }
@@ -777,7 +777,7 @@ this, vspecies().maskAll(true),
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, Double256Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, Double256Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper(((Double256Mask)m).getBits()));
         }
@@ -785,7 +785,7 @@ this, vspecies().maskAll(true),
         @ForceInline
         /*package-private*/
         static Double256Mask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(Double256Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced(Double256Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double512Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double512Vector.java
index 637839cc44f..82edc82efc2 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double512Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double512Vector.java
@@ -529,7 +529,7 @@ public double lane(int i) {
     @ForceInline
     public long laneHelper(int i) {
         return (long) VectorSupport.extract(
-                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                     VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                      this, i,
                      (vec, ix) -> {
                      double[] vecarr = vec.vec();
@@ -556,7 +556,7 @@ public Double512Vector withLane(int i, double e) {
     @ForceInline
     public Double512Vector withLaneHelper(int i, double e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)Double.doubleToRawLongBits(e),
                                 (v, ix, bits) -> {
                                     double[] res = v.vec().clone();
@@ -671,7 +671,7 @@ public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
         /*package-private*/
         Double512Mask indexPartiallyInUpperRange(long offset, long limit) {
             return (Double512Mask) VectorSupport.indexPartiallyInUpperRange(
-                Double512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                Double512Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> (Double512Mask) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -687,7 +687,7 @@ public Double512Mask not() {
         @ForceInline
         public Double512Mask compress() {
             return (Double512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                Double512Vector.class, Double512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                Double512Vector.class, Double512Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 m1.trueCount()));
         }
@@ -700,7 +700,7 @@ public Double512Mask compress() {
         public Double512Mask and(VectorMask<Double> mask) {
             Objects.requireNonNull(mask);
             Double512Mask m = (Double512Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, Double512Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, Double512Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -710,7 +710,7 @@ public Double512Mask and(VectorMask<Double> mask) {
         public Double512Mask or(VectorMask<Double> mask) {
             Objects.requireNonNull(mask);
             Double512Mask m = (Double512Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, Double512Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, Double512Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -720,7 +720,7 @@ public Double512Mask or(VectorMask<Double> mask) {
         public Double512Mask xor(VectorMask<Double> mask) {
             Objects.requireNonNull(mask);
             Double512Mask m = (Double512Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double512Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double512Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -730,7 +730,7 @@ public Double512Mask xor(VectorMask<Double> mask) {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double512Mask.class, long.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double512Mask.class, long.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -738,7 +738,7 @@ public int trueCount() {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double512Mask.class, long.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double512Mask.class, long.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -746,7 +746,7 @@ public int firstTrue() {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double512Mask.class, long.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double512Mask.class, long.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -757,7 +757,7 @@ public long toLong() {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Double512Mask.class, long.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Double512Mask.class, long.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -768,7 +768,7 @@ public long toLong() {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract(Double512Mask.class, double.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract(Double512Mask.class, double.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -777,7 +777,7 @@ public boolean laneIsSet(int i) {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, Double512Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, Double512Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper(((Double512Mask)m).getBits()));
         }
@@ -785,7 +785,7 @@ this, vspecies().maskAll(true),
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, Double512Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, Double512Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper(((Double512Mask)m).getBits()));
         }
@@ -793,7 +793,7 @@ this, vspecies().maskAll(true),
         @ForceInline
         /*package-private*/
         static Double512Mask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(Double512Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced(Double512Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double64Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double64Vector.java
index b5ace52e89b..f7a94c39739 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double64Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double64Vector.java
@@ -522,7 +522,7 @@ public double lane(int i) {
     @ForceInline
     public long laneHelper(int i) {
         return (long) VectorSupport.extract(
-                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                     VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                      this, i,
                      (vec, ix) -> {
                      double[] vecarr = vec.vec();
@@ -542,7 +542,7 @@ public Double64Vector withLane(int i, double e) {
     @ForceInline
     public Double64Vector withLaneHelper(int i, double e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)Double.doubleToRawLongBits(e),
                                 (v, ix, bits) -> {
                                     double[] res = v.vec().clone();
@@ -657,7 +657,7 @@ public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
         /*package-private*/
         Double64Mask indexPartiallyInUpperRange(long offset, long limit) {
             return (Double64Mask) VectorSupport.indexPartiallyInUpperRange(
-                Double64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                Double64Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> (Double64Mask) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -673,7 +673,7 @@ public Double64Mask not() {
         @ForceInline
         public Double64Mask compress() {
             return (Double64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                Double64Vector.class, Double64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                Double64Vector.class, Double64Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 m1.trueCount()));
         }
@@ -686,7 +686,7 @@ public Double64Mask compress() {
         public Double64Mask and(VectorMask<Double> mask) {
             Objects.requireNonNull(mask);
             Double64Mask m = (Double64Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, Double64Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, Double64Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -696,7 +696,7 @@ public Double64Mask and(VectorMask<Double> mask) {
         public Double64Mask or(VectorMask<Double> mask) {
             Objects.requireNonNull(mask);
             Double64Mask m = (Double64Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, Double64Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, Double64Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -706,7 +706,7 @@ public Double64Mask or(VectorMask<Double> mask) {
         public Double64Mask xor(VectorMask<Double> mask) {
             Objects.requireNonNull(mask);
             Double64Mask m = (Double64Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double64Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double64Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -716,7 +716,7 @@ public Double64Mask xor(VectorMask<Double> mask) {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double64Mask.class, long.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double64Mask.class, long.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -724,7 +724,7 @@ public int trueCount() {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double64Mask.class, long.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double64Mask.class, long.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -732,7 +732,7 @@ public int firstTrue() {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double64Mask.class, long.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double64Mask.class, long.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -743,7 +743,7 @@ public long toLong() {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Double64Mask.class, long.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Double64Mask.class, long.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -754,7 +754,7 @@ public long toLong() {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract(Double64Mask.class, double.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract(Double64Mask.class, double.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -763,7 +763,7 @@ public boolean laneIsSet(int i) {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, Double64Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, Double64Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper(((Double64Mask)m).getBits()));
         }
@@ -771,7 +771,7 @@ this, vspecies().maskAll(true),
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, Double64Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, Double64Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper(((Double64Mask)m).getBits()));
         }
@@ -779,7 +779,7 @@ this, vspecies().maskAll(true),
         @ForceInline
         /*package-private*/
         static Double64Mask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(Double64Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced(Double64Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/DoubleMaxVector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/DoubleMaxVector.java
index 06f3a632ee0..93e76e227a8 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/DoubleMaxVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/DoubleMaxVector.java
@@ -521,7 +521,7 @@ public double lane(int i) {
     @ForceInline
     public long laneHelper(int i) {
         return (long) VectorSupport.extract(
-                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                     VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                      this, i,
                      (vec, ix) -> {
                      double[] vecarr = vec.vec();
@@ -541,7 +541,7 @@ public DoubleMaxVector withLane(int i, double e) {
     @ForceInline
     public DoubleMaxVector withLaneHelper(int i, double e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)Double.doubleToRawLongBits(e),
                                 (v, ix, bits) -> {
                                     double[] res = v.vec().clone();
@@ -656,7 +656,7 @@ public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
         /*package-private*/
         DoubleMaxMask indexPartiallyInUpperRange(long offset, long limit) {
             return (DoubleMaxMask) VectorSupport.indexPartiallyInUpperRange(
-                DoubleMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                DoubleMaxMask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> (DoubleMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -672,7 +672,7 @@ public DoubleMaxMask not() {
         @ForceInline
         public DoubleMaxMask compress() {
             return (DoubleMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                DoubleMaxVector.class, DoubleMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                DoubleMaxVector.class, DoubleMaxMask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 m1.trueCount()));
         }
@@ -685,7 +685,7 @@ public DoubleMaxMask compress() {
         public DoubleMaxMask and(VectorMask<Double> mask) {
             Objects.requireNonNull(mask);
             DoubleMaxMask m = (DoubleMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, DoubleMaxMask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, DoubleMaxMask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -695,7 +695,7 @@ public DoubleMaxMask and(VectorMask<Double> mask) {
         public DoubleMaxMask or(VectorMask<Double> mask) {
             Objects.requireNonNull(mask);
             DoubleMaxMask m = (DoubleMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, DoubleMaxMask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, DoubleMaxMask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -705,7 +705,7 @@ public DoubleMaxMask or(VectorMask<Double> mask) {
         public DoubleMaxMask xor(VectorMask<Double> mask) {
             Objects.requireNonNull(mask);
             DoubleMaxMask m = (DoubleMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, DoubleMaxMask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, DoubleMaxMask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -715,7 +715,7 @@ public DoubleMaxMask xor(VectorMask<Double> mask) {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, DoubleMaxMask.class, long.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, DoubleMaxMask.class, long.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -723,7 +723,7 @@ public int trueCount() {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, DoubleMaxMask.class, long.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, DoubleMaxMask.class, long.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -731,7 +731,7 @@ public int firstTrue() {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, DoubleMaxMask.class, long.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, DoubleMaxMask.class, long.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -742,7 +742,7 @@ public long toLong() {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, DoubleMaxMask.class, long.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, DoubleMaxMask.class, long.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -753,7 +753,7 @@ public long toLong() {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract(DoubleMaxMask.class, double.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract(DoubleMaxMask.class, double.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -762,7 +762,7 @@ public boolean laneIsSet(int i) {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, DoubleMaxMask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, DoubleMaxMask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper(((DoubleMaxMask)m).getBits()));
         }
@@ -770,7 +770,7 @@ this, vspecies().maskAll(true),
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, DoubleMaxMask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, DoubleMaxMask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper(((DoubleMaxMask)m).getBits()));
         }
@@ -778,7 +778,7 @@ this, vspecies().maskAll(true),
         @ForceInline
         /*package-private*/
         static DoubleMaxMask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(DoubleMaxMask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced(DoubleMaxMask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/DoubleVector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/DoubleVector.java
index 83a295c9e7a..9c20a7c755c 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/DoubleVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/DoubleVector.java
@@ -564,7 +564,7 @@ static DoubleVector selectFromTwoVectorHelper(Vector<Double> indexes, Vector<Dou
     @ForceInline
     public static DoubleVector zero(VectorSpecies<Double> species) {
         DoubleSpecies vsp = (DoubleSpecies) species;
-        return VectorSupport.fromBitsCoerced(vsp.vectorType(), double.class, double.class, VECTOR_OPER_TYPE, species.length(),
+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), double.class, VECTOR_OPER_TYPE, species.length(),
                         toBits(0.0f), MODE_BROADCAST, vsp,
                         ((bits_, s_) -> s_.rvOp(i -> bits_)));
     }
@@ -686,7 +686,7 @@ else if (opKind(op, VO_MATHLIB)) {
         }
         int opc = opCode(op);
         return VectorSupport.unaryOp(
-            opc, getClass(), null, double.class, double.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, double.class, VECTOR_OPER_TYPE, length(),
             this, null,
             UN_IMPL.find(op, opc, DoubleVector::unaryOperations));
     }
@@ -714,7 +714,7 @@ else if (opKind(op, VO_MATHLIB)) {
         }
         int opc = opCode(op);
         return VectorSupport.unaryOp(
-            opc, getClass(), maskClass, double.class, double.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, double.class, VECTOR_OPER_TYPE, length(),
             this, m,
             UN_IMPL.find(op, opc, DoubleVector::unaryOperations));
     }
@@ -803,7 +803,7 @@ else if (opKind(op, VO_MATHLIB)) {
 
         int opc = opCode(op);
         return VectorSupport.binaryOp(
-            opc, getClass(), null, double.class, double.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, double.class, VECTOR_OPER_TYPE, length(),
             this, that, null,
             BIN_IMPL.find(op, opc, DoubleVector::binaryOperations));
     }
@@ -841,7 +841,7 @@ else if (opKind(op, VO_MATHLIB)) {
 
         int opc = opCode(op);
         return VectorSupport.binaryOp(
-            opc, getClass(), maskClass, double.class, double.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, double.class, VECTOR_OPER_TYPE, length(),
             this, that, m,
             BIN_IMPL.find(op, opc, DoubleVector::binaryOperations));
     }
@@ -1023,7 +1023,7 @@ DoubleVector lanewiseTemplate(VectorOperators.Ternary op,
         tother.check(this);
         int opc = opCode(op);
         return VectorSupport.ternaryOp(
-            opc, getClass(), null, double.class, double.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, double.class, VECTOR_OPER_TYPE, length(),
             this, that, tother, null,
             TERN_IMPL.find(op, opc, DoubleVector::ternaryOperations));
     }
@@ -1058,7 +1058,7 @@ DoubleVector lanewiseTemplate(VectorOperators.Ternary op,
 
         int opc = opCode(op);
         return VectorSupport.ternaryOp(
-            opc, getClass(), maskClass, double.class, double.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, double.class, VECTOR_OPER_TYPE, length(),
             this, that, tother, m,
             TERN_IMPL.find(op, opc, DoubleVector::ternaryOperations));
     }
@@ -1930,7 +1930,7 @@ M compareTemplate(Class<M> maskType, Comparison op, Vector<Double> v) {
         that.check(this);
         int opc = opCode(op);
         return VectorSupport.compare(
-            opc, getClass(), maskType, double.class, double.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskType, double.class, VECTOR_OPER_TYPE, length(),
             this, that, null,
             (cond, v0, v1, m1) -> {
                 AbstractMask<Double> m
@@ -1952,7 +1952,7 @@ M compareTemplate(Class<M> maskType, Comparison op, Vector<Double> v, M m) {
         m.check(maskType, this);
         int opc = opCode(op);
         return VectorSupport.compare(
-            opc, getClass(), maskType, double.class, double.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskType, double.class, VECTOR_OPER_TYPE, length(),
             this, that, m,
             (cond, v0, v1, m1) -> {
                 AbstractMask<Double> cmpM
@@ -2079,7 +2079,7 @@ VectorMask<Double> compare(Comparison op, long e, VectorMask<Double> m) {
     blendTemplate(Class<M> maskType, DoubleVector v, M m) {
         v.check(this);
         return VectorSupport.blend(
-            getClass(), maskType, double.class, double.class, VECTOR_OPER_TYPE, length(),
+            getClass(), maskType, double.class, VECTOR_OPER_TYPE, length(),
             this, v, m,
             (v0, v1, m_) -> v0.bOp(v1, m_, (i, a, b) -> b));
     }
@@ -2096,7 +2096,7 @@ final DoubleVector addIndexTemplate(int scale) {
         // make sure VLENGTH*scale doesn't overflow:
         vsp.checkScale(scale);
         return VectorSupport.indexVector(
-            getClass(), double.class, double.class, VECTOR_OPER_TYPE, length(),
+            getClass(), double.class, VECTOR_OPER_TYPE, length(),
             this, scale, vsp,
             (v, scale_, s)
             -> {
@@ -2288,7 +2288,7 @@ DoubleVector sliceTemplate(int origin) {
     DoubleVector rearrangeTemplate(Class<S> shuffletype, S shuffle) {
         Objects.requireNonNull(shuffle);
         return VectorSupport.rearrangeOp(
-            getClass(), shuffletype, null, double.class, double.class, VECTOR_OPER_TYPE, length(),
+            getClass(), shuffletype, null, double.class, VECTOR_OPER_TYPE, length(),
             this, shuffle, null,
             (v1, s_, m_) -> v1.uOp((i, a) -> {
                 int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
@@ -2315,7 +2315,7 @@ DoubleVector rearrangeTemplate(Class<S> shuffletype,
         Objects.requireNonNull(shuffle);
         m.check(masktype, this);
         return VectorSupport.rearrangeOp(
-                   getClass(), shuffletype, masktype, double.class, double.class, VECTOR_OPER_TYPE, length(),
+                   getClass(), shuffletype, masktype, double.class, VECTOR_OPER_TYPE, length(),
                    this, shuffle, m,
                    (v1, s_, m_) -> v1.uOp((i, a) -> {
                         int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
@@ -2341,7 +2341,7 @@ DoubleVector rearrangeTemplate(Class<S> shuffletype,
         VectorMask<Double> valid = shuffle.laneIsValid();
         DoubleVector r0 =
             VectorSupport.rearrangeOp(
-                getClass(), shuffletype, null, double.class, double.class, VECTOR_OPER_TYPE, length(),
+                getClass(), shuffletype, null, double.class, VECTOR_OPER_TYPE, length(),
                 this, shuffle, null,
                 (v0, s_, m_) -> v0.uOp((i, a) -> {
                     int ei = Integer.remainderUnsigned(s_.laneSource(i), v0.length());
@@ -2349,7 +2349,7 @@ DoubleVector rearrangeTemplate(Class<S> shuffletype,
                 }));
         DoubleVector r1 =
             VectorSupport.rearrangeOp(
-                getClass(), shuffletype, null, double.class, double.class, VECTOR_OPER_TYPE, length(),
+                getClass(), shuffletype, null, double.class, VECTOR_OPER_TYPE, length(),
                 v, shuffle, null,
                 (v1, s_, m_) -> v1.uOp((i, a) -> {
                     int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
@@ -2393,7 +2393,7 @@ VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp, boolean wrap) {
     DoubleVector compressTemplate(Class<M> masktype, M m) {
       m.check(masktype, this);
       return (DoubleVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,
-                                                        double.class, double.class, VECTOR_OPER_TYPE, length(), this, m,
+                                                        double.class, VECTOR_OPER_TYPE, length(), this, m,
                                                         (v1, m1) -> compressHelper(v1, m1));
     }
 
@@ -2412,7 +2412,7 @@ DoubleVector compressTemplate(Class<M> masktype, M m) {
     DoubleVector expandTemplate(Class<M> masktype, M m) {
       m.check(masktype, this);
       return (DoubleVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,
-                                                        double.class, double.class, VECTOR_OPER_TYPE, length(), this, m,
+                                                        double.class, VECTOR_OPER_TYPE, length(), this, m,
                                                         (v1, m1) -> expandHelper(v1, m1));
     }
 
@@ -2427,7 +2427,7 @@ DoubleVector expandTemplate(Class<M> masktype, M m) {
     /*package-private*/
     @ForceInline
     final DoubleVector selectFromTemplate(DoubleVector v) {
-        return (DoubleVector)VectorSupport.selectFromOp(getClass(), null, double.class, double.class, VECTOR_OPER_TYPE,
+        return (DoubleVector)VectorSupport.selectFromOp(getClass(), null, double.class, VECTOR_OPER_TYPE,
                                                         length(), this, v, null,
                                                         (v1, v2, _m) ->
                                                          v2.rearrange(v1.toShuffle()));
@@ -2447,7 +2447,7 @@ final DoubleVector selectFromTemplate(DoubleVector v) {
     DoubleVector selectFromTemplate(DoubleVector v,
                                             Class<M> masktype, M m) {
         m.check(masktype, this);
-        return (DoubleVector)VectorSupport.selectFromOp(getClass(), masktype, double.class, double.class, VECTOR_OPER_TYPE,
+        return (DoubleVector)VectorSupport.selectFromOp(getClass(), masktype, double.class, VECTOR_OPER_TYPE,
                                                         length(), this, v, m,
                                                         (v1, v2, _m) ->
                                                          v2.rearrange(v1.toShuffle(), _m));
@@ -2465,7 +2465,7 @@ DoubleVector selectFromTemplate(DoubleVector v,
     /*package-private*/
     @ForceInline
     final DoubleVector selectFromTemplate(DoubleVector v1, DoubleVector v2) {
-        return VectorSupport.selectFromTwoVectorOp(getClass(), double.class, double.class, VECTOR_OPER_TYPE, length(), this, v1, v2,
+        return VectorSupport.selectFromTwoVectorOp(getClass(), double.class, VECTOR_OPER_TYPE, length(), this, v1, v2,
                                                    (vec1, vec2, vec3) -> selectFromTwoVectorHelper(vec1, vec2, vec3));
     }
 
@@ -2663,7 +2663,7 @@ public abstract double reduceLanes(VectorOperators.Associative op,
         }
         int opc = opCode(op);
         return fromBits(VectorSupport.reductionCoerced(
-            opc, getClass(), maskClass, double.class, double.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, double.class, VECTOR_OPER_TYPE, length(),
             this, m,
             REDUCE_IMPL.find(op, opc, DoubleVector::reductionOperations)));
     }
@@ -2681,7 +2681,7 @@ opc, getClass(), maskClass, double.class, double.class, VECTOR_OPER_TYPE, length
         }
         int opc = opCode(op);
         return fromBits(VectorSupport.reductionCoerced(
-            opc, getClass(), null, double.class, double.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, double.class, VECTOR_OPER_TYPE, length(),
             this, null,
             REDUCE_IMPL.find(op, opc, DoubleVector::reductionOperations)));
     }
@@ -2938,7 +2938,7 @@ DoubleVector fromArray(VectorSpecies<Double> species,
         vix = VectorIntrinsics.checkIndex(vix, a.length);
 
         return VectorSupport.loadWithMap(
-            vectorType, null, double.class, double.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+            vectorType, null, double.class, VECTOR_OPER_TYPE, vsp.laneCount(),
             isp.vectorType(), isp.length(),
             a, ARRAY_BASE, vix, null, null, null, null,
             a, offset, indexMap, mapOffset, vsp,
@@ -3121,7 +3121,7 @@ void intoArray(double[] a, int offset) {
         offset = checkFromIndexSize(offset, length(), a.length);
         DoubleSpecies vsp = vspecies();
         VectorSupport.store(
-            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false,
             this,
             a, offset,
@@ -3229,7 +3229,7 @@ void intoArray(double[] a, int offset,
         vix = VectorIntrinsics.checkIndex(vix, a.length);
 
         VectorSupport.storeWithMap(
-            vsp.vectorType(), null, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), null, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             isp.vectorType(), isp.length(),
             a, arrayAddress(a, 0), vix,
             this, null,
@@ -3356,7 +3356,7 @@ void intoMemorySegment(MemorySegment ms, long offset,
     DoubleVector fromArray0Template(double[] a, int offset) {
         DoubleSpecies vsp = vspecies();
         return VectorSupport.load(
-            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false,
             a, offset, vsp,
             (arr, off, s) -> s.ldOp(arr, (int) off,
@@ -3373,7 +3373,7 @@ DoubleVector fromArray0Template(Class<M> maskClass, double[] a, int offset, M m,
         m.check(species());
         DoubleSpecies vsp = vspecies();
         return VectorSupport.loadMasked(
-            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false, m, offsetInRange,
             a, offset, vsp,
             (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,
@@ -3424,7 +3424,7 @@ DoubleVector fromArray0Template(Class<M> maskClass, double[] a, int offset,
         vix = VectorIntrinsics.checkIndex(vix, a.length);
 
         return VectorSupport.loadWithMap(
-            vectorType, maskClass, double.class, double.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+            vectorType, maskClass, double.class, VECTOR_OPER_TYPE, vsp.laneCount(),
             isp.vectorType(), isp.length(),
             a, ARRAY_BASE, vix, null, null, null, m,
             a, offset, indexMap, mapOffset, vsp,
@@ -3441,7 +3441,7 @@ DoubleVector fromArray0Template(Class<M> maskClass, double[] a, int offset,
     DoubleVector fromMemorySegment0Template(MemorySegment ms, long offset) {
         DoubleSpecies vsp = vspecies();
         return ScopedMemoryAccess.loadFromMemorySegment(
-                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                 (AbstractMemorySegmentImpl) ms, offset, vsp,
                 (msp, off, s) -> {
                     return s.ldLongOp((MemorySegment) msp, off, DoubleVector::memorySegmentGet);
@@ -3457,7 +3457,7 @@ DoubleVector fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, lo
         DoubleSpecies vsp = vspecies();
         m.check(vsp);
         return ScopedMemoryAccess.loadFromMemorySegmentMasked(
-                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                 (AbstractMemorySegmentImpl) ms, offset, m, vsp, offsetInRange,
                 (msp, off, s, vm) -> {
                     return s.ldLongOp((MemorySegment) msp, off, vm, DoubleVector::memorySegmentGet);
@@ -3475,7 +3475,7 @@ DoubleVector fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, lo
     void intoArray0Template(double[] a, int offset) {
         DoubleSpecies vsp = vspecies();
         VectorSupport.store(
-            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false,
             this, a, offset,
             (arr, off, v)
@@ -3492,7 +3492,7 @@ void intoArray0Template(Class<M> maskClass, double[] a, int offset, M m) {
         m.check(species());
         DoubleSpecies vsp = vspecies();
         VectorSupport.storeMasked(
-            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false,
             this, m, a, offset,
             (arr, off, v, vm)
@@ -3540,7 +3540,7 @@ void intoArray0Template(Class<M> maskClass, double[] a, int offset,
         vix = VectorIntrinsics.checkIndex(vix, a.length);
 
         VectorSupport.storeWithMap(
-            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             isp.vectorType(), isp.length(),
             a, arrayAddress(a, 0), vix,
             this, m,
@@ -3559,7 +3559,7 @@ a, arrayAddress(a, 0), vix,
     void intoMemorySegment0(MemorySegment ms, long offset) {
         DoubleSpecies vsp = vspecies();
         ScopedMemoryAccess.storeIntoMemorySegment(
-                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                 this,
                 (AbstractMemorySegmentImpl) ms, offset,
                 (msp, off, v) -> {
@@ -3576,7 +3576,7 @@ void intoMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offse
         DoubleSpecies vsp = vspecies();
         m.check(vsp);
         ScopedMemoryAccess.storeIntoMemorySegmentMasked(
-                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                 this, m,
                 (AbstractMemorySegmentImpl) ms, offset,
                 (msp, off, v, vm) -> {
@@ -3793,7 +3793,7 @@ public final long checkValue(long e) {
         final DoubleVector broadcastBits(long bits) {
             return (DoubleVector)
                 VectorSupport.fromBitsCoerced(
-                    vectorType, double.class, double.class, VECTOR_OPER_TYPE, laneCount,
+                    vectorType, double.class, VECTOR_OPER_TYPE, laneCount,
                     bits, MODE_BROADCAST, this,
                     (bits_, s_) -> s_.rvOp(i -> bits_));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float128Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float128Vector.java
index 9202d6548f7..90186647529 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float128Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float128Vector.java
@@ -525,7 +525,7 @@ public float lane(int i) {
     @ForceInline
     public int laneHelper(int i) {
         return (int) VectorSupport.extract(
-                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                     VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                      this, i,
                      (vec, ix) -> {
                      float[] vecarr = vec.vec();
@@ -548,7 +548,7 @@ public Float128Vector withLane(int i, float e) {
     @ForceInline
     public Float128Vector withLaneHelper(int i, float e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)Float.floatToRawIntBits(e),
                                 (v, ix, bits) -> {
                                     float[] res = v.vec().clone();
@@ -663,7 +663,7 @@ public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
         /*package-private*/
         Float128Mask indexPartiallyInUpperRange(long offset, long limit) {
             return (Float128Mask) VectorSupport.indexPartiallyInUpperRange(
-                Float128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                Float128Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> (Float128Mask) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -679,7 +679,7 @@ public Float128Mask not() {
         @ForceInline
         public Float128Mask compress() {
             return (Float128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                Float128Vector.class, Float128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                Float128Vector.class, Float128Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 m1.trueCount()));
         }
@@ -692,7 +692,7 @@ public Float128Mask compress() {
         public Float128Mask and(VectorMask<Float> mask) {
             Objects.requireNonNull(mask);
             Float128Mask m = (Float128Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, Float128Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, Float128Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -702,7 +702,7 @@ public Float128Mask and(VectorMask<Float> mask) {
         public Float128Mask or(VectorMask<Float> mask) {
             Objects.requireNonNull(mask);
             Float128Mask m = (Float128Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, Float128Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, Float128Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -712,7 +712,7 @@ public Float128Mask or(VectorMask<Float> mask) {
         public Float128Mask xor(VectorMask<Float> mask) {
             Objects.requireNonNull(mask);
             Float128Mask m = (Float128Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float128Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float128Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -722,7 +722,7 @@ public Float128Mask xor(VectorMask<Float> mask) {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float128Mask.class, int.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float128Mask.class, int.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -730,7 +730,7 @@ public int trueCount() {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float128Mask.class, int.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float128Mask.class, int.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -738,7 +738,7 @@ public int firstTrue() {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float128Mask.class, int.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float128Mask.class, int.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -749,7 +749,7 @@ public long toLong() {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Float128Mask.class, int.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Float128Mask.class, int.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -760,7 +760,7 @@ public long toLong() {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract(Float128Mask.class, float.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract(Float128Mask.class, float.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -769,7 +769,7 @@ public boolean laneIsSet(int i) {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, Float128Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, Float128Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper(((Float128Mask)m).getBits()));
         }
@@ -777,7 +777,7 @@ this, vspecies().maskAll(true),
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, Float128Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, Float128Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper(((Float128Mask)m).getBits()));
         }
@@ -785,7 +785,7 @@ this, vspecies().maskAll(true),
         @ForceInline
         /*package-private*/
         static Float128Mask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(Float128Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced(Float128Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float256Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float256Vector.java
index f5383fff60a..4c17a7e3c3a 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float256Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float256Vector.java
@@ -529,7 +529,7 @@ public float lane(int i) {
     @ForceInline
     public int laneHelper(int i) {
         return (int) VectorSupport.extract(
-                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                     VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                      this, i,
                      (vec, ix) -> {
                      float[] vecarr = vec.vec();
@@ -556,7 +556,7 @@ public Float256Vector withLane(int i, float e) {
     @ForceInline
     public Float256Vector withLaneHelper(int i, float e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)Float.floatToRawIntBits(e),
                                 (v, ix, bits) -> {
                                     float[] res = v.vec().clone();
@@ -671,7 +671,7 @@ public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
         /*package-private*/
         Float256Mask indexPartiallyInUpperRange(long offset, long limit) {
             return (Float256Mask) VectorSupport.indexPartiallyInUpperRange(
-                Float256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                Float256Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> (Float256Mask) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -687,7 +687,7 @@ public Float256Mask not() {
         @ForceInline
         public Float256Mask compress() {
             return (Float256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                Float256Vector.class, Float256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                Float256Vector.class, Float256Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 m1.trueCount()));
         }
@@ -700,7 +700,7 @@ public Float256Mask compress() {
         public Float256Mask and(VectorMask<Float> mask) {
             Objects.requireNonNull(mask);
             Float256Mask m = (Float256Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, Float256Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, Float256Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -710,7 +710,7 @@ public Float256Mask and(VectorMask<Float> mask) {
         public Float256Mask or(VectorMask<Float> mask) {
             Objects.requireNonNull(mask);
             Float256Mask m = (Float256Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, Float256Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, Float256Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -720,7 +720,7 @@ public Float256Mask or(VectorMask<Float> mask) {
         public Float256Mask xor(VectorMask<Float> mask) {
             Objects.requireNonNull(mask);
             Float256Mask m = (Float256Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float256Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float256Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -730,7 +730,7 @@ public Float256Mask xor(VectorMask<Float> mask) {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float256Mask.class, int.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float256Mask.class, int.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -738,7 +738,7 @@ public int trueCount() {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float256Mask.class, int.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float256Mask.class, int.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -746,7 +746,7 @@ public int firstTrue() {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float256Mask.class, int.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float256Mask.class, int.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -757,7 +757,7 @@ public long toLong() {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Float256Mask.class, int.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Float256Mask.class, int.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -768,7 +768,7 @@ public long toLong() {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract(Float256Mask.class, float.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract(Float256Mask.class, float.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -777,7 +777,7 @@ public boolean laneIsSet(int i) {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, Float256Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, Float256Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper(((Float256Mask)m).getBits()));
         }
@@ -785,7 +785,7 @@ this, vspecies().maskAll(true),
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, Float256Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, Float256Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper(((Float256Mask)m).getBits()));
         }
@@ -793,7 +793,7 @@ this, vspecies().maskAll(true),
         @ForceInline
         /*package-private*/
         static Float256Mask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(Float256Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced(Float256Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float512Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float512Vector.java
index f491ea350fa..40c231362c5 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float512Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float512Vector.java
@@ -537,7 +537,7 @@ public float lane(int i) {
     @ForceInline
     public int laneHelper(int i) {
         return (int) VectorSupport.extract(
-                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                     VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                      this, i,
                      (vec, ix) -> {
                      float[] vecarr = vec.vec();
@@ -572,7 +572,7 @@ public Float512Vector withLane(int i, float e) {
     @ForceInline
     public Float512Vector withLaneHelper(int i, float e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)Float.floatToRawIntBits(e),
                                 (v, ix, bits) -> {
                                     float[] res = v.vec().clone();
@@ -687,7 +687,7 @@ public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
         /*package-private*/
         Float512Mask indexPartiallyInUpperRange(long offset, long limit) {
             return (Float512Mask) VectorSupport.indexPartiallyInUpperRange(
-                Float512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                Float512Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> (Float512Mask) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -703,7 +703,7 @@ public Float512Mask not() {
         @ForceInline
         public Float512Mask compress() {
             return (Float512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                Float512Vector.class, Float512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                Float512Vector.class, Float512Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 m1.trueCount()));
         }
@@ -716,7 +716,7 @@ public Float512Mask compress() {
         public Float512Mask and(VectorMask<Float> mask) {
             Objects.requireNonNull(mask);
             Float512Mask m = (Float512Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, Float512Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, Float512Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -726,7 +726,7 @@ public Float512Mask and(VectorMask<Float> mask) {
         public Float512Mask or(VectorMask<Float> mask) {
             Objects.requireNonNull(mask);
             Float512Mask m = (Float512Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, Float512Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, Float512Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -736,7 +736,7 @@ public Float512Mask or(VectorMask<Float> mask) {
         public Float512Mask xor(VectorMask<Float> mask) {
             Objects.requireNonNull(mask);
             Float512Mask m = (Float512Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float512Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float512Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -746,7 +746,7 @@ public Float512Mask xor(VectorMask<Float> mask) {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float512Mask.class, int.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float512Mask.class, int.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -754,7 +754,7 @@ public int trueCount() {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float512Mask.class, int.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float512Mask.class, int.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -762,7 +762,7 @@ public int firstTrue() {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float512Mask.class, int.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float512Mask.class, int.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -773,7 +773,7 @@ public long toLong() {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Float512Mask.class, int.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Float512Mask.class, int.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -784,7 +784,7 @@ public long toLong() {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract(Float512Mask.class, float.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract(Float512Mask.class, float.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -793,7 +793,7 @@ public boolean laneIsSet(int i) {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, Float512Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, Float512Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper(((Float512Mask)m).getBits()));
         }
@@ -801,7 +801,7 @@ this, vspecies().maskAll(true),
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, Float512Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, Float512Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper(((Float512Mask)m).getBits()));
         }
@@ -809,7 +809,7 @@ this, vspecies().maskAll(true),
         @ForceInline
         /*package-private*/
         static Float512Mask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(Float512Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced(Float512Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float64Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float64Vector.java
index 6d76e8b7640..96c962b379e 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float64Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float64Vector.java
@@ -523,7 +523,7 @@ public float lane(int i) {
     @ForceInline
     public int laneHelper(int i) {
         return (int) VectorSupport.extract(
-                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                     VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                      this, i,
                      (vec, ix) -> {
                      float[] vecarr = vec.vec();
@@ -544,7 +544,7 @@ public Float64Vector withLane(int i, float e) {
     @ForceInline
     public Float64Vector withLaneHelper(int i, float e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)Float.floatToRawIntBits(e),
                                 (v, ix, bits) -> {
                                     float[] res = v.vec().clone();
@@ -659,7 +659,7 @@ public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
         /*package-private*/
         Float64Mask indexPartiallyInUpperRange(long offset, long limit) {
             return (Float64Mask) VectorSupport.indexPartiallyInUpperRange(
-                Float64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                Float64Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> (Float64Mask) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -675,7 +675,7 @@ public Float64Mask not() {
         @ForceInline
         public Float64Mask compress() {
             return (Float64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                Float64Vector.class, Float64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                Float64Vector.class, Float64Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 m1.trueCount()));
         }
@@ -688,7 +688,7 @@ public Float64Mask compress() {
         public Float64Mask and(VectorMask<Float> mask) {
             Objects.requireNonNull(mask);
             Float64Mask m = (Float64Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, Float64Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, Float64Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -698,7 +698,7 @@ public Float64Mask and(VectorMask<Float> mask) {
         public Float64Mask or(VectorMask<Float> mask) {
             Objects.requireNonNull(mask);
             Float64Mask m = (Float64Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, Float64Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, Float64Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -708,7 +708,7 @@ public Float64Mask or(VectorMask<Float> mask) {
         public Float64Mask xor(VectorMask<Float> mask) {
             Objects.requireNonNull(mask);
             Float64Mask m = (Float64Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float64Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float64Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -718,7 +718,7 @@ public Float64Mask xor(VectorMask<Float> mask) {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float64Mask.class, int.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float64Mask.class, int.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -726,7 +726,7 @@ public int trueCount() {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float64Mask.class, int.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float64Mask.class, int.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -734,7 +734,7 @@ public int firstTrue() {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float64Mask.class, int.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float64Mask.class, int.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -745,7 +745,7 @@ public long toLong() {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Float64Mask.class, int.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Float64Mask.class, int.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -756,7 +756,7 @@ public long toLong() {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract(Float64Mask.class, float.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract(Float64Mask.class, float.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -765,7 +765,7 @@ public boolean laneIsSet(int i) {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, Float64Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, Float64Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper(((Float64Mask)m).getBits()));
         }
@@ -773,7 +773,7 @@ this, vspecies().maskAll(true),
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, Float64Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, Float64Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper(((Float64Mask)m).getBits()));
         }
@@ -781,7 +781,7 @@ this, vspecies().maskAll(true),
         @ForceInline
         /*package-private*/
         static Float64Mask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(Float64Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced(Float64Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/FloatMaxVector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/FloatMaxVector.java
index dd1ae255054..fba86f7d740 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/FloatMaxVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/FloatMaxVector.java
@@ -521,7 +521,7 @@ public float lane(int i) {
     @ForceInline
     public int laneHelper(int i) {
         return (int) VectorSupport.extract(
-                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                     VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                      this, i,
                      (vec, ix) -> {
                      float[] vecarr = vec.vec();
@@ -541,7 +541,7 @@ public FloatMaxVector withLane(int i, float e) {
     @ForceInline
     public FloatMaxVector withLaneHelper(int i, float e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)Float.floatToRawIntBits(e),
                                 (v, ix, bits) -> {
                                     float[] res = v.vec().clone();
@@ -656,7 +656,7 @@ public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
         /*package-private*/
         FloatMaxMask indexPartiallyInUpperRange(long offset, long limit) {
             return (FloatMaxMask) VectorSupport.indexPartiallyInUpperRange(
-                FloatMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                FloatMaxMask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> (FloatMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -672,7 +672,7 @@ public FloatMaxMask not() {
         @ForceInline
         public FloatMaxMask compress() {
             return (FloatMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                FloatMaxVector.class, FloatMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                FloatMaxVector.class, FloatMaxMask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 m1.trueCount()));
         }
@@ -685,7 +685,7 @@ public FloatMaxMask compress() {
         public FloatMaxMask and(VectorMask<Float> mask) {
             Objects.requireNonNull(mask);
             FloatMaxMask m = (FloatMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, FloatMaxMask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, FloatMaxMask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -695,7 +695,7 @@ public FloatMaxMask and(VectorMask<Float> mask) {
         public FloatMaxMask or(VectorMask<Float> mask) {
             Objects.requireNonNull(mask);
             FloatMaxMask m = (FloatMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, FloatMaxMask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, FloatMaxMask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -705,7 +705,7 @@ public FloatMaxMask or(VectorMask<Float> mask) {
         public FloatMaxMask xor(VectorMask<Float> mask) {
             Objects.requireNonNull(mask);
             FloatMaxMask m = (FloatMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, FloatMaxMask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, FloatMaxMask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -715,7 +715,7 @@ public FloatMaxMask xor(VectorMask<Float> mask) {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, FloatMaxMask.class, int.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, FloatMaxMask.class, int.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -723,7 +723,7 @@ public int trueCount() {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, FloatMaxMask.class, int.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, FloatMaxMask.class, int.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -731,7 +731,7 @@ public int firstTrue() {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, FloatMaxMask.class, int.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, FloatMaxMask.class, int.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -742,7 +742,7 @@ public long toLong() {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, FloatMaxMask.class, int.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, FloatMaxMask.class, int.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -753,7 +753,7 @@ public long toLong() {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract(FloatMaxMask.class, float.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract(FloatMaxMask.class, float.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -762,7 +762,7 @@ public boolean laneIsSet(int i) {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, FloatMaxMask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, FloatMaxMask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper(((FloatMaxMask)m).getBits()));
         }
@@ -770,7 +770,7 @@ this, vspecies().maskAll(true),
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, FloatMaxMask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, FloatMaxMask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper(((FloatMaxMask)m).getBits()));
         }
@@ -778,7 +778,7 @@ this, vspecies().maskAll(true),
         @ForceInline
         /*package-private*/
         static FloatMaxMask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(FloatMaxMask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced(FloatMaxMask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/FloatVector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/FloatVector.java
index be7abaac806..ad52d6dcf66 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/FloatVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/FloatVector.java
@@ -564,7 +564,7 @@ static FloatVector selectFromTwoVectorHelper(Vector<Float> indexes, Vector<Float
     @ForceInline
     public static FloatVector zero(VectorSpecies<Float> species) {
         FloatSpecies vsp = (FloatSpecies) species;
-        return VectorSupport.fromBitsCoerced(vsp.vectorType(), float.class, float.class, VECTOR_OPER_TYPE, species.length(),
+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), float.class, VECTOR_OPER_TYPE, species.length(),
                         toBits(0.0f), MODE_BROADCAST, vsp,
                         ((bits_, s_) -> s_.rvOp(i -> bits_)));
     }
@@ -686,7 +686,7 @@ else if (opKind(op, VO_MATHLIB)) {
         }
         int opc = opCode(op);
         return VectorSupport.unaryOp(
-            opc, getClass(), null, float.class, float.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, float.class, VECTOR_OPER_TYPE, length(),
             this, null,
             UN_IMPL.find(op, opc, FloatVector::unaryOperations));
     }
@@ -714,7 +714,7 @@ else if (opKind(op, VO_MATHLIB)) {
         }
         int opc = opCode(op);
         return VectorSupport.unaryOp(
-            opc, getClass(), maskClass, float.class, float.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, float.class, VECTOR_OPER_TYPE, length(),
             this, m,
             UN_IMPL.find(op, opc, FloatVector::unaryOperations));
     }
@@ -803,7 +803,7 @@ else if (opKind(op, VO_MATHLIB)) {
 
         int opc = opCode(op);
         return VectorSupport.binaryOp(
-            opc, getClass(), null, float.class, float.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, float.class, VECTOR_OPER_TYPE, length(),
             this, that, null,
             BIN_IMPL.find(op, opc, FloatVector::binaryOperations));
     }
@@ -841,7 +841,7 @@ else if (opKind(op, VO_MATHLIB)) {
 
         int opc = opCode(op);
         return VectorSupport.binaryOp(
-            opc, getClass(), maskClass, float.class, float.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, float.class, VECTOR_OPER_TYPE, length(),
             this, that, m,
             BIN_IMPL.find(op, opc, FloatVector::binaryOperations));
     }
@@ -1023,7 +1023,7 @@ FloatVector lanewiseTemplate(VectorOperators.Ternary op,
         tother.check(this);
         int opc = opCode(op);
         return VectorSupport.ternaryOp(
-            opc, getClass(), null, float.class, float.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, float.class, VECTOR_OPER_TYPE, length(),
             this, that, tother, null,
             TERN_IMPL.find(op, opc, FloatVector::ternaryOperations));
     }
@@ -1058,7 +1058,7 @@ FloatVector lanewiseTemplate(VectorOperators.Ternary op,
 
         int opc = opCode(op);
         return VectorSupport.ternaryOp(
-            opc, getClass(), maskClass, float.class, float.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, float.class, VECTOR_OPER_TYPE, length(),
             this, that, tother, m,
             TERN_IMPL.find(op, opc, FloatVector::ternaryOperations));
     }
@@ -1942,7 +1942,7 @@ M compareTemplate(Class<M> maskType, Comparison op, Vector<Float> v) {
         that.check(this);
         int opc = opCode(op);
         return VectorSupport.compare(
-            opc, getClass(), maskType, float.class, float.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskType, float.class, VECTOR_OPER_TYPE, length(),
             this, that, null,
             (cond, v0, v1, m1) -> {
                 AbstractMask<Float> m
@@ -1964,7 +1964,7 @@ M compareTemplate(Class<M> maskType, Comparison op, Vector<Float> v, M m) {
         m.check(maskType, this);
         int opc = opCode(op);
         return VectorSupport.compare(
-            opc, getClass(), maskType, float.class, float.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskType, float.class, VECTOR_OPER_TYPE, length(),
             this, that, m,
             (cond, v0, v1, m1) -> {
                 AbstractMask<Float> cmpM
@@ -2091,7 +2091,7 @@ VectorMask<Float> compare(Comparison op, long e, VectorMask<Float> m) {
     blendTemplate(Class<M> maskType, FloatVector v, M m) {
         v.check(this);
         return VectorSupport.blend(
-            getClass(), maskType, float.class, float.class, VECTOR_OPER_TYPE, length(),
+            getClass(), maskType, float.class, VECTOR_OPER_TYPE, length(),
             this, v, m,
             (v0, v1, m_) -> v0.bOp(v1, m_, (i, a, b) -> b));
     }
@@ -2108,7 +2108,7 @@ final FloatVector addIndexTemplate(int scale) {
         // make sure VLENGTH*scale doesn't overflow:
         vsp.checkScale(scale);
         return VectorSupport.indexVector(
-            getClass(), float.class, float.class, VECTOR_OPER_TYPE, length(),
+            getClass(), float.class, VECTOR_OPER_TYPE, length(),
             this, scale, vsp,
             (v, scale_, s)
             -> {
@@ -2300,7 +2300,7 @@ FloatVector sliceTemplate(int origin) {
     FloatVector rearrangeTemplate(Class<S> shuffletype, S shuffle) {
         Objects.requireNonNull(shuffle);
         return VectorSupport.rearrangeOp(
-            getClass(), shuffletype, null, float.class, float.class, VECTOR_OPER_TYPE, length(),
+            getClass(), shuffletype, null, float.class, VECTOR_OPER_TYPE, length(),
             this, shuffle, null,
             (v1, s_, m_) -> v1.uOp((i, a) -> {
                 int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
@@ -2327,7 +2327,7 @@ FloatVector rearrangeTemplate(Class<S> shuffletype,
         Objects.requireNonNull(shuffle);
         m.check(masktype, this);
         return VectorSupport.rearrangeOp(
-                   getClass(), shuffletype, masktype, float.class, float.class, VECTOR_OPER_TYPE, length(),
+                   getClass(), shuffletype, masktype, float.class, VECTOR_OPER_TYPE, length(),
                    this, shuffle, m,
                    (v1, s_, m_) -> v1.uOp((i, a) -> {
                         int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
@@ -2353,7 +2353,7 @@ FloatVector rearrangeTemplate(Class<S> shuffletype,
         VectorMask<Float> valid = shuffle.laneIsValid();
         FloatVector r0 =
             VectorSupport.rearrangeOp(
-                getClass(), shuffletype, null, float.class, float.class, VECTOR_OPER_TYPE, length(),
+                getClass(), shuffletype, null, float.class, VECTOR_OPER_TYPE, length(),
                 this, shuffle, null,
                 (v0, s_, m_) -> v0.uOp((i, a) -> {
                     int ei = Integer.remainderUnsigned(s_.laneSource(i), v0.length());
@@ -2361,7 +2361,7 @@ FloatVector rearrangeTemplate(Class<S> shuffletype,
                 }));
         FloatVector r1 =
             VectorSupport.rearrangeOp(
-                getClass(), shuffletype, null, float.class, float.class, VECTOR_OPER_TYPE, length(),
+                getClass(), shuffletype, null, float.class, VECTOR_OPER_TYPE, length(),
                 v, shuffle, null,
                 (v1, s_, m_) -> v1.uOp((i, a) -> {
                     int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
@@ -2405,7 +2405,7 @@ VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp, boolean wrap) {
     FloatVector compressTemplate(Class<M> masktype, M m) {
       m.check(masktype, this);
       return (FloatVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,
-                                                        float.class, float.class, VECTOR_OPER_TYPE, length(), this, m,
+                                                        float.class, VECTOR_OPER_TYPE, length(), this, m,
                                                         (v1, m1) -> compressHelper(v1, m1));
     }
 
@@ -2424,7 +2424,7 @@ float.class, float.class, VECTOR_OPER_TYPE, length(), this, m,
     FloatVector expandTemplate(Class<M> masktype, M m) {
       m.check(masktype, this);
       return (FloatVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,
-                                                        float.class, float.class, VECTOR_OPER_TYPE, length(), this, m,
+                                                        float.class, VECTOR_OPER_TYPE, length(), this, m,
                                                         (v1, m1) -> expandHelper(v1, m1));
     }
 
@@ -2439,7 +2439,7 @@ float.class, float.class, VECTOR_OPER_TYPE, length(), this, m,
     /*package-private*/
     @ForceInline
     final FloatVector selectFromTemplate(FloatVector v) {
-        return (FloatVector)VectorSupport.selectFromOp(getClass(), null, float.class, float.class, VECTOR_OPER_TYPE,
+        return (FloatVector)VectorSupport.selectFromOp(getClass(), null, float.class, VECTOR_OPER_TYPE,
                                                         length(), this, v, null,
                                                         (v1, v2, _m) ->
                                                          v2.rearrange(v1.toShuffle()));
@@ -2459,7 +2459,7 @@ final FloatVector selectFromTemplate(FloatVector v) {
     FloatVector selectFromTemplate(FloatVector v,
                                             Class<M> masktype, M m) {
         m.check(masktype, this);
-        return (FloatVector)VectorSupport.selectFromOp(getClass(), masktype, float.class, float.class, VECTOR_OPER_TYPE,
+        return (FloatVector)VectorSupport.selectFromOp(getClass(), masktype, float.class, VECTOR_OPER_TYPE,
                                                         length(), this, v, m,
                                                         (v1, v2, _m) ->
                                                          v2.rearrange(v1.toShuffle(), _m));
@@ -2477,7 +2477,7 @@ FloatVector selectFromTemplate(FloatVector v,
     /*package-private*/
     @ForceInline
     final FloatVector selectFromTemplate(FloatVector v1, FloatVector v2) {
-        return VectorSupport.selectFromTwoVectorOp(getClass(), float.class, float.class, VECTOR_OPER_TYPE, length(), this, v1, v2,
+        return VectorSupport.selectFromTwoVectorOp(getClass(), float.class, VECTOR_OPER_TYPE, length(), this, v1, v2,
                                                    (vec1, vec2, vec3) -> selectFromTwoVectorHelper(vec1, vec2, vec3));
     }
 
@@ -2683,7 +2683,7 @@ float reduceLanesTemplate(VectorOperators.Associative op,
         }
         int opc = opCode(op);
         return fromBits(VectorSupport.reductionCoerced(
-            opc, getClass(), maskClass, float.class, float.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, float.class, VECTOR_OPER_TYPE, length(),
             this, m,
             REDUCE_IMPL.find(op, opc, FloatVector::reductionOperations)));
     }
@@ -2701,7 +2701,7 @@ float reduceLanesTemplate(VectorOperators.Associative op) {
         }
         int opc = opCode(op);
         return fromBits(VectorSupport.reductionCoerced(
-            opc, getClass(), null, float.class, float.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, float.class, VECTOR_OPER_TYPE, length(),
             this, null,
             REDUCE_IMPL.find(op, opc, FloatVector::reductionOperations)));
     }
@@ -2944,7 +2944,7 @@ FloatVector fromArray(VectorSpecies<Float> species,
         vix = VectorIntrinsics.checkIndex(vix, a.length);
 
         return VectorSupport.loadWithMap(
-            vectorType, null, float.class, float.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+            vectorType, null, float.class, VECTOR_OPER_TYPE, vsp.laneCount(),
             isp.vectorType(), isp.length(),
             a, ARRAY_BASE, vix, null, null, null, null,
             a, offset, indexMap, mapOffset, vsp,
@@ -3127,7 +3127,7 @@ void intoArray(float[] a, int offset) {
         offset = checkFromIndexSize(offset, length(), a.length);
         FloatSpecies vsp = vspecies();
         VectorSupport.store(
-            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false,
             this,
             a, offset,
@@ -3216,7 +3216,7 @@ void intoArray(float[] a, int offset,
         vix = VectorIntrinsics.checkIndex(vix, a.length);
 
         VectorSupport.storeWithMap(
-            vsp.vectorType(), null, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), null, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             isp.vectorType(), isp.length(),
             a, arrayAddress(a, 0), vix,
             this, null,
@@ -3343,7 +3343,7 @@ void intoMemorySegment(MemorySegment ms, long offset,
     FloatVector fromArray0Template(float[] a, int offset) {
         FloatSpecies vsp = vspecies();
         return VectorSupport.load(
-            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false,
             a, offset, vsp,
             (arr, off, s) -> s.ldOp(arr, (int) off,
@@ -3360,7 +3360,7 @@ FloatVector fromArray0Template(Class<M> maskClass, float[] a, int offset, M m, i
         m.check(species());
         FloatSpecies vsp = vspecies();
         return VectorSupport.loadMasked(
-            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false, m, offsetInRange,
             a, offset, vsp,
             (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,
@@ -3393,7 +3393,7 @@ FloatVector fromArray0Template(Class<M> maskClass, float[] a, int offset,
         vix = VectorIntrinsics.checkIndex(vix, a.length);
 
         return VectorSupport.loadWithMap(
-            vectorType, maskClass, float.class, float.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+            vectorType, maskClass, float.class, VECTOR_OPER_TYPE, vsp.laneCount(),
             isp.vectorType(), isp.length(),
             a, ARRAY_BASE, vix, null, null, null, m,
             a, offset, indexMap, mapOffset, vsp,
@@ -3410,7 +3410,7 @@ FloatVector fromArray0Template(Class<M> maskClass, float[] a, int offset,
     FloatVector fromMemorySegment0Template(MemorySegment ms, long offset) {
         FloatSpecies vsp = vspecies();
         return ScopedMemoryAccess.loadFromMemorySegment(
-                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                 (AbstractMemorySegmentImpl) ms, offset, vsp,
                 (msp, off, s) -> {
                     return s.ldLongOp((MemorySegment) msp, off, FloatVector::memorySegmentGet);
@@ -3426,7 +3426,7 @@ FloatVector fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, lon
         FloatSpecies vsp = vspecies();
         m.check(vsp);
         return ScopedMemoryAccess.loadFromMemorySegmentMasked(
-                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                 (AbstractMemorySegmentImpl) ms, offset, m, vsp, offsetInRange,
                 (msp, off, s, vm) -> {
                     return s.ldLongOp((MemorySegment) msp, off, vm, FloatVector::memorySegmentGet);
@@ -3444,7 +3444,7 @@ FloatVector fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, lon
     void intoArray0Template(float[] a, int offset) {
         FloatSpecies vsp = vspecies();
         VectorSupport.store(
-            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false,
             this, a, offset,
             (arr, off, v)
@@ -3461,7 +3461,7 @@ void intoArray0Template(Class<M> maskClass, float[] a, int offset, M m) {
         m.check(species());
         FloatSpecies vsp = vspecies();
         VectorSupport.storeMasked(
-            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false,
             this, m, a, offset,
             (arr, off, v, vm)
@@ -3490,7 +3490,7 @@ void intoArray0Template(Class<M> maskClass, float[] a, int offset,
         vix = VectorIntrinsics.checkIndex(vix, a.length);
 
         VectorSupport.storeWithMap(
-            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             isp.vectorType(), isp.length(),
             a, arrayAddress(a, 0), vix,
             this, m,
@@ -3509,7 +3509,7 @@ a, arrayAddress(a, 0), vix,
     void intoMemorySegment0(MemorySegment ms, long offset) {
         FloatSpecies vsp = vspecies();
         ScopedMemoryAccess.storeIntoMemorySegment(
-                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                 this,
                 (AbstractMemorySegmentImpl) ms, offset,
                 (msp, off, v) -> {
@@ -3526,7 +3526,7 @@ void intoMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offse
         FloatSpecies vsp = vspecies();
         m.check(vsp);
         ScopedMemoryAccess.storeIntoMemorySegmentMasked(
-                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                 this, m,
                 (AbstractMemorySegmentImpl) ms, offset,
                 (msp, off, v, vm) -> {
@@ -3743,7 +3743,7 @@ public final long checkValue(long e) {
         final FloatVector broadcastBits(long bits) {
             return (FloatVector)
                 VectorSupport.fromBitsCoerced(
-                    vectorType, float.class, float.class, VECTOR_OPER_TYPE, laneCount,
+                    vectorType, float.class, VECTOR_OPER_TYPE, laneCount,
                     bits, MODE_BROADCAST, this,
                     (bits_, s_) -> s_.rvOp(i -> bits_));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Halffloat128Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Halffloat128Vector.java
index 45f851a11e7..e4a2c7300c5 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Halffloat128Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Halffloat128Vector.java
@@ -529,7 +529,7 @@ public short lane(int i) {
     @ForceInline
     public short laneHelper(int i) {
         return (short) VectorSupport.extract(
-                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                     VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                      this, i,
                      (vec, ix) -> {
                      short[] vecarr = vec.vec();
@@ -556,7 +556,7 @@ public Halffloat128Vector withLane(int i, short e) {
     @ForceInline
     public Halffloat128Vector withLaneHelper(int i, short e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)e,
                                 (v, ix, bits) -> {
                                     short[] res = v.vec().clone();
@@ -671,7 +671,7 @@ public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
         /*package-private*/
         Halffloat128Mask indexPartiallyInUpperRange(long offset, long limit) {
             return (Halffloat128Mask) VectorSupport.indexPartiallyInUpperRange(
-                Halffloat128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                Halffloat128Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> (Halffloat128Mask) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -687,7 +687,7 @@ public Halffloat128Mask not() {
         @ForceInline
         public Halffloat128Mask compress() {
             return (Halffloat128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                Halffloat128Vector.class, Halffloat128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                Halffloat128Vector.class, Halffloat128Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 Float16.float16ToShortBits(Float16.valueOf(m1.trueCount()))));
         }
@@ -700,7 +700,7 @@ public Halffloat128Mask compress() {
         public Halffloat128Mask and(VectorMask<Float16> mask) {
             Objects.requireNonNull(mask);
             Halffloat128Mask m = (Halffloat128Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat128Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat128Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -710,7 +710,7 @@ public Halffloat128Mask and(VectorMask<Float16> mask) {
         public Halffloat128Mask or(VectorMask<Float16> mask) {
             Objects.requireNonNull(mask);
             Halffloat128Mask m = (Halffloat128Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat128Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat128Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -720,7 +720,7 @@ public Halffloat128Mask or(VectorMask<Float16> mask) {
         public Halffloat128Mask xor(VectorMask<Float16> mask) {
             Objects.requireNonNull(mask);
             Halffloat128Mask m = (Halffloat128Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat128Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat128Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -730,7 +730,7 @@ public Halffloat128Mask xor(VectorMask<Float16> mask) {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat128Mask.class, short.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat128Mask.class, short.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -738,7 +738,7 @@ public int trueCount() {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat128Mask.class, short.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat128Mask.class, short.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -746,7 +746,7 @@ public int firstTrue() {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat128Mask.class, short.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat128Mask.class, short.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -757,7 +757,7 @@ public long toLong() {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat128Mask.class, short.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat128Mask.class, short.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -768,7 +768,7 @@ public long toLong() {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract(Halffloat128Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract(Halffloat128Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -777,7 +777,7 @@ public boolean laneIsSet(int i) {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, Halffloat128Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, Halffloat128Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper(((Halffloat128Mask)m).getBits()));
         }
@@ -785,7 +785,7 @@ this, vspecies().maskAll(true),
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, Halffloat128Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, Halffloat128Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper(((Halffloat128Mask)m).getBits()));
         }
@@ -793,7 +793,7 @@ this, vspecies().maskAll(true),
         @ForceInline
         /*package-private*/
         static Halffloat128Mask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(Halffloat128Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced(Halffloat128Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Halffloat256Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Halffloat256Vector.java
index 149c19e7626..f92c4ed8f79 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Halffloat256Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Halffloat256Vector.java
@@ -537,7 +537,7 @@ public short lane(int i) {
     @ForceInline
     public short laneHelper(int i) {
         return (short) VectorSupport.extract(
-                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                     VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                      this, i,
                      (vec, ix) -> {
                      short[] vecarr = vec.vec();
@@ -572,7 +572,7 @@ public Halffloat256Vector withLane(int i, short e) {
     @ForceInline
     public Halffloat256Vector withLaneHelper(int i, short e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)e,
                                 (v, ix, bits) -> {
                                     short[] res = v.vec().clone();
@@ -687,7 +687,7 @@ public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
         /*package-private*/
         Halffloat256Mask indexPartiallyInUpperRange(long offset, long limit) {
             return (Halffloat256Mask) VectorSupport.indexPartiallyInUpperRange(
-                Halffloat256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                Halffloat256Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> (Halffloat256Mask) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -703,7 +703,7 @@ public Halffloat256Mask not() {
         @ForceInline
         public Halffloat256Mask compress() {
             return (Halffloat256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                Halffloat256Vector.class, Halffloat256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                Halffloat256Vector.class, Halffloat256Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 Float16.float16ToShortBits(Float16.valueOf(m1.trueCount()))));
         }
@@ -716,7 +716,7 @@ public Halffloat256Mask compress() {
         public Halffloat256Mask and(VectorMask<Float16> mask) {
             Objects.requireNonNull(mask);
             Halffloat256Mask m = (Halffloat256Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat256Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat256Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -726,7 +726,7 @@ public Halffloat256Mask and(VectorMask<Float16> mask) {
         public Halffloat256Mask or(VectorMask<Float16> mask) {
             Objects.requireNonNull(mask);
             Halffloat256Mask m = (Halffloat256Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat256Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat256Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -736,7 +736,7 @@ public Halffloat256Mask or(VectorMask<Float16> mask) {
         public Halffloat256Mask xor(VectorMask<Float16> mask) {
             Objects.requireNonNull(mask);
             Halffloat256Mask m = (Halffloat256Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat256Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat256Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -746,7 +746,7 @@ public Halffloat256Mask xor(VectorMask<Float16> mask) {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat256Mask.class, short.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat256Mask.class, short.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -754,7 +754,7 @@ public int trueCount() {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat256Mask.class, short.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat256Mask.class, short.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -762,7 +762,7 @@ public int firstTrue() {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat256Mask.class, short.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat256Mask.class, short.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -773,7 +773,7 @@ public long toLong() {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat256Mask.class, short.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat256Mask.class, short.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -784,7 +784,7 @@ public long toLong() {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract(Halffloat256Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract(Halffloat256Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -793,7 +793,7 @@ public boolean laneIsSet(int i) {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, Halffloat256Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, Halffloat256Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper(((Halffloat256Mask)m).getBits()));
         }
@@ -801,7 +801,7 @@ this, vspecies().maskAll(true),
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, Halffloat256Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, Halffloat256Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper(((Halffloat256Mask)m).getBits()));
         }
@@ -809,7 +809,7 @@ this, vspecies().maskAll(true),
         @ForceInline
         /*package-private*/
         static Halffloat256Mask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(Halffloat256Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced(Halffloat256Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Halffloat512Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Halffloat512Vector.java
index 74c9aa2ec9d..15e86b35b42 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Halffloat512Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Halffloat512Vector.java
@@ -553,7 +553,7 @@ public short lane(int i) {
     @ForceInline
     public short laneHelper(int i) {
         return (short) VectorSupport.extract(
-                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                     VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                      this, i,
                      (vec, ix) -> {
                      short[] vecarr = vec.vec();
@@ -604,7 +604,7 @@ public Halffloat512Vector withLane(int i, short e) {
     @ForceInline
     public Halffloat512Vector withLaneHelper(int i, short e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)e,
                                 (v, ix, bits) -> {
                                     short[] res = v.vec().clone();
@@ -719,7 +719,7 @@ public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
         /*package-private*/
         Halffloat512Mask indexPartiallyInUpperRange(long offset, long limit) {
             return (Halffloat512Mask) VectorSupport.indexPartiallyInUpperRange(
-                Halffloat512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                Halffloat512Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> (Halffloat512Mask) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -735,7 +735,7 @@ public Halffloat512Mask not() {
         @ForceInline
         public Halffloat512Mask compress() {
             return (Halffloat512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                Halffloat512Vector.class, Halffloat512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                Halffloat512Vector.class, Halffloat512Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 Float16.float16ToShortBits(Float16.valueOf(m1.trueCount()))));
         }
@@ -748,7 +748,7 @@ public Halffloat512Mask compress() {
         public Halffloat512Mask and(VectorMask<Float16> mask) {
             Objects.requireNonNull(mask);
             Halffloat512Mask m = (Halffloat512Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat512Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat512Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -758,7 +758,7 @@ public Halffloat512Mask and(VectorMask<Float16> mask) {
         public Halffloat512Mask or(VectorMask<Float16> mask) {
             Objects.requireNonNull(mask);
             Halffloat512Mask m = (Halffloat512Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat512Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat512Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -768,7 +768,7 @@ public Halffloat512Mask or(VectorMask<Float16> mask) {
         public Halffloat512Mask xor(VectorMask<Float16> mask) {
             Objects.requireNonNull(mask);
             Halffloat512Mask m = (Halffloat512Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat512Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat512Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -778,7 +778,7 @@ public Halffloat512Mask xor(VectorMask<Float16> mask) {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat512Mask.class, short.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat512Mask.class, short.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -786,7 +786,7 @@ public int trueCount() {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat512Mask.class, short.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat512Mask.class, short.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -794,7 +794,7 @@ public int firstTrue() {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat512Mask.class, short.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat512Mask.class, short.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -805,7 +805,7 @@ public long toLong() {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat512Mask.class, short.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat512Mask.class, short.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -816,7 +816,7 @@ public long toLong() {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract(Halffloat512Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract(Halffloat512Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -825,7 +825,7 @@ public boolean laneIsSet(int i) {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, Halffloat512Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, Halffloat512Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper(((Halffloat512Mask)m).getBits()));
         }
@@ -833,7 +833,7 @@ this, vspecies().maskAll(true),
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, Halffloat512Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, Halffloat512Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper(((Halffloat512Mask)m).getBits()));
         }
@@ -841,7 +841,7 @@ this, vspecies().maskAll(true),
         @ForceInline
         /*package-private*/
         static Halffloat512Mask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(Halffloat512Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced(Halffloat512Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Halffloat64Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Halffloat64Vector.java
index ee9a38b4d40..2fced0182d3 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Halffloat64Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Halffloat64Vector.java
@@ -525,7 +525,7 @@ public short lane(int i) {
     @ForceInline
     public short laneHelper(int i) {
         return (short) VectorSupport.extract(
-                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                     VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                      this, i,
                      (vec, ix) -> {
                      short[] vecarr = vec.vec();
@@ -548,7 +548,7 @@ public Halffloat64Vector withLane(int i, short e) {
     @ForceInline
     public Halffloat64Vector withLaneHelper(int i, short e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)e,
                                 (v, ix, bits) -> {
                                     short[] res = v.vec().clone();
@@ -663,7 +663,7 @@ public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
         /*package-private*/
         Halffloat64Mask indexPartiallyInUpperRange(long offset, long limit) {
             return (Halffloat64Mask) VectorSupport.indexPartiallyInUpperRange(
-                Halffloat64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                Halffloat64Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> (Halffloat64Mask) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -679,7 +679,7 @@ public Halffloat64Mask not() {
         @ForceInline
         public Halffloat64Mask compress() {
             return (Halffloat64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                Halffloat64Vector.class, Halffloat64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                Halffloat64Vector.class, Halffloat64Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 Float16.float16ToShortBits(Float16.valueOf(m1.trueCount()))));
         }
@@ -692,7 +692,7 @@ public Halffloat64Mask compress() {
         public Halffloat64Mask and(VectorMask<Float16> mask) {
             Objects.requireNonNull(mask);
             Halffloat64Mask m = (Halffloat64Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat64Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat64Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -702,7 +702,7 @@ public Halffloat64Mask and(VectorMask<Float16> mask) {
         public Halffloat64Mask or(VectorMask<Float16> mask) {
             Objects.requireNonNull(mask);
             Halffloat64Mask m = (Halffloat64Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat64Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat64Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -712,7 +712,7 @@ public Halffloat64Mask or(VectorMask<Float16> mask) {
         public Halffloat64Mask xor(VectorMask<Float16> mask) {
             Objects.requireNonNull(mask);
             Halffloat64Mask m = (Halffloat64Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat64Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat64Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -722,7 +722,7 @@ public Halffloat64Mask xor(VectorMask<Float16> mask) {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat64Mask.class, short.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat64Mask.class, short.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -730,7 +730,7 @@ public int trueCount() {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat64Mask.class, short.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat64Mask.class, short.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -738,7 +738,7 @@ public int firstTrue() {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat64Mask.class, short.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat64Mask.class, short.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -749,7 +749,7 @@ public long toLong() {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat64Mask.class, short.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat64Mask.class, short.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -760,7 +760,7 @@ public long toLong() {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract(Halffloat64Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract(Halffloat64Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -769,7 +769,7 @@ public boolean laneIsSet(int i) {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, Halffloat64Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, Halffloat64Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper(((Halffloat64Mask)m).getBits()));
         }
@@ -777,7 +777,7 @@ this, vspecies().maskAll(true),
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, Halffloat64Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, Halffloat64Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper(((Halffloat64Mask)m).getBits()));
         }
@@ -785,7 +785,7 @@ this, vspecies().maskAll(true),
         @ForceInline
         /*package-private*/
         static Halffloat64Mask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(Halffloat64Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced(Halffloat64Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/HalffloatMaxVector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/HalffloatMaxVector.java
index 8448153cd00..dae70528a5a 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/HalffloatMaxVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/HalffloatMaxVector.java
@@ -521,7 +521,7 @@ public short lane(int i) {
     @ForceInline
     public short laneHelper(int i) {
         return (short) VectorSupport.extract(
-                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                     VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                      this, i,
                      (vec, ix) -> {
                      short[] vecarr = vec.vec();
@@ -541,7 +541,7 @@ public HalffloatMaxVector withLane(int i, short e) {
     @ForceInline
     public HalffloatMaxVector withLaneHelper(int i, short e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)e,
                                 (v, ix, bits) -> {
                                     short[] res = v.vec().clone();
@@ -656,7 +656,7 @@ public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
         /*package-private*/
         HalffloatMaxMask indexPartiallyInUpperRange(long offset, long limit) {
             return (HalffloatMaxMask) VectorSupport.indexPartiallyInUpperRange(
-                HalffloatMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                HalffloatMaxMask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> (HalffloatMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -672,7 +672,7 @@ public HalffloatMaxMask not() {
         @ForceInline
         public HalffloatMaxMask compress() {
             return (HalffloatMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                HalffloatMaxVector.class, HalffloatMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                HalffloatMaxVector.class, HalffloatMaxMask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 Float16.float16ToShortBits(Float16.valueOf(m1.trueCount()))));
         }
@@ -685,7 +685,7 @@ public HalffloatMaxMask compress() {
         public HalffloatMaxMask and(VectorMask<Float16> mask) {
             Objects.requireNonNull(mask);
             HalffloatMaxMask m = (HalffloatMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, HalffloatMaxMask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, HalffloatMaxMask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -695,7 +695,7 @@ public HalffloatMaxMask and(VectorMask<Float16> mask) {
         public HalffloatMaxMask or(VectorMask<Float16> mask) {
             Objects.requireNonNull(mask);
             HalffloatMaxMask m = (HalffloatMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, HalffloatMaxMask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, HalffloatMaxMask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -705,7 +705,7 @@ public HalffloatMaxMask or(VectorMask<Float16> mask) {
         public HalffloatMaxMask xor(VectorMask<Float16> mask) {
             Objects.requireNonNull(mask);
             HalffloatMaxMask m = (HalffloatMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, HalffloatMaxMask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, HalffloatMaxMask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -715,7 +715,7 @@ public HalffloatMaxMask xor(VectorMask<Float16> mask) {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, HalffloatMaxMask.class, short.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, HalffloatMaxMask.class, short.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -723,7 +723,7 @@ public int trueCount() {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, HalffloatMaxMask.class, short.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, HalffloatMaxMask.class, short.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -731,7 +731,7 @@ public int firstTrue() {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, HalffloatMaxMask.class, short.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, HalffloatMaxMask.class, short.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -742,7 +742,7 @@ public long toLong() {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, HalffloatMaxMask.class, short.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, HalffloatMaxMask.class, short.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -753,7 +753,7 @@ public long toLong() {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract(HalffloatMaxMask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract(HalffloatMaxMask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -762,7 +762,7 @@ public boolean laneIsSet(int i) {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, HalffloatMaxMask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, HalffloatMaxMask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper(((HalffloatMaxMask)m).getBits()));
         }
@@ -770,7 +770,7 @@ this, vspecies().maskAll(true),
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, HalffloatMaxMask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, HalffloatMaxMask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper(((HalffloatMaxMask)m).getBits()));
         }
@@ -778,7 +778,7 @@ this, vspecies().maskAll(true),
         @ForceInline
         /*package-private*/
         static HalffloatMaxMask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(HalffloatMaxMask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced(HalffloatMaxMask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/HalffloatVector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/HalffloatVector.java
index 6873f300b49..ef117e79a8a 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/HalffloatVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/HalffloatVector.java
@@ -535,7 +535,8 @@ static HalffloatVector selectFromTwoVectorHelper(Vector<Float16> indexes, Vector
         short[] vecPayload2 = ((HalffloatVector)src1).vec();
         short[] vecPayload3 = ((HalffloatVector)src2).vec();
         for (int i = 0; i < vlen; i++) {
-            int wrapped_index = VectorIntrinsics.wrapToRange((int)vecPayload1[i], 2 * vlen);
+            int index = Float16.shortBitsToFloat16(vecPayload1[i]).intValue();
+            int wrapped_index = VectorIntrinsics.wrapToRange(index, 2 * vlen);
             res[i] = wrapped_index >= vlen ? vecPayload3[wrapped_index - vlen] : vecPayload2[wrapped_index];
         }
         return ((HalffloatVector)src1).vectorFactory(res);
@@ -565,7 +566,7 @@ static HalffloatVector selectFromTwoVectorHelper(Vector<Float16> indexes, Vector
     @ForceInline
     public static HalffloatVector zero(VectorSpecies<Float16> species) {
         HalffloatSpecies vsp = (HalffloatSpecies) species;
-        return VectorSupport.fromBitsCoerced(vsp.vectorType(), short.class, Float16.class, VECTOR_OPER_TYPE, species.length(),
+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), short.class, VECTOR_OPER_TYPE, species.length(),
                         toBits((short) 0), MODE_BROADCAST, vsp,
                         ((bits_, s_) -> s_.rvOp(i -> bits_)));
     }
@@ -687,7 +688,7 @@ else if (opKind(op, VO_MATHLIB)) {
         }
         int opc = opCode(op);
         return VectorSupport.unaryOp(
-            opc, getClass(), null, short.class, Float16.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, short.class, VECTOR_OPER_TYPE, length(),
             this, null,
             UN_IMPL.find(op, opc, HalffloatVector::unaryOperations));
     }
@@ -715,7 +716,7 @@ else if (opKind(op, VO_MATHLIB)) {
         }
         int opc = opCode(op);
         return VectorSupport.unaryOp(
-            opc, getClass(), maskClass, short.class, Float16.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, short.class, VECTOR_OPER_TYPE, length(),
             this, m,
             UN_IMPL.find(op, opc, HalffloatVector::unaryOperations));
     }
@@ -804,7 +805,7 @@ else if (opKind(op, VO_MATHLIB)) {
 
         int opc = opCode(op);
         return VectorSupport.binaryOp(
-            opc, getClass(), null, short.class, Float16.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, short.class, VECTOR_OPER_TYPE, length(),
             this, that, null,
             BIN_IMPL.find(op, opc, HalffloatVector::binaryOperations));
     }
@@ -842,7 +843,7 @@ else if (opKind(op, VO_MATHLIB)) {
 
         int opc = opCode(op);
         return VectorSupport.binaryOp(
-            opc, getClass(), maskClass, short.class, Float16.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, short.class, VECTOR_OPER_TYPE, length(),
             this, that, m,
             BIN_IMPL.find(op, opc, HalffloatVector::binaryOperations));
     }
@@ -1022,7 +1023,7 @@ HalffloatVector lanewiseTemplate(VectorOperators.Ternary op,
         tother.check(this);
         int opc = opCode(op);
         return VectorSupport.ternaryOp(
-            opc, getClass(), null, short.class, Float16.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, short.class, VECTOR_OPER_TYPE, length(),
             this, that, tother, null,
             TERN_IMPL.find(op, opc, HalffloatVector::ternaryOperations));
     }
@@ -1057,7 +1058,7 @@ HalffloatVector lanewiseTemplate(VectorOperators.Ternary op,
 
         int opc = opCode(op);
         return VectorSupport.ternaryOp(
-            opc, getClass(), maskClass, short.class, Float16.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, short.class, VECTOR_OPER_TYPE, length(),
             this, that, tother, m,
             TERN_IMPL.find(op, opc, HalffloatVector::ternaryOperations));
     }
@@ -1929,7 +1930,7 @@ M compareTemplate(Class<M> maskType, Comparison op, Vector<Float16> v) {
         that.check(this);
         int opc = opCode(op);
         return VectorSupport.compare(
-            opc, getClass(), maskType, short.class, Float16.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskType, short.class, VECTOR_OPER_TYPE, length(),
             this, that, null,
             (cond, v0, v1, m1) -> {
                 AbstractMask<Float16> m
@@ -1951,7 +1952,7 @@ M compareTemplate(Class<M> maskType, Comparison op, Vector<Float16> v, M m) {
         m.check(maskType, this);
         int opc = opCode(op);
         return VectorSupport.compare(
-            opc, getClass(), maskType, short.class, Float16.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskType, short.class, VECTOR_OPER_TYPE, length(),
             this, that, m,
             (cond, v0, v1, m1) -> {
                 AbstractMask<Float16> cmpM
@@ -2078,7 +2079,7 @@ VectorMask<Float16> compare(Comparison op, long e, VectorMask<Float16> m) {
     blendTemplate(Class<M> maskType, HalffloatVector v, M m) {
         v.check(this);
         return VectorSupport.blend(
-            getClass(), maskType, short.class, Float16.class, VECTOR_OPER_TYPE, length(),
+            getClass(), maskType, short.class, VECTOR_OPER_TYPE, length(),
             this, v, m,
             (v0, v1, m_) -> v0.bOp(v1, m_, (i, a, b) -> b));
     }
@@ -2095,7 +2096,7 @@ final HalffloatVector addIndexTemplate(int scale) {
         // make sure VLENGTH*scale doesn't overflow:
         vsp.checkScale(scale);
         return VectorSupport.indexVector(
-            getClass(), short.class, Float16.class, VECTOR_OPER_TYPE, length(),
+            getClass(), short.class, VECTOR_OPER_TYPE, length(),
             this, scale, vsp,
             (v, scale_, s)
             -> {
@@ -2287,7 +2288,7 @@ HalffloatVector sliceTemplate(int origin) {
     HalffloatVector rearrangeTemplate(Class<S> shuffletype, S shuffle) {
         Objects.requireNonNull(shuffle);
         return VectorSupport.rearrangeOp(
-            getClass(), shuffletype, null, short.class, Float16.class, VECTOR_OPER_TYPE, length(),
+            getClass(), shuffletype, null, short.class, VECTOR_OPER_TYPE, length(),
             this, shuffle, null,
             (v1, s_, m_) -> v1.uOp((i, a) -> {
                 int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
@@ -2314,7 +2315,7 @@ HalffloatVector rearrangeTemplate(Class<S> shuffletype,
         Objects.requireNonNull(shuffle);
         m.check(masktype, this);
         return VectorSupport.rearrangeOp(
-                   getClass(), shuffletype, masktype, short.class, Float16.class, VECTOR_OPER_TYPE, length(),
+                   getClass(), shuffletype, masktype, short.class, VECTOR_OPER_TYPE, length(),
                    this, shuffle, m,
                    (v1, s_, m_) -> v1.uOp((i, a) -> {
                         int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
@@ -2340,7 +2341,7 @@ HalffloatVector rearrangeTemplate(Class<S> shuffletype,
         VectorMask<Float16> valid = shuffle.laneIsValid();
         HalffloatVector r0 =
             VectorSupport.rearrangeOp(
-                getClass(), shuffletype, null, short.class, Float16.class, VECTOR_OPER_TYPE, length(),
+                getClass(), shuffletype, null, short.class, VECTOR_OPER_TYPE, length(),
                 this, shuffle, null,
                 (v0, s_, m_) -> v0.uOp((i, a) -> {
                     int ei = Integer.remainderUnsigned(s_.laneSource(i), v0.length());
@@ -2348,7 +2349,7 @@ HalffloatVector rearrangeTemplate(Class<S> shuffletype,
                 }));
         HalffloatVector r1 =
             VectorSupport.rearrangeOp(
-                getClass(), shuffletype, null, short.class, Float16.class, VECTOR_OPER_TYPE, length(),
+                getClass(), shuffletype, null, short.class, VECTOR_OPER_TYPE, length(),
                 v, shuffle, null,
                 (v1, s_, m_) -> v1.uOp((i, a) -> {
                     int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
@@ -2392,7 +2393,7 @@ VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp, boolean wrap) {
     HalffloatVector compressTemplate(Class<M> masktype, M m) {
       m.check(masktype, this);
       return (HalffloatVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,
-                                                        short.class, Float16.class, VECTOR_OPER_TYPE, length(), this, m,
+                                                        short.class, VECTOR_OPER_TYPE, length(), this, m,
                                                         (v1, m1) -> compressHelper(v1, m1));
     }
 
@@ -2411,7 +2412,7 @@ short.class, Float16.class, VECTOR_OPER_TYPE, length(), this, m,
     HalffloatVector expandTemplate(Class<M> masktype, M m) {
       m.check(masktype, this);
       return (HalffloatVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,
-                                                        short.class, Float16.class, VECTOR_OPER_TYPE, length(), this, m,
+                                                        short.class, VECTOR_OPER_TYPE, length(), this, m,
                                                         (v1, m1) -> expandHelper(v1, m1));
     }
 
@@ -2426,7 +2427,7 @@ short.class, Float16.class, VECTOR_OPER_TYPE, length(), this, m,
     /*package-private*/
     @ForceInline
     final HalffloatVector selectFromTemplate(HalffloatVector v) {
-        return (HalffloatVector)VectorSupport.selectFromOp(getClass(), null, short.class, Float16.class, VECTOR_OPER_TYPE,
+        return (HalffloatVector)VectorSupport.selectFromOp(getClass(), null, short.class, VECTOR_OPER_TYPE,
                                                         length(), this, v, null,
                                                         (v1, v2, _m) ->
                                                          v2.rearrange(v1.toShuffle()));
@@ -2446,7 +2447,7 @@ final HalffloatVector selectFromTemplate(HalffloatVector v) {
     HalffloatVector selectFromTemplate(HalffloatVector v,
                                             Class<M> masktype, M m) {
         m.check(masktype, this);
-        return (HalffloatVector)VectorSupport.selectFromOp(getClass(), masktype, short.class, Float16.class, VECTOR_OPER_TYPE,
+        return (HalffloatVector)VectorSupport.selectFromOp(getClass(), masktype, short.class, VECTOR_OPER_TYPE,
                                                         length(), this, v, m,
                                                         (v1, v2, _m) ->
                                                          v2.rearrange(v1.toShuffle(), _m));
@@ -2464,7 +2465,7 @@ HalffloatVector selectFromTemplate(HalffloatVector v,
     /*package-private*/
     @ForceInline
     final HalffloatVector selectFromTemplate(HalffloatVector v1, HalffloatVector v2) {
-        return VectorSupport.selectFromTwoVectorOp(getClass(), short.class, Float16.class, VECTOR_OPER_TYPE, length(), this, v1, v2,
+        return VectorSupport.selectFromTwoVectorOp(getClass(), short.class, VECTOR_OPER_TYPE, length(), this, v1, v2,
                                                    (vec1, vec2, vec3) -> selectFromTwoVectorHelper(vec1, vec2, vec3));
     }
 
@@ -2662,7 +2663,7 @@ short reduceLanesTemplate(VectorOperators.Associative op,
         }
         int opc = opCode(op);
         return fromBits(VectorSupport.reductionCoerced(
-            opc, getClass(), maskClass, short.class, Float16.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, short.class, VECTOR_OPER_TYPE, length(),
             this, m,
             REDUCE_IMPL.find(op, opc, HalffloatVector::reductionOperations)));
     }
@@ -2680,7 +2681,7 @@ short reduceLanesTemplate(VectorOperators.Associative op) {
         }
         int opc = opCode(op);
         return fromBits(VectorSupport.reductionCoerced(
-            opc, getClass(), null, short.class, Float16.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, short.class, VECTOR_OPER_TYPE, length(),
             this, null,
             REDUCE_IMPL.find(op, opc, HalffloatVector::reductionOperations)));
     }
@@ -2937,7 +2938,7 @@ HalffloatVector fromArray(VectorSpecies<Float16> species,
         }
 
         return VectorSupport.loadWithMap(
-            vectorType, null, short.class, Float16.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+            vectorType, null, short.class, VECTOR_OPER_TYPE, vsp.laneCount(),
             lsp.vectorType(), lsp.length(),
             a, ARRAY_BASE, vix0, vix1, null, null, null,
             a, offset, indexMap, mapOffset, vsp,
@@ -3270,7 +3271,7 @@ void intoArray(short[] a, int offset) {
         offset = checkFromIndexSize(offset, length(), a.length);
         HalffloatSpecies vsp = vspecies();
         VectorSupport.store(
-            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false,
             this,
             a, offset,
@@ -3419,7 +3420,7 @@ void intoCharArray(char[] a, int offset) {
         offset = checkFromIndexSize(offset, length(), a.length);
         HalffloatSpecies vsp = vspecies();
         VectorSupport.store(
-            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, charArrayAddress(a, offset), false,
             this,
             a, offset,
@@ -3624,7 +3625,7 @@ void intoMemorySegment(MemorySegment ms, long offset,
     HalffloatVector fromArray0Template(short[] a, int offset) {
         HalffloatSpecies vsp = vspecies();
         return VectorSupport.load(
-            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false,
             a, offset, vsp,
             (arr, off, s) -> s.ldOp(arr, (int) off,
@@ -3641,7 +3642,7 @@ HalffloatVector fromArray0Template(Class<M> maskClass, short[] a, int offset, M
         m.check(species());
         HalffloatSpecies vsp = vspecies();
         return VectorSupport.loadMasked(
-            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false, m, offsetInRange,
             a, offset, vsp,
             (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,
@@ -3688,7 +3689,7 @@ HalffloatVector fromArray0Template(Class<M> maskClass, short[] a, int offset,
         }
 
         return VectorSupport.loadWithMap(
-            vectorType, maskClass, short.class, Float16.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+            vectorType, maskClass, short.class, VECTOR_OPER_TYPE, vsp.laneCount(),
             lsp.vectorType(), lsp.length(),
             a, ARRAY_BASE, vix0, vix1, null, null, m,
             a, offset, indexMap, mapOffset, vsp,
@@ -3704,7 +3705,7 @@ HalffloatVector fromArray0Template(Class<M> maskClass, short[] a, int offset,
     HalffloatVector fromCharArray0Template(char[] a, int offset) {
         HalffloatSpecies vsp = vspecies();
         return VectorSupport.load(
-            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, charArrayAddress(a, offset), false,
             a, offset, vsp,
             (arr, off, s) -> s.ldOp(arr, (int) off,
@@ -3721,7 +3722,7 @@ HalffloatVector fromCharArray0Template(Class<M> maskClass, char[] a, int offset,
         m.check(species());
         HalffloatSpecies vsp = vspecies();
         return VectorSupport.loadMasked(
-                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                 a, charArrayAddress(a, offset), false, m, offsetInRange,
                 a, offset, vsp,
                 (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,
@@ -3736,7 +3737,7 @@ a, charArrayAddress(a, offset), false, m, offsetInRange,
     HalffloatVector fromMemorySegment0Template(MemorySegment ms, long offset) {
         HalffloatSpecies vsp = vspecies();
         return ScopedMemoryAccess.loadFromMemorySegment(
-                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                 (AbstractMemorySegmentImpl) ms, offset, vsp,
                 (msp, off, s) -> {
                     return s.ldLongOp((MemorySegment) msp, off, HalffloatVector::memorySegmentGet);
@@ -3752,7 +3753,7 @@ HalffloatVector fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms,
         HalffloatSpecies vsp = vspecies();
         m.check(vsp);
         return ScopedMemoryAccess.loadFromMemorySegmentMasked(
-                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                 (AbstractMemorySegmentImpl) ms, offset, m, vsp, offsetInRange,
                 (msp, off, s, vm) -> {
                     return s.ldLongOp((MemorySegment) msp, off, vm, HalffloatVector::memorySegmentGet);
@@ -3770,7 +3771,7 @@ HalffloatVector fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms,
     void intoArray0Template(short[] a, int offset) {
         HalffloatSpecies vsp = vspecies();
         VectorSupport.store(
-            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false,
             this, a, offset,
             (arr, off, v)
@@ -3787,7 +3788,7 @@ void intoArray0Template(Class<M> maskClass, short[] a, int offset, M m) {
         m.check(species());
         HalffloatSpecies vsp = vspecies();
         VectorSupport.storeMasked(
-            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false,
             this, m, a, offset,
             (arr, off, v, vm)
@@ -3802,7 +3803,7 @@ a, arrayAddress(a, offset), false,
     void intoMemorySegment0(MemorySegment ms, long offset) {
         HalffloatSpecies vsp = vspecies();
         ScopedMemoryAccess.storeIntoMemorySegment(
-                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                 this,
                 (AbstractMemorySegmentImpl) ms, offset,
                 (msp, off, v) -> {
@@ -3819,7 +3820,7 @@ void intoMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offse
         HalffloatSpecies vsp = vspecies();
         m.check(vsp);
         ScopedMemoryAccess.storeIntoMemorySegmentMasked(
-                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                 this, m,
                 (AbstractMemorySegmentImpl) ms, offset,
                 (msp, off, v, vm) -> {
@@ -3837,7 +3838,7 @@ void intoCharArray0Template(Class<M> maskClass, char[] a, int offset, M m) {
         m.check(species());
         HalffloatSpecies vsp = vspecies();
         VectorSupport.storeMasked(
-            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, charArrayAddress(a, offset), false,
             this, m, a, offset,
             (arr, off, v, vm)
@@ -4069,7 +4070,7 @@ public final long checkValue(long e) {
         final HalffloatVector broadcastBits(long bits) {
             return (HalffloatVector)
                 VectorSupport.fromBitsCoerced(
-                    vectorType, short.class, Float16.class, VECTOR_OPER_TYPE, laneCount,
+                    vectorType, short.class, VECTOR_OPER_TYPE, laneCount,
                     bits, MODE_BROADCAST, this,
                     (bits_, s_) -> s_.rvOp(i -> bits_));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int128Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int128Vector.java
index 69b50f30684..9949158018c 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int128Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int128Vector.java
@@ -536,7 +536,7 @@ public int lane(int i) {
     @ForceInline
     public int laneHelper(int i) {
         return (int) VectorSupport.extract(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i,
                                 (vec, ix) -> {
                                     int[] vecarr = vec.vec();
@@ -559,7 +559,7 @@ public Int128Vector withLane(int i, int e) {
     @ForceInline
     public Int128Vector withLaneHelper(int i, int e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)e,
                                 (v, ix, bits) -> {
                                     int[] res = v.vec().clone();
@@ -674,7 +674,7 @@ public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
         /*package-private*/
         Int128Mask indexPartiallyInUpperRange(long offset, long limit) {
             return (Int128Mask) VectorSupport.indexPartiallyInUpperRange(
-                Int128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                Int128Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> (Int128Mask) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -690,7 +690,7 @@ public Int128Mask not() {
         @ForceInline
         public Int128Mask compress() {
             return (Int128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                Int128Vector.class, Int128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                Int128Vector.class, Int128Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 m1.trueCount()));
         }
@@ -703,7 +703,7 @@ public Int128Mask compress() {
         public Int128Mask and(VectorMask<Integer> mask) {
             Objects.requireNonNull(mask);
             Int128Mask m = (Int128Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, Int128Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, Int128Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -713,7 +713,7 @@ public Int128Mask and(VectorMask<Integer> mask) {
         public Int128Mask or(VectorMask<Integer> mask) {
             Objects.requireNonNull(mask);
             Int128Mask m = (Int128Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, Int128Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, Int128Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -723,7 +723,7 @@ public Int128Mask or(VectorMask<Integer> mask) {
         public Int128Mask xor(VectorMask<Integer> mask) {
             Objects.requireNonNull(mask);
             Int128Mask m = (Int128Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int128Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int128Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -733,7 +733,7 @@ public Int128Mask xor(VectorMask<Integer> mask) {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int128Mask.class, int.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int128Mask.class, int.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -741,7 +741,7 @@ public int trueCount() {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int128Mask.class, int.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int128Mask.class, int.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -749,7 +749,7 @@ public int firstTrue() {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int128Mask.class, int.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int128Mask.class, int.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -760,7 +760,7 @@ public long toLong() {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Int128Mask.class, int.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Int128Mask.class, int.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -771,7 +771,7 @@ public long toLong() {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract(Int128Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract(Int128Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -780,7 +780,7 @@ public boolean laneIsSet(int i) {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, Int128Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, Int128Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper(((Int128Mask)m).getBits()));
         }
@@ -788,7 +788,7 @@ this, vspecies().maskAll(true),
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, Int128Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, Int128Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper(((Int128Mask)m).getBits()));
         }
@@ -796,7 +796,7 @@ this, vspecies().maskAll(true),
         @ForceInline
         /*package-private*/
         static Int128Mask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(Int128Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced(Int128Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int256Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int256Vector.java
index f7e1cb8dbcf..0eddd456ea2 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int256Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int256Vector.java
@@ -540,7 +540,7 @@ public int lane(int i) {
     @ForceInline
     public int laneHelper(int i) {
         return (int) VectorSupport.extract(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i,
                                 (vec, ix) -> {
                                     int[] vecarr = vec.vec();
@@ -567,7 +567,7 @@ public Int256Vector withLane(int i, int e) {
     @ForceInline
     public Int256Vector withLaneHelper(int i, int e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)e,
                                 (v, ix, bits) -> {
                                     int[] res = v.vec().clone();
@@ -682,7 +682,7 @@ public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
         /*package-private*/
         Int256Mask indexPartiallyInUpperRange(long offset, long limit) {
             return (Int256Mask) VectorSupport.indexPartiallyInUpperRange(
-                Int256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                Int256Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> (Int256Mask) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -698,7 +698,7 @@ public Int256Mask not() {
         @ForceInline
         public Int256Mask compress() {
             return (Int256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                Int256Vector.class, Int256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                Int256Vector.class, Int256Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 m1.trueCount()));
         }
@@ -711,7 +711,7 @@ public Int256Mask compress() {
         public Int256Mask and(VectorMask<Integer> mask) {
             Objects.requireNonNull(mask);
             Int256Mask m = (Int256Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, Int256Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, Int256Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -721,7 +721,7 @@ public Int256Mask and(VectorMask<Integer> mask) {
         public Int256Mask or(VectorMask<Integer> mask) {
             Objects.requireNonNull(mask);
             Int256Mask m = (Int256Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, Int256Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, Int256Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -731,7 +731,7 @@ public Int256Mask or(VectorMask<Integer> mask) {
         public Int256Mask xor(VectorMask<Integer> mask) {
             Objects.requireNonNull(mask);
             Int256Mask m = (Int256Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int256Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int256Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -741,7 +741,7 @@ public Int256Mask xor(VectorMask<Integer> mask) {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int256Mask.class, int.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int256Mask.class, int.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -749,7 +749,7 @@ public int trueCount() {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int256Mask.class, int.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int256Mask.class, int.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -757,7 +757,7 @@ public int firstTrue() {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int256Mask.class, int.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int256Mask.class, int.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -768,7 +768,7 @@ public long toLong() {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Int256Mask.class, int.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Int256Mask.class, int.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -779,7 +779,7 @@ public long toLong() {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract(Int256Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract(Int256Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -788,7 +788,7 @@ public boolean laneIsSet(int i) {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, Int256Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, Int256Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper(((Int256Mask)m).getBits()));
         }
@@ -796,7 +796,7 @@ this, vspecies().maskAll(true),
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, Int256Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, Int256Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper(((Int256Mask)m).getBits()));
         }
@@ -804,7 +804,7 @@ this, vspecies().maskAll(true),
         @ForceInline
         /*package-private*/
         static Int256Mask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(Int256Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced(Int256Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int512Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int512Vector.java
index e321f2a3d65..f323f282f19 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int512Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int512Vector.java
@@ -548,7 +548,7 @@ public int lane(int i) {
     @ForceInline
     public int laneHelper(int i) {
         return (int) VectorSupport.extract(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i,
                                 (vec, ix) -> {
                                     int[] vecarr = vec.vec();
@@ -583,7 +583,7 @@ public Int512Vector withLane(int i, int e) {
     @ForceInline
     public Int512Vector withLaneHelper(int i, int e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)e,
                                 (v, ix, bits) -> {
                                     int[] res = v.vec().clone();
@@ -698,7 +698,7 @@ public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
         /*package-private*/
         Int512Mask indexPartiallyInUpperRange(long offset, long limit) {
             return (Int512Mask) VectorSupport.indexPartiallyInUpperRange(
-                Int512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                Int512Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> (Int512Mask) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -714,7 +714,7 @@ public Int512Mask not() {
         @ForceInline
         public Int512Mask compress() {
             return (Int512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                Int512Vector.class, Int512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                Int512Vector.class, Int512Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 m1.trueCount()));
         }
@@ -727,7 +727,7 @@ public Int512Mask compress() {
         public Int512Mask and(VectorMask<Integer> mask) {
             Objects.requireNonNull(mask);
             Int512Mask m = (Int512Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, Int512Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, Int512Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -737,7 +737,7 @@ public Int512Mask and(VectorMask<Integer> mask) {
         public Int512Mask or(VectorMask<Integer> mask) {
             Objects.requireNonNull(mask);
             Int512Mask m = (Int512Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, Int512Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, Int512Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -747,7 +747,7 @@ public Int512Mask or(VectorMask<Integer> mask) {
         public Int512Mask xor(VectorMask<Integer> mask) {
             Objects.requireNonNull(mask);
             Int512Mask m = (Int512Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int512Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int512Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -757,7 +757,7 @@ public Int512Mask xor(VectorMask<Integer> mask) {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int512Mask.class, int.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int512Mask.class, int.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -765,7 +765,7 @@ public int trueCount() {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int512Mask.class, int.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int512Mask.class, int.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -773,7 +773,7 @@ public int firstTrue() {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int512Mask.class, int.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int512Mask.class, int.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -784,7 +784,7 @@ public long toLong() {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Int512Mask.class, int.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Int512Mask.class, int.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -795,7 +795,7 @@ public long toLong() {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract(Int512Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract(Int512Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -804,7 +804,7 @@ public boolean laneIsSet(int i) {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, Int512Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, Int512Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper(((Int512Mask)m).getBits()));
         }
@@ -812,7 +812,7 @@ this, vspecies().maskAll(true),
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, Int512Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, Int512Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper(((Int512Mask)m).getBits()));
         }
@@ -820,7 +820,7 @@ this, vspecies().maskAll(true),
         @ForceInline
         /*package-private*/
         static Int512Mask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(Int512Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced(Int512Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int64Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int64Vector.java
index 3d1da443fc8..4836e58118c 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int64Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int64Vector.java
@@ -534,7 +534,7 @@ public int lane(int i) {
     @ForceInline
     public int laneHelper(int i) {
         return (int) VectorSupport.extract(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i,
                                 (vec, ix) -> {
                                     int[] vecarr = vec.vec();
@@ -555,7 +555,7 @@ public Int64Vector withLane(int i, int e) {
     @ForceInline
     public Int64Vector withLaneHelper(int i, int e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)e,
                                 (v, ix, bits) -> {
                                     int[] res = v.vec().clone();
@@ -670,7 +670,7 @@ public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
         /*package-private*/
         Int64Mask indexPartiallyInUpperRange(long offset, long limit) {
             return (Int64Mask) VectorSupport.indexPartiallyInUpperRange(
-                Int64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                Int64Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> (Int64Mask) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -686,7 +686,7 @@ public Int64Mask not() {
         @ForceInline
         public Int64Mask compress() {
             return (Int64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                Int64Vector.class, Int64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                Int64Vector.class, Int64Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 m1.trueCount()));
         }
@@ -699,7 +699,7 @@ public Int64Mask compress() {
         public Int64Mask and(VectorMask<Integer> mask) {
             Objects.requireNonNull(mask);
             Int64Mask m = (Int64Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, Int64Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, Int64Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -709,7 +709,7 @@ public Int64Mask and(VectorMask<Integer> mask) {
         public Int64Mask or(VectorMask<Integer> mask) {
             Objects.requireNonNull(mask);
             Int64Mask m = (Int64Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, Int64Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, Int64Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -719,7 +719,7 @@ public Int64Mask or(VectorMask<Integer> mask) {
         public Int64Mask xor(VectorMask<Integer> mask) {
             Objects.requireNonNull(mask);
             Int64Mask m = (Int64Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int64Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int64Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -729,7 +729,7 @@ public Int64Mask xor(VectorMask<Integer> mask) {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int64Mask.class, int.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int64Mask.class, int.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -737,7 +737,7 @@ public int trueCount() {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int64Mask.class, int.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int64Mask.class, int.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -745,7 +745,7 @@ public int firstTrue() {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int64Mask.class, int.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int64Mask.class, int.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -756,7 +756,7 @@ public long toLong() {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Int64Mask.class, int.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Int64Mask.class, int.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -767,7 +767,7 @@ public long toLong() {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract(Int64Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract(Int64Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -776,7 +776,7 @@ public boolean laneIsSet(int i) {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, Int64Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, Int64Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper(((Int64Mask)m).getBits()));
         }
@@ -784,7 +784,7 @@ this, vspecies().maskAll(true),
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, Int64Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, Int64Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper(((Int64Mask)m).getBits()));
         }
@@ -792,7 +792,7 @@ this, vspecies().maskAll(true),
         @ForceInline
         /*package-private*/
         static Int64Mask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(Int64Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced(Int64Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/IntMaxVector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/IntMaxVector.java
index 6cb2387f082..eef9dfa624d 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/IntMaxVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/IntMaxVector.java
@@ -533,7 +533,7 @@ public int lane(int i) {
     @ForceInline
     public int laneHelper(int i) {
         return (int) VectorSupport.extract(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i,
                                 (vec, ix) -> {
                                     int[] vecarr = vec.vec();
@@ -553,7 +553,7 @@ public IntMaxVector withLane(int i, int e) {
     @ForceInline
     public IntMaxVector withLaneHelper(int i, int e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)e,
                                 (v, ix, bits) -> {
                                     int[] res = v.vec().clone();
@@ -668,7 +668,7 @@ public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
         /*package-private*/
         IntMaxMask indexPartiallyInUpperRange(long offset, long limit) {
             return (IntMaxMask) VectorSupport.indexPartiallyInUpperRange(
-                IntMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                IntMaxMask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> (IntMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -684,7 +684,7 @@ public IntMaxMask not() {
         @ForceInline
         public IntMaxMask compress() {
             return (IntMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                IntMaxVector.class, IntMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                IntMaxVector.class, IntMaxMask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 m1.trueCount()));
         }
@@ -697,7 +697,7 @@ public IntMaxMask compress() {
         public IntMaxMask and(VectorMask<Integer> mask) {
             Objects.requireNonNull(mask);
             IntMaxMask m = (IntMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, IntMaxMask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, IntMaxMask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -707,7 +707,7 @@ public IntMaxMask and(VectorMask<Integer> mask) {
         public IntMaxMask or(VectorMask<Integer> mask) {
             Objects.requireNonNull(mask);
             IntMaxMask m = (IntMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, IntMaxMask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, IntMaxMask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -717,7 +717,7 @@ public IntMaxMask or(VectorMask<Integer> mask) {
         public IntMaxMask xor(VectorMask<Integer> mask) {
             Objects.requireNonNull(mask);
             IntMaxMask m = (IntMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, IntMaxMask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, IntMaxMask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -727,7 +727,7 @@ public IntMaxMask xor(VectorMask<Integer> mask) {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, IntMaxMask.class, int.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, IntMaxMask.class, int.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -735,7 +735,7 @@ public int trueCount() {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, IntMaxMask.class, int.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, IntMaxMask.class, int.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -743,7 +743,7 @@ public int firstTrue() {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, IntMaxMask.class, int.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, IntMaxMask.class, int.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -754,7 +754,7 @@ public long toLong() {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, IntMaxMask.class, int.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, IntMaxMask.class, int.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -765,7 +765,7 @@ public long toLong() {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract(IntMaxMask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract(IntMaxMask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -774,7 +774,7 @@ public boolean laneIsSet(int i) {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, IntMaxMask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, IntMaxMask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper(((IntMaxMask)m).getBits()));
         }
@@ -782,7 +782,7 @@ this, vspecies().maskAll(true),
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, IntMaxMask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, IntMaxMask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper(((IntMaxMask)m).getBits()));
         }
@@ -790,7 +790,7 @@ this, vspecies().maskAll(true),
         @ForceInline
         /*package-private*/
         static IntMaxMask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(IntMaxMask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced(IntMaxMask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/IntVector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/IntVector.java
index f16608e5f41..89976a05218 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/IntVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/IntVector.java
@@ -575,7 +575,7 @@ static IntVector selectFromTwoVectorHelper(Vector<Integer> indexes, Vector<Integ
     @ForceInline
     public static IntVector zero(VectorSpecies<Integer> species) {
         IntSpecies vsp = (IntSpecies) species;
-        return VectorSupport.fromBitsCoerced(vsp.vectorType(), int.class, int.class, VECTOR_OPER_TYPE, species.length(),
+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), int.class, VECTOR_OPER_TYPE, species.length(),
                                 0, MODE_BROADCAST, vsp,
                                 ((bits_, s_) -> s_.rvOp(i -> bits_)));
     }
@@ -697,7 +697,7 @@ else if (op == NOT) {
         }
         int opc = opCode(op);
         return VectorSupport.unaryOp(
-            opc, getClass(), null, int.class, int.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, int.class, VECTOR_OPER_TYPE, length(),
             this, null,
             UN_IMPL.find(op, opc, IntVector::unaryOperations));
     }
@@ -725,7 +725,7 @@ else if (op == NOT) {
         }
         int opc = opCode(op);
         return VectorSupport.unaryOp(
-            opc, getClass(), maskClass, int.class, int.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, int.class, VECTOR_OPER_TYPE, length(),
             this, m,
             UN_IMPL.find(op, opc, IntVector::unaryOperations));
     }
@@ -798,7 +798,7 @@ IntVector lanewiseTemplate(VectorOperators.Binary op,
 
         int opc = opCode(op);
         return VectorSupport.binaryOp(
-            opc, getClass(), null, int.class, int.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, int.class, VECTOR_OPER_TYPE, length(),
             this, that, null,
             BIN_IMPL.find(op, opc, IntVector::binaryOperations));
     }
@@ -849,7 +849,7 @@ IntVector lanewiseTemplate(VectorOperators.Binary op,
 
         int opc = opCode(op);
         return VectorSupport.binaryOp(
-            opc, getClass(), maskClass, int.class, int.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, int.class, VECTOR_OPER_TYPE, length(),
             this, that, m,
             BIN_IMPL.find(op, opc, IntVector::binaryOperations));
     }
@@ -1040,7 +1040,7 @@ IntVector lanewise(VectorOperators.Binary op,
         e &= SHIFT_MASK;
         int opc = opCode(op);
         return VectorSupport.broadcastInt(
-            opc, getClass(), null, int.class, int.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, int.class, VECTOR_OPER_TYPE, length(),
             this, e, null,
             BIN_INT_IMPL.find(op, opc, IntVector::broadcastIntOperations));
     }
@@ -1061,7 +1061,7 @@ opc, getClass(), null, int.class, int.class, VECTOR_OPER_TYPE, length(),
         e &= SHIFT_MASK;
         int opc = opCode(op);
         return VectorSupport.broadcastInt(
-            opc, getClass(), maskClass, int.class, int.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, int.class, VECTOR_OPER_TYPE, length(),
             this, e, m,
             BIN_INT_IMPL.find(op, opc, IntVector::broadcastIntOperations));
     }
@@ -1137,7 +1137,7 @@ IntVector lanewiseTemplate(VectorOperators.Ternary op,
         }
         int opc = opCode(op);
         return VectorSupport.ternaryOp(
-            opc, getClass(), null, int.class, int.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, int.class, VECTOR_OPER_TYPE, length(),
             this, that, tother, null,
             TERN_IMPL.find(op, opc, IntVector::ternaryOperations));
     }
@@ -1177,7 +1177,7 @@ IntVector lanewiseTemplate(VectorOperators.Ternary op,
         }
         int opc = opCode(op);
         return VectorSupport.ternaryOp(
-            opc, getClass(), maskClass, int.class, int.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, int.class, VECTOR_OPER_TYPE, length(),
             this, that, tother, m,
             TERN_IMPL.find(op, opc, IntVector::ternaryOperations));
     }
@@ -2057,7 +2057,7 @@ M compareTemplate(Class<M> maskType, Comparison op, Vector<Integer> v) {
         that.check(this);
         int opc = opCode(op);
         return VectorSupport.compare(
-            opc, getClass(), maskType, int.class, int.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskType, int.class, VECTOR_OPER_TYPE, length(),
             this, that, null,
             (cond, v0, v1, m1) -> {
                 AbstractMask<Integer> m
@@ -2079,7 +2079,7 @@ M compareTemplate(Class<M> maskType, Comparison op, Vector<Integer> v, M m) {
         m.check(maskType, this);
         int opc = opCode(op);
         return VectorSupport.compare(
-            opc, getClass(), maskType, int.class, int.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskType, int.class, VECTOR_OPER_TYPE, length(),
             this, that, m,
             (cond, v0, v1, m1) -> {
                 AbstractMask<Integer> cmpM
@@ -2210,7 +2210,7 @@ VectorMask<Integer> compare(Comparison op, long e, VectorMask<Integer> m) {
     blendTemplate(Class<M> maskType, IntVector v, M m) {
         v.check(this);
         return VectorSupport.blend(
-            getClass(), maskType, int.class, int.class, VECTOR_OPER_TYPE, length(),
+            getClass(), maskType, int.class, VECTOR_OPER_TYPE, length(),
             this, v, m,
             (v0, v1, m_) -> v0.bOp(v1, m_, (i, a, b) -> b));
     }
@@ -2227,7 +2227,7 @@ final IntVector addIndexTemplate(int scale) {
         // make sure VLENGTH*scale doesn't overflow:
         vsp.checkScale(scale);
         return VectorSupport.indexVector(
-            getClass(), int.class, int.class, VECTOR_OPER_TYPE, length(),
+            getClass(), int.class, VECTOR_OPER_TYPE, length(),
             this, scale, vsp,
             (v, scale_, s)
             -> {
@@ -2419,7 +2419,7 @@ IntVector sliceTemplate(int origin) {
     IntVector rearrangeTemplate(Class<S> shuffletype, S shuffle) {
         Objects.requireNonNull(shuffle);
         return VectorSupport.rearrangeOp(
-            getClass(), shuffletype, null, int.class, int.class, VECTOR_OPER_TYPE, length(),
+            getClass(), shuffletype, null, int.class, VECTOR_OPER_TYPE, length(),
             this, shuffle, null,
             (v1, s_, m_) -> v1.uOp((i, a) -> {
                 int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
@@ -2446,7 +2446,7 @@ IntVector rearrangeTemplate(Class<S> shuffletype,
         Objects.requireNonNull(shuffle);
         m.check(masktype, this);
         return VectorSupport.rearrangeOp(
-                   getClass(), shuffletype, masktype, int.class, int.class, VECTOR_OPER_TYPE, length(),
+                   getClass(), shuffletype, masktype, int.class, VECTOR_OPER_TYPE, length(),
                    this, shuffle, m,
                    (v1, s_, m_) -> v1.uOp((i, a) -> {
                         int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
@@ -2472,7 +2472,7 @@ IntVector rearrangeTemplate(Class<S> shuffletype,
         VectorMask<Integer> valid = shuffle.laneIsValid();
         IntVector r0 =
             VectorSupport.rearrangeOp(
-                getClass(), shuffletype, null, int.class, int.class, VECTOR_OPER_TYPE, length(),
+                getClass(), shuffletype, null, int.class, VECTOR_OPER_TYPE, length(),
                 this, shuffle, null,
                 (v0, s_, m_) -> v0.uOp((i, a) -> {
                     int ei = Integer.remainderUnsigned(s_.laneSource(i), v0.length());
@@ -2480,7 +2480,7 @@ IntVector rearrangeTemplate(Class<S> shuffletype,
                 }));
         IntVector r1 =
             VectorSupport.rearrangeOp(
-                getClass(), shuffletype, null, int.class, int.class, VECTOR_OPER_TYPE, length(),
+                getClass(), shuffletype, null, int.class, VECTOR_OPER_TYPE, length(),
                 v, shuffle, null,
                 (v1, s_, m_) -> v1.uOp((i, a) -> {
                     int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
@@ -2530,7 +2530,7 @@ VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp, boolean wrap) {
     IntVector compressTemplate(Class<M> masktype, M m) {
       m.check(masktype, this);
       return (IntVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,
-                                                        int.class, int.class, VECTOR_OPER_TYPE, length(), this, m,
+                                                        int.class, VECTOR_OPER_TYPE, length(), this, m,
                                                         (v1, m1) -> compressHelper(v1, m1));
     }
 
@@ -2549,7 +2549,7 @@ int.class, int.class, VECTOR_OPER_TYPE, length(), this, m,
     IntVector expandTemplate(Class<M> masktype, M m) {
       m.check(masktype, this);
       return (IntVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,
-                                                        int.class, int.class, VECTOR_OPER_TYPE, length(), this, m,
+                                                        int.class, VECTOR_OPER_TYPE, length(), this, m,
                                                         (v1, m1) -> expandHelper(v1, m1));
     }
 
@@ -2564,7 +2564,7 @@ int.class, int.class, VECTOR_OPER_TYPE, length(), this, m,
     /*package-private*/
     @ForceInline
     final IntVector selectFromTemplate(IntVector v) {
-        return (IntVector)VectorSupport.selectFromOp(getClass(), null, int.class, int.class, VECTOR_OPER_TYPE,
+        return (IntVector)VectorSupport.selectFromOp(getClass(), null, int.class, VECTOR_OPER_TYPE,
                                                         length(), this, v, null,
                                                         (v1, v2, _m) ->
                                                          v2.rearrange(v1.toShuffle()));
@@ -2584,7 +2584,7 @@ final IntVector selectFromTemplate(IntVector v) {
     IntVector selectFromTemplate(IntVector v,
                                             Class<M> masktype, M m) {
         m.check(masktype, this);
-        return (IntVector)VectorSupport.selectFromOp(getClass(), masktype, int.class, int.class, VECTOR_OPER_TYPE,
+        return (IntVector)VectorSupport.selectFromOp(getClass(), masktype, int.class, VECTOR_OPER_TYPE,
                                                         length(), this, v, m,
                                                         (v1, v2, _m) ->
                                                          v2.rearrange(v1.toShuffle(), _m));
@@ -2602,7 +2602,7 @@ IntVector selectFromTemplate(IntVector v,
     /*package-private*/
     @ForceInline
     final IntVector selectFromTemplate(IntVector v1, IntVector v2) {
-        return VectorSupport.selectFromTwoVectorOp(getClass(), int.class, int.class, VECTOR_OPER_TYPE, length(), this, v1, v2,
+        return VectorSupport.selectFromTwoVectorOp(getClass(), int.class, VECTOR_OPER_TYPE, length(), this, v1, v2,
                                                    (vec1, vec2, vec3) -> selectFromTwoVectorHelper(vec1, vec2, vec3));
     }
 
@@ -2822,7 +2822,7 @@ int reduceLanesTemplate(VectorOperators.Associative op,
         }
         int opc = opCode(op);
         return fromBits(VectorSupport.reductionCoerced(
-            opc, getClass(), maskClass, int.class, int.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, int.class, VECTOR_OPER_TYPE, length(),
             this, m,
             REDUCE_IMPL.find(op, opc, IntVector::reductionOperations)));
     }
@@ -2840,7 +2840,7 @@ int reduceLanesTemplate(VectorOperators.Associative op) {
         }
         int opc = opCode(op);
         return fromBits(VectorSupport.reductionCoerced(
-            opc, getClass(), null, int.class, int.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, int.class, VECTOR_OPER_TYPE, length(),
             this, null,
             REDUCE_IMPL.find(op, opc, IntVector::reductionOperations)));
     }
@@ -3100,7 +3100,7 @@ IntVector fromArray(VectorSpecies<Integer> species,
         vix = VectorIntrinsics.checkIndex(vix, a.length);
 
         return VectorSupport.loadWithMap(
-            vectorType, null, int.class, int.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+            vectorType, null, int.class, VECTOR_OPER_TYPE, vsp.laneCount(),
             isp.vectorType(), isp.length(),
             a, ARRAY_BASE, vix, null, null, null, null,
             a, offset, indexMap, mapOffset, vsp,
@@ -3283,7 +3283,7 @@ void intoArray(int[] a, int offset) {
         offset = checkFromIndexSize(offset, length(), a.length);
         IntSpecies vsp = vspecies();
         VectorSupport.store(
-            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false,
             this,
             a, offset,
@@ -3372,7 +3372,7 @@ void intoArray(int[] a, int offset,
         vix = VectorIntrinsics.checkIndex(vix, a.length);
 
         VectorSupport.storeWithMap(
-            vsp.vectorType(), null, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), null, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             isp.vectorType(), isp.length(),
             a, arrayAddress(a, 0), vix,
             this, null,
@@ -3499,7 +3499,7 @@ void intoMemorySegment(MemorySegment ms, long offset,
     IntVector fromArray0Template(int[] a, int offset) {
         IntSpecies vsp = vspecies();
         return VectorSupport.load(
-            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false,
             a, offset, vsp,
             (arr, off, s) -> s.ldOp(arr, (int) off,
@@ -3516,7 +3516,7 @@ IntVector fromArray0Template(Class<M> maskClass, int[] a, int offset, M m, int o
         m.check(species());
         IntSpecies vsp = vspecies();
         return VectorSupport.loadMasked(
-            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false, m, offsetInRange,
             a, offset, vsp,
             (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,
@@ -3549,7 +3549,7 @@ IntVector fromArray0Template(Class<M> maskClass, int[] a, int offset,
         vix = VectorIntrinsics.checkIndex(vix, a.length);
 
         return VectorSupport.loadWithMap(
-            vectorType, maskClass, int.class, int.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+            vectorType, maskClass, int.class, VECTOR_OPER_TYPE, vsp.laneCount(),
             isp.vectorType(), isp.length(),
             a, ARRAY_BASE, vix, null, null, null, m,
             a, offset, indexMap, mapOffset, vsp,
@@ -3566,7 +3566,7 @@ IntVector fromArray0Template(Class<M> maskClass, int[] a, int offset,
     IntVector fromMemorySegment0Template(MemorySegment ms, long offset) {
         IntSpecies vsp = vspecies();
         return ScopedMemoryAccess.loadFromMemorySegment(
-                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                 (AbstractMemorySegmentImpl) ms, offset, vsp,
                 (msp, off, s) -> {
                     return s.ldLongOp((MemorySegment) msp, off, IntVector::memorySegmentGet);
@@ -3582,7 +3582,7 @@ IntVector fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long
         IntSpecies vsp = vspecies();
         m.check(vsp);
         return ScopedMemoryAccess.loadFromMemorySegmentMasked(
-                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                 (AbstractMemorySegmentImpl) ms, offset, m, vsp, offsetInRange,
                 (msp, off, s, vm) -> {
                     return s.ldLongOp((MemorySegment) msp, off, vm, IntVector::memorySegmentGet);
@@ -3600,7 +3600,7 @@ IntVector fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long
     void intoArray0Template(int[] a, int offset) {
         IntSpecies vsp = vspecies();
         VectorSupport.store(
-            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false,
             this, a, offset,
             (arr, off, v)
@@ -3617,7 +3617,7 @@ void intoArray0Template(Class<M> maskClass, int[] a, int offset, M m) {
         m.check(species());
         IntSpecies vsp = vspecies();
         VectorSupport.storeMasked(
-            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false,
             this, m, a, offset,
             (arr, off, v, vm)
@@ -3646,7 +3646,7 @@ void intoArray0Template(Class<M> maskClass, int[] a, int offset,
         vix = VectorIntrinsics.checkIndex(vix, a.length);
 
         VectorSupport.storeWithMap(
-            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             isp.vectorType(), isp.length(),
             a, arrayAddress(a, 0), vix,
             this, m,
@@ -3665,7 +3665,7 @@ a, arrayAddress(a, 0), vix,
     void intoMemorySegment0(MemorySegment ms, long offset) {
         IntSpecies vsp = vspecies();
         ScopedMemoryAccess.storeIntoMemorySegment(
-                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                 this,
                 (AbstractMemorySegmentImpl) ms, offset,
                 (msp, off, v) -> {
@@ -3682,7 +3682,7 @@ void intoMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offse
         IntSpecies vsp = vspecies();
         m.check(vsp);
         ScopedMemoryAccess.storeIntoMemorySegmentMasked(
-                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                 this, m,
                 (AbstractMemorySegmentImpl) ms, offset,
                 (msp, off, v, vm) -> {
@@ -3899,7 +3899,7 @@ public final long checkValue(long e) {
         final IntVector broadcastBits(long bits) {
             return (IntVector)
                 VectorSupport.fromBitsCoerced(
-                    vectorType, int.class, int.class, VECTOR_OPER_TYPE, laneCount,
+                    vectorType, int.class, VECTOR_OPER_TYPE, laneCount,
                     bits, MODE_BROADCAST, this,
                     (bits_, s_) -> s_.rvOp(i -> bits_));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long128Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long128Vector.java
index 549d06d40c4..d60d26702b7 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long128Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long128Vector.java
@@ -524,7 +524,7 @@ public long lane(int i) {
     @ForceInline
     public long laneHelper(int i) {
         return (long) VectorSupport.extract(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i,
                                 (vec, ix) -> {
                                     long[] vecarr = vec.vec();
@@ -545,7 +545,7 @@ public Long128Vector withLane(int i, long e) {
     @ForceInline
     public Long128Vector withLaneHelper(int i, long e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)e,
                                 (v, ix, bits) -> {
                                     long[] res = v.vec().clone();
@@ -660,7 +660,7 @@ public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
         /*package-private*/
         Long128Mask indexPartiallyInUpperRange(long offset, long limit) {
             return (Long128Mask) VectorSupport.indexPartiallyInUpperRange(
-                Long128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                Long128Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> (Long128Mask) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -676,7 +676,7 @@ public Long128Mask not() {
         @ForceInline
         public Long128Mask compress() {
             return (Long128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                Long128Vector.class, Long128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                Long128Vector.class, Long128Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 m1.trueCount()));
         }
@@ -689,7 +689,7 @@ public Long128Mask compress() {
         public Long128Mask and(VectorMask<Long> mask) {
             Objects.requireNonNull(mask);
             Long128Mask m = (Long128Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, Long128Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, Long128Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -699,7 +699,7 @@ public Long128Mask and(VectorMask<Long> mask) {
         public Long128Mask or(VectorMask<Long> mask) {
             Objects.requireNonNull(mask);
             Long128Mask m = (Long128Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, Long128Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, Long128Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -709,7 +709,7 @@ public Long128Mask or(VectorMask<Long> mask) {
         public Long128Mask xor(VectorMask<Long> mask) {
             Objects.requireNonNull(mask);
             Long128Mask m = (Long128Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long128Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long128Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -719,7 +719,7 @@ public Long128Mask xor(VectorMask<Long> mask) {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long128Mask.class, long.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long128Mask.class, long.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -727,7 +727,7 @@ public int trueCount() {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long128Mask.class, long.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long128Mask.class, long.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -735,7 +735,7 @@ public int firstTrue() {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long128Mask.class, long.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long128Mask.class, long.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -746,7 +746,7 @@ public long toLong() {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Long128Mask.class, long.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Long128Mask.class, long.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -757,7 +757,7 @@ public long toLong() {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract(Long128Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract(Long128Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -766,7 +766,7 @@ public boolean laneIsSet(int i) {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, Long128Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, Long128Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper(((Long128Mask)m).getBits()));
         }
@@ -774,7 +774,7 @@ this, vspecies().maskAll(true),
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, Long128Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, Long128Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper(((Long128Mask)m).getBits()));
         }
@@ -782,7 +782,7 @@ this, vspecies().maskAll(true),
         @ForceInline
         /*package-private*/
         static Long128Mask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(Long128Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced(Long128Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long256Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long256Vector.java
index c71b65396d0..4f7f2e629fd 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long256Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long256Vector.java
@@ -526,7 +526,7 @@ public long lane(int i) {
     @ForceInline
     public long laneHelper(int i) {
         return (long) VectorSupport.extract(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i,
                                 (vec, ix) -> {
                                     long[] vecarr = vec.vec();
@@ -549,7 +549,7 @@ public Long256Vector withLane(int i, long e) {
     @ForceInline
     public Long256Vector withLaneHelper(int i, long e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)e,
                                 (v, ix, bits) -> {
                                     long[] res = v.vec().clone();
@@ -664,7 +664,7 @@ public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
         /*package-private*/
         Long256Mask indexPartiallyInUpperRange(long offset, long limit) {
             return (Long256Mask) VectorSupport.indexPartiallyInUpperRange(
-                Long256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                Long256Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> (Long256Mask) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -680,7 +680,7 @@ public Long256Mask not() {
         @ForceInline
         public Long256Mask compress() {
             return (Long256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                Long256Vector.class, Long256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                Long256Vector.class, Long256Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 m1.trueCount()));
         }
@@ -693,7 +693,7 @@ public Long256Mask compress() {
         public Long256Mask and(VectorMask<Long> mask) {
             Objects.requireNonNull(mask);
             Long256Mask m = (Long256Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, Long256Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, Long256Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -703,7 +703,7 @@ public Long256Mask and(VectorMask<Long> mask) {
         public Long256Mask or(VectorMask<Long> mask) {
             Objects.requireNonNull(mask);
             Long256Mask m = (Long256Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, Long256Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, Long256Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -713,7 +713,7 @@ public Long256Mask or(VectorMask<Long> mask) {
         public Long256Mask xor(VectorMask<Long> mask) {
             Objects.requireNonNull(mask);
             Long256Mask m = (Long256Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long256Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long256Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -723,7 +723,7 @@ public Long256Mask xor(VectorMask<Long> mask) {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long256Mask.class, long.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long256Mask.class, long.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -731,7 +731,7 @@ public int trueCount() {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long256Mask.class, long.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long256Mask.class, long.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -739,7 +739,7 @@ public int firstTrue() {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long256Mask.class, long.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long256Mask.class, long.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -750,7 +750,7 @@ public long toLong() {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Long256Mask.class, long.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Long256Mask.class, long.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -761,7 +761,7 @@ public long toLong() {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract(Long256Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract(Long256Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -770,7 +770,7 @@ public boolean laneIsSet(int i) {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, Long256Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, Long256Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper(((Long256Mask)m).getBits()));
         }
@@ -778,7 +778,7 @@ this, vspecies().maskAll(true),
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, Long256Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, Long256Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper(((Long256Mask)m).getBits()));
         }
@@ -786,7 +786,7 @@ this, vspecies().maskAll(true),
         @ForceInline
         /*package-private*/
         static Long256Mask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(Long256Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced(Long256Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long512Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long512Vector.java
index 513e07a3ee3..8f763f974d7 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long512Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long512Vector.java
@@ -530,7 +530,7 @@ public long lane(int i) {
     @ForceInline
     public long laneHelper(int i) {
         return (long) VectorSupport.extract(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i,
                                 (vec, ix) -> {
                                     long[] vecarr = vec.vec();
@@ -557,7 +557,7 @@ public Long512Vector withLane(int i, long e) {
     @ForceInline
     public Long512Vector withLaneHelper(int i, long e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)e,
                                 (v, ix, bits) -> {
                                     long[] res = v.vec().clone();
@@ -672,7 +672,7 @@ public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
         /*package-private*/
         Long512Mask indexPartiallyInUpperRange(long offset, long limit) {
             return (Long512Mask) VectorSupport.indexPartiallyInUpperRange(
-                Long512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                Long512Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> (Long512Mask) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -688,7 +688,7 @@ public Long512Mask not() {
         @ForceInline
         public Long512Mask compress() {
             return (Long512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                Long512Vector.class, Long512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                Long512Vector.class, Long512Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 m1.trueCount()));
         }
@@ -701,7 +701,7 @@ public Long512Mask compress() {
         public Long512Mask and(VectorMask<Long> mask) {
             Objects.requireNonNull(mask);
             Long512Mask m = (Long512Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, Long512Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, Long512Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -711,7 +711,7 @@ public Long512Mask and(VectorMask<Long> mask) {
         public Long512Mask or(VectorMask<Long> mask) {
             Objects.requireNonNull(mask);
             Long512Mask m = (Long512Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, Long512Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, Long512Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -721,7 +721,7 @@ public Long512Mask or(VectorMask<Long> mask) {
         public Long512Mask xor(VectorMask<Long> mask) {
             Objects.requireNonNull(mask);
             Long512Mask m = (Long512Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long512Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long512Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -731,7 +731,7 @@ public Long512Mask xor(VectorMask<Long> mask) {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long512Mask.class, long.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long512Mask.class, long.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -739,7 +739,7 @@ public int trueCount() {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long512Mask.class, long.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long512Mask.class, long.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -747,7 +747,7 @@ public int firstTrue() {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long512Mask.class, long.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long512Mask.class, long.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -758,7 +758,7 @@ public long toLong() {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Long512Mask.class, long.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Long512Mask.class, long.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -769,7 +769,7 @@ public long toLong() {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract(Long512Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract(Long512Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -778,7 +778,7 @@ public boolean laneIsSet(int i) {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, Long512Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, Long512Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper(((Long512Mask)m).getBits()));
         }
@@ -786,7 +786,7 @@ this, vspecies().maskAll(true),
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, Long512Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, Long512Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper(((Long512Mask)m).getBits()));
         }
@@ -794,7 +794,7 @@ this, vspecies().maskAll(true),
         @ForceInline
         /*package-private*/
         static Long512Mask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(Long512Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced(Long512Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long64Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long64Vector.java
index a26ec8b4002..666f5c3dc74 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long64Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long64Vector.java
@@ -523,7 +523,7 @@ public long lane(int i) {
     @ForceInline
     public long laneHelper(int i) {
         return (long) VectorSupport.extract(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i,
                                 (vec, ix) -> {
                                     long[] vecarr = vec.vec();
@@ -543,7 +543,7 @@ public Long64Vector withLane(int i, long e) {
     @ForceInline
     public Long64Vector withLaneHelper(int i, long e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)e,
                                 (v, ix, bits) -> {
                                     long[] res = v.vec().clone();
@@ -658,7 +658,7 @@ public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
         /*package-private*/
         Long64Mask indexPartiallyInUpperRange(long offset, long limit) {
             return (Long64Mask) VectorSupport.indexPartiallyInUpperRange(
-                Long64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                Long64Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> (Long64Mask) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -674,7 +674,7 @@ public Long64Mask not() {
         @ForceInline
         public Long64Mask compress() {
             return (Long64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                Long64Vector.class, Long64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                Long64Vector.class, Long64Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 m1.trueCount()));
         }
@@ -687,7 +687,7 @@ public Long64Mask compress() {
         public Long64Mask and(VectorMask<Long> mask) {
             Objects.requireNonNull(mask);
             Long64Mask m = (Long64Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, Long64Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, Long64Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -697,7 +697,7 @@ public Long64Mask and(VectorMask<Long> mask) {
         public Long64Mask or(VectorMask<Long> mask) {
             Objects.requireNonNull(mask);
             Long64Mask m = (Long64Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, Long64Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, Long64Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -707,7 +707,7 @@ public Long64Mask or(VectorMask<Long> mask) {
         public Long64Mask xor(VectorMask<Long> mask) {
             Objects.requireNonNull(mask);
             Long64Mask m = (Long64Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long64Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long64Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -717,7 +717,7 @@ public Long64Mask xor(VectorMask<Long> mask) {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long64Mask.class, long.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long64Mask.class, long.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -725,7 +725,7 @@ public int trueCount() {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long64Mask.class, long.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long64Mask.class, long.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -733,7 +733,7 @@ public int firstTrue() {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long64Mask.class, long.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long64Mask.class, long.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -744,7 +744,7 @@ public long toLong() {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Long64Mask.class, long.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Long64Mask.class, long.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -755,7 +755,7 @@ public long toLong() {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract(Long64Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract(Long64Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -764,7 +764,7 @@ public boolean laneIsSet(int i) {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, Long64Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, Long64Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper(((Long64Mask)m).getBits()));
         }
@@ -772,7 +772,7 @@ this, vspecies().maskAll(true),
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, Long64Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, Long64Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper(((Long64Mask)m).getBits()));
         }
@@ -780,7 +780,7 @@ this, vspecies().maskAll(true),
         @ForceInline
         /*package-private*/
         static Long64Mask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(Long64Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced(Long64Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/LongMaxVector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/LongMaxVector.java
index ae5b5fd3b68..349459b44a4 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/LongMaxVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/LongMaxVector.java
@@ -523,7 +523,7 @@ public long lane(int i) {
     @ForceInline
     public long laneHelper(int i) {
         return (long) VectorSupport.extract(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i,
                                 (vec, ix) -> {
                                     long[] vecarr = vec.vec();
@@ -543,7 +543,7 @@ public LongMaxVector withLane(int i, long e) {
     @ForceInline
     public LongMaxVector withLaneHelper(int i, long e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)e,
                                 (v, ix, bits) -> {
                                     long[] res = v.vec().clone();
@@ -658,7 +658,7 @@ public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
         /*package-private*/
         LongMaxMask indexPartiallyInUpperRange(long offset, long limit) {
             return (LongMaxMask) VectorSupport.indexPartiallyInUpperRange(
-                LongMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                LongMaxMask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> (LongMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -674,7 +674,7 @@ public LongMaxMask not() {
         @ForceInline
         public LongMaxMask compress() {
             return (LongMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                LongMaxVector.class, LongMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                LongMaxVector.class, LongMaxMask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 m1.trueCount()));
         }
@@ -687,7 +687,7 @@ public LongMaxMask compress() {
         public LongMaxMask and(VectorMask<Long> mask) {
             Objects.requireNonNull(mask);
             LongMaxMask m = (LongMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, LongMaxMask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, LongMaxMask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -697,7 +697,7 @@ public LongMaxMask and(VectorMask<Long> mask) {
         public LongMaxMask or(VectorMask<Long> mask) {
             Objects.requireNonNull(mask);
             LongMaxMask m = (LongMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, LongMaxMask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, LongMaxMask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -707,7 +707,7 @@ public LongMaxMask or(VectorMask<Long> mask) {
         public LongMaxMask xor(VectorMask<Long> mask) {
             Objects.requireNonNull(mask);
             LongMaxMask m = (LongMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, LongMaxMask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, LongMaxMask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -717,7 +717,7 @@ public LongMaxMask xor(VectorMask<Long> mask) {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, LongMaxMask.class, long.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, LongMaxMask.class, long.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -725,7 +725,7 @@ public int trueCount() {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, LongMaxMask.class, long.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, LongMaxMask.class, long.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -733,7 +733,7 @@ public int firstTrue() {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, LongMaxMask.class, long.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, LongMaxMask.class, long.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -744,7 +744,7 @@ public long toLong() {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, LongMaxMask.class, long.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, LongMaxMask.class, long.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -755,7 +755,7 @@ public long toLong() {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract(LongMaxMask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract(LongMaxMask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -764,7 +764,7 @@ public boolean laneIsSet(int i) {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, LongMaxMask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, LongMaxMask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper(((LongMaxMask)m).getBits()));
         }
@@ -772,7 +772,7 @@ this, vspecies().maskAll(true),
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, LongMaxMask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, LongMaxMask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper(((LongMaxMask)m).getBits()));
         }
@@ -780,7 +780,7 @@ this, vspecies().maskAll(true),
         @ForceInline
         /*package-private*/
         static LongMaxMask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(LongMaxMask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced(LongMaxMask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/LongVector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/LongVector.java
index cc394f24a76..8bbb5e09db8 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/LongVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/LongVector.java
@@ -575,7 +575,7 @@ static LongVector selectFromTwoVectorHelper(Vector<Long> indexes, Vector<Long> s
     @ForceInline
     public static LongVector zero(VectorSpecies<Long> species) {
         LongSpecies vsp = (LongSpecies) species;
-        return VectorSupport.fromBitsCoerced(vsp.vectorType(), long.class, long.class, VECTOR_OPER_TYPE, species.length(),
+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), long.class, VECTOR_OPER_TYPE, species.length(),
                                 0, MODE_BROADCAST, vsp,
                                 ((bits_, s_) -> s_.rvOp(i -> bits_)));
     }
@@ -655,7 +655,7 @@ else if (op == NOT) {
         }
         int opc = opCode(op);
         return VectorSupport.unaryOp(
-            opc, getClass(), null, long.class, long.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, long.class, VECTOR_OPER_TYPE, length(),
             this, null,
             UN_IMPL.find(op, opc, LongVector::unaryOperations));
     }
@@ -683,7 +683,7 @@ else if (op == NOT) {
         }
         int opc = opCode(op);
         return VectorSupport.unaryOp(
-            opc, getClass(), maskClass, long.class, long.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, long.class, VECTOR_OPER_TYPE, length(),
             this, m,
             UN_IMPL.find(op, opc, LongVector::unaryOperations));
     }
@@ -756,7 +756,7 @@ LongVector lanewiseTemplate(VectorOperators.Binary op,
 
         int opc = opCode(op);
         return VectorSupport.binaryOp(
-            opc, getClass(), null, long.class, long.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, long.class, VECTOR_OPER_TYPE, length(),
             this, that, null,
             BIN_IMPL.find(op, opc, LongVector::binaryOperations));
     }
@@ -807,7 +807,7 @@ LongVector lanewiseTemplate(VectorOperators.Binary op,
 
         int opc = opCode(op);
         return VectorSupport.binaryOp(
-            opc, getClass(), maskClass, long.class, long.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, long.class, VECTOR_OPER_TYPE, length(),
             this, that, m,
             BIN_IMPL.find(op, opc, LongVector::binaryOperations));
     }
@@ -953,7 +953,7 @@ LongVector lanewise(VectorOperators.Binary op,
         e &= SHIFT_MASK;
         int opc = opCode(op);
         return VectorSupport.broadcastInt(
-            opc, getClass(), null, long.class, long.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, long.class, VECTOR_OPER_TYPE, length(),
             this, e, null,
             BIN_INT_IMPL.find(op, opc, LongVector::broadcastIntOperations));
     }
@@ -974,7 +974,7 @@ opc, getClass(), null, long.class, long.class, VECTOR_OPER_TYPE, length(),
         e &= SHIFT_MASK;
         int opc = opCode(op);
         return VectorSupport.broadcastInt(
-            opc, getClass(), maskClass, long.class, long.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, long.class, VECTOR_OPER_TYPE, length(),
             this, e, m,
             BIN_INT_IMPL.find(op, opc, LongVector::broadcastIntOperations));
     }
@@ -1050,7 +1050,7 @@ LongVector lanewiseTemplate(VectorOperators.Ternary op,
         }
         int opc = opCode(op);
         return VectorSupport.ternaryOp(
-            opc, getClass(), null, long.class, long.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, long.class, VECTOR_OPER_TYPE, length(),
             this, that, tother, null,
             TERN_IMPL.find(op, opc, LongVector::ternaryOperations));
     }
@@ -1090,7 +1090,7 @@ LongVector lanewiseTemplate(VectorOperators.Ternary op,
         }
         int opc = opCode(op);
         return VectorSupport.ternaryOp(
-            opc, getClass(), maskClass, long.class, long.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, long.class, VECTOR_OPER_TYPE, length(),
             this, that, tother, m,
             TERN_IMPL.find(op, opc, LongVector::ternaryOperations));
     }
@@ -1970,7 +1970,7 @@ M compareTemplate(Class<M> maskType, Comparison op, Vector<Long> v) {
         that.check(this);
         int opc = opCode(op);
         return VectorSupport.compare(
-            opc, getClass(), maskType, long.class, long.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskType, long.class, VECTOR_OPER_TYPE, length(),
             this, that, null,
             (cond, v0, v1, m1) -> {
                 AbstractMask<Long> m
@@ -1992,7 +1992,7 @@ M compareTemplate(Class<M> maskType, Comparison op, Vector<Long> v, M m) {
         m.check(maskType, this);
         int opc = opCode(op);
         return VectorSupport.compare(
-            opc, getClass(), maskType, long.class, long.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskType, long.class, VECTOR_OPER_TYPE, length(),
             this, that, m,
             (cond, v0, v1, m1) -> {
                 AbstractMask<Long> cmpM
@@ -2097,7 +2097,7 @@ public final VectorMask<Long> compare(VectorOperators.Comparison op,
     blendTemplate(Class<M> maskType, LongVector v, M m) {
         v.check(this);
         return VectorSupport.blend(
-            getClass(), maskType, long.class, long.class, VECTOR_OPER_TYPE, length(),
+            getClass(), maskType, long.class, VECTOR_OPER_TYPE, length(),
             this, v, m,
             (v0, v1, m_) -> v0.bOp(v1, m_, (i, a, b) -> b));
     }
@@ -2114,7 +2114,7 @@ final LongVector addIndexTemplate(int scale) {
         // make sure VLENGTH*scale doesn't overflow:
         vsp.checkScale(scale);
         return VectorSupport.indexVector(
-            getClass(), long.class, long.class, VECTOR_OPER_TYPE, length(),
+            getClass(), long.class, VECTOR_OPER_TYPE, length(),
             this, scale, vsp,
             (v, scale_, s)
             -> {
@@ -2285,7 +2285,7 @@ LongVector sliceTemplate(int origin) {
     LongVector rearrangeTemplate(Class<S> shuffletype, S shuffle) {
         Objects.requireNonNull(shuffle);
         return VectorSupport.rearrangeOp(
-            getClass(), shuffletype, null, long.class, long.class, VECTOR_OPER_TYPE, length(),
+            getClass(), shuffletype, null, long.class, VECTOR_OPER_TYPE, length(),
             this, shuffle, null,
             (v1, s_, m_) -> v1.uOp((i, a) -> {
                 int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
@@ -2312,7 +2312,7 @@ LongVector rearrangeTemplate(Class<S> shuffletype,
         Objects.requireNonNull(shuffle);
         m.check(masktype, this);
         return VectorSupport.rearrangeOp(
-                   getClass(), shuffletype, masktype, long.class, long.class, VECTOR_OPER_TYPE, length(),
+                   getClass(), shuffletype, masktype, long.class, VECTOR_OPER_TYPE, length(),
                    this, shuffle, m,
                    (v1, s_, m_) -> v1.uOp((i, a) -> {
                         int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
@@ -2338,7 +2338,7 @@ LongVector rearrangeTemplate(Class<S> shuffletype,
         VectorMask<Long> valid = shuffle.laneIsValid();
         LongVector r0 =
             VectorSupport.rearrangeOp(
-                getClass(), shuffletype, null, long.class, long.class, VECTOR_OPER_TYPE, length(),
+                getClass(), shuffletype, null, long.class, VECTOR_OPER_TYPE, length(),
                 this, shuffle, null,
                 (v0, s_, m_) -> v0.uOp((i, a) -> {
                     int ei = Integer.remainderUnsigned(s_.laneSource(i), v0.length());
@@ -2346,7 +2346,7 @@ LongVector rearrangeTemplate(Class<S> shuffletype,
                 }));
         LongVector r1 =
             VectorSupport.rearrangeOp(
-                getClass(), shuffletype, null, long.class, long.class, VECTOR_OPER_TYPE, length(),
+                getClass(), shuffletype, null, long.class, VECTOR_OPER_TYPE, length(),
                 v, shuffle, null,
                 (v1, s_, m_) -> v1.uOp((i, a) -> {
                     int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
@@ -2396,7 +2396,7 @@ VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp, boolean wrap) {
     LongVector compressTemplate(Class<M> masktype, M m) {
       m.check(masktype, this);
       return (LongVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,
-                                                        long.class, long.class, VECTOR_OPER_TYPE, length(), this, m,
+                                                        long.class, VECTOR_OPER_TYPE, length(), this, m,
                                                         (v1, m1) -> compressHelper(v1, m1));
     }
 
@@ -2415,7 +2415,7 @@ long.class, long.class, VECTOR_OPER_TYPE, length(), this, m,
     LongVector expandTemplate(Class<M> masktype, M m) {
       m.check(masktype, this);
       return (LongVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,
-                                                        long.class, long.class, VECTOR_OPER_TYPE, length(), this, m,
+                                                        long.class, VECTOR_OPER_TYPE, length(), this, m,
                                                         (v1, m1) -> expandHelper(v1, m1));
     }
 
@@ -2430,7 +2430,7 @@ long.class, long.class, VECTOR_OPER_TYPE, length(), this, m,
     /*package-private*/
     @ForceInline
     final LongVector selectFromTemplate(LongVector v) {
-        return (LongVector)VectorSupport.selectFromOp(getClass(), null, long.class, long.class, VECTOR_OPER_TYPE,
+        return (LongVector)VectorSupport.selectFromOp(getClass(), null, long.class, VECTOR_OPER_TYPE,
                                                         length(), this, v, null,
                                                         (v1, v2, _m) ->
                                                          v2.rearrange(v1.toShuffle()));
@@ -2450,7 +2450,7 @@ final LongVector selectFromTemplate(LongVector v) {
     LongVector selectFromTemplate(LongVector v,
                                             Class<M> masktype, M m) {
         m.check(masktype, this);
-        return (LongVector)VectorSupport.selectFromOp(getClass(), masktype, long.class, long.class, VECTOR_OPER_TYPE,
+        return (LongVector)VectorSupport.selectFromOp(getClass(), masktype, long.class, VECTOR_OPER_TYPE,
                                                         length(), this, v, m,
                                                         (v1, v2, _m) ->
                                                          v2.rearrange(v1.toShuffle(), _m));
@@ -2468,7 +2468,7 @@ LongVector selectFromTemplate(LongVector v,
     /*package-private*/
     @ForceInline
     final LongVector selectFromTemplate(LongVector v1, LongVector v2) {
-        return VectorSupport.selectFromTwoVectorOp(getClass(), long.class, long.class, VECTOR_OPER_TYPE, length(), this, v1, v2,
+        return VectorSupport.selectFromTwoVectorOp(getClass(), long.class, VECTOR_OPER_TYPE, length(), this, v1, v2,
                                                    (vec1, vec2, vec3) -> selectFromTwoVectorHelper(vec1, vec2, vec3));
     }
 
@@ -2688,7 +2688,7 @@ long reduceLanesTemplate(VectorOperators.Associative op,
         }
         int opc = opCode(op);
         return fromBits(VectorSupport.reductionCoerced(
-            opc, getClass(), maskClass, long.class, long.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, long.class, VECTOR_OPER_TYPE, length(),
             this, m,
             REDUCE_IMPL.find(op, opc, LongVector::reductionOperations)));
     }
@@ -2706,7 +2706,7 @@ long reduceLanesTemplate(VectorOperators.Associative op) {
         }
         int opc = opCode(op);
         return fromBits(VectorSupport.reductionCoerced(
-            opc, getClass(), null, long.class, long.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, long.class, VECTOR_OPER_TYPE, length(),
             this, null,
             REDUCE_IMPL.find(op, opc, LongVector::reductionOperations)));
     }
@@ -2979,7 +2979,7 @@ LongVector fromArray(VectorSpecies<Long> species,
         vix = VectorIntrinsics.checkIndex(vix, a.length);
 
         return VectorSupport.loadWithMap(
-            vectorType, null, long.class, long.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+            vectorType, null, long.class, VECTOR_OPER_TYPE, vsp.laneCount(),
             isp.vectorType(), isp.length(),
             a, ARRAY_BASE, vix, null, null, null, null,
             a, offset, indexMap, mapOffset, vsp,
@@ -3162,7 +3162,7 @@ void intoArray(long[] a, int offset) {
         offset = checkFromIndexSize(offset, length(), a.length);
         LongSpecies vsp = vspecies();
         VectorSupport.store(
-            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false,
             this,
             a, offset,
@@ -3270,7 +3270,7 @@ void intoArray(long[] a, int offset,
         vix = VectorIntrinsics.checkIndex(vix, a.length);
 
         VectorSupport.storeWithMap(
-            vsp.vectorType(), null, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), null, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             isp.vectorType(), isp.length(),
             a, arrayAddress(a, 0), vix,
             this, null,
@@ -3397,7 +3397,7 @@ void intoMemorySegment(MemorySegment ms, long offset,
     LongVector fromArray0Template(long[] a, int offset) {
         LongSpecies vsp = vspecies();
         return VectorSupport.load(
-            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false,
             a, offset, vsp,
             (arr, off, s) -> s.ldOp(arr, (int) off,
@@ -3414,7 +3414,7 @@ LongVector fromArray0Template(Class<M> maskClass, long[] a, int offset, M m, int
         m.check(species());
         LongSpecies vsp = vspecies();
         return VectorSupport.loadMasked(
-            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false, m, offsetInRange,
             a, offset, vsp,
             (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,
@@ -3465,7 +3465,7 @@ LongVector fromArray0Template(Class<M> maskClass, long[] a, int offset,
         vix = VectorIntrinsics.checkIndex(vix, a.length);
 
         return VectorSupport.loadWithMap(
-            vectorType, maskClass, long.class, long.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+            vectorType, maskClass, long.class, VECTOR_OPER_TYPE, vsp.laneCount(),
             isp.vectorType(), isp.length(),
             a, ARRAY_BASE, vix, null, null, null, m,
             a, offset, indexMap, mapOffset, vsp,
@@ -3482,7 +3482,7 @@ LongVector fromArray0Template(Class<M> maskClass, long[] a, int offset,
     LongVector fromMemorySegment0Template(MemorySegment ms, long offset) {
         LongSpecies vsp = vspecies();
         return ScopedMemoryAccess.loadFromMemorySegment(
-                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                 (AbstractMemorySegmentImpl) ms, offset, vsp,
                 (msp, off, s) -> {
                     return s.ldLongOp((MemorySegment) msp, off, LongVector::memorySegmentGet);
@@ -3498,7 +3498,7 @@ LongVector fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long
         LongSpecies vsp = vspecies();
         m.check(vsp);
         return ScopedMemoryAccess.loadFromMemorySegmentMasked(
-                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                 (AbstractMemorySegmentImpl) ms, offset, m, vsp, offsetInRange,
                 (msp, off, s, vm) -> {
                     return s.ldLongOp((MemorySegment) msp, off, vm, LongVector::memorySegmentGet);
@@ -3516,7 +3516,7 @@ LongVector fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long
     void intoArray0Template(long[] a, int offset) {
         LongSpecies vsp = vspecies();
         VectorSupport.store(
-            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false,
             this, a, offset,
             (arr, off, v)
@@ -3533,7 +3533,7 @@ void intoArray0Template(Class<M> maskClass, long[] a, int offset, M m) {
         m.check(species());
         LongSpecies vsp = vspecies();
         VectorSupport.storeMasked(
-            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false,
             this, m, a, offset,
             (arr, off, v, vm)
@@ -3581,7 +3581,7 @@ void intoArray0Template(Class<M> maskClass, long[] a, int offset,
         vix = VectorIntrinsics.checkIndex(vix, a.length);
 
         VectorSupport.storeWithMap(
-            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             isp.vectorType(), isp.length(),
             a, arrayAddress(a, 0), vix,
             this, m,
@@ -3600,7 +3600,7 @@ a, arrayAddress(a, 0), vix,
     void intoMemorySegment0(MemorySegment ms, long offset) {
         LongSpecies vsp = vspecies();
         ScopedMemoryAccess.storeIntoMemorySegment(
-                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                 this,
                 (AbstractMemorySegmentImpl) ms, offset,
                 (msp, off, v) -> {
@@ -3617,7 +3617,7 @@ void intoMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offse
         LongSpecies vsp = vspecies();
         m.check(vsp);
         ScopedMemoryAccess.storeIntoMemorySegmentMasked(
-                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                 this, m,
                 (AbstractMemorySegmentImpl) ms, offset,
                 (msp, off, v, vm) -> {
@@ -3834,7 +3834,7 @@ public final long checkValue(long e) {
         final LongVector broadcastBits(long bits) {
             return (LongVector)
                 VectorSupport.fromBitsCoerced(
-                    vectorType, long.class, long.class, VECTOR_OPER_TYPE, laneCount,
+                    vectorType, long.class, VECTOR_OPER_TYPE, laneCount,
                     bits, MODE_BROADCAST, this,
                     (bits_, s_) -> s_.rvOp(i -> bits_));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short128Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short128Vector.java
index 52cb78a79a6..66b3073636f 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short128Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short128Vector.java
@@ -540,7 +540,7 @@ public short lane(int i) {
     @ForceInline
     public short laneHelper(int i) {
         return (short) VectorSupport.extract(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i,
                                 (vec, ix) -> {
                                     short[] vecarr = vec.vec();
@@ -567,7 +567,7 @@ public Short128Vector withLane(int i, short e) {
     @ForceInline
     public Short128Vector withLaneHelper(int i, short e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)e,
                                 (v, ix, bits) -> {
                                     short[] res = v.vec().clone();
@@ -682,7 +682,7 @@ public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
         /*package-private*/
         Short128Mask indexPartiallyInUpperRange(long offset, long limit) {
             return (Short128Mask) VectorSupport.indexPartiallyInUpperRange(
-                Short128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                Short128Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> (Short128Mask) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -698,7 +698,7 @@ public Short128Mask not() {
         @ForceInline
         public Short128Mask compress() {
             return (Short128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                Short128Vector.class, Short128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                Short128Vector.class, Short128Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 m1.trueCount()));
         }
@@ -711,7 +711,7 @@ public Short128Mask compress() {
         public Short128Mask and(VectorMask<Short> mask) {
             Objects.requireNonNull(mask);
             Short128Mask m = (Short128Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, Short128Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, Short128Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -721,7 +721,7 @@ public Short128Mask and(VectorMask<Short> mask) {
         public Short128Mask or(VectorMask<Short> mask) {
             Objects.requireNonNull(mask);
             Short128Mask m = (Short128Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, Short128Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, Short128Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -731,7 +731,7 @@ public Short128Mask or(VectorMask<Short> mask) {
         public Short128Mask xor(VectorMask<Short> mask) {
             Objects.requireNonNull(mask);
             Short128Mask m = (Short128Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short128Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short128Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -741,7 +741,7 @@ public Short128Mask xor(VectorMask<Short> mask) {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short128Mask.class, short.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short128Mask.class, short.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -749,7 +749,7 @@ public int trueCount() {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short128Mask.class, short.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short128Mask.class, short.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -757,7 +757,7 @@ public int firstTrue() {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short128Mask.class, short.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short128Mask.class, short.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -768,7 +768,7 @@ public long toLong() {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Short128Mask.class, short.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Short128Mask.class, short.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -779,7 +779,7 @@ public long toLong() {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract(Short128Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract(Short128Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -788,7 +788,7 @@ public boolean laneIsSet(int i) {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, Short128Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, Short128Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper(((Short128Mask)m).getBits()));
         }
@@ -796,7 +796,7 @@ this, vspecies().maskAll(true),
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, Short128Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, Short128Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper(((Short128Mask)m).getBits()));
         }
@@ -804,7 +804,7 @@ this, vspecies().maskAll(true),
         @ForceInline
         /*package-private*/
         static Short128Mask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(Short128Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced(Short128Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short256Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short256Vector.java
index 74219ad19d7..51bb65ab806 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short256Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short256Vector.java
@@ -548,7 +548,7 @@ public short lane(int i) {
     @ForceInline
     public short laneHelper(int i) {
         return (short) VectorSupport.extract(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i,
                                 (vec, ix) -> {
                                     short[] vecarr = vec.vec();
@@ -583,7 +583,7 @@ public Short256Vector withLane(int i, short e) {
     @ForceInline
     public Short256Vector withLaneHelper(int i, short e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)e,
                                 (v, ix, bits) -> {
                                     short[] res = v.vec().clone();
@@ -698,7 +698,7 @@ public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
         /*package-private*/
         Short256Mask indexPartiallyInUpperRange(long offset, long limit) {
             return (Short256Mask) VectorSupport.indexPartiallyInUpperRange(
-                Short256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                Short256Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> (Short256Mask) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -714,7 +714,7 @@ public Short256Mask not() {
         @ForceInline
         public Short256Mask compress() {
             return (Short256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                Short256Vector.class, Short256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                Short256Vector.class, Short256Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 m1.trueCount()));
         }
@@ -727,7 +727,7 @@ public Short256Mask compress() {
         public Short256Mask and(VectorMask<Short> mask) {
             Objects.requireNonNull(mask);
             Short256Mask m = (Short256Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, Short256Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, Short256Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -737,7 +737,7 @@ public Short256Mask and(VectorMask<Short> mask) {
         public Short256Mask or(VectorMask<Short> mask) {
             Objects.requireNonNull(mask);
             Short256Mask m = (Short256Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, Short256Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, Short256Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -747,7 +747,7 @@ public Short256Mask or(VectorMask<Short> mask) {
         public Short256Mask xor(VectorMask<Short> mask) {
             Objects.requireNonNull(mask);
             Short256Mask m = (Short256Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short256Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short256Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -757,7 +757,7 @@ public Short256Mask xor(VectorMask<Short> mask) {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short256Mask.class, short.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short256Mask.class, short.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -765,7 +765,7 @@ public int trueCount() {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short256Mask.class, short.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short256Mask.class, short.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -773,7 +773,7 @@ public int firstTrue() {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short256Mask.class, short.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short256Mask.class, short.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -784,7 +784,7 @@ public long toLong() {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Short256Mask.class, short.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Short256Mask.class, short.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -795,7 +795,7 @@ public long toLong() {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract(Short256Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract(Short256Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -804,7 +804,7 @@ public boolean laneIsSet(int i) {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, Short256Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, Short256Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper(((Short256Mask)m).getBits()));
         }
@@ -812,7 +812,7 @@ this, vspecies().maskAll(true),
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, Short256Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, Short256Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper(((Short256Mask)m).getBits()));
         }
@@ -820,7 +820,7 @@ this, vspecies().maskAll(true),
         @ForceInline
         /*package-private*/
         static Short256Mask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(Short256Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced(Short256Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short512Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short512Vector.java
index a927d8884b1..2bd0872594a 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short512Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short512Vector.java
@@ -564,7 +564,7 @@ public short lane(int i) {
     @ForceInline
     public short laneHelper(int i) {
         return (short) VectorSupport.extract(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i,
                                 (vec, ix) -> {
                                     short[] vecarr = vec.vec();
@@ -615,7 +615,7 @@ public Short512Vector withLane(int i, short e) {
     @ForceInline
     public Short512Vector withLaneHelper(int i, short e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)e,
                                 (v, ix, bits) -> {
                                     short[] res = v.vec().clone();
@@ -730,7 +730,7 @@ public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
         /*package-private*/
         Short512Mask indexPartiallyInUpperRange(long offset, long limit) {
             return (Short512Mask) VectorSupport.indexPartiallyInUpperRange(
-                Short512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                Short512Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> (Short512Mask) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -746,7 +746,7 @@ public Short512Mask not() {
         @ForceInline
         public Short512Mask compress() {
             return (Short512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                Short512Vector.class, Short512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                Short512Vector.class, Short512Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 m1.trueCount()));
         }
@@ -759,7 +759,7 @@ public Short512Mask compress() {
         public Short512Mask and(VectorMask<Short> mask) {
             Objects.requireNonNull(mask);
             Short512Mask m = (Short512Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, Short512Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, Short512Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -769,7 +769,7 @@ public Short512Mask and(VectorMask<Short> mask) {
         public Short512Mask or(VectorMask<Short> mask) {
             Objects.requireNonNull(mask);
             Short512Mask m = (Short512Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, Short512Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, Short512Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -779,7 +779,7 @@ public Short512Mask or(VectorMask<Short> mask) {
         public Short512Mask xor(VectorMask<Short> mask) {
             Objects.requireNonNull(mask);
             Short512Mask m = (Short512Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short512Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short512Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -789,7 +789,7 @@ public Short512Mask xor(VectorMask<Short> mask) {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short512Mask.class, short.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short512Mask.class, short.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -797,7 +797,7 @@ public int trueCount() {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short512Mask.class, short.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short512Mask.class, short.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -805,7 +805,7 @@ public int firstTrue() {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short512Mask.class, short.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short512Mask.class, short.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -816,7 +816,7 @@ public long toLong() {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Short512Mask.class, short.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Short512Mask.class, short.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -827,7 +827,7 @@ public long toLong() {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract(Short512Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract(Short512Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -836,7 +836,7 @@ public boolean laneIsSet(int i) {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, Short512Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, Short512Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper(((Short512Mask)m).getBits()));
         }
@@ -844,7 +844,7 @@ this, vspecies().maskAll(true),
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, Short512Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, Short512Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper(((Short512Mask)m).getBits()));
         }
@@ -852,7 +852,7 @@ this, vspecies().maskAll(true),
         @ForceInline
         /*package-private*/
         static Short512Mask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(Short512Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced(Short512Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short64Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short64Vector.java
index 0899d69face..124c97149a1 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short64Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short64Vector.java
@@ -536,7 +536,7 @@ public short lane(int i) {
     @ForceInline
     public short laneHelper(int i) {
         return (short) VectorSupport.extract(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i,
                                 (vec, ix) -> {
                                     short[] vecarr = vec.vec();
@@ -559,7 +559,7 @@ public Short64Vector withLane(int i, short e) {
     @ForceInline
     public Short64Vector withLaneHelper(int i, short e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)e,
                                 (v, ix, bits) -> {
                                     short[] res = v.vec().clone();
@@ -674,7 +674,7 @@ public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
         /*package-private*/
         Short64Mask indexPartiallyInUpperRange(long offset, long limit) {
             return (Short64Mask) VectorSupport.indexPartiallyInUpperRange(
-                Short64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                Short64Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> (Short64Mask) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -690,7 +690,7 @@ public Short64Mask not() {
         @ForceInline
         public Short64Mask compress() {
             return (Short64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                Short64Vector.class, Short64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                Short64Vector.class, Short64Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 m1.trueCount()));
         }
@@ -703,7 +703,7 @@ public Short64Mask compress() {
         public Short64Mask and(VectorMask<Short> mask) {
             Objects.requireNonNull(mask);
             Short64Mask m = (Short64Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, Short64Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, Short64Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -713,7 +713,7 @@ public Short64Mask and(VectorMask<Short> mask) {
         public Short64Mask or(VectorMask<Short> mask) {
             Objects.requireNonNull(mask);
             Short64Mask m = (Short64Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, Short64Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, Short64Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -723,7 +723,7 @@ public Short64Mask or(VectorMask<Short> mask) {
         public Short64Mask xor(VectorMask<Short> mask) {
             Objects.requireNonNull(mask);
             Short64Mask m = (Short64Mask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short64Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short64Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -733,7 +733,7 @@ public Short64Mask xor(VectorMask<Short> mask) {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short64Mask.class, short.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short64Mask.class, short.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -741,7 +741,7 @@ public int trueCount() {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short64Mask.class, short.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short64Mask.class, short.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -749,7 +749,7 @@ public int firstTrue() {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short64Mask.class, short.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short64Mask.class, short.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -760,7 +760,7 @@ public long toLong() {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Short64Mask.class, short.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Short64Mask.class, short.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -771,7 +771,7 @@ public long toLong() {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract(Short64Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract(Short64Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -780,7 +780,7 @@ public boolean laneIsSet(int i) {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, Short64Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, Short64Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper(((Short64Mask)m).getBits()));
         }
@@ -788,7 +788,7 @@ this, vspecies().maskAll(true),
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, Short64Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, Short64Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper(((Short64Mask)m).getBits()));
         }
@@ -796,7 +796,7 @@ this, vspecies().maskAll(true),
         @ForceInline
         /*package-private*/
         static Short64Mask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(Short64Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced(Short64Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ShortMaxVector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ShortMaxVector.java
index fa7a3fb1383..519ba6cda74 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ShortMaxVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ShortMaxVector.java
@@ -533,7 +533,7 @@ public short lane(int i) {
     @ForceInline
     public short laneHelper(int i) {
         return (short) VectorSupport.extract(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i,
                                 (vec, ix) -> {
                                     short[] vecarr = vec.vec();
@@ -553,7 +553,7 @@ public ShortMaxVector withLane(int i, short e) {
     @ForceInline
     public ShortMaxVector withLaneHelper(int i, short e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)e,
                                 (v, ix, bits) -> {
                                     short[] res = v.vec().clone();
@@ -668,7 +668,7 @@ public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
         /*package-private*/
         ShortMaxMask indexPartiallyInUpperRange(long offset, long limit) {
             return (ShortMaxMask) VectorSupport.indexPartiallyInUpperRange(
-                ShortMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                ShortMaxMask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> (ShortMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -684,7 +684,7 @@ public ShortMaxMask not() {
         @ForceInline
         public ShortMaxMask compress() {
             return (ShortMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                ShortMaxVector.class, ShortMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                ShortMaxVector.class, ShortMaxMask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 m1.trueCount()));
         }
@@ -697,7 +697,7 @@ public ShortMaxMask compress() {
         public ShortMaxMask and(VectorMask<Short> mask) {
             Objects.requireNonNull(mask);
             ShortMaxMask m = (ShortMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, ShortMaxMask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, ShortMaxMask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -707,7 +707,7 @@ public ShortMaxMask and(VectorMask<Short> mask) {
         public ShortMaxMask or(VectorMask<Short> mask) {
             Objects.requireNonNull(mask);
             ShortMaxMask m = (ShortMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, ShortMaxMask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, ShortMaxMask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -717,7 +717,7 @@ public ShortMaxMask or(VectorMask<Short> mask) {
         public ShortMaxMask xor(VectorMask<Short> mask) {
             Objects.requireNonNull(mask);
             ShortMaxMask m = (ShortMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, ShortMaxMask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, ShortMaxMask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -727,7 +727,7 @@ public ShortMaxMask xor(VectorMask<Short> mask) {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, ShortMaxMask.class, short.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, ShortMaxMask.class, short.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -735,7 +735,7 @@ public int trueCount() {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, ShortMaxMask.class, short.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, ShortMaxMask.class, short.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -743,7 +743,7 @@ public int firstTrue() {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, ShortMaxMask.class, short.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, ShortMaxMask.class, short.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -754,7 +754,7 @@ public long toLong() {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, ShortMaxMask.class, short.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, ShortMaxMask.class, short.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -765,7 +765,7 @@ public long toLong() {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract(ShortMaxMask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract(ShortMaxMask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -774,7 +774,7 @@ public boolean laneIsSet(int i) {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, ShortMaxMask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, ShortMaxMask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper(((ShortMaxMask)m).getBits()));
         }
@@ -782,7 +782,7 @@ this, vspecies().maskAll(true),
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, ShortMaxMask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, ShortMaxMask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper(((ShortMaxMask)m).getBits()));
         }
@@ -790,7 +790,7 @@ this, vspecies().maskAll(true),
         @ForceInline
         /*package-private*/
         static ShortMaxMask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(ShortMaxMask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced(ShortMaxMask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ShortVector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ShortVector.java
index a8b637be9c6..b203b399972 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ShortVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ShortVector.java
@@ -575,7 +575,7 @@ static ShortVector selectFromTwoVectorHelper(Vector<Short> indexes, Vector<Short
     @ForceInline
     public static ShortVector zero(VectorSpecies<Short> species) {
         ShortSpecies vsp = (ShortSpecies) species;
-        return VectorSupport.fromBitsCoerced(vsp.vectorType(), short.class, short.class, VECTOR_OPER_TYPE, species.length(),
+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), short.class, VECTOR_OPER_TYPE, species.length(),
                                 0, MODE_BROADCAST, vsp,
                                 ((bits_, s_) -> s_.rvOp(i -> bits_)));
     }
@@ -697,7 +697,7 @@ else if (op == NOT) {
         }
         int opc = opCode(op);
         return VectorSupport.unaryOp(
-            opc, getClass(), null, short.class, short.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, short.class, VECTOR_OPER_TYPE, length(),
             this, null,
             UN_IMPL.find(op, opc, ShortVector::unaryOperations));
     }
@@ -725,7 +725,7 @@ else if (op == NOT) {
         }
         int opc = opCode(op);
         return VectorSupport.unaryOp(
-            opc, getClass(), maskClass, short.class, short.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, short.class, VECTOR_OPER_TYPE, length(),
             this, m,
             UN_IMPL.find(op, opc, ShortVector::unaryOperations));
     }
@@ -798,7 +798,7 @@ ShortVector lanewiseTemplate(VectorOperators.Binary op,
 
         int opc = opCode(op);
         return VectorSupport.binaryOp(
-            opc, getClass(), null, short.class, short.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, short.class, VECTOR_OPER_TYPE, length(),
             this, that, null,
             BIN_IMPL.find(op, opc, ShortVector::binaryOperations));
     }
@@ -849,7 +849,7 @@ ShortVector lanewiseTemplate(VectorOperators.Binary op,
 
         int opc = opCode(op);
         return VectorSupport.binaryOp(
-            opc, getClass(), maskClass, short.class, short.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, short.class, VECTOR_OPER_TYPE, length(),
             this, that, m,
             BIN_IMPL.find(op, opc, ShortVector::binaryOperations));
     }
@@ -1036,7 +1036,7 @@ ShortVector lanewise(VectorOperators.Binary op,
         e &= SHIFT_MASK;
         int opc = opCode(op);
         return VectorSupport.broadcastInt(
-            opc, getClass(), null, short.class, short.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, short.class, VECTOR_OPER_TYPE, length(),
             this, e, null,
             BIN_INT_IMPL.find(op, opc, ShortVector::broadcastIntOperations));
     }
@@ -1057,7 +1057,7 @@ opc, getClass(), null, short.class, short.class, VECTOR_OPER_TYPE, length(),
         e &= SHIFT_MASK;
         int opc = opCode(op);
         return VectorSupport.broadcastInt(
-            opc, getClass(), maskClass, short.class, short.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, short.class, VECTOR_OPER_TYPE, length(),
             this, e, m,
             BIN_INT_IMPL.find(op, opc, ShortVector::broadcastIntOperations));
     }
@@ -1134,7 +1134,7 @@ ShortVector lanewiseTemplate(VectorOperators.Ternary op,
         }
         int opc = opCode(op);
         return VectorSupport.ternaryOp(
-            opc, getClass(), null, short.class, short.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, short.class, VECTOR_OPER_TYPE, length(),
             this, that, tother, null,
             TERN_IMPL.find(op, opc, ShortVector::ternaryOperations));
     }
@@ -1174,7 +1174,7 @@ ShortVector lanewiseTemplate(VectorOperators.Ternary op,
         }
         int opc = opCode(op);
         return VectorSupport.ternaryOp(
-            opc, getClass(), maskClass, short.class, short.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, short.class, VECTOR_OPER_TYPE, length(),
             this, that, tother, m,
             TERN_IMPL.find(op, opc, ShortVector::ternaryOperations));
     }
@@ -2073,7 +2073,7 @@ M compareTemplate(Class<M> maskType, Comparison op, Vector<Short> v) {
         that.check(this);
         int opc = opCode(op);
         return VectorSupport.compare(
-            opc, getClass(), maskType, short.class, short.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskType, short.class, VECTOR_OPER_TYPE, length(),
             this, that, null,
             (cond, v0, v1, m1) -> {
                 AbstractMask<Short> m
@@ -2095,7 +2095,7 @@ M compareTemplate(Class<M> maskType, Comparison op, Vector<Short> v, M m) {
         m.check(maskType, this);
         int opc = opCode(op);
         return VectorSupport.compare(
-            opc, getClass(), maskType, short.class, short.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskType, short.class, VECTOR_OPER_TYPE, length(),
             this, that, m,
             (cond, v0, v1, m1) -> {
                 AbstractMask<Short> cmpM
@@ -2226,7 +2226,7 @@ VectorMask<Short> compare(Comparison op, long e, VectorMask<Short> m) {
     blendTemplate(Class<M> maskType, ShortVector v, M m) {
         v.check(this);
         return VectorSupport.blend(
-            getClass(), maskType, short.class, short.class, VECTOR_OPER_TYPE, length(),
+            getClass(), maskType, short.class, VECTOR_OPER_TYPE, length(),
             this, v, m,
             (v0, v1, m_) -> v0.bOp(v1, m_, (i, a, b) -> b));
     }
@@ -2243,7 +2243,7 @@ final ShortVector addIndexTemplate(int scale) {
         // make sure VLENGTH*scale doesn't overflow:
         vsp.checkScale(scale);
         return VectorSupport.indexVector(
-            getClass(), short.class, short.class, VECTOR_OPER_TYPE, length(),
+            getClass(), short.class, VECTOR_OPER_TYPE, length(),
             this, scale, vsp,
             (v, scale_, s)
             -> {
@@ -2435,7 +2435,7 @@ ShortVector sliceTemplate(int origin) {
     ShortVector rearrangeTemplate(Class<S> shuffletype, S shuffle) {
         Objects.requireNonNull(shuffle);
         return VectorSupport.rearrangeOp(
-            getClass(), shuffletype, null, short.class, short.class, VECTOR_OPER_TYPE, length(),
+            getClass(), shuffletype, null, short.class, VECTOR_OPER_TYPE, length(),
             this, shuffle, null,
             (v1, s_, m_) -> v1.uOp((i, a) -> {
                 int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
@@ -2462,7 +2462,7 @@ ShortVector rearrangeTemplate(Class<S> shuffletype,
         Objects.requireNonNull(shuffle);
         m.check(masktype, this);
         return VectorSupport.rearrangeOp(
-                   getClass(), shuffletype, masktype, short.class, short.class, VECTOR_OPER_TYPE, length(),
+                   getClass(), shuffletype, masktype, short.class, VECTOR_OPER_TYPE, length(),
                    this, shuffle, m,
                    (v1, s_, m_) -> v1.uOp((i, a) -> {
                         int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
@@ -2488,7 +2488,7 @@ ShortVector rearrangeTemplate(Class<S> shuffletype,
         VectorMask<Short> valid = shuffle.laneIsValid();
         ShortVector r0 =
             VectorSupport.rearrangeOp(
-                getClass(), shuffletype, null, short.class, short.class, VECTOR_OPER_TYPE, length(),
+                getClass(), shuffletype, null, short.class, VECTOR_OPER_TYPE, length(),
                 this, shuffle, null,
                 (v0, s_, m_) -> v0.uOp((i, a) -> {
                     int ei = Integer.remainderUnsigned(s_.laneSource(i), v0.length());
@@ -2496,7 +2496,7 @@ ShortVector rearrangeTemplate(Class<S> shuffletype,
                 }));
         ShortVector r1 =
             VectorSupport.rearrangeOp(
-                getClass(), shuffletype, null, short.class, short.class, VECTOR_OPER_TYPE, length(),
+                getClass(), shuffletype, null, short.class, VECTOR_OPER_TYPE, length(),
                 v, shuffle, null,
                 (v1, s_, m_) -> v1.uOp((i, a) -> {
                     int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
@@ -2546,7 +2546,7 @@ VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp, boolean wrap) {
     ShortVector compressTemplate(Class<M> masktype, M m) {
       m.check(masktype, this);
       return (ShortVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,
-                                                        short.class, short.class, VECTOR_OPER_TYPE, length(), this, m,
+                                                        short.class, VECTOR_OPER_TYPE, length(), this, m,
                                                         (v1, m1) -> compressHelper(v1, m1));
     }
 
@@ -2565,7 +2565,7 @@ short.class, short.class, VECTOR_OPER_TYPE, length(), this, m,
     ShortVector expandTemplate(Class<M> masktype, M m) {
       m.check(masktype, this);
       return (ShortVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,
-                                                        short.class, short.class, VECTOR_OPER_TYPE, length(), this, m,
+                                                        short.class, VECTOR_OPER_TYPE, length(), this, m,
                                                         (v1, m1) -> expandHelper(v1, m1));
     }
 
@@ -2580,7 +2580,7 @@ short.class, short.class, VECTOR_OPER_TYPE, length(), this, m,
     /*package-private*/
     @ForceInline
     final ShortVector selectFromTemplate(ShortVector v) {
-        return (ShortVector)VectorSupport.selectFromOp(getClass(), null, short.class, short.class, VECTOR_OPER_TYPE,
+        return (ShortVector)VectorSupport.selectFromOp(getClass(), null, short.class, VECTOR_OPER_TYPE,
                                                         length(), this, v, null,
                                                         (v1, v2, _m) ->
                                                          v2.rearrange(v1.toShuffle()));
@@ -2600,7 +2600,7 @@ final ShortVector selectFromTemplate(ShortVector v) {
     ShortVector selectFromTemplate(ShortVector v,
                                             Class<M> masktype, M m) {
         m.check(masktype, this);
-        return (ShortVector)VectorSupport.selectFromOp(getClass(), masktype, short.class, short.class, VECTOR_OPER_TYPE,
+        return (ShortVector)VectorSupport.selectFromOp(getClass(), masktype, short.class, VECTOR_OPER_TYPE,
                                                         length(), this, v, m,
                                                         (v1, v2, _m) ->
                                                          v2.rearrange(v1.toShuffle(), _m));
@@ -2618,7 +2618,7 @@ ShortVector selectFromTemplate(ShortVector v,
     /*package-private*/
     @ForceInline
     final ShortVector selectFromTemplate(ShortVector v1, ShortVector v2) {
-        return VectorSupport.selectFromTwoVectorOp(getClass(), short.class, short.class, VECTOR_OPER_TYPE, length(), this, v1, v2,
+        return VectorSupport.selectFromTwoVectorOp(getClass(), short.class, VECTOR_OPER_TYPE, length(), this, v1, v2,
                                                    (vec1, vec2, vec3) -> selectFromTwoVectorHelper(vec1, vec2, vec3));
     }
 
@@ -2838,7 +2838,7 @@ short reduceLanesTemplate(VectorOperators.Associative op,
         }
         int opc = opCode(op);
         return fromBits(VectorSupport.reductionCoerced(
-            opc, getClass(), maskClass, short.class, short.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, short.class, VECTOR_OPER_TYPE, length(),
             this, m,
             REDUCE_IMPL.find(op, opc, ShortVector::reductionOperations)));
     }
@@ -2856,7 +2856,7 @@ short reduceLanesTemplate(VectorOperators.Associative op) {
         }
         int opc = opCode(op);
         return fromBits(VectorSupport.reductionCoerced(
-            opc, getClass(), null, short.class, short.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, short.class, VECTOR_OPER_TYPE, length(),
             this, null,
             REDUCE_IMPL.find(op, opc, ShortVector::reductionOperations)));
     }
@@ -3137,7 +3137,7 @@ ShortVector fromArray(VectorSpecies<Short> species,
         }
 
         return VectorSupport.loadWithMap(
-            vectorType, null, short.class, short.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+            vectorType, null, short.class, VECTOR_OPER_TYPE, vsp.laneCount(),
             lsp.vectorType(), lsp.length(),
             a, ARRAY_BASE, vix0, vix1, null, null, null,
             a, offset, indexMap, mapOffset, vsp,
@@ -3470,7 +3470,7 @@ void intoArray(short[] a, int offset) {
         offset = checkFromIndexSize(offset, length(), a.length);
         ShortSpecies vsp = vspecies();
         VectorSupport.store(
-            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false,
             this,
             a, offset,
@@ -3619,7 +3619,7 @@ void intoCharArray(char[] a, int offset) {
         offset = checkFromIndexSize(offset, length(), a.length);
         ShortSpecies vsp = vspecies();
         VectorSupport.store(
-            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, charArrayAddress(a, offset), false,
             this,
             a, offset,
@@ -3824,7 +3824,7 @@ void intoMemorySegment(MemorySegment ms, long offset,
     ShortVector fromArray0Template(short[] a, int offset) {
         ShortSpecies vsp = vspecies();
         return VectorSupport.load(
-            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false,
             a, offset, vsp,
             (arr, off, s) -> s.ldOp(arr, (int) off,
@@ -3841,7 +3841,7 @@ ShortVector fromArray0Template(Class<M> maskClass, short[] a, int offset, M m, i
         m.check(species());
         ShortSpecies vsp = vspecies();
         return VectorSupport.loadMasked(
-            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false, m, offsetInRange,
             a, offset, vsp,
             (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,
@@ -3888,7 +3888,7 @@ ShortVector fromArray0Template(Class<M> maskClass, short[] a, int offset,
         }
 
         return VectorSupport.loadWithMap(
-            vectorType, maskClass, short.class, short.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+            vectorType, maskClass, short.class, VECTOR_OPER_TYPE, vsp.laneCount(),
             lsp.vectorType(), lsp.length(),
             a, ARRAY_BASE, vix0, vix1, null, null, m,
             a, offset, indexMap, mapOffset, vsp,
@@ -3904,7 +3904,7 @@ ShortVector fromArray0Template(Class<M> maskClass, short[] a, int offset,
     ShortVector fromCharArray0Template(char[] a, int offset) {
         ShortSpecies vsp = vspecies();
         return VectorSupport.load(
-            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, charArrayAddress(a, offset), false,
             a, offset, vsp,
             (arr, off, s) -> s.ldOp(arr, (int) off,
@@ -3921,7 +3921,7 @@ ShortVector fromCharArray0Template(Class<M> maskClass, char[] a, int offset, M m
         m.check(species());
         ShortSpecies vsp = vspecies();
         return VectorSupport.loadMasked(
-                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                 a, charArrayAddress(a, offset), false, m, offsetInRange,
                 a, offset, vsp,
                 (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,
@@ -3936,7 +3936,7 @@ a, charArrayAddress(a, offset), false, m, offsetInRange,
     ShortVector fromMemorySegment0Template(MemorySegment ms, long offset) {
         ShortSpecies vsp = vspecies();
         return ScopedMemoryAccess.loadFromMemorySegment(
-                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                 (AbstractMemorySegmentImpl) ms, offset, vsp,
                 (msp, off, s) -> {
                     return s.ldLongOp((MemorySegment) msp, off, ShortVector::memorySegmentGet);
@@ -3952,7 +3952,7 @@ ShortVector fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, lon
         ShortSpecies vsp = vspecies();
         m.check(vsp);
         return ScopedMemoryAccess.loadFromMemorySegmentMasked(
-                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                 (AbstractMemorySegmentImpl) ms, offset, m, vsp, offsetInRange,
                 (msp, off, s, vm) -> {
                     return s.ldLongOp((MemorySegment) msp, off, vm, ShortVector::memorySegmentGet);
@@ -3970,7 +3970,7 @@ ShortVector fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, lon
     void intoArray0Template(short[] a, int offset) {
         ShortSpecies vsp = vspecies();
         VectorSupport.store(
-            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false,
             this, a, offset,
             (arr, off, v)
@@ -3987,7 +3987,7 @@ void intoArray0Template(Class<M> maskClass, short[] a, int offset, M m) {
         m.check(species());
         ShortSpecies vsp = vspecies();
         VectorSupport.storeMasked(
-            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false,
             this, m, a, offset,
             (arr, off, v, vm)
@@ -4002,7 +4002,7 @@ a, arrayAddress(a, offset), false,
     void intoMemorySegment0(MemorySegment ms, long offset) {
         ShortSpecies vsp = vspecies();
         ScopedMemoryAccess.storeIntoMemorySegment(
-                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                 this,
                 (AbstractMemorySegmentImpl) ms, offset,
                 (msp, off, v) -> {
@@ -4019,7 +4019,7 @@ void intoMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offse
         ShortSpecies vsp = vspecies();
         m.check(vsp);
         ScopedMemoryAccess.storeIntoMemorySegmentMasked(
-                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                 this, m,
                 (AbstractMemorySegmentImpl) ms, offset,
                 (msp, off, v, vm) -> {
@@ -4037,7 +4037,7 @@ void intoCharArray0Template(Class<M> maskClass, char[] a, int offset, M m) {
         m.check(species());
         ShortSpecies vsp = vspecies();
         VectorSupport.storeMasked(
-            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, charArrayAddress(a, offset), false,
             this, m, a, offset,
             (arr, off, v, vm)
@@ -4269,7 +4269,7 @@ public final long checkValue(long e) {
         final ShortVector broadcastBits(long bits) {
             return (ShortVector)
                 VectorSupport.fromBitsCoerced(
-                    vectorType, short.class, short.class, VECTOR_OPER_TYPE, laneCount,
+                    vectorType, short.class, VECTOR_OPER_TYPE, laneCount,
                     bits, MODE_BROADCAST, this,
                     (bits_, s_) -> s_.rvOp(i -> bits_));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Vector.java
index 7e01356139d..6318a7476e3 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Vector.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/VectorMask.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/VectorMask.java
index 5ebc8ce163e..fcefd22957b 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/VectorMask.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/VectorMask.java
@@ -209,11 +209,11 @@ public static <E> VectorMask<E> fromArray(VectorSpecies<E> species, boolean[] bi
         int laneCount = vsp.laneCount();
         offset = VectorIntrinsics.checkFromIndexSize(offset, laneCount, bits.length);
         return VectorSupport.load(
-                vsp.maskType(), vsp.carrierType(), vsp.elementType(),
-                vsp.operType(), laneCount, bits, (long) offset + Unsafe.ARRAY_BOOLEAN_BASE_OFFSET, false,
+                vsp.maskType(), vsp.carrierType(), vsp.operType(), laneCount, bits,
+                (long) offset + Unsafe.ARRAY_BOOLEAN_BASE_OFFSET, false,
                 bits, offset, vsp,
                 (c, idx, s)
-                  -> s.opm(n -> c[((int )idx) + n]));
+                  -> s.opm(n -> c[((int)idx) + n]));
     }
 
     /**
@@ -242,7 +242,7 @@ public static <E> VectorMask<E> fromArray(VectorSpecies<E> species, boolean[] bi
     public static <E> VectorMask<E> fromLong(VectorSpecies<E> species, long bits) {
         AbstractSpecies<E> vsp = (AbstractSpecies<E>) species;
         bits = bits & (0xFFFFFFFFFFFFFFFFL >>> (64 - vsp.laneCount()));
-        return VectorSupport.fromBitsCoerced(vsp.maskType(), vsp.carrierType(), vsp.elementType(),
+        return VectorSupport.fromBitsCoerced(vsp.maskType(), vsp.carrierType(),
                                              vsp.operType(), vsp.laneCount(), bits,
                                              VectorSupport.MODE_BITS_COERCED_LONG_TO_MASK, vsp,
                                              (m, s) -> {
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/VectorOperators.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/VectorOperators.java
index 292c9810319..976626d49b9 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/VectorOperators.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/VectorOperators.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/X-Vector.java.template b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/X-Vector.java.template
index e6ebcbdc0a8..9380e3f2389 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/X-Vector.java.template
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/X-Vector.java.template
@@ -570,7 +570,12 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         $type$[] vecPayload2 = (($abstractvectortype$)src1).vec();
         $type$[] vecPayload3 = (($abstractvectortype$)src2).vec();
         for (int i = 0; i < vlen; i++) {
+#if[FP16]
+            int index = Float16.shortBitsToFloat16(vecPayload1[i]).intValue();
+            int wrapped_index = VectorIntrinsics.wrapToRange(index, 2 * vlen);
+#else[FP16]
             int wrapped_index = VectorIntrinsics.wrapToRange((int)vecPayload1[i], 2 * vlen);
+#end[FP16]
             res[i] = wrapped_index >= vlen ? vecPayload3[wrapped_index - vlen] : vecPayload2[wrapped_index];
         }
         return (($abstractvectortype$)src1).vectorFactory(res);
@@ -601,11 +606,11 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
     public static $abstractvectortype$ zero(VectorSpecies<$Boxtype$> species) {
         $Type$Species vsp = ($Type$Species) species;
 #if[FP]
-        return VectorSupport.fromBitsCoerced(vsp.vectorType(), $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, species.length(),
+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), $carriertype$.class, VECTOR_OPER_TYPE, species.length(),
                         toBits({#if[FP16]?(short) 0:0.0f}), MODE_BROADCAST, vsp,
                         ((bits_, s_) -> s_.rvOp(i -> bits_)));
 #else[FP]
-        return VectorSupport.fromBitsCoerced(vsp.vectorType(), $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, species.length(),
+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), $carriertype$.class, VECTOR_OPER_TYPE, species.length(),
                                 0, MODE_BROADCAST, vsp,
                                 ((bits_, s_) -> s_.rvOp(i -> bits_)));
 #end[FP]
@@ -737,7 +742,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         }
         int opc = opCode(op);
         return VectorSupport.unaryOp(
-            opc, getClass(), null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, $carriertype$.class, VECTOR_OPER_TYPE, length(),
             this, null,
             UN_IMPL.find(op, opc, $abstractvectortype$::unaryOperations));
     }
@@ -772,7 +777,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         }
         int opc = opCode(op);
         return VectorSupport.unaryOp(
-            opc, getClass(), maskClass, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, $carriertype$.class, VECTOR_OPER_TYPE, length(),
             this, m,
             UN_IMPL.find(op, opc, $abstractvectortype$::unaryOperations));
     }
@@ -951,7 +956,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
 
         int opc = opCode(op);
         return VectorSupport.binaryOp(
-            opc, getClass(), null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, $carriertype$.class, VECTOR_OPER_TYPE, length(),
             this, that, null,
             BIN_IMPL.find(op, opc, $abstractvectortype$::binaryOperations));
     }
@@ -1018,7 +1023,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
 
         int opc = opCode(op);
         return VectorSupport.binaryOp(
-            opc, getClass(), maskClass, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, $carriertype$.class, VECTOR_OPER_TYPE, length(),
             this, that, m,
             BIN_IMPL.find(op, opc, $abstractvectortype$::binaryOperations));
     }
@@ -1270,7 +1275,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         e &= SHIFT_MASK;
         int opc = opCode(op);
         return VectorSupport.broadcastInt(
-            opc, getClass(), null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, $carriertype$.class, VECTOR_OPER_TYPE, length(),
             this, e, null,
             BIN_INT_IMPL.find(op, opc, $abstractvectortype$::broadcastIntOperations));
     }
@@ -1291,7 +1296,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         e &= SHIFT_MASK;
         int opc = opCode(op);
         return VectorSupport.broadcastInt(
-            opc, getClass(), maskClass, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, $carriertype$.class, VECTOR_OPER_TYPE, length(),
             this, e, m,
             BIN_INT_IMPL.find(op, opc, $abstractvectortype$::broadcastIntOperations));
     }
@@ -1375,7 +1380,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
 #end[BITWISE]
         int opc = opCode(op);
         return VectorSupport.ternaryOp(
-            opc, getClass(), null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, $carriertype$.class, VECTOR_OPER_TYPE, length(),
             this, that, tother, null,
             TERN_IMPL.find(op, opc, $abstractvectortype$::ternaryOperations));
     }
@@ -1417,7 +1422,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
 #end[BITWISE]
         int opc = opCode(op);
         return VectorSupport.ternaryOp(
-            opc, getClass(), maskClass, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, $carriertype$.class, VECTOR_OPER_TYPE, length(),
             this, that, tother, m,
             TERN_IMPL.find(op, opc, $abstractvectortype$::ternaryOperations));
     }
@@ -2554,7 +2559,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         that.check(this);
         int opc = opCode(op);
         return VectorSupport.compare(
-            opc, getClass(), maskType, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskType, $carriertype$.class, VECTOR_OPER_TYPE, length(),
             this, that, null,
             (cond, v0, v1, m1) -> {
                 AbstractMask<$Boxtype$> m
@@ -2576,7 +2581,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         m.check(maskType, this);
         int opc = opCode(op);
         return VectorSupport.compare(
-            opc, getClass(), maskType, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskType, $carriertype$.class, VECTOR_OPER_TYPE, length(),
             this, that, m,
             (cond, v0, v1, m1) -> {
                 AbstractMask<$Boxtype$> cmpM
@@ -2720,7 +2725,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
     blendTemplate(Class<M> maskType, $abstractvectortype$ v, M m) {
         v.check(this);
         return VectorSupport.blend(
-            getClass(), maskType, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
+            getClass(), maskType, $carriertype$.class, VECTOR_OPER_TYPE, length(),
             this, v, m,
             (v0, v1, m_) -> v0.bOp(v1, m_, (i, a, b) -> b));
     }
@@ -2737,7 +2742,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         // make sure VLENGTH*scale doesn't overflow:
         vsp.checkScale(scale);
         return VectorSupport.indexVector(
-            getClass(), $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
+            getClass(), $carriertype$.class, VECTOR_OPER_TYPE, length(),
             this, scale, vsp,
             (v, scale_, s)
             -> {
@@ -2951,7 +2956,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
     $abstractvectortype$ rearrangeTemplate(Class<S> shuffletype, S shuffle) {
         Objects.requireNonNull(shuffle);
         return VectorSupport.rearrangeOp(
-            getClass(), shuffletype, null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
+            getClass(), shuffletype, null, $carriertype$.class, VECTOR_OPER_TYPE, length(),
             this, shuffle, null,
             (v1, s_, m_) -> v1.uOp((i, a) -> {
                 int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
@@ -2978,7 +2983,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         Objects.requireNonNull(shuffle);
         m.check(masktype, this);
         return VectorSupport.rearrangeOp(
-                   getClass(), shuffletype, masktype, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
+                   getClass(), shuffletype, masktype, $carriertype$.class, VECTOR_OPER_TYPE, length(),
                    this, shuffle, m,
                    (v1, s_, m_) -> v1.uOp((i, a) -> {
                         int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
@@ -3004,7 +3009,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         VectorMask<$Boxtype$> valid = shuffle.laneIsValid();
         $abstractvectortype$ r0 =
             VectorSupport.rearrangeOp(
-                getClass(), shuffletype, null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
+                getClass(), shuffletype, null, $carriertype$.class, VECTOR_OPER_TYPE, length(),
                 this, shuffle, null,
                 (v0, s_, m_) -> v0.uOp((i, a) -> {
                     int ei = Integer.remainderUnsigned(s_.laneSource(i), v0.length());
@@ -3012,7 +3017,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
                 }));
         $abstractvectortype$ r1 =
             VectorSupport.rearrangeOp(
-                getClass(), shuffletype, null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
+                getClass(), shuffletype, null, $carriertype$.class, VECTOR_OPER_TYPE, length(),
                 v, shuffle, null,
                 (v1, s_, m_) -> v1.uOp((i, a) -> {
                     int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
@@ -3077,7 +3082,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
     $Type$Vector compressTemplate(Class<M> masktype, M m) {
       m.check(masktype, this);
       return ($Type$Vector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,
-                                                        $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(), this, m,
+                                                        $carriertype$.class, VECTOR_OPER_TYPE, length(), this, m,
                                                         (v1, m1) -> compressHelper(v1, m1));
     }
 
@@ -3096,7 +3101,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
     $Type$Vector expandTemplate(Class<M> masktype, M m) {
       m.check(masktype, this);
       return ($Type$Vector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,
-                                                        $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(), this, m,
+                                                        $carriertype$.class, VECTOR_OPER_TYPE, length(), this, m,
                                                         (v1, m1) -> expandHelper(v1, m1));
     }
 
@@ -3111,7 +3116,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
     /*package-private*/
     @ForceInline
     final $abstractvectortype$ selectFromTemplate($abstractvectortype$ v) {
-        return ($Type$Vector)VectorSupport.selectFromOp(getClass(), null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE,
+        return ($Type$Vector)VectorSupport.selectFromOp(getClass(), null, $carriertype$.class, VECTOR_OPER_TYPE,
                                                         length(), this, v, null,
                                                         (v1, v2, _m) ->
                                                          v2.rearrange(v1.toShuffle()));
@@ -3131,7 +3136,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
     $abstractvectortype$ selectFromTemplate($abstractvectortype$ v,
                                             Class<M> masktype, M m) {
         m.check(masktype, this);
-        return ($Type$Vector)VectorSupport.selectFromOp(getClass(), masktype, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE,
+        return ($Type$Vector)VectorSupport.selectFromOp(getClass(), masktype, $carriertype$.class, VECTOR_OPER_TYPE,
                                                         length(), this, v, m,
                                                         (v1, v2, _m) ->
                                                          v2.rearrange(v1.toShuffle(), _m));
@@ -3149,7 +3154,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
     /*package-private*/
     @ForceInline
     final $abstractvectortype$ selectFromTemplate($abstractvectortype$ v1, $abstractvectortype$ v2) {
-        return VectorSupport.selectFromTwoVectorOp(getClass(), $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(), this, v1, v2,
+        return VectorSupport.selectFromTwoVectorOp(getClass(), $carriertype$.class, VECTOR_OPER_TYPE, length(), this, v1, v2,
                                                    (vec1, vec2, vec3) -> selectFromTwoVectorHelper(vec1, vec2, vec3));
     }
 
@@ -3498,7 +3503,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         }
         int opc = opCode(op);
         return fromBits(VectorSupport.reductionCoerced(
-            opc, getClass(), maskClass, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), maskClass, $carriertype$.class, VECTOR_OPER_TYPE, length(),
             this, m,
             REDUCE_IMPL.find(op, opc, $abstractvectortype$::reductionOperations)));
     }
@@ -3516,7 +3521,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         }
         int opc = opCode(op);
         return fromBits(VectorSupport.reductionCoerced(
-            opc, getClass(), null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
+            opc, getClass(), null, $carriertype$.class, VECTOR_OPER_TYPE, length(),
             this, null,
             REDUCE_IMPL.find(op, opc, $abstractvectortype$::reductionOperations)));
     }
@@ -3887,7 +3892,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         }
 
         return VectorSupport.loadWithMap(
-            vectorType, null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+            vectorType, null, $carriertype$.class, VECTOR_OPER_TYPE, vsp.laneCount(),
             lsp.vectorType(), lsp.length(),
             a, ARRAY_BASE, vix0, vix1, vix2, vix3, null,
             a, offset, indexMap, mapOffset, vsp,
@@ -3895,7 +3900,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
             s.vOp(n -> c[idx + iMap[idy+n]]));
 #else[byte]
         return VectorSupport.loadWithMap(
-            vectorType, null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+            vectorType, null, $carriertype$.class, VECTOR_OPER_TYPE, vsp.laneCount(),
             lsp.vectorType(), lsp.length(),
             a, ARRAY_BASE, vix0, vix1, null, null, null,
             a, offset, indexMap, mapOffset, vsp,
@@ -3948,7 +3953,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         vix = VectorIntrinsics.checkIndex(vix, a.length);
 
         return VectorSupport.loadWithMap(
-            vectorType, null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+            vectorType, null, $carriertype$.class, VECTOR_OPER_TYPE, vsp.laneCount(),
             isp.vectorType(), isp.length(),
             a, ARRAY_BASE, vix, null, null, null, null,
             a, offset, indexMap, mapOffset, vsp,
@@ -4447,7 +4452,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         offset = checkFromIndexSize(offset, length(), a.length);
         $Type$Species vsp = vspecies();
         VectorSupport.store(
-            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false,
             this,
             a, offset,
@@ -4574,7 +4579,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         vix = VectorIntrinsics.checkIndex(vix, a.length);
 
         VectorSupport.storeWithMap(
-            vsp.vectorType(), null, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), null, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             isp.vectorType(), isp.length(),
             a, arrayAddress(a, 0), vix,
             this, null,
@@ -4667,7 +4672,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         offset = checkFromIndexSize(offset, length(), a.length);
         $Type$Species vsp = vspecies();
         VectorSupport.store(
-            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, charArrayAddress(a, offset), false,
             this,
             a, offset,
@@ -4829,7 +4834,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         $Type$Species vsp = vspecies();
         ByteVector normalized = this.and((byte) 1);
         VectorSupport.store(
-            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, booleanArrayAddress(a, offset), false,
             normalized,
             a, offset,
@@ -5043,7 +5048,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
     $abstractvectortype$ fromArray0Template($type$[] a, int offset) {
         $Type$Species vsp = vspecies();
         return VectorSupport.load(
-            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false,
             a, offset, vsp,
             (arr, off, s) -> s.ldOp(arr, (int) off,
@@ -5060,7 +5065,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         m.check(species());
         $Type$Species vsp = vspecies();
         return VectorSupport.loadMasked(
-            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false, m, offsetInRange,
             a, offset, vsp,
             (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,
@@ -5118,7 +5123,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         }
 
         return VectorSupport.loadWithMap(
-            vectorType, maskClass, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+            vectorType, maskClass, $carriertype$.class, VECTOR_OPER_TYPE, vsp.laneCount(),
             lsp.vectorType(), lsp.length(),
             a, ARRAY_BASE, vix0, vix1, vix2, vix3, m,
             a, offset, indexMap, mapOffset, vsp,
@@ -5126,7 +5131,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
             s.vOp(vm, n -> c[idx + iMap[idy+n]]));
 #else[byte]
         return VectorSupport.loadWithMap(
-            vectorType, maskClass, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+            vectorType, maskClass, $carriertype$.class, VECTOR_OPER_TYPE, vsp.laneCount(),
             lsp.vectorType(), lsp.length(),
             a, ARRAY_BASE, vix0, vix1, null, null, m,
             a, offset, indexMap, mapOffset, vsp,
@@ -5181,7 +5186,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         vix = VectorIntrinsics.checkIndex(vix, a.length);
 
         return VectorSupport.loadWithMap(
-            vectorType, maskClass, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+            vectorType, maskClass, $carriertype$.class, VECTOR_OPER_TYPE, vsp.laneCount(),
             isp.vectorType(), isp.length(),
             a, ARRAY_BASE, vix, null, null, null, m,
             a, offset, indexMap, mapOffset, vsp,
@@ -5199,7 +5204,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
     $abstractvectortype$ fromCharArray0Template(char[] a, int offset) {
         $Type$Species vsp = vspecies();
         return VectorSupport.load(
-            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, charArrayAddress(a, offset), false,
             a, offset, vsp,
             (arr, off, s) -> s.ldOp(arr, (int) off,
@@ -5216,7 +5221,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         m.check(species());
         $Type$Species vsp = vspecies();
         return VectorSupport.loadMasked(
-                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                 a, charArrayAddress(a, offset), false, m, offsetInRange,
                 a, offset, vsp,
                 (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,
@@ -5233,7 +5238,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
     $abstractvectortype$ fromBooleanArray0Template(boolean[] a, int offset) {
         $Type$Species vsp = vspecies();
         return VectorSupport.load(
-            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, booleanArrayAddress(a, offset), false,
             a, offset, vsp,
             (arr, off, s) -> s.ldOp(arr, (int) off,
@@ -5250,7 +5255,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         m.check(species());
         $Type$Species vsp = vspecies();
         return VectorSupport.loadMasked(
-            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, booleanArrayAddress(a, offset), false, m, offsetInRange,
             a, offset, vsp,
             (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,
@@ -5265,7 +5270,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
     $abstractvectortype$ fromMemorySegment0Template(MemorySegment ms, long offset) {
         $Type$Species vsp = vspecies();
         return ScopedMemoryAccess.loadFromMemorySegment(
-                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                 (AbstractMemorySegmentImpl) ms, offset, vsp,
                 (msp, off, s) -> {
                     return s.ldLongOp((MemorySegment) msp, off, $abstractvectortype$::memorySegmentGet);
@@ -5281,7 +5286,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         $Type$Species vsp = vspecies();
         m.check(vsp);
         return ScopedMemoryAccess.loadFromMemorySegmentMasked(
-                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                 (AbstractMemorySegmentImpl) ms, offset, m, vsp, offsetInRange,
                 (msp, off, s, vm) -> {
                     return s.ldLongOp((MemorySegment) msp, off, vm, $abstractvectortype$::memorySegmentGet);
@@ -5299,7 +5304,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
     void intoArray0Template($type$[] a, int offset) {
         $Type$Species vsp = vspecies();
         VectorSupport.store(
-            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false,
             this, a, offset,
             (arr, off, v)
@@ -5316,7 +5321,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         m.check(species());
         $Type$Species vsp = vspecies();
         VectorSupport.storeMasked(
-            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, arrayAddress(a, offset), false,
             this, m, a, offset,
             (arr, off, v, vm)
@@ -5372,7 +5377,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         vix = VectorIntrinsics.checkIndex(vix, a.length);
 
         VectorSupport.storeWithMap(
-            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             isp.vectorType(), isp.length(),
             a, arrayAddress(a, 0), vix,
             this, m,
@@ -5397,7 +5402,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         $Type$Species vsp = vspecies();
         ByteVector normalized = this.and((byte) 1);
         VectorSupport.storeMasked(
-            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, booleanArrayAddress(a, offset), false,
             normalized, m, a, offset,
             (arr, off, v, vm)
@@ -5411,7 +5416,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
     void intoMemorySegment0(MemorySegment ms, long offset) {
         $Type$Species vsp = vspecies();
         ScopedMemoryAccess.storeIntoMemorySegment(
-                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                 this,
                 (AbstractMemorySegmentImpl) ms, offset,
                 (msp, off, v) -> {
@@ -5428,7 +5433,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         $Type$Species vsp = vspecies();
         m.check(vsp);
         ScopedMemoryAccess.storeIntoMemorySegmentMasked(
-                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                 this, m,
                 (AbstractMemorySegmentImpl) ms, offset,
                 (msp, off, v, vm) -> {
@@ -5447,7 +5452,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         m.check(species());
         $Type$Species vsp = vspecies();
         VectorSupport.storeMasked(
-            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),
             a, charArrayAddress(a, offset), false,
             this, m, a, offset,
             (arr, off, v, vm)
@@ -5719,7 +5724,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         final $abstractvectortype$ broadcastBits(long bits) {
             return ($abstractvectortype$)
                 VectorSupport.fromBitsCoerced(
-                    vectorType, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, laneCount,
+                    vectorType, $carriertype$.class, VECTOR_OPER_TYPE, laneCount,
                     bits, MODE_BROADCAST, this,
                     (bits_, s_) -> s_.rvOp(i -> bits_));
         }
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/X-VectorBits.java.template b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/X-VectorBits.java.template
index 1a2f455d525..b8760d5aef4 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/X-VectorBits.java.template
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/X-VectorBits.java.template
@@ -602,7 +602,7 @@ final class $vectortype$ extends $abstractvectortype$ {
     @ForceInline
     public $bitstype$ laneHelper(int i) {
         return ($bitstype$) VectorSupport.extract(
-                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                     VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                      this, i,
                      (vec, ix) -> {
                      $type$[] vecarr = vec.vec();
@@ -670,7 +670,7 @@ final class $vectortype$ extends $abstractvectortype$ {
     @ForceInline
     public $vectortype$ withLaneHelper(int i, $type$ e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long){#if[FP16]?e:$Type$.$type$ToRaw$Bitstype$Bits(e)},
                                 (v, ix, bits) -> {
                                     $type$[] res = v.vec().clone();
@@ -773,7 +773,7 @@ final class $vectortype$ extends $abstractvectortype$ {
     @ForceInline
     public $type$ laneHelper(int i) {
         return ($type$) VectorSupport.extract(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i,
                                 (vec, ix) -> {
                                     $type$[] vecarr = vec.vec();
@@ -875,7 +875,7 @@ final class $vectortype$ extends $abstractvectortype$ {
     @ForceInline
     public $vectortype$ withLaneHelper(int i, $type$ e) {
         return VectorSupport.insert(
-                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,
                                 this, i, (long)e,
                                 (v, ix, bits) -> {
                                     $type$[] res = v.vec().clone();
@@ -991,7 +991,7 @@ final class $vectortype$ extends $abstractvectortype$ {
         /*package-private*/
         $masktype$ indexPartiallyInUpperRange(long offset, long limit) {
             return ($masktype$) VectorSupport.indexPartiallyInUpperRange(
-                $masktype$.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
+                $masktype$.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                 (o, l) -> ($masktype$) TRUE_MASK.indexPartiallyInRange(o, l));
         }
 
@@ -1007,7 +1007,7 @@ final class $vectortype$ extends $abstractvectortype$ {
         @ForceInline
         public $masktype$ compress() {
             return ($masktype$)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                $vectortype$.class, $masktype$.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
+                $vectortype$.class, $masktype$.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
                 {#if[FP16]?Float16.float16ToShortBits(Float16.valueOf(m1.trueCount())):m1.trueCount()}));
         }
@@ -1020,7 +1020,7 @@ final class $vectortype$ extends $abstractvectortype$ {
         public $masktype$ and(VectorMask<$Boxtype$> mask) {
             Objects.requireNonNull(mask);
             $masktype$ m = ($masktype$)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, $masktype$.class, null, $bitstype$.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_AND, $masktype$.class, null, $bitstype$.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
         }
@@ -1030,7 +1030,7 @@ final class $vectortype$ extends $abstractvectortype$ {
         public $masktype$ or(VectorMask<$Boxtype$> mask) {
             Objects.requireNonNull(mask);
             $masktype$ m = ($masktype$)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, $masktype$.class, null, $bitstype$.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_OR, $masktype$.class, null, $bitstype$.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
         }
@@ -1040,7 +1040,7 @@ final class $vectortype$ extends $abstractvectortype$ {
         public $masktype$ xor(VectorMask<$Boxtype$> mask) {
             Objects.requireNonNull(mask);
             $masktype$ m = ($masktype$)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, $masktype$.class, null, $bitstype$.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.binaryOp(VECTOR_OP_XOR, $masktype$.class, null, $bitstype$.class, VECTOR_OPER_TYPE, VLENGTH,
                                           this, m, null,
                                           (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
         }
@@ -1050,7 +1050,7 @@ final class $vectortype$ extends $abstractvectortype$ {
         @Override
         @ForceInline
         public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, $masktype$.class, $bitstype$.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, $masktype$.class, $bitstype$.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> trueCountHelper(m.getBits()));
         }
@@ -1058,7 +1058,7 @@ final class $vectortype$ extends $abstractvectortype$ {
         @Override
         @ForceInline
         public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, $masktype$.class, $bitstype$.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, $masktype$.class, $bitstype$.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> firstTrueHelper(m.getBits()));
         }
@@ -1066,7 +1066,7 @@ final class $vectortype$ extends $abstractvectortype$ {
         @Override
         @ForceInline
         public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, $masktype$.class, $bitstype$.class, ETYPE,
+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, $masktype$.class, $bitstype$.class,
                                                             VECTOR_OPER_TYPE, VLENGTH, this,
                                                             (m) -> lastTrueHelper(m.getBits()));
         }
@@ -1077,7 +1077,7 @@ final class $vectortype$ extends $abstractvectortype$ {
             if (length() > Long.SIZE) {
                 throw new UnsupportedOperationException("too many lanes for one long");
             }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, $masktype$.class, $bitstype$.class, ETYPE,
+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, $masktype$.class, $bitstype$.class,
                                                       VECTOR_OPER_TYPE, VLENGTH, this,
                                                       (m) -> toLongHelper(m.getBits()));
         }
@@ -1088,7 +1088,7 @@ final class $vectortype$ extends $abstractvectortype$ {
         @ForceInline
         public boolean laneIsSet(int i) {
             Objects.checkIndex(i, length());
-            return VectorSupport.extract($masktype$.class, $type$.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.extract($masktype$.class, $type$.class, VECTOR_OPER_TYPE, VLENGTH,
                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
         }
 
@@ -1097,7 +1097,7 @@ final class $vectortype$ extends $abstractvectortype$ {
         @Override
         @ForceInline
         public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, $masktype$.class, $bitstype$.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_ne, $masktype$.class, $bitstype$.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> anyTrueHelper((($masktype$)m).getBits()));
         }
@@ -1105,7 +1105,7 @@ final class $vectortype$ extends $abstractvectortype$ {
         @Override
         @ForceInline
         public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, $masktype$.class, $bitstype$.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.test(BT_overflow, $masktype$.class, $bitstype$.class, VECTOR_OPER_TYPE, VLENGTH,
                                       this, vspecies().maskAll(true),
                                       (m, __) -> allTrueHelper((($masktype$)m).getBits()));
         }
@@ -1113,7 +1113,7 @@ final class $vectortype$ extends $abstractvectortype$ {
         @ForceInline
         /*package-private*/
         static $masktype$ maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced($masktype$.class, $bitstype$.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+            return VectorSupport.fromBitsCoerced($masktype$.class, $bitstype$.class, VECTOR_OPER_TYPE, VLENGTH,
                                                  (bit ? -1 : 0), MODE_BROADCAST, null,
                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
         }
diff --git a/test/jdk/jdk/incubator/vector/Byte128VectorTests.java b/test/jdk/jdk/incubator/vector/Byte128VectorTests.java
index 7f462d53233..219ab16c343 100644
--- a/test/jdk/jdk/incubator/vector/Byte128VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Byte128VectorTests.java
@@ -6522,7 +6522,7 @@ static void ADDReduceLongByte128VectorTests(IntFunction<byte[]> fa) {
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
@@ -6563,7 +6563,7 @@ static void ADDReduceLongByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFun
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
diff --git a/test/jdk/jdk/incubator/vector/Byte256VectorTests.java b/test/jdk/jdk/incubator/vector/Byte256VectorTests.java
index 17d26e3a46a..39b74d64f0c 100644
--- a/test/jdk/jdk/incubator/vector/Byte256VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Byte256VectorTests.java
@@ -6522,7 +6522,7 @@ static void ADDReduceLongByte256VectorTests(IntFunction<byte[]> fa) {
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
@@ -6563,7 +6563,7 @@ static void ADDReduceLongByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFun
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
diff --git a/test/jdk/jdk/incubator/vector/Byte512VectorTests.java b/test/jdk/jdk/incubator/vector/Byte512VectorTests.java
index f77dd4c6fd8..db8a7f5d024 100644
--- a/test/jdk/jdk/incubator/vector/Byte512VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Byte512VectorTests.java
@@ -6522,7 +6522,7 @@ static void ADDReduceLongByte512VectorTests(IntFunction<byte[]> fa) {
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
@@ -6563,7 +6563,7 @@ static void ADDReduceLongByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFun
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
diff --git a/test/jdk/jdk/incubator/vector/Byte64VectorTests.java b/test/jdk/jdk/incubator/vector/Byte64VectorTests.java
index e5ac3bff978..b3003635b0a 100644
--- a/test/jdk/jdk/incubator/vector/Byte64VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Byte64VectorTests.java
@@ -6522,7 +6522,7 @@ static void ADDReduceLongByte64VectorTests(IntFunction<byte[]> fa) {
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
@@ -6563,7 +6563,7 @@ static void ADDReduceLongByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunc
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
diff --git a/test/jdk/jdk/incubator/vector/ByteMaxVectorTests.java b/test/jdk/jdk/incubator/vector/ByteMaxVectorTests.java
index 4a484cf3bf6..053cdae4a5e 100644
--- a/test/jdk/jdk/incubator/vector/ByteMaxVectorTests.java
+++ b/test/jdk/jdk/incubator/vector/ByteMaxVectorTests.java
@@ -6527,7 +6527,7 @@ static void ADDReduceLongByteMaxVectorTests(IntFunction<byte[]> fa) {
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
@@ -6568,7 +6568,7 @@ static void ADDReduceLongByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFun
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
diff --git a/test/jdk/jdk/incubator/vector/Double128VectorTests.java b/test/jdk/jdk/incubator/vector/Double128VectorTests.java
index 9c8ba2d9eb7..0688a380d6a 100644
--- a/test/jdk/jdk/incubator/vector/Double128VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Double128VectorTests.java
@@ -4921,7 +4921,7 @@ static void ADDReduceLongDouble128VectorTests(IntFunction<double[]> fa) {
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
@@ -4962,7 +4962,7 @@ static void ADDReduceLongDouble128VectorTestsMasked(IntFunction<double[]> fa, In
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
diff --git a/test/jdk/jdk/incubator/vector/Double256VectorTests.java b/test/jdk/jdk/incubator/vector/Double256VectorTests.java
index 9c326ed6695..86113790f8b 100644
--- a/test/jdk/jdk/incubator/vector/Double256VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Double256VectorTests.java
@@ -4921,7 +4921,7 @@ static void ADDReduceLongDouble256VectorTests(IntFunction<double[]> fa) {
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
@@ -4962,7 +4962,7 @@ static void ADDReduceLongDouble256VectorTestsMasked(IntFunction<double[]> fa, In
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
diff --git a/test/jdk/jdk/incubator/vector/Double512VectorTests.java b/test/jdk/jdk/incubator/vector/Double512VectorTests.java
index 862064fd259..8c0d0531087 100644
--- a/test/jdk/jdk/incubator/vector/Double512VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Double512VectorTests.java
@@ -4921,7 +4921,7 @@ static void ADDReduceLongDouble512VectorTests(IntFunction<double[]> fa) {
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
@@ -4962,7 +4962,7 @@ static void ADDReduceLongDouble512VectorTestsMasked(IntFunction<double[]> fa, In
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
diff --git a/test/jdk/jdk/incubator/vector/Double64VectorTests.java b/test/jdk/jdk/incubator/vector/Double64VectorTests.java
index 7f24df8abbb..4f01df5ba6d 100644
--- a/test/jdk/jdk/incubator/vector/Double64VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Double64VectorTests.java
@@ -4921,7 +4921,7 @@ static void ADDReduceLongDouble64VectorTests(IntFunction<double[]> fa) {
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
@@ -4962,7 +4962,7 @@ static void ADDReduceLongDouble64VectorTestsMasked(IntFunction<double[]> fa, Int
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
diff --git a/test/jdk/jdk/incubator/vector/DoubleMaxVectorTests.java b/test/jdk/jdk/incubator/vector/DoubleMaxVectorTests.java
index 316154684e0..6d3b80c906b 100644
--- a/test/jdk/jdk/incubator/vector/DoubleMaxVectorTests.java
+++ b/test/jdk/jdk/incubator/vector/DoubleMaxVectorTests.java
@@ -4926,7 +4926,7 @@ static void ADDReduceLongDoubleMaxVectorTests(IntFunction<double[]> fa) {
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
@@ -4967,7 +4967,7 @@ static void ADDReduceLongDoubleMaxVectorTestsMasked(IntFunction<double[]> fa, In
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
diff --git a/test/jdk/jdk/incubator/vector/Float128VectorTests.java b/test/jdk/jdk/incubator/vector/Float128VectorTests.java
index e1da9f165bd..b85697cf753 100644
--- a/test/jdk/jdk/incubator/vector/Float128VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Float128VectorTests.java
@@ -4900,7 +4900,7 @@ static void ADDReduceLongFloat128VectorTests(IntFunction<float[]> fa) {
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
@@ -4941,7 +4941,7 @@ static void ADDReduceLongFloat128VectorTestsMasked(IntFunction<float[]> fa, IntF
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
diff --git a/test/jdk/jdk/incubator/vector/Float256VectorTests.java b/test/jdk/jdk/incubator/vector/Float256VectorTests.java
index 7a106ad15ae..578bfa47291 100644
--- a/test/jdk/jdk/incubator/vector/Float256VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Float256VectorTests.java
@@ -4900,7 +4900,7 @@ static void ADDReduceLongFloat256VectorTests(IntFunction<float[]> fa) {
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
@@ -4941,7 +4941,7 @@ static void ADDReduceLongFloat256VectorTestsMasked(IntFunction<float[]> fa, IntF
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
diff --git a/test/jdk/jdk/incubator/vector/Float512VectorTests.java b/test/jdk/jdk/incubator/vector/Float512VectorTests.java
index 37868d62a5e..a759f756cd3 100644
--- a/test/jdk/jdk/incubator/vector/Float512VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Float512VectorTests.java
@@ -4900,7 +4900,7 @@ static void ADDReduceLongFloat512VectorTests(IntFunction<float[]> fa) {
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
@@ -4941,7 +4941,7 @@ static void ADDReduceLongFloat512VectorTestsMasked(IntFunction<float[]> fa, IntF
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
diff --git a/test/jdk/jdk/incubator/vector/Float64VectorTests.java b/test/jdk/jdk/incubator/vector/Float64VectorTests.java
index 02af9064ce2..d47e9bd8d4a 100644
--- a/test/jdk/jdk/incubator/vector/Float64VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Float64VectorTests.java
@@ -4900,7 +4900,7 @@ static void ADDReduceLongFloat64VectorTests(IntFunction<float[]> fa) {
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
@@ -4941,7 +4941,7 @@ static void ADDReduceLongFloat64VectorTestsMasked(IntFunction<float[]> fa, IntFu
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
diff --git a/test/jdk/jdk/incubator/vector/FloatMaxVectorTests.java b/test/jdk/jdk/incubator/vector/FloatMaxVectorTests.java
index bc8717514c7..a5a17acc949 100644
--- a/test/jdk/jdk/incubator/vector/FloatMaxVectorTests.java
+++ b/test/jdk/jdk/incubator/vector/FloatMaxVectorTests.java
@@ -4905,7 +4905,7 @@ static void ADDReduceLongFloatMaxVectorTests(IntFunction<float[]> fa) {
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
@@ -4946,7 +4946,7 @@ static void ADDReduceLongFloatMaxVectorTestsMasked(IntFunction<float[]> fa, IntF
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
diff --git a/test/jdk/jdk/incubator/vector/Halffloat128VectorTests.java b/test/jdk/jdk/incubator/vector/Halffloat128VectorTests.java
index 6f8973a9b60..8b5a7158cdb 100644
--- a/test/jdk/jdk/incubator/vector/Halffloat128VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Halffloat128VectorTests.java
@@ -332,7 +332,7 @@ static void assertSelectFromTwoVectorEquals(short[] r, short[] order, short[] a,
             for (; i < a.length; i += vector_len) {
                 for (j = 0; j < vector_len; j++) {
                     idx = i + j;
-                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);
+                    wrapped_index = Math.floorMod(Float16.shortBitsToFloat16(order[idx]).intValue(), 2 * vector_len);
                     is_exceptional_idx = wrapped_index >= vector_len;
                     oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;
                     Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));
@@ -2707,7 +2707,7 @@ static long ADDReduceLong(short[] a, int idx) {
     static long ADDReduceAllLong(short[] a) {
         long res = 0;
         for (int i = 0; i < a.length; i += SPECIES.length()) {
-            res += ADDReduceLong(a, i);
+            res = Float.floatToFloat16(Float.float16ToFloat((short)res) + Float.float16ToFloat((short)ADDReduceLong(a, i)));
         }
 
         return res;
@@ -2725,8 +2725,8 @@ static void ADDReduceLongHalffloat128VectorTests(IntFunction<short[]> fa) {
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
-            ra += r[i];
+        for (int i = 0; i < a.length; i++) {
+            ra = (long)(Float16.float16ToRawShortBits(Float16.add(Float16.shortBitsToFloat16((short)ra), Float16.shortBitsToFloat16((short)r[i]))));
         }
 
         assertReductionLongArraysEquals(r, ra, a,
@@ -2746,7 +2746,7 @@ static long ADDReduceLongMasked(short[] a, int idx, boolean[] mask) {
     static long ADDReduceAllLongMasked(short[] a, boolean[] mask) {
         long res = 0;
         for (int i = 0; i < a.length; i += SPECIES.length()) {
-            res += ADDReduceLongMasked(a, i, mask);
+            res = Float.floatToFloat16(Float.float16ToFloat((short)res) + Float.float16ToFloat((short)ADDReduceLongMasked(a, i, mask)));
         }
 
         return res;
@@ -2766,8 +2766,8 @@ static void ADDReduceLongHalffloat128VectorTestsMasked(IntFunction<short[]> fa,
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
-            ra += r[i];
+        for (int i = 0; i < a.length; i++) {
+            ra = (long)(Float16.float16ToRawShortBits(Float16.add(Float16.shortBitsToFloat16((short)ra), Float16.shortBitsToFloat16((short)r[i]))));
         }
 
         assertReductionLongArraysEqualsMasked(r, ra, a, mask,
diff --git a/test/jdk/jdk/incubator/vector/Halffloat256VectorTests.java b/test/jdk/jdk/incubator/vector/Halffloat256VectorTests.java
index 8362c255167..5c8e853ac1b 100644
--- a/test/jdk/jdk/incubator/vector/Halffloat256VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Halffloat256VectorTests.java
@@ -332,7 +332,7 @@ static void assertSelectFromTwoVectorEquals(short[] r, short[] order, short[] a,
             for (; i < a.length; i += vector_len) {
                 for (j = 0; j < vector_len; j++) {
                     idx = i + j;
-                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);
+                    wrapped_index = Math.floorMod(Float16.shortBitsToFloat16(order[idx]).intValue(), 2 * vector_len);
                     is_exceptional_idx = wrapped_index >= vector_len;
                     oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;
                     Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));
@@ -2707,7 +2707,7 @@ static long ADDReduceLong(short[] a, int idx) {
     static long ADDReduceAllLong(short[] a) {
         long res = 0;
         for (int i = 0; i < a.length; i += SPECIES.length()) {
-            res += ADDReduceLong(a, i);
+            res = Float.floatToFloat16(Float.float16ToFloat((short)res) + Float.float16ToFloat((short)ADDReduceLong(a, i)));
         }
 
         return res;
@@ -2725,8 +2725,8 @@ static void ADDReduceLongHalffloat256VectorTests(IntFunction<short[]> fa) {
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
-            ra += r[i];
+        for (int i = 0; i < a.length; i++) {
+            ra = (long)(Float16.float16ToRawShortBits(Float16.add(Float16.shortBitsToFloat16((short)ra), Float16.shortBitsToFloat16((short)r[i]))));
         }
 
         assertReductionLongArraysEquals(r, ra, a,
@@ -2746,7 +2746,7 @@ static long ADDReduceLongMasked(short[] a, int idx, boolean[] mask) {
     static long ADDReduceAllLongMasked(short[] a, boolean[] mask) {
         long res = 0;
         for (int i = 0; i < a.length; i += SPECIES.length()) {
-            res += ADDReduceLongMasked(a, i, mask);
+            res = Float.floatToFloat16(Float.float16ToFloat((short)res) + Float.float16ToFloat((short)ADDReduceLongMasked(a, i, mask)));
         }
 
         return res;
@@ -2766,8 +2766,8 @@ static void ADDReduceLongHalffloat256VectorTestsMasked(IntFunction<short[]> fa,
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
-            ra += r[i];
+        for (int i = 0; i < a.length; i++) {
+            ra = (long)(Float16.float16ToRawShortBits(Float16.add(Float16.shortBitsToFloat16((short)ra), Float16.shortBitsToFloat16((short)r[i]))));
         }
 
         assertReductionLongArraysEqualsMasked(r, ra, a, mask,
diff --git a/test/jdk/jdk/incubator/vector/Halffloat512VectorTests.java b/test/jdk/jdk/incubator/vector/Halffloat512VectorTests.java
index e4d2085bd4c..5916ba3e9c9 100644
--- a/test/jdk/jdk/incubator/vector/Halffloat512VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Halffloat512VectorTests.java
@@ -332,7 +332,7 @@ static void assertSelectFromTwoVectorEquals(short[] r, short[] order, short[] a,
             for (; i < a.length; i += vector_len) {
                 for (j = 0; j < vector_len; j++) {
                     idx = i + j;
-                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);
+                    wrapped_index = Math.floorMod(Float16.shortBitsToFloat16(order[idx]).intValue(), 2 * vector_len);
                     is_exceptional_idx = wrapped_index >= vector_len;
                     oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;
                     Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));
@@ -2707,7 +2707,7 @@ static long ADDReduceLong(short[] a, int idx) {
     static long ADDReduceAllLong(short[] a) {
         long res = 0;
         for (int i = 0; i < a.length; i += SPECIES.length()) {
-            res += ADDReduceLong(a, i);
+            res = Float.floatToFloat16(Float.float16ToFloat((short)res) + Float.float16ToFloat((short)ADDReduceLong(a, i)));
         }
 
         return res;
@@ -2725,8 +2725,8 @@ static void ADDReduceLongHalffloat512VectorTests(IntFunction<short[]> fa) {
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
-            ra += r[i];
+        for (int i = 0; i < a.length; i++) {
+            ra = (long)(Float16.float16ToRawShortBits(Float16.add(Float16.shortBitsToFloat16((short)ra), Float16.shortBitsToFloat16((short)r[i]))));
         }
 
         assertReductionLongArraysEquals(r, ra, a,
@@ -2746,7 +2746,7 @@ static long ADDReduceLongMasked(short[] a, int idx, boolean[] mask) {
     static long ADDReduceAllLongMasked(short[] a, boolean[] mask) {
         long res = 0;
         for (int i = 0; i < a.length; i += SPECIES.length()) {
-            res += ADDReduceLongMasked(a, i, mask);
+            res = Float.floatToFloat16(Float.float16ToFloat((short)res) + Float.float16ToFloat((short)ADDReduceLongMasked(a, i, mask)));
         }
 
         return res;
@@ -2766,8 +2766,8 @@ static void ADDReduceLongHalffloat512VectorTestsMasked(IntFunction<short[]> fa,
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
-            ra += r[i];
+        for (int i = 0; i < a.length; i++) {
+            ra = (long)(Float16.float16ToRawShortBits(Float16.add(Float16.shortBitsToFloat16((short)ra), Float16.shortBitsToFloat16((short)r[i]))));
         }
 
         assertReductionLongArraysEqualsMasked(r, ra, a, mask,
diff --git a/test/jdk/jdk/incubator/vector/Halffloat64VectorTests.java b/test/jdk/jdk/incubator/vector/Halffloat64VectorTests.java
index c1c61e6a547..87e6311030d 100644
--- a/test/jdk/jdk/incubator/vector/Halffloat64VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Halffloat64VectorTests.java
@@ -332,7 +332,7 @@ static void assertSelectFromTwoVectorEquals(short[] r, short[] order, short[] a,
             for (; i < a.length; i += vector_len) {
                 for (j = 0; j < vector_len; j++) {
                     idx = i + j;
-                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);
+                    wrapped_index = Math.floorMod(Float16.shortBitsToFloat16(order[idx]).intValue(), 2 * vector_len);
                     is_exceptional_idx = wrapped_index >= vector_len;
                     oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;
                     Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));
@@ -2707,7 +2707,7 @@ static long ADDReduceLong(short[] a, int idx) {
     static long ADDReduceAllLong(short[] a) {
         long res = 0;
         for (int i = 0; i < a.length; i += SPECIES.length()) {
-            res += ADDReduceLong(a, i);
+            res = Float.floatToFloat16(Float.float16ToFloat((short)res) + Float.float16ToFloat((short)ADDReduceLong(a, i)));
         }
 
         return res;
@@ -2725,8 +2725,8 @@ static void ADDReduceLongHalffloat64VectorTests(IntFunction<short[]> fa) {
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
-            ra += r[i];
+        for (int i = 0; i < a.length; i++) {
+            ra = (long)(Float16.float16ToRawShortBits(Float16.add(Float16.shortBitsToFloat16((short)ra), Float16.shortBitsToFloat16((short)r[i]))));
         }
 
         assertReductionLongArraysEquals(r, ra, a,
@@ -2746,7 +2746,7 @@ static long ADDReduceLongMasked(short[] a, int idx, boolean[] mask) {
     static long ADDReduceAllLongMasked(short[] a, boolean[] mask) {
         long res = 0;
         for (int i = 0; i < a.length; i += SPECIES.length()) {
-            res += ADDReduceLongMasked(a, i, mask);
+            res = Float.floatToFloat16(Float.float16ToFloat((short)res) + Float.float16ToFloat((short)ADDReduceLongMasked(a, i, mask)));
         }
 
         return res;
@@ -2766,8 +2766,8 @@ static void ADDReduceLongHalffloat64VectorTestsMasked(IntFunction<short[]> fa, I
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
-            ra += r[i];
+        for (int i = 0; i < a.length; i++) {
+            ra = (long)(Float16.float16ToRawShortBits(Float16.add(Float16.shortBitsToFloat16((short)ra), Float16.shortBitsToFloat16((short)r[i]))));
         }
 
         assertReductionLongArraysEqualsMasked(r, ra, a, mask,
diff --git a/test/jdk/jdk/incubator/vector/HalffloatMaxVectorTests.java b/test/jdk/jdk/incubator/vector/HalffloatMaxVectorTests.java
index 93bb17c937d..0060ceaf433 100644
--- a/test/jdk/jdk/incubator/vector/HalffloatMaxVectorTests.java
+++ b/test/jdk/jdk/incubator/vector/HalffloatMaxVectorTests.java
@@ -337,7 +337,7 @@ static void assertSelectFromTwoVectorEquals(short[] r, short[] order, short[] a,
             for (; i < a.length; i += vector_len) {
                 for (j = 0; j < vector_len; j++) {
                     idx = i + j;
-                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);
+                    wrapped_index = Math.floorMod(Float16.shortBitsToFloat16(order[idx]).intValue(), 2 * vector_len);
                     is_exceptional_idx = wrapped_index >= vector_len;
                     oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;
                     Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));
@@ -2712,7 +2712,7 @@ static long ADDReduceLong(short[] a, int idx) {
     static long ADDReduceAllLong(short[] a) {
         long res = 0;
         for (int i = 0; i < a.length; i += SPECIES.length()) {
-            res += ADDReduceLong(a, i);
+            res = Float.floatToFloat16(Float.float16ToFloat((short)res) + Float.float16ToFloat((short)ADDReduceLong(a, i)));
         }
 
         return res;
@@ -2730,8 +2730,8 @@ static void ADDReduceLongHalffloatMaxVectorTests(IntFunction<short[]> fa) {
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
-            ra += r[i];
+        for (int i = 0; i < a.length; i++) {
+            ra = (long)(Float16.float16ToRawShortBits(Float16.add(Float16.shortBitsToFloat16((short)ra), Float16.shortBitsToFloat16((short)r[i]))));
         }
 
         assertReductionLongArraysEquals(r, ra, a,
@@ -2751,7 +2751,7 @@ static long ADDReduceLongMasked(short[] a, int idx, boolean[] mask) {
     static long ADDReduceAllLongMasked(short[] a, boolean[] mask) {
         long res = 0;
         for (int i = 0; i < a.length; i += SPECIES.length()) {
-            res += ADDReduceLongMasked(a, i, mask);
+            res = Float.floatToFloat16(Float.float16ToFloat((short)res) + Float.float16ToFloat((short)ADDReduceLongMasked(a, i, mask)));
         }
 
         return res;
@@ -2771,8 +2771,8 @@ static void ADDReduceLongHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa,
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
-            ra += r[i];
+        for (int i = 0; i < a.length; i++) {
+            ra = (long)(Float16.float16ToRawShortBits(Float16.add(Float16.shortBitsToFloat16((short)ra), Float16.shortBitsToFloat16((short)r[i]))));
         }
 
         assertReductionLongArraysEqualsMasked(r, ra, a, mask,
diff --git a/test/jdk/jdk/incubator/vector/Int128VectorTests.java b/test/jdk/jdk/incubator/vector/Int128VectorTests.java
index d1dc1350090..2dff3ee250e 100644
--- a/test/jdk/jdk/incubator/vector/Int128VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Int128VectorTests.java
@@ -6555,7 +6555,7 @@ static void ADDReduceLongInt128VectorTests(IntFunction<int[]> fa) {
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
@@ -6596,7 +6596,7 @@ static void ADDReduceLongInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunct
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
diff --git a/test/jdk/jdk/incubator/vector/Int256VectorTests.java b/test/jdk/jdk/incubator/vector/Int256VectorTests.java
index 431afebb935..606e5504dee 100644
--- a/test/jdk/jdk/incubator/vector/Int256VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Int256VectorTests.java
@@ -6555,7 +6555,7 @@ static void ADDReduceLongInt256VectorTests(IntFunction<int[]> fa) {
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
@@ -6596,7 +6596,7 @@ static void ADDReduceLongInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunct
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
diff --git a/test/jdk/jdk/incubator/vector/Int512VectorTests.java b/test/jdk/jdk/incubator/vector/Int512VectorTests.java
index dac76b84510..5f67c3a4f72 100644
--- a/test/jdk/jdk/incubator/vector/Int512VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Int512VectorTests.java
@@ -6555,7 +6555,7 @@ static void ADDReduceLongInt512VectorTests(IntFunction<int[]> fa) {
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
@@ -6596,7 +6596,7 @@ static void ADDReduceLongInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunct
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
diff --git a/test/jdk/jdk/incubator/vector/Int64VectorTests.java b/test/jdk/jdk/incubator/vector/Int64VectorTests.java
index 3f3e926142b..c872efcecd5 100644
--- a/test/jdk/jdk/incubator/vector/Int64VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Int64VectorTests.java
@@ -6555,7 +6555,7 @@ static void ADDReduceLongInt64VectorTests(IntFunction<int[]> fa) {
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
@@ -6596,7 +6596,7 @@ static void ADDReduceLongInt64VectorTestsMasked(IntFunction<int[]> fa, IntFuncti
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
diff --git a/test/jdk/jdk/incubator/vector/IntMaxVectorTests.java b/test/jdk/jdk/incubator/vector/IntMaxVectorTests.java
index 84d0d3c2fdb..6b6f9576ad9 100644
--- a/test/jdk/jdk/incubator/vector/IntMaxVectorTests.java
+++ b/test/jdk/jdk/incubator/vector/IntMaxVectorTests.java
@@ -6560,7 +6560,7 @@ static void ADDReduceLongIntMaxVectorTests(IntFunction<int[]> fa) {
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
@@ -6601,7 +6601,7 @@ static void ADDReduceLongIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunct
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
diff --git a/test/jdk/jdk/incubator/vector/Short128VectorTests.java b/test/jdk/jdk/incubator/vector/Short128VectorTests.java
index dc43fde806c..6ea7358d057 100644
--- a/test/jdk/jdk/incubator/vector/Short128VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Short128VectorTests.java
@@ -6507,7 +6507,7 @@ static void ADDReduceLongShort128VectorTests(IntFunction<short[]> fa) {
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
@@ -6548,7 +6548,7 @@ static void ADDReduceLongShort128VectorTestsMasked(IntFunction<short[]> fa, IntF
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
diff --git a/test/jdk/jdk/incubator/vector/Short256VectorTests.java b/test/jdk/jdk/incubator/vector/Short256VectorTests.java
index 091a99236a8..2b8080aac70 100644
--- a/test/jdk/jdk/incubator/vector/Short256VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Short256VectorTests.java
@@ -6507,7 +6507,7 @@ static void ADDReduceLongShort256VectorTests(IntFunction<short[]> fa) {
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
@@ -6548,7 +6548,7 @@ static void ADDReduceLongShort256VectorTestsMasked(IntFunction<short[]> fa, IntF
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
diff --git a/test/jdk/jdk/incubator/vector/Short512VectorTests.java b/test/jdk/jdk/incubator/vector/Short512VectorTests.java
index 5cbae8a5759..f333a4c9edd 100644
--- a/test/jdk/jdk/incubator/vector/Short512VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Short512VectorTests.java
@@ -6507,7 +6507,7 @@ static void ADDReduceLongShort512VectorTests(IntFunction<short[]> fa) {
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
@@ -6548,7 +6548,7 @@ static void ADDReduceLongShort512VectorTestsMasked(IntFunction<short[]> fa, IntF
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
diff --git a/test/jdk/jdk/incubator/vector/Short64VectorTests.java b/test/jdk/jdk/incubator/vector/Short64VectorTests.java
index 9cca2a65ab8..353bef63d1b 100644
--- a/test/jdk/jdk/incubator/vector/Short64VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Short64VectorTests.java
@@ -6507,7 +6507,7 @@ static void ADDReduceLongShort64VectorTests(IntFunction<short[]> fa) {
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
@@ -6548,7 +6548,7 @@ static void ADDReduceLongShort64VectorTestsMasked(IntFunction<short[]> fa, IntFu
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
diff --git a/test/jdk/jdk/incubator/vector/ShortMaxVectorTests.java b/test/jdk/jdk/incubator/vector/ShortMaxVectorTests.java
index 978e3a51a1b..67dac0c15a1 100644
--- a/test/jdk/jdk/incubator/vector/ShortMaxVectorTests.java
+++ b/test/jdk/jdk/incubator/vector/ShortMaxVectorTests.java
@@ -6512,7 +6512,7 @@ static void ADDReduceLongShortMaxVectorTests(IntFunction<short[]> fa) {
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
@@ -6553,7 +6553,7 @@ static void ADDReduceLongShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntF
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
             ra += r[i];
         }
 
diff --git a/test/jdk/jdk/incubator/vector/templates/Unit-Miscellaneous.template b/test/jdk/jdk/incubator/vector/templates/Unit-Miscellaneous.template
index 569e02f7d3f..a4c8f734e52 100644
--- a/test/jdk/jdk/incubator/vector/templates/Unit-Miscellaneous.template
+++ b/test/jdk/jdk/incubator/vector/templates/Unit-Miscellaneous.template
@@ -144,7 +144,11 @@
     static long ADDReduceAllLong($type$[] a) {
         long res = 0;
         for (int i = 0; i < a.length; i += SPECIES.length()) {
+#if[Halffloat]
+            res = Float.floatToFloat16(Float.float16ToFloat((short)res) + Float.float16ToFloat((short)ADDReduceLong(a, i)));
+#else[Halffloat]
             res += ADDReduceLong(a, i);
+#end[Halffloat]
         }
 
         return res;
@@ -162,8 +166,12 @@
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
+#if[Halffloat]
+            ra = (long)(Float16.float16ToRawShortBits(Float16.add(Float16.shortBitsToFloat16((short)ra), Float16.shortBitsToFloat16((short)r[i]))));
+#else[Halffloat]
             ra += r[i];
+#end[Halffloat]
         }
 
         assertReductionLongArraysEquals(r, ra, a,
@@ -187,7 +195,11 @@
     static long ADDReduceAllLongMasked($type$[] a, boolean[] mask) {
         long res = 0;
         for (int i = 0; i < a.length; i += SPECIES.length()) {
+#if[Halffloat]
+            res = Float.floatToFloat16(Float.float16ToFloat((short)res) + Float.float16ToFloat((short)ADDReduceLongMasked(a, i, mask)));
+#else[Halffloat]
             res += ADDReduceLongMasked(a, i, mask);
+#end[Halffloat]
         }
 
         return res;
@@ -207,8 +219,12 @@
         }
 
         ra = 0;
-        for (int i = 0; i < a.length; i ++) {
+        for (int i = 0; i < a.length; i++) {
+#if[Halffloat]
+            ra = (long)(Float16.float16ToRawShortBits(Float16.add(Float16.shortBitsToFloat16((short)ra), Float16.shortBitsToFloat16((short)r[i]))));
+#else[Halffloat]
             ra += r[i];
+#end[Halffloat]
         }
 
         assertReductionLongArraysEqualsMasked(r, ra, a, mask,
diff --git a/test/jdk/jdk/incubator/vector/templates/Unit-header.template b/test/jdk/jdk/incubator/vector/templates/Unit-header.template
index 65902a0af85..a6c118bf8ed 100644
--- a/test/jdk/jdk/incubator/vector/templates/Unit-header.template
+++ b/test/jdk/jdk/incubator/vector/templates/Unit-header.template
@@ -414,7 +414,7 @@ relativeError));
             for (; i < a.length; i += vector_len) {
                 for (j = 0; j < vector_len; j++) {
                     idx = i + j;
-                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);
+                    wrapped_index = Math.floorMod({#if[FP16]?Float16.shortBitsToFloat16(order[idx]).intValue():(int)order[idx]}, 2 * vector_len);
                     is_exceptional_idx = wrapped_index >= vector_len;
                     oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;
                     Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));
