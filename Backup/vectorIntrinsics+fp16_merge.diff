commit 29cb3f84c205e1e649d3513ba2b42e6e6a59fe0e
Merge: 1317dcdf615 c794a0ac84d
Author: Jatin Bhateja <jatin.bhateja@gmail.com>
Date:   Wed Aug 20 19:38:46 2025 +0530

    Merge branch 'vectorIntrinsics' of http://github.com/openjdk/panama-vector into vectorIntrinsics+fp16

diff --cc src/hotspot/cpu/aarch64/aarch64_vector.ad
index 0b85963087f,58300992c2a..27447719436
--- a/src/hotspot/cpu/aarch64/aarch64_vector.ad
+++ b/src/hotspot/cpu/aarch64/aarch64_vector.ad
@@@ -2337,12 -2635,12 +2740,13 @@@ instruct vfmla(vReg dst_src1, vReg src2
  // dst_src1 = dst_src1 * src2 + src3
  
  instruct vfmad_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{
-   predicate(UseFMA && UseSVE > 0);
+   predicate(UseSVE > 0);
 +  match(Set dst_src1 (FmaVHF (Binary dst_src1 src2) (Binary src3 pg)));
-   match(Set dst_src1 (FmaVF  (Binary dst_src1 src2) (Binary src3 pg)));
-   match(Set dst_src1 (FmaVD  (Binary dst_src1 src2) (Binary src3 pg)));
+   match(Set dst_src1 (FmaVF (Binary dst_src1 src2) (Binary src3 pg)));
+   match(Set dst_src1 (FmaVD (Binary dst_src1 src2) (Binary src3 pg)));
    format %{ "vfmad_masked $dst_src1, $pg, $src2, $src3" %}
    ins_encode %{
+     assert(UseFMA, "Needs FMA instructions support.");
      BasicType bt = Matcher::vector_element_basic_type(this);
      __ sve_fmad($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),
                  $pg$$PRegister, $src2$$FloatRegister, $src3$$FloatRegister);
@@@ -3067,54 -3337,15 +3443,54 @@@ instruct reduce_addL_sve(iRegLNoSp dst
    ins_pipe(pipe_slow);
  %}
  
 +// reduction addHF
 +instruct reduce_addHF_neon(iRegINoSp dst, iRegIorL2I hfsrc, vReg vsrc, vReg tmp1, vRegF tmp2) %{
 +  predicate(UseSVE == 0);
 +  match(Set dst (AddReductionVHF hfsrc vsrc));
 +  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);
 +  format %{ "reduce_addHF_neon $dst, $hfsrc, $vsrc\t# KILL $tmp1, $tmp2" %}
 +  ins_encode %{
 +    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);
 +    assert(length_in_bytes == 8 || length_in_bytes == 16, "invalid vector length");
 +
 +    __ fmovwh($tmp2$$FloatRegister, $hfsrc$$Register);
 +    if (length_in_bytes == 8) {
 +      __ faddp($tmp1$$FloatRegister, __ T4H, $vsrc$$FloatRegister, $vsrc$$FloatRegister);
 +    } else {
 +      __ faddp($tmp1$$FloatRegister, __ T8H, $vsrc$$FloatRegister, $vsrc$$FloatRegister);
 +      __ faddp($tmp1$$FloatRegister, __ T4H, $tmp1$$FloatRegister, $tmp1$$FloatRegister);
 +    }
 +    __ faddp($tmp1$$FloatRegister, $tmp1$$FloatRegister, __ H);
 +    __ faddh($tmp2$$FloatRegister, $tmp2$$FloatRegister, $tmp1$$FloatRegister);
 +    __ fmovhw($dst$$Register, $tmp2$$FloatRegister);
 +  %}
 +  ins_pipe(pipe_slow);
 +%}
 +
 +instruct reduce_addHF_sve(iRegINoSp dst, iRegIorL2I hfsrc, vReg vsrc, vRegF tmp) %{
 +  predicate(UseSVE > 0);
 +  match(Set dst (AddReductionVHF hfsrc vsrc));
 +  effect(TEMP tmp);
 +  format %{ "reduce_addHF_sve $dst, $hfsrc, $vsrc\t# KILL $tmp" %}
 +  ins_encode %{
 +    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);
 +    assert(length_in_bytes == MaxVectorSize, "invalid vector length");
 +    __ fmovwh($tmp$$FloatRegister, $hfsrc$$Register);
 +    __ sve_fadda($tmp$$FloatRegister, __ H, ptrue, $vsrc$$FloatRegister);
 +    __ fmovhw($dst$$Register, $tmp$$FloatRegister);
 +  %}
 +  ins_pipe(pipe_slow);
 +%};
 +
  // reduction addF
- // Floating-point addition is not associative, so the rules for AddReductionVF
- // on NEON can't be used to auto-vectorize floating-point reduce-add.
- // Currently, on NEON, AddReductionVF is only generated by Vector API.
- instruct reduce_add2F_neon(vRegF dst, vRegF fsrc, vReg vsrc) %{
-   predicate(UseSVE == 0 && Matcher::vector_length(n->in(2)) == 2);
+ 
+ instruct reduce_non_strict_order_add2F_neon(vRegF dst, vRegF fsrc, vReg vsrc) %{
+   // Non-strictly ordered floating-point add reduction for a 64-bits-long vector. This rule is
+   // intended for the VectorAPI (which allows for non-strictly ordered add reduction).
+   predicate(Matcher::vector_length(n->in(2)) == 2 && !n->as_Reduction()->requires_strict_order());
    match(Set dst (AddReductionVF fsrc vsrc));
    effect(TEMP_DEF dst);
-   format %{ "reduce_add2F_neon $dst, $fsrc, $vsrc" %}
+   format %{ "reduce_non_strict_order_add2F_neon $dst, $fsrc, $vsrc" %}
    ins_encode %{
      __ faddp($dst$$FloatRegister, $vsrc$$FloatRegister, __ S);
      __ fadds($dst$$FloatRegister, $dst$$FloatRegister, $fsrc$$FloatRegister);
diff --cc src/hotspot/cpu/aarch64/aarch64_vector_ad.m4
index 425698619d2,4d91e04dc21..59d04c59ae1
--- a/src/hotspot/cpu/aarch64/aarch64_vector_ad.m4
+++ b/src/hotspot/cpu/aarch64/aarch64_vector_ad.m4
@@@ -641,16 -701,30 +719,31 @@@ BINARY_OP_NEON_SVE_PAIRWISE(vdivF,  Div
  BINARY_OP_NEON_SVE_PAIRWISE(vdivD,  DivVD,  fdiv, sve_fdiv, D)
  
  // vector float div - predicated
 -BINARY_OP_PREDICATE(vdivF, DivVF, sve_fdiv, S)
 -BINARY_OP_PREDICATE(vdivD, DivVD, sve_fdiv, D)
 +BINARY_OP_PREDICATE(vdivHF, DivVHF, sve_fdiv, H)
 +BINARY_OP_PREDICATE(vdivF,  DivVF,  sve_fdiv, S)
 +BINARY_OP_PREDICATE(vdivD,  DivVD,  sve_fdiv, D)
  dnl
- dnl BITWISE_OP($1,        $2,      $3,        $4      )
- dnl BITWISE_OP(rule_name, op_name, insn_neon, insn_sve)
- define(`BITWISE_OP', `
- instruct $1(vReg dst, vReg src1, vReg src2) %{
+ dnl BITWISE_OP_IMM($1,        $2,   $3,      $4,   $5,   $6        )
+ dnl BITWISE_OP_IMM(rule_name, type, op_name, insn, size, basic_type)
+ define(`BITWISE_OP_IMM', `
+ instruct $1(vReg dst_src, imm$2Log con) %{
+   predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n) == $6);
+   match(Set dst_src ($3 dst_src (Replicate con)));
+   format %{ "$1 $dst_src, $dst_src, $con" %}
+   ins_encode %{
+     __ $4($dst_src$$FloatRegister, __ $5, (uint64_t)($con$$constant));
+   %}
+   ins_pipe(pipe_slow);
+ %}')dnl
+ dnl
+ dnl BITWISE_OPS($1,        $2,      $3,        $4      )
+ dnl BITWISE_OPS(rule_name, op_name, insn_neon, insn_sve)
+ define(`BITWISE_OPS',
+ `// vector $1
+ 
+ instruct v$1(vReg dst, vReg src1, vReg src2) %{
    match(Set dst ($2 src1 src2));
-   format %{ "$1 $dst, $src1, $src2" %}
+   format %{ "v$1 $dst, $src1, $src2" %}
    ins_encode %{
      uint length_in_bytes = Matcher::vector_length_in_bytes(this);
      if (VM_Version::use_neon_for_vector(length_in_bytes)) {
@@@ -1231,12 -1402,12 +1425,13 @@@ instruct vfmla(vReg dst_src1, vReg src2
  // dst_src1 = dst_src1 * src2 + src3
  
  instruct vfmad_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{
-   predicate(UseFMA && UseSVE > 0);
+   predicate(UseSVE > 0);
 +  match(Set dst_src1 (FmaVHF (Binary dst_src1 src2) (Binary src3 pg)));
-   match(Set dst_src1 (FmaVF  (Binary dst_src1 src2) (Binary src3 pg)));
-   match(Set dst_src1 (FmaVD  (Binary dst_src1 src2) (Binary src3 pg)));
+   match(Set dst_src1 (FmaVF (Binary dst_src1 src2) (Binary src3 pg)));
+   match(Set dst_src1 (FmaVD (Binary dst_src1 src2) (Binary src3 pg)));
    format %{ "vfmad_masked $dst_src1, $pg, $src2, $src3" %}
    ins_encode %{
+     assert(UseFMA, "Needs FMA instructions support.");
      BasicType bt = Matcher::vector_element_basic_type(this);
      __ sve_fmad($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),
                  $pg$$PRegister, $src2$$FloatRegister, $src3$$FloatRegister);
@@@ -1851,54 -1994,15 +2018,54 @@@ REDUCE_ADD_INT_NEON_SVE_PAIRWISE(I, iRe
  // reduction addL
  REDUCE_ADD_INT_NEON_SVE_PAIRWISE(L, iRegL)
  
 +// reduction addHF
 +instruct reduce_addHF_neon(iRegINoSp dst, iRegIorL2I hfsrc, vReg vsrc, vReg tmp1, vRegF tmp2) %{
 +  predicate(UseSVE == 0);
 +  match(Set dst (AddReductionVHF hfsrc vsrc));
 +  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);
 +  format %{ "reduce_addHF_neon $dst, $hfsrc, $vsrc\t# KILL $tmp1, $tmp2" %}
 +  ins_encode %{
 +    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);
 +    assert(length_in_bytes == 8 || length_in_bytes == 16, "invalid vector length");
 +
 +    __ fmovwh($tmp2$$FloatRegister, $hfsrc$$Register);
 +    if (length_in_bytes == 8) {
 +      __ faddp($tmp1$$FloatRegister, __ T4H, $vsrc$$FloatRegister, $vsrc$$FloatRegister);
 +    } else {
 +      __ faddp($tmp1$$FloatRegister, __ T8H, $vsrc$$FloatRegister, $vsrc$$FloatRegister);
 +      __ faddp($tmp1$$FloatRegister, __ T4H, $tmp1$$FloatRegister, $tmp1$$FloatRegister);
 +    }
 +    __ faddp($tmp1$$FloatRegister, $tmp1$$FloatRegister, __ H);
 +    __ faddh($tmp2$$FloatRegister, $tmp2$$FloatRegister, $tmp1$$FloatRegister);
 +    __ fmovhw($dst$$Register, $tmp2$$FloatRegister);
 +  %}
 +  ins_pipe(pipe_slow);
 +%}
 +
 +instruct reduce_addHF_sve(iRegINoSp dst, iRegIorL2I hfsrc, vReg vsrc, vRegF tmp) %{
 +  predicate(UseSVE > 0);
 +  match(Set dst (AddReductionVHF hfsrc vsrc));
 +  effect(TEMP tmp);
 +  format %{ "reduce_addHF_sve $dst, $hfsrc, $vsrc\t# KILL $tmp" %}
 +  ins_encode %{
 +    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);
 +    assert(length_in_bytes == MaxVectorSize, "invalid vector length");
 +    __ fmovwh($tmp$$FloatRegister, $hfsrc$$Register);
 +    __ sve_fadda($tmp$$FloatRegister, __ H, ptrue, $vsrc$$FloatRegister);
 +    __ fmovhw($dst$$Register, $tmp$$FloatRegister);
 +  %}
 +  ins_pipe(pipe_slow);
 +%};
 +
  // reduction addF
- // Floating-point addition is not associative, so the rules for AddReductionVF
- // on NEON can't be used to auto-vectorize floating-point reduce-add.
- // Currently, on NEON, AddReductionVF is only generated by Vector API.
- instruct reduce_add2F_neon(vRegF dst, vRegF fsrc, vReg vsrc) %{
-   predicate(UseSVE == 0 && Matcher::vector_length(n->in(2)) == 2);
+ 
+ instruct reduce_non_strict_order_add2F_neon(vRegF dst, vRegF fsrc, vReg vsrc) %{
+   // Non-strictly ordered floating-point add reduction for a 64-bits-long vector. This rule is
+   // intended for the VectorAPI (which allows for non-strictly ordered add reduction).
+   predicate(Matcher::vector_length(n->in(2)) == 2 && !n->as_Reduction()->requires_strict_order());
    match(Set dst (AddReductionVF fsrc vsrc));
    effect(TEMP_DEF dst);
-   format %{ "reduce_add2F_neon $dst, $fsrc, $vsrc" %}
+   format %{ "reduce_non_strict_order_add2F_neon $dst, $fsrc, $vsrc" %}
    ins_encode %{
      __ faddp($dst$$FloatRegister, $vsrc$$FloatRegister, __ S);
      __ fadds($dst$$FloatRegister, $dst$$FloatRegister, $fsrc$$FloatRegister);
diff --cc src/hotspot/cpu/aarch64/assembler_aarch64.hpp
index bb6ba79cae8,11d302e9026..e1217e4a9f7
--- a/src/hotspot/cpu/aarch64/assembler_aarch64.hpp
+++ b/src/hotspot/cpu/aarch64/assembler_aarch64.hpp
@@@ -2050,47 -2065,69 +2065,78 @@@ public
  #undef INSN
  
    // Floating-point data-processing (2 source)
-   void data_processing(unsigned op31, unsigned type, unsigned opcode,
+   void data_processing(unsigned op31, unsigned type, unsigned opcode, unsigned op21,
                         FloatRegister Vd, FloatRegister Vn, FloatRegister Vm) {
      starti;
 +    int op21 = (opcode == 0b000101) ? 0b0 : 0b1;
      f(op31, 31, 29);
      f(0b11110, 28, 24);
      f(type, 23, 22), f(op21, 21), f(opcode, 15, 10);
      rf(Vm, 16), rf(Vn, 5), rf(Vd, 0);
    }
  
- #define INSN(NAME, op31, type, opcode)                  \
+ #define INSN(NAME, op31, type, opcode, op21)                            \
    void NAME(FloatRegister Vd, FloatRegister Vn, FloatRegister Vm) {     \
-     data_processing(op31, type, opcode, Vd, Vn, Vm);    \
-   }
- 
-   INSN(fabds,  0b011, 0b10, 0b110101);
-   INSN(fmuls,  0b000, 0b00, 0b000010);
-   INSN(fdivs,  0b000, 0b00, 0b000110);
-   INSN(fadds,  0b000, 0b00, 0b001010);
-   INSN(fsubs,  0b000, 0b00, 0b001110);
-   INSN(fmaxs,  0b000, 0b00, 0b010010);
-   INSN(fmins,  0b000, 0b00, 0b010110);
-   INSN(fnmuls, 0b000, 0b00, 0b100010);
- 
-   INSN(fabdd,  0b011, 0b11, 0b110101);
-   INSN(fmuld,  0b000, 0b01, 0b000010);
-   INSN(fdivd,  0b000, 0b01, 0b000110);
-   INSN(faddd,  0b000, 0b01, 0b001010);
-   INSN(fsubd,  0b000, 0b01, 0b001110);
-   INSN(fmaxd,  0b000, 0b01, 0b010010);
-   INSN(fmind,  0b000, 0b01, 0b010110);
-   INSN(fnmuld, 0b000, 0b01, 0b100010);
+     data_processing(op31, type, opcode, op21, Vd, Vn, Vm);              \
+   }
+ 
+   INSN(fmuls,  0b000, 0b00, 0b000010, 0b1);
+   INSN(fdivs,  0b000, 0b00, 0b000110, 0b1);
+   INSN(fadds,  0b000, 0b00, 0b001010, 0b1);
+   INSN(fsubs,  0b000, 0b00, 0b001110, 0b1);
+   INSN(fmaxs,  0b000, 0b00, 0b010010, 0b1);
+   INSN(fmins,  0b000, 0b00, 0b010110, 0b1);
+   INSN(fnmuls, 0b000, 0b00, 0b100010, 0b1);
+ 
+   INSN(fmuld,  0b000, 0b01, 0b000010, 0b1);
+   INSN(fdivd,  0b000, 0b01, 0b000110, 0b1);
+   INSN(faddd,  0b000, 0b01, 0b001010, 0b1);
+   INSN(fsubd,  0b000, 0b01, 0b001110, 0b1);
+   INSN(fmaxd,  0b000, 0b01, 0b010010, 0b1);
+   INSN(fmind,  0b000, 0b01, 0b010110, 0b1);
+   INSN(fnmuld, 0b000, 0b01, 0b100010, 0b1);
+ 
+   // Half-precision floating-point instructions
+   INSN(fmulh,  0b000, 0b11, 0b000010, 0b1);
+   INSN(fdivh,  0b000, 0b11, 0b000110, 0b1);
+   INSN(faddh,  0b000, 0b11, 0b001010, 0b1);
+   INSN(fsubh,  0b000, 0b11, 0b001110, 0b1);
+   INSN(fmaxh,  0b000, 0b11, 0b010010, 0b1);
+   INSN(fminh,  0b000, 0b11, 0b010110, 0b1);
+   INSN(fnmulh, 0b000, 0b11, 0b100010, 0b1);
+ #undef INSN
+ 
+ // Advanced SIMD scalar three same
+ #define INSN(NAME, U, size, opcode)                                                     \
+   void NAME(FloatRegister Vd, FloatRegister Vn, FloatRegister Vm) {                     \
+     starti;                                                                             \
+     f(0b01, 31, 30), f(U, 29), f(0b11110, 28, 24), f(size, 23, 22), f(1, 21);           \
+     rf(Vm, 16), f(opcode, 15, 11), f(1, 10), rf(Vn, 5), rf(Vd, 0);                      \
+   }
+ 
+   INSN(fabds, 0b1, 0b10, 0b11010); // Floating-point Absolute Difference (single-precision)
+   INSN(fabdd, 0b1, 0b11, 0b11010); // Floating-point Absolute Difference (double-precision)
+ 
+ #undef INSN
+ 
+ // Advanced SIMD scalar three same FP16
+ #define INSN(NAME, U, a, opcode)                                                       \
+   void NAME(FloatRegister Vd, FloatRegister Vn, FloatRegister Vm) {                    \
+     starti;                                                                            \
+     f(0b01, 31, 30), f(U, 29), f(0b11110, 28, 24), f(a, 23), f(0b10, 22, 21);          \
+     rf(Vm, 16), f(0b00, 15, 14), f(opcode, 13, 11), f(1, 10), rf(Vn, 5), rf(Vd, 0);    \
+   }
+ 
+   INSN(fabdh, 0b1, 0b1, 0b010); // Floating-point Absolute Difference (half-precision float)
  
 +  INSN(fabdh,  0b011, 0b11, 0b000101);
 +  INSN(fmulh,  0b000, 0b11, 0b000010);
 +  INSN(fdivh,  0b000, 0b11, 0b000110);
 +  INSN(faddh,  0b000, 0b11, 0b001010);
 +  INSN(fsubh,  0b000, 0b11, 0b001110);
 +  INSN(fmaxh,  0b000, 0b11, 0b010010);
 +  INSN(fminh,  0b000, 0b11, 0b010110);
 +  INSN(fnmulh, 0b000, 0b11, 0b100010);
  #undef INSN
  
     // Floating-point data-processing (3 source)
diff --cc src/hotspot/cpu/x86/assembler_x86.cpp
index 213b17263a9,d1b6897f287..96a8d884fb9
--- a/src/hotspot/cpu/x86/assembler_x86.cpp
+++ b/src/hotspot/cpu/x86/assembler_x86.cpp
@@@ -6745,22 -7634,7 +7698,8 @@@ void Assembler::vaddps(XMMRegister dst
    emit_operand(dst, src, 0);
  }
  
- void Assembler::evaddph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len) {
-   assert(VM_Version::supports_avx512_fp16() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), "");
-   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
-   attributes.set_is_evex_instruction();
-   attributes.set_embedded_opmask_register_specifier(mask);
-   attributes.reset_is_clear_context();
-   int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);
-   emit_int16(0x58, (0xC0 | encode));
- }
- 
- void Assembler::evaddph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
-   evaddph(dst, k0, nds, src, vector_len);
- }
 +
  void Assembler::subpd(XMMRegister dst, XMMRegister src) {
-   NOT_LP64(assert(VM_Version::supports_sse2(), ""));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);
@@@ -6810,22 -7683,7 +7748,8 @@@ void Assembler::vsubps(XMMRegister dst
    emit_operand(dst, src, 0);
  }
  
- void Assembler::evsubph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len) {
-   assert(VM_Version::supports_avx512_fp16() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), "");
-   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
-   attributes.set_is_evex_instruction();
-   attributes.set_embedded_opmask_register_specifier(mask);
-   attributes.reset_is_clear_context();
-   int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);
-   emit_int16(0x5C, (0xC0 | encode));
- }
- 
- void Assembler::evsubph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
-   evsubph(dst, k0, nds, src, vector_len);
- }
 +
  void Assembler::mulpd(XMMRegister dst, XMMRegister src) {
-   NOT_LP64(assert(VM_Version::supports_sse2(), ""));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);
@@@ -6886,53 -7742,6 +7808,40 @@@ void Assembler::vmulps(XMMRegister dst
    emit_operand(dst, src, 0);
  }
  
- void Assembler::evmulph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len) {
-   assert(VM_Version::supports_avx512_fp16() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), "");
-   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
-   attributes.set_is_evex_instruction();
-   attributes.set_embedded_opmask_register_specifier(mask);
-   attributes.reset_is_clear_context();
-   int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);
-   emit_int16(0x59, (0xC0 | encode));
- }
- 
- void Assembler::evmulph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
-   evmulph(dst, k0, nds, src, vector_len);
- }
 +
 +void Assembler::evfmadd231ph(XMMRegister dst, KRegister mask, XMMRegister src1, XMMRegister src2, int vector_len) {
 +  assert(VM_Version::supports_avx512_fp16() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), "");
 +  assert(VM_Version::supports_fma(), "");
 +  InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
 +  attributes.set_is_evex_instruction();
 +  attributes.set_embedded_opmask_register_specifier(mask);
 +  attributes.reset_is_clear_context();
 +  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP6, &attributes);
 +  emit_int16((unsigned char)0xB8, (0xC0 | encode));
 +}
 +
 +void Assembler::evfmadd231ph(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len) {
 +  evfmadd231ph(dst, k0, src1, src2, vector_len);
 +}
 +
 +void Assembler::evfmadd231ph(XMMRegister dst, KRegister mask, XMMRegister src1, Address src2, int vector_len) {
 +  assert(VM_Version::supports_avx512_fp16() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), "");
 +  assert(VM_Version::supports_fma(), "");
 +  InstructionMark im(this);
 +  InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
 +  attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
 +  attributes.set_is_evex_instruction();
 +  attributes.set_embedded_opmask_register_specifier(mask);
 +  attributes.reset_is_clear_context();
 +  vex_prefix(src2, src1->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP6, &attributes);
 +  emit_int8((unsigned char)0xB8);
 +  emit_operand(dst, src2, 0);
 +}
 +
 +void Assembler::evfmadd231ph(XMMRegister dst, XMMRegister src1, Address src2, int vector_len) {
 +  evfmadd231ph(dst, k0, src1, src2, vector_len);
 +}
 +
  void Assembler::vfmadd231pd(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len) {
    assert(VM_Version::supports_fma(), "");
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
@@@ -7018,20 -7825,6 +7925,7 @@@ void Assembler::vdivps(XMMRegister dst
    emit_operand(dst, src, 0);
  }
  
- void Assembler::evdivph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len) {
-   assert(VM_Version::supports_avx512_fp16() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), "");
-   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
-   attributes.set_is_evex_instruction();
-   attributes.set_embedded_opmask_register_specifier(mask);
-   attributes.reset_is_clear_context();
-   int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);
-   emit_int16(0x5E, (0xC0 | encode));
- }
- 
- void Assembler::evdivph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
-   evdivph(dst, k0, nds, src, vector_len);
- }
 +
  void Assembler::vroundpd(XMMRegister dst, XMMRegister src, int32_t rmode, int vector_len) {
    assert(VM_Version::supports_avx(), "");
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
@@@ -14146,3 -16443,280 +16544,304 @@@ void InstructionAttr::set_address_attri
      _input_size_in_bits = input_size_in_bits;
    }
  }
+ 
+ void Assembler::evpermi2b(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
+   assert(VM_Version::supports_avx512_vbmi() && (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl()), "");
+   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
+   attributes.set_is_evex_instruction();
+   int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);
+   emit_int16(0x75, (0xC0 | encode));
+ }
+ 
+ void Assembler::evpermi2w(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
+   assert(VM_Version::supports_avx512bw() && (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl()), "");
+   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
+   attributes.set_is_evex_instruction();
+   int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);
+   emit_int16(0x75, (0xC0 | encode));
+ }
+ 
+ void Assembler::evpermi2d(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
+   assert(VM_Version::supports_evex() && (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl()), "");
+   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
+   attributes.set_is_evex_instruction();
+   int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);
+   emit_int16(0x76, (0xC0 | encode));
+ }
+ 
+ void Assembler::evpermi2q(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
+   assert(VM_Version::supports_evex() && (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl()), "");
+   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
+   attributes.set_is_evex_instruction();
+   int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);
+   emit_int16(0x76, (0xC0 | encode));
+ }
+ 
+ void Assembler::evpermi2ps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
+   assert(VM_Version::supports_evex() && (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl()), "");
+   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
+   attributes.set_is_evex_instruction();
+   int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);
+   emit_int16(0x77, (0xC0 | encode));
+ }
+ 
+ void Assembler::evpermi2pd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
+   assert(VM_Version::supports_evex() && (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl()), "");
+   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
+   attributes.set_is_evex_instruction();
+   int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);
+   emit_int16(0x77, (0xC0 | encode));
+ }
+ 
+ void Assembler::evpermt2b(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
+   assert(VM_Version::supports_avx512_vbmi(), "");
+   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
+   attributes.set_is_evex_instruction();
+   int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);
+   emit_int16(0x7D, (0xC0 | encode));
+ }
+ 
+ void Assembler::evpermt2w(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
+   assert(vector_len <= AVX_256bit ? VM_Version::supports_avx512vlbw() : VM_Version::supports_avx512bw(), "");
+   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
+   attributes.set_is_evex_instruction();
+   int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);
+   emit_int16(0x7D, (0xC0 | encode));
+ }
+ 
+ void Assembler::evpermt2d(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
+   assert(VM_Version::supports_evex() && (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl()), "");
+   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
+   attributes.set_is_evex_instruction();
+   int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);
+   emit_int16(0x7E, (0xC0 | encode));
+ }
+ 
+ void Assembler::evpermt2q(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
+   assert(VM_Version::supports_evex() && (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl()), "");
+   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
+   attributes.set_is_evex_instruction();
+   int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);
+   emit_int16(0x7E, (0xC0 | encode));
+ }
+ 
 -void Assembler::evaddph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
++void Assembler::evaddph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len) {
+   assert(VM_Version::supports_avx512_fp16(), "requires AVX512-FP16");
+   assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), "");
 -  InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
++  InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
+   attributes.set_is_evex_instruction();
++  attributes.set_embedded_opmask_register_specifier(mask);
++  attributes.reset_is_clear_context();
+   int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);
+   emit_int16(0x58, (0xC0 | encode));
+ }
+ 
++void Assembler::evaddph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
++  evaddph(dst, k0, nds, src, vector_len);
++}
++
+ void Assembler::evaddph(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
+   assert(VM_Version::supports_avx512_fp16(), "requires AVX512-FP16");
+   assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), "");
+   InstructionMark im(this);
+   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
+   attributes.set_is_evex_instruction();
+   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_NObit);
+   vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);
+   emit_int8(0x58);
+   emit_operand(dst, src, 0);
+ }
+ 
 -void Assembler::evsubph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
++void Assembler::evsubph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len) {
+   assert(VM_Version::supports_avx512_fp16(), "requires AVX512-FP16");
+   assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), "");
 -  InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
++  InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
+   attributes.set_is_evex_instruction();
++  attributes.set_embedded_opmask_register_specifier(mask);
++  attributes.reset_is_clear_context();
+   int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);
+   emit_int16(0x5C, (0xC0 | encode));
+ }
+ 
++void Assembler::evsubph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
++  evsubph(dst, k0, nds, src, vector_len);
++}
++
+ void Assembler::evsubph(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
+   assert(VM_Version::supports_avx512_fp16(), "requires AVX512-FP16");
+   assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), "");
+   InstructionMark im(this);
+   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
+   attributes.set_is_evex_instruction();
+   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_NObit);
+   vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);
+   emit_int8(0x5C);
+   emit_operand(dst, src, 0);
+ }
+ 
 -void Assembler::evmulph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
 -  assert(VM_Version::supports_avx512_fp16(), "requires AVX512-FP16");
 -  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), "");
 -  InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
 -  attributes.set_is_evex_instruction();
 -  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);
 -  emit_int16(0x59, (0xC0 | encode));
 -}
 -
+ void Assembler::evmulph(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
+   assert(VM_Version::supports_avx512_fp16(), "requires AVX512-FP16");
+   assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), "");
+   InstructionMark im(this);
+   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
+   attributes.set_is_evex_instruction();
+   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_NObit);
+   vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);
+   emit_int8(0x59);
+   emit_operand(dst, src, 0);
+ }
+ 
++void Assembler::evmulph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len) {
++  assert(VM_Version::supports_avx512_fp16(), "requires AVX512-FP16");
++  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), "");
++  InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
++  attributes.set_is_evex_instruction();
++  attributes.set_embedded_opmask_register_specifier(mask);
++  attributes.reset_is_clear_context();
++  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);
++  emit_int16(0x59, (0xC0 | encode));
++}
++
++void Assembler::evmulph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
++  evmulph(dst, k0, nds, src, vector_len);
++}
++
+ void Assembler::evminph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
+   assert(VM_Version::supports_avx512_fp16(), "requires AVX512-FP16");
+   assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), "");
+   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
+   attributes.set_is_evex_instruction();
+   int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);
+   emit_int16(0x5D, (0xC0 | encode));
+ }
+ 
+ void Assembler::evminph(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
+   assert(VM_Version::supports_avx512_fp16(), "requires AVX512-FP16");
+   assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), "");
+   InstructionMark im(this);
+   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
+   attributes.set_is_evex_instruction();
+   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_NObit);
+   vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);
+   emit_int8(0x5D);
+   emit_operand(dst, src, 0);
+ }
+ 
+ void Assembler::evminmaxph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int imm8, int vector_len) {
+   assert(VM_Version::supports_avx10_2(), "");
+   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false,/* uses_vl */ true);
+   attributes.set_is_evex_instruction();
+   attributes.set_embedded_opmask_register_specifier(mask);
+   if (merge) {
+     attributes.reset_is_clear_context();
+   }
+   int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3A, &attributes);
+   emit_int24(0x52, (0xC0 | encode), imm8);
+ }
+ 
+ void Assembler::evminmaxph(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int imm8, int vector_len) {
+   assert(VM_Version::supports_avx10_2(), "");
+   InstructionMark im(this);
+   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
+   attributes.set_is_evex_instruction();
+   attributes.set_embedded_opmask_register_specifier(mask);
+   if (merge) {
+     attributes.reset_is_clear_context();
+   }
+   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_NObit);
+   vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3A, &attributes);
+   emit_int8(0x52);
+   emit_operand(dst, src, 0);
+   emit_int8(imm8);
+ }
+ 
+ void Assembler::evmaxph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
+   assert(VM_Version::supports_avx512_fp16(), "requires AVX512-FP16");
+   assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), "");
+   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
+   attributes.set_is_evex_instruction();
+   int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);
+   emit_int16(0x5F, (0xC0 | encode));
+ }
+ 
+ void Assembler::evmaxph(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
+   assert(VM_Version::supports_avx512_fp16(), "requires AVX512-FP16");
+   assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), "");
+   InstructionMark im(this);
+   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
+   attributes.set_is_evex_instruction();
+   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_NObit);
+   vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);
+   emit_int8(0x5F);
+   emit_operand(dst, src, 0);
+ }
+ 
 -void Assembler::evdivph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
++void Assembler::evdivph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len) {
+   assert(VM_Version::supports_avx512_fp16(), "requires AVX512-FP16");
+   assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), "");
 -  InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
++  InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
+   attributes.set_is_evex_instruction();
++  attributes.set_embedded_opmask_register_specifier(mask);
++  attributes.reset_is_clear_context();
+   int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);
+   emit_int16(0x5E, (0xC0 | encode));
+ }
+ 
++void Assembler::evdivph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
++  evdivph(dst, k0, nds, src, vector_len);
++}
++
+ void Assembler::evdivph(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
+   assert(VM_Version::supports_avx512_fp16(), "requires AVX512-FP16");
+   assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), "");
+   InstructionMark im(this);
+   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
+   attributes.set_is_evex_instruction();
+   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_NObit);
+   vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);
+   emit_int8(0x5E);
+   emit_operand(dst, src, 0);
+ }
+ 
+ void Assembler::evsqrtph(XMMRegister dst, XMMRegister src, int vector_len) {
+   assert(VM_Version::supports_avx512_fp16(), "");
+   assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), "");
+   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
+   attributes.set_is_evex_instruction();
+   int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);
+   emit_int16(0x51, (0xC0 | encode));
+ }
+ 
+ void Assembler::evsqrtph(XMMRegister dst, Address src, int vector_len) {
+   assert(VM_Version::supports_avx512_fp16(), "");
+   assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), "");
+   InstructionMark im(this);
+   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
+   attributes.set_is_evex_instruction();
+   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_NObit);
+   vex_prefix(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);
+   emit_int8(0x51);
+   emit_operand(dst, src, 0);
+ }
+ 
+ void Assembler::evfmadd132ph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
+   assert(VM_Version::supports_avx512_fp16(), "");
+   assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), "");
+   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
+   attributes.set_is_evex_instruction();
+   int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP6, &attributes);
+   emit_int16(0x98, (0xC0 | encode));
+ }
+ 
+ void Assembler::evfmadd132ph(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
+   assert(VM_Version::supports_avx512_fp16(), "");
+   assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), "");
+   InstructionMark im(this);
+   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
+   attributes.set_is_evex_instruction();
+   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_NObit);
+   vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP6, &attributes);
+   emit_int8(0x98);
+   emit_operand(dst, src, 0);
+ }
+ 
diff --cc src/hotspot/cpu/x86/assembler_x86.hpp
index c7aa04eada3,45c24f8c832..8c77c7cf424
--- a/src/hotspot/cpu/x86/assembler_x86.hpp
+++ b/src/hotspot/cpu/x86/assembler_x86.hpp
@@@ -2260,9 -2365,9 +2375,10 @@@ private
    void vaddsd(XMMRegister dst, XMMRegister nds, XMMRegister src);
    void vaddss(XMMRegister dst, XMMRegister nds, Address src);
    void vaddss(XMMRegister dst, XMMRegister nds, XMMRegister src);
 +  void evaddsh(XMMRegister dst, XMMRegister nds, XMMRegister src);
    void vdivsd(XMMRegister dst, XMMRegister nds, Address src);
    void vdivsd(XMMRegister dst, XMMRegister nds, XMMRegister src);
+   void evdivsd(XMMRegister dst, XMMRegister nds, XMMRegister src, EvexRoundPrefix rmode);
    void vdivss(XMMRegister dst, XMMRegister nds, Address src);
    void vdivss(XMMRegister dst, XMMRegister nds, XMMRegister src);
    void vfmadd231sd(XMMRegister dst, XMMRegister nds, XMMRegister src);
@@@ -2548,6 -2697,24 +2712,28 @@@
    void evplzcntd(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);
    void evplzcntq(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);
  
+   // Float16 Vector instructions.
+   void evaddph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
+   void evaddph(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
++  void evaddph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len);
+   void evsubph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
+   void evsubph(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
++  void evsubph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len);
+   void evdivph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
+   void evdivph(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
++  void evdivph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len);
+   void evmulph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
+   void evmulph(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
++  void evmulph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len);
+   void evminph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
+   void evminph(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
+   void evmaxph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
+   void evmaxph(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
+   void evfmadd132ph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
+   void evfmadd132ph(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
+   void evsqrtph(XMMRegister dst, XMMRegister src1, int vector_len);
+   void evsqrtph(XMMRegister dst, Address src1, int vector_len);
+ 
    // Sub packed integers
    void psubb(XMMRegister dst, XMMRegister src);
    void psubw(XMMRegister dst, XMMRegister src);
diff --cc src/hotspot/cpu/x86/c2_MacroAssembler_x86.cpp
index d5726d9827a,8c3f33e0aca..e59cd705b99
--- a/src/hotspot/cpu/x86/c2_MacroAssembler_x86.cpp
+++ b/src/hotspot/cpu/x86/c2_MacroAssembler_x86.cpp
@@@ -2119,26 -2205,29 +2205,49 @@@ void C2_MacroAssembler::reduce16F(int o
    reduce8F(opcode, dst, vtmp1, vtmp1, vtmp2);
  }
  
 +void C2_MacroAssembler::reduce8HF(Register dst, XMMRegister src, XMMRegister vtmp, XMMRegister vtmp1, XMMRegister vtmp2) {
 +  movdl(vtmp1, dst);
 +  evaddsh(vtmp1, vtmp1, src);
 +  pshuflw(vtmp, src, 0x01);
 +  evaddsh(vtmp1, vtmp1, vtmp);
 +  pshuflw(vtmp, src, 0x02);
 +  evaddsh(vtmp1, vtmp1, vtmp);
 +  pshuflw(vtmp, src, 0x03);
 +  evaddsh(vtmp1, vtmp1, vtmp);
 +  pshufd(vtmp2, src, 0x0E);
 +  evaddsh(vtmp1, vtmp1, vtmp2);
 +  pshuflw(vtmp, vtmp2, 0x01);
 +  evaddsh(vtmp1, vtmp1, vtmp);
 +  pshuflw(vtmp, vtmp2, 0x02);
 +  evaddsh(vtmp1, vtmp1, vtmp);
 +  pshuflw(vtmp, vtmp2, 0x03);
 +  evaddsh(vtmp1, vtmp1, vtmp);
 +  movdl(dst, vtmp1);
 +}
 +
+ void C2_MacroAssembler::unorderedReduce2F(int opcode, XMMRegister dst, XMMRegister src) {
+   pshufd(dst, src, 0x1);
+   reduce_operation_128(T_FLOAT, opcode, dst, src);
+ }
+ 
+ void C2_MacroAssembler::unorderedReduce4F(int opcode, XMMRegister dst, XMMRegister src, XMMRegister vtmp) {
+   pshufd(vtmp, src, 0xE);
+   unordered_reduce_operation_128(T_FLOAT, opcode, vtmp, src);
+   unorderedReduce2F(opcode, dst, vtmp);
+ }
+ 
+ void C2_MacroAssembler::unorderedReduce8F(int opcode, XMMRegister dst, XMMRegister src, XMMRegister vtmp1, XMMRegister vtmp2) {
+   vextractf128_high(vtmp1, src);
+   unordered_reduce_operation_128(T_FLOAT, opcode, vtmp1, src);
+   unorderedReduce4F(opcode, dst, vtmp1, vtmp2);
+ }
+ 
+ void C2_MacroAssembler::unorderedReduce16F(int opcode, XMMRegister dst, XMMRegister src, XMMRegister vtmp1, XMMRegister vtmp2) {
+   vextractf64x4_high(vtmp2, src);
+   unordered_reduce_operation_256(T_FLOAT, opcode, vtmp2, vtmp2, src);
+   unorderedReduce8F(opcode, dst, vtmp2, vtmp1, vtmp2);
+ }
+ 
  void C2_MacroAssembler::reduce2D(int opcode, XMMRegister dst, XMMRegister src, XMMRegister vtmp) {
    reduce_operation_128(T_DOUBLE, opcode, dst, src);
    pshufd(vtmp, src, 0xE);
diff --cc src/hotspot/cpu/x86/stubDeclarations_x86.hpp
index 00000000000,30a93fa4917..cb4c1c480e3
mode 000000,100644..100644
--- a/src/hotspot/cpu/x86/stubDeclarations_x86.hpp
+++ b/src/hotspot/cpu/x86/stubDeclarations_x86.hpp
@@@ -1,0 -1,252 +1,260 @@@
+ /*
+  * Copyright (c) 2025, Oracle and/or its affiliates. All rights reserved.
+  * Copyright (c) 2025, Red Hat, Inc. All rights reserved.
+  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+  *
+  * This code is free software; you can redistribute it and/or modify it
+  * under the terms of the GNU General Public License version 2 only, as
+  * published by the Free Software Foundation.
+  *
+  * This code is distributed in the hope that it will be useful, but WITHOUT
+  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+  * version 2 for more details (a copy is included in the LICENSE file that
+  * accompanied this code).
+  *
+  * You should have received a copy of the GNU General Public License version
+  * 2 along with this work; if not, write to the Free Software Foundation,
+  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+  *
+  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+  * or visit www.oracle.com if you need additional information or have any
+  * questions.
+  *
+  */
+ 
+ #ifndef CPU_X86_STUBDECLARATIONS_HPP
+ #define CPU_X86_STUBDECLARATIONS_HPP
+ 
+ #define STUBGEN_PREUNIVERSE_BLOBS_ARCH_DO(do_stub,                      \
+                                           do_arch_blob,                 \
+                                           do_arch_entry,                \
+                                           do_arch_entry_init)           \
+   do_arch_blob(preuniverse, 500)                                        \
+ 
+ 
+ #define STUBGEN_INITIAL_BLOBS_ARCH_DO(do_stub,                          \
+                                       do_arch_blob,                     \
+                                       do_arch_entry,                    \
+                                       do_arch_entry_init)               \
+   do_arch_blob(initial, PRODUCT_ONLY(20000) NOT_PRODUCT(21000) WINDOWS_ONLY(+1000))                      \
+   do_stub(initial, verify_mxcsr)                                        \
+   do_arch_entry(x86, initial, verify_mxcsr, verify_mxcsr_entry,         \
+                 verify_mxcsr_entry)                                     \
+   do_stub(initial, get_previous_sp)                                     \
+   do_arch_entry(x86, initial, get_previous_sp,                          \
+                 get_previous_sp_entry,                                  \
+                 get_previous_sp_entry)                                  \
+   do_stub(initial, f2i_fixup)                                           \
+   do_arch_entry(x86, initial, f2i_fixup, f2i_fixup, f2i_fixup)          \
+   do_stub(initial, f2l_fixup)                                           \
+   do_arch_entry(x86, initial, f2l_fixup, f2l_fixup, f2l_fixup)          \
+   do_stub(initial, d2i_fixup)                                           \
+   do_arch_entry(x86, initial, d2i_fixup, d2i_fixup, d2i_fixup)          \
+   do_stub(initial, d2l_fixup)                                           \
+   do_arch_entry(x86, initial, d2l_fixup, d2l_fixup, d2l_fixup)          \
+   do_stub(initial, float_sign_mask)                                     \
+   do_arch_entry(x86, initial, float_sign_mask, float_sign_mask,         \
+                 float_sign_mask)                                        \
+   do_stub(initial, float_sign_flip)                                     \
+   do_arch_entry(x86, initial, float_sign_flip, float_sign_flip,         \
+                 float_sign_flip)                                        \
+   do_stub(initial, double_sign_mask)                                    \
+   do_arch_entry(x86, initial, double_sign_mask, double_sign_mask,       \
+                 double_sign_mask)                                       \
+   do_stub(initial, double_sign_flip)                                    \
+   do_arch_entry(x86, initial, double_sign_flip, double_sign_flip,       \
+                 double_sign_flip)                                       \
+ 
+ #define STUBGEN_CONTINUATION_BLOBS_ARCH_DO(do_stub,                     \
+                                            do_arch_blob,                \
+                                            do_arch_entry,               \
+                                            do_arch_entry_init)          \
+   do_arch_blob(continuation, 3000)                                      \
+ 
+ 
+ #define STUBGEN_COMPILER_BLOBS_ARCH_DO(do_stub,                         \
+                                        do_arch_blob,                    \
+                                        do_arch_entry,                   \
+                                        do_arch_entry_init)              \
+   do_arch_blob(compiler, 109000 WINDOWS_ONLY(+2000))                    \
+   do_stub(compiler, vector_float_sign_mask)                             \
+   do_arch_entry(x86, compiler, vector_float_sign_mask,                  \
+                 vector_float_sign_mask, vector_float_sign_mask)         \
++  do_stub(compiler, vector_halffloat_sign_mask)                         \
++  do_arch_entry(x86, compiler, vector_halffloat_sign_mask,              \
++                vector_halffloat_sign_mask,                             \
++                vector_halffloat_sign_mask)                             \
++  do_stub(compiler, vector_halffloat_sign_flip)                         \
++  do_arch_entry(x86, compiler, vector_halffloat_sign_flip,              \
++                vector_halffloat_sign_flip,                             \
++                vector_halffloat_sign_flip)                             \
+   do_stub(compiler, vector_float_sign_flip)                             \
+   do_arch_entry(x86, compiler, vector_float_sign_flip,                  \
+                 vector_float_sign_flip, vector_float_sign_flip)         \
+   do_stub(compiler, vector_double_sign_mask)                            \
+   do_arch_entry(x86, compiler, vector_double_sign_mask,                 \
+                 vector_double_sign_mask, vector_double_sign_mask)       \
+   do_stub(compiler, vector_double_sign_flip)                            \
+   do_arch_entry(x86, compiler, vector_double_sign_flip,                 \
+                 vector_double_sign_flip, vector_double_sign_flip)       \
+   do_stub(compiler, vector_all_bits_set)                                \
+   do_arch_entry(x86, compiler, vector_all_bits_set,                     \
+                 vector_all_bits_set, vector_all_bits_set)               \
+   do_stub(compiler, vector_int_mask_cmp_bits)                           \
+   do_arch_entry(x86, compiler, vector_int_mask_cmp_bits,                \
+                 vector_int_mask_cmp_bits, vector_int_mask_cmp_bits)     \
+   do_stub(compiler, vector_short_to_byte_mask)                          \
+   do_arch_entry(x86, compiler, vector_short_to_byte_mask,               \
+                 vector_short_to_byte_mask, vector_short_to_byte_mask)   \
+   do_stub(compiler, vector_byte_perm_mask)                              \
+   do_arch_entry(x86, compiler,vector_byte_perm_mask,                    \
+                 vector_byte_perm_mask, vector_byte_perm_mask)           \
+   do_stub(compiler, vector_int_to_byte_mask)                            \
+   do_arch_entry(x86, compiler, vector_int_to_byte_mask,                 \
+                 vector_int_to_byte_mask, vector_int_to_byte_mask)       \
+   do_stub(compiler, vector_int_to_short_mask)                           \
+   do_arch_entry(x86, compiler, vector_int_to_short_mask,                \
+                 vector_int_to_short_mask, vector_int_to_short_mask)     \
+   do_stub(compiler, vector_32_bit_mask)                                 \
+   do_arch_entry(x86, compiler, vector_32_bit_mask,                      \
+                 vector_32_bit_mask, vector_32_bit_mask)                 \
+   do_stub(compiler, vector_64_bit_mask)                                 \
+   do_arch_entry(x86, compiler, vector_64_bit_mask,                      \
+                 vector_64_bit_mask, vector_64_bit_mask)                 \
+   do_stub(compiler, vector_byte_shuffle_mask)                           \
+   do_arch_entry(x86, compiler, vector_byte_shuffle_mask,                 \
+                 vector_byte_shuffle_mask, vector_byte_shuffle_mask)     \
+   do_stub(compiler, vector_short_shuffle_mask)                          \
+   do_arch_entry(x86, compiler, vector_short_shuffle_mask,               \
+                 vector_short_shuffle_mask, vector_short_shuffle_mask)   \
+   do_stub(compiler, vector_int_shuffle_mask)                            \
+   do_arch_entry(x86, compiler, vector_int_shuffle_mask,                 \
+                 vector_int_shuffle_mask, vector_int_shuffle_mask)       \
+   do_stub(compiler, vector_long_shuffle_mask)                           \
+   do_arch_entry(x86, compiler, vector_long_shuffle_mask,                \
+                 vector_long_shuffle_mask, vector_long_shuffle_mask)     \
+   do_stub(compiler, vector_long_sign_mask)                              \
+   do_arch_entry(x86, compiler, vector_long_sign_mask,                   \
+                 vector_long_sign_mask, vector_long_sign_mask)           \
+   do_stub(compiler, vector_iota_indices)                                \
+   do_arch_entry(x86, compiler, vector_iota_indices,                     \
+                 vector_iota_indices, vector_iota_indices)               \
+   do_stub(compiler, vector_count_leading_zeros_lut)                     \
+   do_arch_entry(x86, compiler, vector_count_leading_zeros_lut,          \
+                 vector_count_leading_zeros_lut,                         \
+                 vector_count_leading_zeros_lut)                         \
+   do_stub(compiler, vector_reverse_bit_lut)                             \
+   do_arch_entry(x86, compiler, vector_reverse_bit_lut,                  \
+                 vector_reverse_bit_lut, vector_reverse_bit_lut)         \
+   do_stub(compiler, vector_reverse_byte_perm_mask_short)                \
+   do_arch_entry(x86, compiler, vector_reverse_byte_perm_mask_short,     \
+                 vector_reverse_byte_perm_mask_short,                    \
+                 vector_reverse_byte_perm_mask_short)                    \
+   do_stub(compiler, vector_reverse_byte_perm_mask_int)                  \
+   do_arch_entry(x86, compiler, vector_reverse_byte_perm_mask_int,       \
+                 vector_reverse_byte_perm_mask_int,                      \
+                 vector_reverse_byte_perm_mask_int)                      \
+   do_stub(compiler, vector_reverse_byte_perm_mask_long)                 \
+   do_arch_entry(x86, compiler, vector_reverse_byte_perm_mask_long,      \
+                 vector_reverse_byte_perm_mask_long,                     \
+                 vector_reverse_byte_perm_mask_long)                     \
+   do_stub(compiler, vector_popcount_lut)                                \
+   do_arch_entry(x86, compiler, vector_popcount_lut,                     \
+                 vector_popcount_lut, vector_popcount_lut)               \
+   do_stub(compiler, upper_word_mask)                                    \
+   do_arch_entry(x86, compiler, upper_word_mask, upper_word_mask_addr,   \
+                 upper_word_mask_addr)                                   \
+   do_stub(compiler, shuffle_byte_flip_mask)                             \
+   do_arch_entry(x86, compiler, shuffle_byte_flip_mask,                  \
+                 shuffle_byte_flip_mask_addr,                            \
+                 shuffle_byte_flip_mask_addr)                            \
+   do_stub(compiler, pshuffle_byte_flip_mask)                            \
+   do_arch_entry(x86, compiler, pshuffle_byte_flip_mask,                 \
+                 pshuffle_byte_flip_mask_addr,                           \
+                 pshuffle_byte_flip_mask_addr)                           \
+   /* x86_64 exposes these 3 stubs via a generic entry array */          \
+   /* other arches use arch-specific entries */                          \
+   /* this really needs rationalising */                                 \
+   do_stub(compiler, string_indexof_linear_ll)                           \
+   do_stub(compiler, string_indexof_linear_uu)                           \
+   do_stub(compiler, string_indexof_linear_ul)                           \
+   do_stub(compiler, pshuffle_byte_flip_mask_sha512)                     \
+   do_arch_entry(x86, compiler, pshuffle_byte_flip_mask_sha512,          \
+                 pshuffle_byte_flip_mask_addr_sha512,                    \
+                 pshuffle_byte_flip_mask_addr_sha512)                    \
+   do_stub(compiler, compress_perm_table32)                              \
+   do_arch_entry(x86, compiler, compress_perm_table32,                   \
+                 compress_perm_table32, compress_perm_table32)           \
+   do_stub(compiler, compress_perm_table64)                              \
+   do_arch_entry(x86, compiler, compress_perm_table64,                   \
+                 compress_perm_table64, compress_perm_table64)           \
+   do_stub(compiler, expand_perm_table32)                                \
+   do_arch_entry(x86, compiler, expand_perm_table32,                     \
+                 expand_perm_table32, expand_perm_table32)               \
+   do_stub(compiler, expand_perm_table64)                                \
+   do_arch_entry(x86, compiler, expand_perm_table64,                     \
+                 expand_perm_table64, expand_perm_table64)               \
+   do_stub(compiler, avx2_shuffle_base64)                                \
+   do_arch_entry(x86, compiler, avx2_shuffle_base64,                     \
+                 avx2_shuffle_base64, base64_avx2_shuffle_addr)          \
+   do_stub(compiler, avx2_input_mask_base64)                             \
+   do_arch_entry(x86, compiler, avx2_input_mask_base64,                  \
+                 avx2_input_mask_base64,                                 \
+                 base64_avx2_input_mask_addr)                            \
+   do_stub(compiler, avx2_lut_base64)                                    \
+   do_arch_entry(x86, compiler, avx2_lut_base64,                         \
+                 avx2_lut_base64, base64_avx2_lut_addr)                  \
+   do_stub(compiler, avx2_decode_tables_base64)                          \
+   do_arch_entry(x86, compiler, avx2_decode_tables_base64,               \
+                 avx2_decode_tables_base64,                              \
+                 base64_AVX2_decode_tables_addr)                         \
+   do_stub(compiler, avx2_decode_lut_tables_base64)                      \
+   do_arch_entry(x86, compiler, avx2_decode_lut_tables_base64,           \
+                 avx2_decode_lut_tables_base64,                          \
+                 base64_AVX2_decode_LUT_tables_addr)                     \
+   do_stub(compiler, shuffle_base64)                                     \
+   do_arch_entry(x86, compiler, shuffle_base64, shuffle_base64,          \
+                 base64_shuffle_addr)                                    \
+   do_stub(compiler, lookup_lo_base64)                                   \
+   do_arch_entry(x86, compiler, lookup_lo_base64, lookup_lo_base64,      \
+                 base64_vbmi_lookup_lo_addr)                             \
+   do_stub(compiler, lookup_hi_base64)                                   \
+   do_arch_entry(x86, compiler, lookup_hi_base64, lookup_hi_base64,      \
+                 base64_vbmi_lookup_hi_addr)                             \
+   do_stub(compiler, lookup_lo_base64url)                                \
+   do_arch_entry(x86, compiler, lookup_lo_base64url,                     \
+                 lookup_lo_base64url,                                    \
+                 base64_vbmi_lookup_lo_url_addr)                         \
+   do_stub(compiler, lookup_hi_base64url)                                \
+   do_arch_entry(x86, compiler, lookup_hi_base64url,                     \
+                 lookup_hi_base64url,                                    \
+                 base64_vbmi_lookup_hi_url_addr)                         \
+   do_stub(compiler, pack_vec_base64)                                    \
+   do_arch_entry(x86, compiler, pack_vec_base64, pack_vec_base64,        \
+                 base64_vbmi_pack_vec_addr)                              \
+   do_stub(compiler, join_0_1_base64)                                    \
+   do_arch_entry(x86, compiler, join_0_1_base64, join_0_1_base64,        \
+                 base64_vbmi_join_0_1_addr)                              \
+   do_stub(compiler, join_1_2_base64)                                    \
+   do_arch_entry(x86, compiler, join_1_2_base64, join_1_2_base64,        \
+                 base64_vbmi_join_1_2_addr)                              \
+   do_stub(compiler, join_2_3_base64)                                    \
+   do_arch_entry(x86, compiler, join_2_3_base64, join_2_3_base64,        \
+                 base64_vbmi_join_2_3_addr)                              \
+   do_stub(compiler, encoding_table_base64)                              \
+   do_arch_entry(x86, compiler, encoding_table_base64,                   \
+                 encoding_table_base64, base64_encoding_table_addr)      \
+   do_stub(compiler, decoding_table_base64)                              \
+   do_arch_entry(x86, compiler, decoding_table_base64,                   \
+                 decoding_table_base64, base64_decoding_table_addr)      \
+ 
+ 
+ #define STUBGEN_FINAL_BLOBS_ARCH_DO(do_stub,                            \
+                                     do_arch_blob,                       \
+                                     do_arch_entry,                      \
+                                     do_arch_entry_init)                 \
+   do_arch_blob(final, 33000                                             \
+                WINDOWS_ONLY(+22000) ZGC_ONLY(+20000))                   \
+ 
+ #endif // CPU_X86_STUBDECLARATIONS_HPP
diff --cc src/hotspot/cpu/x86/stubGenerator_x86_64.cpp
index f77c023a0c2,058ea06ab4e..9df5d6b22f9
--- a/src/hotspot/cpu/x86/stubGenerator_x86_64.cpp
+++ b/src/hotspot/cpu/x86/stubGenerator_x86_64.cpp
@@@ -4003,38 -4164,42 +4164,45 @@@ void StubGenerator::generate_compiler_s
  
    // Entry points that are C2 compiler specific.
  
-   StubRoutines::x86::_vector_float_sign_mask = generate_vector_mask("vector_float_sign_mask", 0x7FFFFFFF7FFFFFFF);
-   StubRoutines::x86::_vector_float_sign_flip = generate_vector_mask("vector_float_sign_flip", 0x8000000080000000);
-   StubRoutines::x86::_vector_double_sign_mask = generate_vector_mask("vector_double_sign_mask", 0x7FFFFFFFFFFFFFFF);
-   StubRoutines::x86::_vector_double_sign_flip = generate_vector_mask("vector_double_sign_flip", 0x8000000000000000);
-   StubRoutines::x86::_vector_all_bits_set = generate_vector_mask("vector_all_bits_set", 0xFFFFFFFFFFFFFFFF);
-   StubRoutines::x86::_vector_int_mask_cmp_bits = generate_vector_mask("vector_int_mask_cmp_bits", 0x0000000100000001);
-   StubRoutines::x86::_vector_short_to_byte_mask = generate_vector_mask("vector_short_to_byte_mask", 0x00ff00ff00ff00ff);
-   StubRoutines::x86::_vector_byte_perm_mask = generate_vector_byte_perm_mask("vector_byte_perm_mask");
-   StubRoutines::x86::_vector_int_to_byte_mask = generate_vector_mask("vector_int_to_byte_mask", 0x000000ff000000ff);
-   StubRoutines::x86::_vector_int_to_short_mask = generate_vector_mask("vector_int_to_short_mask", 0x0000ffff0000ffff);
-   StubRoutines::x86::_vector_32_bit_mask = generate_vector_custom_i32("vector_32_bit_mask", Assembler::AVX_512bit,
++  StubRoutines::x86::_vector_halffloat_sign_mask = generate_vector_mask(StubId::stubgen_vector_halffloat_sign_mask_id, 0x7FFF7FFF7FFF7FFF);
++  StubRoutines::x86::_vector_halffloat_sign_flip = generate_vector_mask(StubId::stubgen_vector_halffloat_sign_flip_id, 0x8000800080008000);
+   StubRoutines::x86::_vector_float_sign_mask = generate_vector_mask(StubId::stubgen_vector_float_sign_mask_id, 0x7FFFFFFF7FFFFFFF);
+   StubRoutines::x86::_vector_float_sign_flip = generate_vector_mask(StubId::stubgen_vector_float_sign_flip_id, 0x8000000080000000);
+   StubRoutines::x86::_vector_double_sign_mask = generate_vector_mask(StubId::stubgen_vector_double_sign_mask_id, 0x7FFFFFFFFFFFFFFF);
+   StubRoutines::x86::_vector_double_sign_flip = generate_vector_mask(StubId::stubgen_vector_double_sign_flip_id, 0x8000000000000000);
+   StubRoutines::x86::_vector_all_bits_set = generate_vector_mask(StubId::stubgen_vector_all_bits_set_id, 0xFFFFFFFFFFFFFFFF);
+   StubRoutines::x86::_vector_int_mask_cmp_bits = generate_vector_mask(StubId::stubgen_vector_int_mask_cmp_bits_id, 0x0000000100000001);
+   StubRoutines::x86::_vector_short_to_byte_mask = generate_vector_mask(StubId::stubgen_vector_short_to_byte_mask_id, 0x00ff00ff00ff00ff);
+   StubRoutines::x86::_vector_byte_perm_mask = generate_vector_byte_perm_mask();
+   StubRoutines::x86::_vector_int_to_byte_mask = generate_vector_mask(StubId::stubgen_vector_int_to_byte_mask_id, 0x000000ff000000ff);
+   StubRoutines::x86::_vector_int_to_short_mask = generate_vector_mask(StubId::stubgen_vector_int_to_short_mask_id, 0x0000ffff0000ffff);
+   StubRoutines::x86::_vector_32_bit_mask = generate_vector_custom_i32(StubId::stubgen_vector_32_bit_mask_id, Assembler::AVX_512bit,
                                                                        0xFFFFFFFF, 0, 0, 0);
-   StubRoutines::x86::_vector_64_bit_mask = generate_vector_custom_i32("vector_64_bit_mask", Assembler::AVX_512bit,
+   StubRoutines::x86::_vector_64_bit_mask = generate_vector_custom_i32(StubId::stubgen_vector_64_bit_mask_id, Assembler::AVX_512bit,
                                                                        0xFFFFFFFF, 0xFFFFFFFF, 0, 0);
-   StubRoutines::x86::_vector_int_shuffle_mask = generate_vector_mask("vector_int_shuffle_mask", 0x0302010003020100);
-   StubRoutines::x86::_vector_byte_shuffle_mask = generate_vector_byte_shuffle_mask("vector_byte_shuffle_mask");
-   StubRoutines::x86::_vector_short_shuffle_mask = generate_vector_mask("vector_short_shuffle_mask", 0x0100010001000100);
-   StubRoutines::x86::_vector_long_shuffle_mask = generate_vector_mask("vector_long_shuffle_mask", 0x0000000100000000);
-   StubRoutines::x86::_vector_long_sign_mask = generate_vector_mask("vector_long_sign_mask", 0x8000000000000000);
-   StubRoutines::x86::_vector_iota_indices = generate_iota_indices("iota_indices");
-   StubRoutines::x86::_vector_count_leading_zeros_lut = generate_count_leading_zeros_lut("count_leading_zeros_lut");
-   StubRoutines::x86::_vector_reverse_bit_lut = generate_vector_reverse_bit_lut("reverse_bit_lut");
-   StubRoutines::x86::_vector_reverse_byte_perm_mask_long = generate_vector_reverse_byte_perm_mask_long("perm_mask_long");
-   StubRoutines::x86::_vector_reverse_byte_perm_mask_int = generate_vector_reverse_byte_perm_mask_int("perm_mask_int");
-   StubRoutines::x86::_vector_reverse_byte_perm_mask_short = generate_vector_reverse_byte_perm_mask_short("perm_mask_short");
- 
-   StubRoutines::x86::_vector_halffloat_sign_mask = generate_vector_fp_mask("vector_halffloat_sign_mask", 0x7FFF7FFF7FFF7FFF);
-   StubRoutines::x86::_vector_halffloat_sign_flip = generate_vector_fp_mask("vector_halffloat_sign_flip", 0x8000800080008000);
+   StubRoutines::x86::_vector_int_shuffle_mask = generate_vector_mask(StubId::stubgen_vector_int_shuffle_mask_id, 0x0302010003020100);
+   StubRoutines::x86::_vector_byte_shuffle_mask = generate_vector_byte_shuffle_mask();
+   StubRoutines::x86::_vector_short_shuffle_mask = generate_vector_mask(StubId::stubgen_vector_short_shuffle_mask_id, 0x0100010001000100);
+   StubRoutines::x86::_vector_long_shuffle_mask = generate_vector_mask(StubId::stubgen_vector_long_shuffle_mask_id, 0x0000000100000000);
+   StubRoutines::x86::_vector_long_sign_mask = generate_vector_mask(StubId::stubgen_vector_long_sign_mask_id, 0x8000000000000000);
+   StubRoutines::x86::_vector_iota_indices = generate_iota_indices();
+   StubRoutines::x86::_vector_count_leading_zeros_lut = generate_count_leading_zeros_lut();
+   StubRoutines::x86::_vector_reverse_bit_lut = generate_vector_reverse_bit_lut();
+   StubRoutines::x86::_vector_reverse_byte_perm_mask_long = generate_vector_reverse_byte_perm_mask_long();
+   StubRoutines::x86::_vector_reverse_byte_perm_mask_int = generate_vector_reverse_byte_perm_mask_int();
+   StubRoutines::x86::_vector_reverse_byte_perm_mask_short = generate_vector_reverse_byte_perm_mask_short();
+ 
+   if (VM_Version::supports_avx2() && !VM_Version::supports_avx512vl()) {
+     StubRoutines::x86::_compress_perm_table32 = generate_compress_perm_table(StubId::stubgen_compress_perm_table32_id);
+     StubRoutines::x86::_compress_perm_table64 = generate_compress_perm_table(StubId::stubgen_compress_perm_table64_id);
+     StubRoutines::x86::_expand_perm_table32 = generate_expand_perm_table(StubId::stubgen_expand_perm_table32_id);
+     StubRoutines::x86::_expand_perm_table64 = generate_expand_perm_table(StubId::stubgen_expand_perm_table64_id);
+   }
+ 
 +
    if (VM_Version::supports_avx2() && !VM_Version::supports_avx512_vpopcntdq()) {
      // lut implementation influenced by counting 1s algorithm from section 5-1 of Hackers' Delight.
-     StubRoutines::x86::_vector_popcount_lut = generate_popcount_avx_lut("popcount_lut");
+     StubRoutines::x86::_vector_popcount_lut = generate_popcount_avx_lut();
    }
  
    generate_aes_stubs();
diff --cc src/hotspot/cpu/x86/x86.ad
index 8742dd5e22d,2eb748e350c..da91a799568
--- a/src/hotspot/cpu/x86/x86.ad
+++ b/src/hotspot/cpu/x86/x86.ad
@@@ -1394,11 -1322,9 +1322,11 @@@ static Assembler::Width widthForType(Ba
    static address vector_64_bit_mask() { return StubRoutines::x86::vector_64_bit_mask(); }
    static address vector_float_signflip() { return StubRoutines::x86::vector_float_sign_flip();}
    static address vector_double_signflip() { return StubRoutines::x86::vector_double_sign_flip();}
 +  static address vector_halffloat_signmask() { return StubRoutines::x86::vector_halffloat_sign_mask();}
 +  static address vector_halffloat_signflip() { return StubRoutines::x86::vector_halffloat_sign_flip();}
  
  //=============================================================================
- const bool Matcher::match_rule_supported(int opcode) {
+ bool Matcher::match_rule_supported(int opcode) {
    if (!has_match_rule(opcode)) {
      return false; // no match rule present
    }
@@@ -1734,6 -1606,24 +1608,26 @@@ bool Matcher::match_rule_supported_vect
    //   * 128bit vroundpd instruction is present only in AVX1
    int size_in_bits = vlen * type2aelembytes(bt) * BitsPerByte;
    switch (opcode) {
+     case Op_MaxVHF:
+     case Op_MinVHF:
+       if (!VM_Version::supports_avx512bw()) {
+         return false;
+       }
++    case Op_AbsVHF:
+     case Op_AddVHF:
+     case Op_DivVHF:
+     case Op_FmaVHF:
+     case Op_MulVHF:
++    case Op_NegVHF:
+     case Op_SubVHF:
+     case Op_SqrtVHF:
+       if (size_in_bits < 512 && !VM_Version::supports_avx512vl()) {
+         return false;
+       }
+       if (!VM_Version::supports_avx512_fp16()) {
+         return false;
+       }
+       break;
      case Op_AbsVF:
      case Op_NegVF:
        if ((vlen == 16) && (VM_Version::supports_avx512dq() == false)) {
@@@ -1998,24 -1910,6 +1906,14 @@@
          return false;
        }
        break;
-     case Op_AddVHF:
-     case Op_SubVHF:
-     case Op_MulVHF:
-     case Op_DivVHF:
-     case Op_AbsVHF:
-     case Op_NegVHF:
-       if (bt != T_SHORT && !VM_Version::supports_avx512_fp16()) {
-         return false;
-       }
-       break;
 +    case Op_VectorCastF2HF:
 +    case Op_VectorCastHF2F:
 +    case Op_VectorCastD2HF:
 +    case Op_VectorCastHF2D:
 +      if (!VM_Version::supports_avx512_fp16()) {
 +        return false;
 +      }
 +      break;
    }
    return true;  // Per default match rules are supported.
  }
@@@ -2964,29 -2860,6 +2865,28 @@@ operand legVecZ() %
    interface(REG_INTER);
  %}
  
 +// Comparison Code for FP conditional move
 +operand cmpOp_vcmppd() %{
 +  match(Bool);
 +
 +  predicate(n->as_Bool()->_test._test != BoolTest::overflow &&
 +            n->as_Bool()->_test._test != BoolTest::no_overflow);
 +  format %{ "" %}
 +  interface(COND_INTER) %{
 +    equal        (0x0, "eq");
 +    less         (0x1, "lt");
 +    less_equal   (0x2, "le");
 +    not_equal    (0xC, "ne");
 +    greater_equal(0xD, "ge");
 +    greater      (0xE, "gt");
 +    //TODO cannot compile (adlc breaks) without two next lines with error:
 +    // x86_64.ad(13987) Syntax Error: :In operand cmpOp_vcmppd: Do not support this encode constant: ' %{
 +    // equal' for overflow.
 +    overflow     (0x20, "o");  // not really supported by the instruction
 +    no_overflow  (0x21, "no"); // not really supported by the instruction
 +  %}
 +%}
 +
- 
  // INSTRUCTIONS -- Platform independent definitions (same for 32- and 64-bit)
  
  // ============================================================================
@@@ -4999,17 -4924,75 +4951,85 @@@ instruct reduction16F(regF dst, legVec 
    ins_pipe( pipe_slow );
  %}
  
 +// =======================Half Float Reduction==========================================
 +instruct reduction8HF(rRegI dst, vec src2, vec vtmp, vec vtmp1, vec vtmp2) %{
 +  match(Set dst (AddReductionVHF dst src2));
 +  effect(TEMP vtmp, TEMP vtmp1, TEMP vtmp2);
 +  format %{ "reduction_halffloat  $dst, $src2\t using $vtmp, $vtmp1, $vtmp2 as TEMP" %}
 +  ins_encode %{
 +    __ reduce8HF($dst$$Register, $src2$$XMMRegister, $vtmp$$XMMRegister, $vtmp1$$XMMRegister, $vtmp2$$XMMRegister);
 +  %}
 +  ins_pipe( pipe_slow );
 +%}
  
+ instruct unordered_reduction2F(regF dst, regF src1, vec src2) %{
+   // Non-strictly ordered floating-point add/mul reduction for floats. This rule is
+   // intended for the VectorAPI (which allows for non-strictly ordered add/mul reduction).
+   // src1 contains reduction identity
+   predicate(!n->as_Reduction()->requires_strict_order() && Matcher::vector_length(n->in(2)) == 2); // src2
+   match(Set dst (AddReductionVF src1 src2));
+   match(Set dst (MulReductionVF src1 src2));
+   effect(TEMP dst);
+   format %{ "vector_reduction_float  $dst,$src1,$src2 ;" %}
+   ins_encode %{
+     int opcode = this->ideal_Opcode();
+     int vlen = Matcher::vector_length(this, $src2);
+     __ unordered_reduce_fp(opcode, vlen, $dst$$XMMRegister, $src2$$XMMRegister);
+   %}
+   ins_pipe( pipe_slow );
+ %}
+ 
+ instruct unordered_reduction4F(regF dst, regF src1, vec src2, vec vtmp) %{
+   // Non-strictly ordered floating-point add/mul reduction for floats. This rule is
+   // intended for the VectorAPI (which allows for non-strictly ordered add/mul reduction).
+   // src1 contains reduction identity
+   predicate(!n->as_Reduction()->requires_strict_order() && Matcher::vector_length(n->in(2)) == 4); // src2
+   match(Set dst (AddReductionVF src1 src2));
+   match(Set dst (MulReductionVF src1 src2));
+   effect(TEMP dst, TEMP vtmp);
+   format %{ "vector_reduction_float  $dst,$src1,$src2 ; using $vtmp as TEMP" %}
+   ins_encode %{
+     int opcode = this->ideal_Opcode();
+     int vlen = Matcher::vector_length(this, $src2);
+     __ unordered_reduce_fp(opcode, vlen, $dst$$XMMRegister, $src2$$XMMRegister, $vtmp$$XMMRegister);
+   %}
+   ins_pipe( pipe_slow );
+ %}
+ 
+ instruct unordered_reduction8F(regF dst, regF src1, vec src2, vec vtmp1, vec vtmp2) %{
+   // Non-strictly ordered floating-point add/mul reduction for floats. This rule is
+   // intended for the VectorAPI (which allows for non-strictly ordered add/mul reduction).
+   // src1 contains reduction identity
+   predicate(!n->as_Reduction()->requires_strict_order() && Matcher::vector_length(n->in(2)) == 8); // src2
+   match(Set dst (AddReductionVF src1 src2));
+   match(Set dst (MulReductionVF src1 src2));
+   effect(TEMP dst, TEMP vtmp1, TEMP vtmp2);
+   format %{ "vector_reduction_float $dst,$src1,$src2 ; using $vtmp1, $vtmp2 as TEMP" %}
+   ins_encode %{
+     int opcode = this->ideal_Opcode();
+     int vlen = Matcher::vector_length(this, $src2);
+     __ unordered_reduce_fp(opcode, vlen, $dst$$XMMRegister, $src2$$XMMRegister, $vtmp1$$XMMRegister, $vtmp2$$XMMRegister);
+   %}
+   ins_pipe( pipe_slow );
+ %}
+ 
+ instruct unordered_reduction16F(regF dst, regF src1, legVec src2, legVec vtmp1, legVec vtmp2) %{
+   // Non-strictly ordered floating-point add/mul reduction for floats. This rule is
+   // intended for the VectorAPI (which allows for non-strictly ordered add/mul reduction).
+   // src1 contains reduction identity
+   predicate(!n->as_Reduction()->requires_strict_order() && Matcher::vector_length(n->in(2)) == 16); // src2
+   match(Set dst (AddReductionVF src1 src2));
+   match(Set dst (MulReductionVF src1 src2));
+   effect(TEMP dst, TEMP vtmp1, TEMP vtmp2);
+   format %{ "vector_reduction_float $dst,$src1,$src2 ; using $vtmp1, $vtmp2 as TEMP" %}
+   ins_encode %{
+     int opcode = this->ideal_Opcode();
+     int vlen = Matcher::vector_length(this, $src2);
+     __ unordered_reduce_fp(opcode, vlen, $dst$$XMMRegister, $src2$$XMMRegister, $vtmp1$$XMMRegister, $vtmp2$$XMMRegister);
+   %}
+   ins_pipe( pipe_slow );
+ %}
+ 
  // =======================Double Reduction==========================================
  
  instruct reduction2D(regD dst, vec src, vec vtmp) %{
@@@ -6033,53 -6203,6 +6262,42 @@@ instruct vmulD_mem(vec dst, vec src, me
    ins_pipe( pipe_slow );
  %}
  
- //Halffloat vector mul
- instruct vmulHF_reg(vec dst, vec src1, vec src2) %{
-   match(Set dst (MulVHF src1 src2));
-   format %{ "evmulph  $dst,$src1,$src2\t! mul packedHF" %}
-   ins_encode %{
-     int vlen_enc = vector_length_encoding(this);
-     __ evmulph($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);
-   %}
-   ins_pipe( pipe_slow );
- %}
- 
 +instruct vcmov8F_reg(legVec dst, legVec src1, legVec src2, immI8 cop, cmpOp_vcmppd copnd) %{
 +  predicate(Matcher::vector_length(n) == 8);
 +  match(Set dst (CMoveVF (Binary copnd cop) (Binary src1 src2)));
 +  effect(TEMP dst, USE src1, USE src2);
 +  format %{ "cmpps.$copnd  $dst, $src1, $src2  ! vcmovevf, cond=$cop\n\t"
 +            "blendvps $dst,$src1,$src2,$dst ! vcmovevf\n\t"
 +         %}
 +  ins_encode %{
 +    assert(UseAVX > 0, "required");
 +
 +    int vlen_enc = Assembler::AVX_256bit;
 +    int cond = (Assembler::Condition)($copnd$$cmpcode);
 +    __ vcmpps($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, cond, vlen_enc);
 +    __ vblendvps($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, $dst$$XMMRegister, vlen_enc);
 +  %}
 +  ins_pipe( pipe_slow );
 +%}
 +
 +instruct vcmov4D_reg(legVec dst, legVec src1, legVec src2, immI8 cop, cmpOp_vcmppd copnd) %{
 +  predicate(Matcher::vector_length(n) == 4);
 +  match(Set dst (CMoveVD (Binary copnd cop) (Binary src1 src2)));
 +  effect(TEMP dst, USE src1, USE src2);
 +  format %{ "cmppd.$copnd  $dst, $src1, $src2  ! vcmovevd, cond=$cop\n\t"
 +            "vblendvpd $dst,$src1,$src2,$dst ! vcmovevd\n\t"
 +         %}
 +  ins_encode %{
 +    assert(UseAVX > 0, "required");
 +
 +    int vlen_enc = Assembler::AVX_256bit;
 +    int cond = (Assembler::Condition)($copnd$$cmpcode);
 +    __ vcmppd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, cond, vlen_enc);
 +    __ vblendvpd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, $dst$$XMMRegister, vlen_enc);
 +  %}
 +  ins_pipe( pipe_slow );
 +%}
 +
  // --------------------------------- DIV --------------------------------------
  
  // Floats vector div
@@@ -7561,54 -7769,6 +7875,30 @@@ instruct vucast(vec dst, vec src) %
    ins_pipe( pipe_slow );
  %}
  
 +// Convert from Halffloat to other types
 +instruct vcvtHFtoD_reg(vec dst, vec src) %{
 +  predicate(UseAVX > 2 && VM_Version::supports_avx512_fp16() && Matcher::vector_element_basic_type(n) == T_DOUBLE);
 +  match(Set dst (VectorCastHF2D src));
 +  format %{ "evcvtph2pd   $dst,$src\t! convert HF to D vector" %}
 +  ins_encode %{
 +    int vlen_enc = vector_length_encoding(this, $src);
 +    __ evcvtph2pd($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);
 +  %}
 +  ins_pipe( pipe_slow );
 +%}
 +
- instruct vcvtHFtoF_reg(vec dst, vec src) %{
-   predicate(UseAVX > 2 && Matcher::vector_element_basic_type(n) == T_FLOAT);
-   match(Set dst (VectorCastHF2F src));
-   format %{ "evcvtph2ps   $dst,$src\t! convert HF to F vector" %}
-   ins_encode %{
-     int vlen_enc = vector_length_encoding(this, $src);
-     __ evcvtph2ps($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);
-   %}
-   ins_pipe( pipe_slow );
- %}
- 
- // Convert from other types to Halffloat
- instruct vcvtFtoHF_reg(vec dst, vec src) %{
-   predicate(UseAVX > 2 && Matcher::vector_element_basic_type(n) == T_SHORT);
-   match(Set dst (VectorCastF2HF src));
-   format %{ "evcvtps2ph   $dst,$src\t! convert F to HF vector" %}
-   ins_encode %{
-     int midx = 0;
-     int vlen_enc = vector_length_encoding(this, $src);
-     __ evcvtps2ph($dst$$XMMRegister, $src$$XMMRegister, midx, vlen_enc);
-   %}
-   ins_pipe( pipe_slow );
- %}
 +
 +instruct vcvtDtoHF_reg(vec dst, vec src) %{
 +  predicate(UseAVX > 2 && VM_Version::supports_avx512_fp16() && Matcher::vector_element_basic_type(n) == T_SHORT);
 +  match(Set dst (VectorCastD2HF src));
 +  format %{ "evcvtpd2ph   $dst,$src\t! convert D to HF vector" %}
 +  ins_encode %{
 +    int vlen_enc = vector_length_encoding(this, $src);
 +    __ evcvtpd2ph($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);
 +  %}
 +  ins_pipe( pipe_slow );
 +%}
 +
- #ifdef _LP64
  instruct vround_float_avx(vec dst, vec src, rRegP tmp, vec xtmp1, vec xtmp2, vec xtmp3, vec xtmp4, rFlagsReg cr) %{
    predicate(!VM_Version::supports_avx512vl() &&
              Matcher::vector_length_in_bytes(n) < 64 &&
diff --cc src/hotspot/share/adlc/dfa.cpp
index 22ab04f65c5,d23ffb06c01..7c395576ec1
--- a/src/hotspot/share/adlc/dfa.cpp
+++ b/src/hotspot/share/adlc/dfa.cpp
@@@ -580,9 -580,9 +580,9 @@@ const char*  dfa_shared_preds::_pred [d
  // Helper method to check whether a node is vector unary operation.
  static bool is_vector_unary_op_name(const char* op_name) {
    static const char* vector_unary_op_list[] = {
 -    "AbsVB", "AbsVS", "AbsVI", "AbsVL", "AbsVF", "AbsVD",
 -    "NegVI", "NegVL", "NegVF", "NegVD",
 +    "AbsVB", "AbsVS", "AbsVI", "AbsVL", "AbsVHF", "AbsVF", "AbsVD",
 +    "NegVI", "NegVL", "NegVHF", "NegVF", "NegVD",
-     "SqrtVF", "SqrtVD",
+     "SqrtVHF", "SqrtVF", "SqrtVD",
      "PopCountVI", "PopCountVL",
      "CountLeadingZerosV", "CountTrailingZerosV",
      "ReverseV", "ReverseBytesV",
diff --cc src/hotspot/share/adlc/formssel.cpp
index 3161d83d9da,b938d5b7560..0311cb48d8b
--- a/src/hotspot/share/adlc/formssel.cpp
+++ b/src/hotspot/share/adlc/formssel.cpp
@@@ -4204,16 -4338,15 +4339,16 @@@ bool MatchRule::is_vector() const 
      "AddVB","AddVS","AddVI","AddVL","AddVHF","AddVF","AddVD",
      "SubVB","SubVS","SubVI","SubVL","SubVHF","SubVF","SubVD",
      "MulVB","MulVS","MulVI","MulVL","MulVHF","MulVF","MulVD",
 +    "CMoveVD", "CMoveVF",
      "DivVHF","DivVF","DivVD",
 -    "AbsVB","AbsVS","AbsVI","AbsVL","AbsVF","AbsVD",
 -    "NegVF","NegVD","NegVI","NegVL",
 +    "AbsVB","AbsVS","AbsVI","AbsVL","AbsVHF","AbsVF","AbsVD",
 +    "NegVHF","NegVF","NegVD","NegVI","NegVL",
-     "SqrtVD","SqrtVF",
+     "SqrtVD","SqrtVF","SqrtVHF",
      "AndV" ,"XorV" ,"OrV",
-     "MaxV", "MinV",
+     "MaxV", "MinV", "MinVHF", "MaxVHF", "UMinV", "UMaxV",
      "CompressV", "ExpandV", "CompressM", "CompressBitsV", "ExpandBitsV",
      "AddReductionVI", "AddReductionVL",
 -    "AddReductionVF", "AddReductionVD",
 +    "AddReductionVF", "AddReductionVD","AddReductionVHF",
      "MulReductionVI", "MulReductionVL",
      "MulReductionVF", "MulReductionVD",
      "MaxReductionV", "MinReductionV",
@@@ -4231,10 -4364,9 +4366,10 @@@
      "VectorCastB2X", "VectorCastS2X", "VectorCastI2X",
      "VectorCastL2X", "VectorCastF2X", "VectorCastD2X", "VectorCastF2HF", "VectorCastHF2F",
      "VectorUCastB2X", "VectorUCastS2X", "VectorUCastI2X",
 +    "VectorCastD2HF", "VectorCastHF2D",
      "VectorMaskWrapper","VectorMaskCmp","VectorReinterpret","LoadVectorMasked","StoreVectorMasked",
-     "FmaVD","FmaVF","FmaVHF","PopCountVI","PopCountVL","PopulateIndex","VectorLongToMask",
-     "CountLeadingZerosV", "CountTrailingZerosV", "SignumVF", "SignumVD",
+     "FmaVD", "FmaVF", "FmaVHF", "PopCountVI", "PopCountVL", "PopulateIndex", "VectorLongToMask",
+     "CountLeadingZerosV", "CountTrailingZerosV", "SignumVF", "SignumVD", "SaturatingAddV", "SaturatingSubV",
      // Next are vector mask ops.
      "MaskAll", "AndVMask", "OrVMask", "XorVMask", "VectorMaskCast",
      "RoundVF", "RoundVD",
diff --cc src/hotspot/share/classfile/vmIntrinsics.hpp
index 96c9f78577f,3d110c5706b..72d80e6f6f9
--- a/src/hotspot/share/classfile/vmIntrinsics.hpp
+++ b/src/hotspot/share/classfile/vmIntrinsics.hpp
@@@ -917,7 -1002,8 +1002,10 @@@ class methodHandle
    do_intrinsic(_VectorUnaryOp, jdk_internal_vm_vector_VectorSupport, vector_unary_op_name, vector_unary_op_sig, F_S)                           \
     do_signature(vector_unary_op_sig, "(I"                                                                                                      \
                                        "Ljava/lang/Class;"                                                                                      \
-                                       "Ljava/lang/Class;Ljava/lang/Class;"                                                                     \
+                                       "Ljava/lang/Class;"                                                                                      \
+                                       "Ljava/lang/Class;"                                                                                      \
++                                      "Ljava/lang/Class;"                                                                                      \
++                                      "I"                                                                                                      \
                                        "I"                                                                                                      \
                                        "Ljdk/internal/vm/vector/VectorSupport$Vector;"                                                          \
                                        "Ljdk/internal/vm/vector/VectorSupport$VectorMask;"                                                      \
@@@ -930,6 -1016,6 +1018,8 @@@
                                         "Ljava/lang/Class;"                                                                                     \
                                         "Ljava/lang/Class;"                                                                                     \
                                         "Ljava/lang/Class;"                                                                                     \
++                                       "Ljava/lang/Class;"                                                                                     \
++                                       "I"                                                                                                     \
                                         "I"                                                                                                     \
                                         "Ljdk/internal/vm/vector/VectorSupport$VectorPayload;"                                                  \
                                         "Ljdk/internal/vm/vector/VectorSupport$VectorPayload;"                                                  \
@@@ -943,6 -1052,6 +1056,8 @@@
                                          "Ljava/lang/Class;"                                                                                    \
                                          "Ljava/lang/Class;"                                                                                    \
                                          "Ljava/lang/Class;"                                                                                    \
++                                        "Ljava/lang/Class;"                                                                                    \
++                                        "I"                                                                                                    \
                                          "I"                                                                                                    \
                                          "Ljdk/internal/vm/vector/VectorSupport$Vector;"                                                        \
                                          "Ljdk/internal/vm/vector/VectorSupport$Vector;"                                                        \
@@@ -952,10 -1061,21 +1067,25 @@@
                                          "Ljdk/internal/vm/vector/VectorSupport$Vector;")                                                       \
     do_name(vector_ternary_op_name,     "ternaryOp")                                                                                            \
                                                                                                                                                 \
+   do_intrinsic(_VectorSelectFromTwoVectorOp, jdk_internal_vm_vector_VectorSupport, vector_select_from_op_name, vector_select_from_op_sig, F_S) \
+    do_signature(vector_select_from_op_sig, "(Ljava/lang/Class;"                                                                                \
++                                            "Ljava/lang/Class;"                                                                                \
+                                             "Ljava/lang/Class;"                                                                                \
+                                             "I"                                                                                                \
++                                            "I"                                                                                                \
+                                             "Ljdk/internal/vm/vector/VectorSupport$Vector;"                                                    \
+                                             "Ljdk/internal/vm/vector/VectorSupport$Vector;"                                                    \
+                                             "Ljdk/internal/vm/vector/VectorSupport$Vector;"                                                    \
+                                             "Ljdk/internal/vm/vector/VectorSupport$SelectFromTwoVector;)"                                      \
+                                             "Ljdk/internal/vm/vector/VectorSupport$Vector;")                                                   \
+    do_name(vector_select_from_op_name,     "selectFromTwoVectorOp")                                                                            \
+                                                                                                                                                \
    do_intrinsic(_VectorFromBitsCoerced, jdk_internal_vm_vector_VectorSupport, vector_frombits_coerced_name, vector_frombits_coerced_sig, F_S)   \
     do_signature(vector_frombits_coerced_sig, "(Ljava/lang/Class;"                                                                              \
+                                                "Ljava/lang/Class;"                                                                             \
 +                                               "Ljava/lang/Class;"                                                                             \
 +                                               "I"                                                                                             \
+                                                "I"                                                                                             \
                                                 "J"                                                                                             \
                                                 "I"                                                                                             \
                                                 "Ljdk/internal/vm/vector/VectorSupport$VectorSpecies;"                                          \
@@@ -965,10 -1085,11 +1095,13 @@@
                                                                                                                                                 \
    do_intrinsic(_VectorLoadOp, jdk_internal_vm_vector_VectorSupport, vector_load_op_name, vector_load_op_sig, F_S)                              \
     do_signature(vector_load_op_sig, "(Ljava/lang/Class;"                                                                                       \
+                                      "Ljava/lang/Class;"                                                                                       \
 +                                     "Ljava/lang/Class;"                                                                                       \
 +                                     "I"                                                                                                       \
+                                      "I"                                                                                                       \
                                       "Ljava/lang/Object;"                                                                                      \
                                       "J"                                                                                                       \
+                                      "Z"                                                                                                       \
                                       "Ljava/lang/Object;"                                                                                      \
                                       "J"                                                                                                       \
                                       "Ljdk/internal/vm/vector/VectorSupport$VectorSpecies;"                                                    \
@@@ -978,11 -1099,12 +1111,14 @@@
                                                                                                                                                 \
    do_intrinsic(_VectorLoadMaskedOp, jdk_internal_vm_vector_VectorSupport, vector_load_masked_op_name, vector_load_masked_op_sig, F_S)          \
     do_signature(vector_load_masked_op_sig, "(Ljava/lang/Class;"                                                                                \
 +                                            "Ljava/lang/Class;"                                                                                \
                                              "Ljava/lang/Class;"                                                                                \
+                                             "Ljava/lang/Class;"                                                                                \
+                                             "I"                                                                                                \
 +                                            "I"                                                                                                \
                                              "Ljava/lang/Object;"                                                                               \
                                              "J"                                                                                                \
+                                             "Z"                                                                                                \
                                              "Ljdk/internal/vm/vector/VectorSupport$VectorMask;"                                                \
                                              "I"                                                                                                \
                                              "Ljava/lang/Object;"                                                                               \
@@@ -995,6 -1117,6 +1131,8 @@@
    do_intrinsic(_VectorStoreOp, jdk_internal_vm_vector_VectorSupport, vector_store_op_name, vector_store_op_sig, F_S)                           \
     do_signature(vector_store_op_sig, "(Ljava/lang/Class;"                                                                                      \
                                        "Ljava/lang/Class;"                                                                                      \
++                                      "Ljava/lang/Class;"                                                                                      \
++                                      "I"                                                                                                      \
                                        "I"                                                                                                      \
                                        "Ljava/lang/Object;"                                                                                     \
                                        "J"                                                                                                      \
@@@ -1009,6 -1132,6 +1148,8 @@@
     do_signature(vector_store_masked_op_sig, "(Ljava/lang/Class;"                                                                               \
                                               "Ljava/lang/Class;"                                                                               \
                                               "Ljava/lang/Class;"                                                                               \
++                                             "Ljava/lang/Class;"                                                                               \
++                                             "I"                                                                                               \
                                               "I"                                                                                               \
                                               "Ljava/lang/Object;"                                                                              \
                                               "J"                                                                                               \
@@@ -1025,6 -1149,6 +1167,8 @@@
                                                 "Ljava/lang/Class;"                                                                             \
                                                 "Ljava/lang/Class;"                                                                             \
                                                 "Ljava/lang/Class;"                                                                             \
++                                               "Ljava/lang/Class;"                                                                             \
++                                               "I"                                                                                             \
                                                 "I"                                                                                             \
                                                 "Ljdk/internal/vm/vector/VectorSupport$Vector;"                                                 \
                                                 "Ljdk/internal/vm/vector/VectorSupport$VectorMask;"                                             \
@@@ -1036,6 -1160,6 +1180,8 @@@
     do_signature(vector_test_sig, "(I"                                                                                                          \
                                    "Ljava/lang/Class;"                                                                                          \
                                    "Ljava/lang/Class;"                                                                                          \
++                                  "Ljava/lang/Class;"                                                                                          \
++                                  "I"                                                                                                          \
                                    "I"                                                                                                          \
                                    "Ljdk/internal/vm/vector/VectorSupport$VectorMask;"                                                          \
                                    "Ljdk/internal/vm/vector/VectorSupport$VectorMask;"                                                          \
@@@ -1045,9 -1169,9 +1191,11 @@@
                                                                                                                                                 \
    do_intrinsic(_VectorBlend, jdk_internal_vm_vector_VectorSupport, vector_blend_name, vector_blend_sig, F_S)                                   \
     do_signature(vector_blend_sig, "(Ljava/lang/Class;"                                                                                         \
+                                    "Ljava/lang/Class;"                                                                                         \
                                     "Ljava/lang/Class;"                                                                                         \
 +                                   "Ljava/lang/Class;"                                                                                         \
 +                                   "I"                                                                                                         \
+                                    "I"                                                                                                         \
                                     "Ljdk/internal/vm/vector/VectorSupport$Vector;"                                                             \
                                     "Ljdk/internal/vm/vector/VectorSupport$Vector;"                                                             \
                                     "Ljdk/internal/vm/vector/VectorSupport$VectorMask;"                                                         \
@@@ -1058,7 -1182,7 +1206,10 @@@
    do_intrinsic(_VectorCompare, jdk_internal_vm_vector_VectorSupport, vector_compare_name, vector_compare_sig, F_S)                             \
     do_signature(vector_compare_sig, "(I"                                                                                                       \
                                       "Ljava/lang/Class;"                                                                                       \
--                                     "Ljava/lang/Class;Ljava/lang/Class;"                                                                      \
++                                     "Ljava/lang/Class;"                                                                                       \
++                                     "Ljava/lang/Class;"                                                                                       \
++                                     "Ljava/lang/Class;"                                                                                       \
++                                     "I"                                                                                                       \
                                       "I"                                                                                                       \
                                       "Ljdk/internal/vm/vector/VectorSupport$Vector;"                                                           \
                                       "Ljdk/internal/vm/vector/VectorSupport$Vector;"                                                           \
@@@ -1072,6 -1196,6 +1223,8 @@@
                                         "Ljava/lang/Class;"                                                                                     \
                                         "Ljava/lang/Class;"                                                                                     \
                                         "Ljava/lang/Class;"                                                                                     \
++                                       "Ljava/lang/Class;"                                                                                     \
++                                       "I"                                                                                                     \
                                         "I"                                                                                                     \
                                         "Ljdk/internal/vm/vector/VectorSupport$Vector;"                                                         \
                                         "Ljdk/internal/vm/vector/VectorSupport$VectorShuffle;"                                                  \
@@@ -1080,11 -1204,23 +1233,27 @@@
                                         "Ljdk/internal/vm/vector/VectorSupport$Vector;")                                                        \
     do_name(vector_rearrange_name, "rearrangeOp")                                                                                               \
                                                                                                                                                 \
+   do_intrinsic(_VectorSelectFrom, jdk_internal_vm_vector_VectorSupport, vector_select_from_name, vector_select_from_sig, F_S)                  \
+    do_signature(vector_select_from_sig, "(Ljava/lang/Class;"                                                                                   \
++                                        "Ljava/lang/Class;"                                                                                     \
+                                         "Ljava/lang/Class;"                                                                                     \
+                                         "Ljava/lang/Class;"                                                                                     \
+                                         "I"                                                                                                     \
++                                        "I"                                                                                                     \
+                                         "Ljdk/internal/vm/vector/VectorSupport$Vector;"                                                         \
+                                         "Ljdk/internal/vm/vector/VectorSupport$Vector;"                                                         \
+                                         "Ljdk/internal/vm/vector/VectorSupport$VectorMask;"                                                     \
+                                         "Ljdk/internal/vm/vector/VectorSupport$VectorSelectFromOp;)"                                            \
+                                         "Ljdk/internal/vm/vector/VectorSupport$Vector;")                                                        \
+    do_name(vector_select_from_name, "selectFromOp")                                                                                              \
+                                                                                                                                                \
    do_intrinsic(_VectorExtract, jdk_internal_vm_vector_VectorSupport, vector_extract_name, vector_extract_sig, F_S)                             \
     do_signature(vector_extract_sig, "(Ljava/lang/Class;"                                                                                       \
+                                      "Ljava/lang/Class;"                                                                                       \
 +                                     "Ljava/lang/Class;"                                                                                       \
 +                                     "I"                                                                                                       \
-                                      "Ljdk/internal/vm/vector/VectorSupport$Vector;"                                                           \
+                                      "I"                                                                                                       \
+                                      "Ljdk/internal/vm/vector/VectorSupport$VectorPayload;"                                                    \
                                       "I"                                                                                                       \
                                       "Ljdk/internal/vm/vector/VectorSupport$VecExtractOp;)"                                                    \
                                       "J")                                                                                                      \
@@@ -1092,8 -1228,8 +1261,10 @@@
                                                                                                                                                 \
   do_intrinsic(_VectorInsert, jdk_internal_vm_vector_VectorSupport, vector_insert_name, vector_insert_sig, F_S)                                 \
     do_signature(vector_insert_sig, "(Ljava/lang/Class;"                                                                                        \
++				    "Ljava/lang/Class;"                                                                                        \
                                      "Ljava/lang/Class;"                                                                                        \
                                      "I"                                                                                                        \
++                                    "I"                                                                                                        \
                                      "Ljdk/internal/vm/vector/VectorSupport$Vector;"                                                            \
                                      "IJ"                                                                                                       \
                                      "Ljdk/internal/vm/vector/VectorSupport$VecInsertOp;)"                                                      \
@@@ -1105,6 -1241,6 +1276,8 @@@
                                             "Ljava/lang/Class;"                                                                                 \
                                             "Ljava/lang/Class;"                                                                                 \
                                             "Ljava/lang/Class;"                                                                                 \
++                                           "Ljava/lang/Class;"                                                                                 \
++                                           "I"                                                                                                 \
                                             "I"                                                                                                 \
                                             "Ljdk/internal/vm/vector/VectorSupport$Vector;"                                                     \
                                             "I"                                                                                                 \
@@@ -1131,8 -1267,9 +1304,11 @@@
      do_signature(vector_gather_sig, "(Ljava/lang/Class;"                                                                                       \
                                       "Ljava/lang/Class;"                                                                                       \
                                       "Ljava/lang/Class;"                                                                                       \
++                                     "Ljava/lang/Class;"                                                                                       \
++                                     "I"                                                                                                       \
                                       "I"                                                                                                       \
                                       "Ljava/lang/Class;"                                                                                       \
+                                      "I"                                                                                                       \
                                       "Ljava/lang/Object;"                                                                                      \
                                       "J"                                                                                                       \
                                       "Ljdk/internal/vm/vector/VectorSupport$Vector;"                                                           \
@@@ -1146,10 -1286,11 +1325,13 @@@
                                                                                                                                                 \
     do_intrinsic(_VectorScatterOp, jdk_internal_vm_vector_VectorSupport, vector_scatter_name, vector_scatter_sig, F_S)                          \
      do_signature(vector_scatter_sig, "(Ljava/lang/Class;"                                                                                      \
++                                      "Ljava/lang/Class;"                                                                                      \
                                        "Ljava/lang/Class;"                                                                                      \
                                        "Ljava/lang/Class;"                                                                                      \
                                        "I"                                                                                                      \
++                                      "I"                                                                                                      \
                                        "Ljava/lang/Class;"                                                                                      \
+                                       "I"                                                                                                      \
                                        "Ljava/lang/Object;"                                                                                     \
                                        "J"                                                                                                      \
                                        "Ljdk/internal/vm/vector/VectorSupport$Vector;"                                                          \
@@@ -1169,6 -1310,6 +1351,8 @@@
      do_signature(vector_mask_oper_sig, "(I"                                                                                                    \
                                          "Ljava/lang/Class;"                                                                                    \
                                          "Ljava/lang/Class;"                                                                                    \
++                                        "Ljava/lang/Class;"                                                                                    \
++                                        "I"                                                                                                    \
                                          "I"                                                                                                    \
                                          "Ljdk/internal/vm/vector/VectorSupport$VectorMask;"                                                    \
                                          "Ljdk/internal/vm/vector/VectorSupport$VectorMaskOp;)"                                                 \
@@@ -1180,6 -1321,6 +1364,8 @@@
                                        "Ljava/lang/Class;"                                                                                      \
                                        "Ljava/lang/Class;"                                                                                      \
                                        "Ljava/lang/Class;"                                                                                      \
++                                      "Ljava/lang/Class;"                                                                                      \
++                                      "I"                                                                                                      \
                                        "I"                                                                                                      \
                                        "Ljdk/internal/vm/vector/VectorSupport$Vector;"                                                          \
                                        "Ljdk/internal/vm/vector/VectorSupport$VectorMask;"                                                      \
@@@ -1189,8 -1330,8 +1375,10 @@@
                                                                                                                                                 \
    do_intrinsic(_IndexVector, jdk_internal_vm_vector_VectorSupport, index_vector_op_name, index_vector_op_sig, F_S)                             \
      do_signature(index_vector_op_sig, "(Ljava/lang/Class;"                                                                                     \
 +                                       "Ljava/lang/Class;"                                                                                     \
+                                        "Ljava/lang/Class;"                                                                                     \
+                                        "I"                                                                                                     \
 +                                       "I"                                                                                                     \
                                         "Ljdk/internal/vm/vector/VectorSupport$Vector;"                                                         \
                                         "I"                                                                                                     \
                                         "Ljdk/internal/vm/vector/VectorSupport$VectorSpecies;"                                                  \
@@@ -1201,6 -1342,6 +1389,8 @@@
    do_intrinsic(_IndexPartiallyInUpperRange, jdk_internal_vm_vector_VectorSupport, index_partially_in_upper_range_name, index_partially_in_upper_range_sig, F_S)\
      do_signature(index_partially_in_upper_range_sig, "(Ljava/lang/Class;"                                                                                      \
                                                       "Ljava/lang/Class;"                                                                                       \
++                                                     "Ljava/lang/Class;"                                                                                       \
++                                                     "I"                                                                                                       \
                                                       "I"                                                                                                       \
                                                       "J"                                                                                                       \
                                                       "J"                                                                                                       \
diff --cc src/hotspot/share/classfile/vmSymbols.hpp
index caf6788c028,06f27f09c5c..b24522fc890
--- a/src/hotspot/share/classfile/vmSymbols.hpp
+++ b/src/hotspot/share/classfile/vmSymbols.hpp
@@@ -96,6 -99,6 +99,7 @@@ class SerializeClosure
    template(jdk_internal_vm_vector_VectorShuffle,      "jdk/internal/vm/vector/VectorSupport$VectorShuffle") \
    template(payload_name,                              "payload")                                            \
    template(ETYPE_name,                                "ETYPE")                                              \
++  template(CTYPE_name,                                "CTYPE")                                              \
    template(VLENGTH_name,                              "VLENGTH")                                            \
                                                                                                    \
    template(jdk_internal_vm_FillerObject,              "jdk/internal/vm/FillerObject")             \
diff --cc src/hotspot/share/opto/classes.hpp
index 0b42766ab3c,587d5fad8f2..fc83344419c
--- a/src/hotspot/share/opto/classes.hpp
+++ b/src/hotspot/share/opto/classes.hpp
@@@ -130,6 -131,6 +131,8 @@@ macro(GetAndSetI
  macro(GetAndSetL)
  macro(GetAndSetP)
  macro(GetAndSetN)
++macro(CMoveVF)
++macro(CMoveVD)
  macro(Con)
  macro(ConN)
  macro(ConNKlass)
@@@ -403,13 -412,14 +417,14 @@@ macro(MulVF
  macro(MulReductionVF)
  macro(MulVD)
  macro(MulReductionVD)
- macro(MulAddVS2VI)
  macro(MulVHF)
+ macro(MulAddVS2VI)
  macro(FmaVD)
  macro(FmaVF)
+ macro(FmaVHF)
 -macro(DivVHF)
  macro(DivVF)
  macro(DivVD)
 +macro(DivVHF)
  macro(AbsVB)
  macro(AbsVS)
  macro(AbsVI)
@@@ -421,9 -430,9 +436,10 @@@ macro(NegVI
  macro(NegVL)
  macro(NegVF)
  macro(NegVD)
 +macro(NegVHF)
  macro(SqrtVD)
  macro(SqrtVF)
+ macro(SqrtVHF)
  macro(LShiftCntV)
  macro(RShiftCntV)
  macro(LShiftVB)
diff --cc src/hotspot/share/opto/convertnode.hpp
index a6b2f69ccac,7035573589d..52e8226edf8
--- a/src/hotspot/share/opto/convertnode.hpp
+++ b/src/hotspot/share/opto/convertnode.hpp
@@@ -44,38 -60,25 +60,39 @@@ public
  // The conversions operations are all Alpha sorted.  Please keep it that way!
  //------------------------------ConvD2FNode------------------------------------
  // Convert double to float
- class ConvD2FNode : public Node {
+ class ConvD2FNode : public ConvertNode {
    public:
-   ConvD2FNode( Node *in1 ) : Node(0,in1) {}
 -  ConvD2FNode(Node* in1) : ConvertNode(Type::FLOAT,in1) {}
++  ConvD2FNode(Node* in1) : ConvertNode(Type::FLOAT, in1) {}
    virtual int Opcode() const;
-   virtual const Type *bottom_type() const { return Type::FLOAT; }
+   virtual const Type* in_type() const { return Type::DOUBLE; }
    virtual const Type* Value(PhaseGVN* phase) const;
    virtual Node* Identity(PhaseGVN* phase);
-   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
-   virtual uint  ideal_reg() const { return Op_RegF; }
+   virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);
  };
  
 +//------------------------------ConvD2HFNode------------------------------------
 +// Convert Double to Halffloat
- class ConvD2HFNode : public Node {
++class ConvD2HFNode : public ConvertNode {
 +  public:
-   ConvD2HFNode( Node *in1 ) : Node(0,in1) {}
++  ConvD2HFNode(Node* in1) : ConvertNode(TypeInt::SHORT, in1) {}
 +  virtual int Opcode() const;
-   virtual const Type *bottom_type() const { return TypeInt::SHORT; }
-   virtual uint  ideal_reg() const { return Op_RegI; }
++  virtual const Type* in_type() const { return Type::DOUBLE; }
++  /*FIXME
++   * virtual const Type* Value(PhaseGVN* phase) const;
++   * virtual Node* Identity(PhaseGVN* phase);
++   * virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);
++   */
 +};
 +
  //------------------------------ConvD2INode------------------------------------
  // Convert Double to Integer
- class ConvD2INode : public Node {
+ class ConvD2INode : public ConvertNode {
    public:
-   ConvD2INode( Node *in1 ) : Node(0,in1) {}
 -  ConvD2INode(Node* in1) : ConvertNode(TypeInt::INT,in1) {}
++  ConvD2INode(Node* in1) : ConvertNode(TypeInt::INT, in1) {}
    virtual int Opcode() const;
-   virtual const Type *bottom_type() const { return TypeInt::INT; }
+   virtual const Type* in_type() const { return Type::DOUBLE; }
    virtual const Type* Value(PhaseGVN* phase) const;
    virtual Node* Identity(PhaseGVN* phase);
-   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
-   virtual uint  ideal_reg() const { return Op_RegI; }
  };
  
  //------------------------------ConvD2LNode------------------------------------
@@@ -123,50 -115,34 +129,47 @@@ class ConvF2HFNode : public ConvertNod
  
  //------------------------------ConvF2INode------------------------------------
  // Convert float to integer
- class ConvF2INode : public Node {
-   public:
-   ConvF2INode( Node *in1 ) : Node(0,in1) {}
+ class ConvF2INode : public ConvertNode {
+ public:
+   ConvF2INode(Node* in1) : ConvertNode(TypeInt::INT, in1) {}
    virtual int Opcode() const;
-   virtual const Type *bottom_type() const { return TypeInt::INT; }
+   virtual const Type* in_type() const { return TypeInt::FLOAT; }
    virtual const Type* Value(PhaseGVN* phase) const;
    virtual Node* Identity(PhaseGVN* phase);
-   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
-   virtual uint  ideal_reg() const { return Op_RegI; }
  };
  
- 
  //------------------------------ConvF2LNode------------------------------------
  // Convert float to long
- class ConvF2LNode : public Node {
-   public:
-   ConvF2LNode( Node *in1 ) : Node(0,in1) {}
+ class ConvF2LNode : public ConvertNode {
+ public:
+   ConvF2LNode(Node* in1) : ConvertNode(TypeLong::LONG, in1) {}
    virtual int Opcode() const;
-   virtual const Type *bottom_type() const { return TypeLong::LONG; }
+   virtual const Type* in_type() const { return TypeInt::FLOAT; }
    virtual const Type* Value(PhaseGVN* phase) const;
    virtual Node* Identity(PhaseGVN* phase);
-   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
-   virtual uint  ideal_reg() const { return Op_RegL; }
  };
  
 +//------------------------------ConvHF2DNode------------------------------------
 +// Convert Halffloat to Double
- class ConvHF2DNode : public Node {
++class ConvHF2DNode : public ConvertNode {
 +  public:
-   ConvHF2DNode( Node *in1 ) : Node(0,in1) {}
++  ConvHF2DNode(Node* in1) : ConvertNode(Type::DOUBLE, in1) {}
 +  virtual int Opcode() const;
-   virtual const Type *bottom_type() const { return Type::DOUBLE; }
-   virtual uint  ideal_reg() const { return Op_RegD; }
++  virtual const Type* in_type() const { return TypeInt::SHORT; }
++  /*
++   * virtual const Type* Value(PhaseGVN* phase) const;
++   * virtual Node* Identity(PhaseGVN* phase);
++   */
 +};
 +
  //------------------------------ConvHF2FNode------------------------------------
- // Convert Halffloat to Float
- class ConvHF2FNode : public Node {
-   public:
-   ConvHF2FNode( Node *in1 ) : Node(0,in1) {}
+ // Convert Halffloat to float
+ class ConvHF2FNode : public ConvertNode {
+ public:
+   ConvHF2FNode(Node* in1) : ConvertNode(Type::FLOAT, in1) {}
    virtual int Opcode() const;
-   virtual const Type *bottom_type() const { return Type::FLOAT; }
+   virtual const Type* in_type() const { return TypeInt::SHORT; }
    virtual const Type* Value(PhaseGVN* phase) const;
-   virtual uint  ideal_reg() const { return Op_RegF; }
  };
  
  //------------------------------ConvI2DNode------------------------------------
diff --cc src/hotspot/share/opto/vectorIntrinsics.cpp
index 60f07eb90da,10430a09e72..9cfac0c980e
--- a/src/hotspot/share/opto/vectorIntrinsics.cpp
+++ b/src/hotspot/share/opto/vectorIntrinsics.cpp
@@@ -42,7 -41,7 +41,7 @@@ static bool check_vbox(const TypeInstPt
    ciInstanceKlass* ik = vbox_type->instance_klass();
    assert(is_vector(ik), "not a vector");
  
--  ciField* fd1 = ik->get_field_by_name(ciSymbols::ETYPE_name(), ciSymbols::class_signature(), /* is_static */ true);
++  ciField* fd1 = ik->get_field_by_name(ciSymbols::CTYPE_name(), ciSymbols::class_signature(), /* is_static */ true);
    assert(fd1 != nullptr, "element type info is missing");
  
    ciConstant val1 = fd1->constant_value();
@@@ -323,41 -287,42 +287,51 @@@ static bool is_klass_initialized(const 
    return klass->is_initialized();
  }
  
--// public static
--// <V extends Vector<E>,
--//  M extends VectorMask<E>,
--//  E>
--// V unaryOp(int oprId, Class<? extends V> vmClass, Class<? extends M> maskClass, Class<E> elementType,
--//           int length, V v, M m,
--//           UnaryOperation<V, M> defaultImpl)
  //
--// public static
--// <V,
--//  M extends VectorMask<E>,
--//  E>
--// V binaryOp(int oprId, Class<? extends V> vmClass, Class<? extends M> maskClass, Class<E> elementType,
--//            int length, V v1, V v2, M m,
--//            BinaryOperation<V, M> defaultImpl)
++//  public static
++//  <V extends Vector<E>,
++//   M extends VectorMask<E>,
++//   E>
++//  V unaryOp(int oprId,
++//            Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,
++//            int length,
++//            V v, M m,
++//            UnaryOperation<V, M> defaultImpl) {
++//
++//  public static
++//  <VM extends VectorPayload,
++//   M extends VectorMask<E>,
++//   E>
++//  VM binaryOp(int oprId,
++//              Class<? extends VM> vmClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,
++//              int length,
++//              VM v1, VM v2, M m,
++//              BinaryOperation<VM, M> defaultImpl) {
++//
++//
++//  public static
++//  <V extends Vector<E>,
++//   M extends VectorMask<E>,
++//   E>
++//  V ternaryOp(int oprId,
++//              Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,
++//              int length,
++//              V v1, V v2, V v3, M m,
++//              TernaryOperation<V, M> defaultImpl) {
  //
--// public static
--// <V extends Vector<E>,
--//  M extends VectorMask<E>,
--//  E>
--// V ternaryOp(int oprId, Class<? extends V> vmClass, Class<? extends M> maskClass, Class<E> elementType,
--//             int length, V v1, V v2, V v3, M m,
--//             TernaryOperation<V, M> defaultImpl)
  //
  bool LibraryCallKit::inline_vector_nary_operation(int n) {
    const TypeInt*     opr          = gvn().type(argument(0))->isa_int();
    const TypeInstPtr* vector_klass = gvn().type(argument(1))->isa_instptr();
    const TypeInstPtr* mask_klass   = gvn().type(argument(2))->isa_instptr();
    const TypeInstPtr* elem_klass   = gvn().type(argument(3))->isa_instptr();
--  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();
++  const TypeInt*     vlen         = gvn().type(argument(6))->isa_int();
  
-   if (opr == nullptr || vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr ||
-       !opr->is_con() || vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !vlen->is_con()) {
-     if (C->print_intrinsics()) {
-       tty->print_cr("  ** missing constant: opr=%s vclass=%s etype=%s vlen=%s",
+   if (opr          == nullptr || !opr->is_con() ||
+       vector_klass == nullptr || vector_klass->const_oop() == nullptr ||
+       elem_klass   == nullptr || elem_klass->const_oop()   == nullptr ||
+       vlen         == nullptr || !vlen->is_con()) {
+     log_if_needed("  ** missing constant: opr=%s vclass=%s etype=%s vlen=%s",
                      NodeClassNames[argument(0)->Opcode()],
                      NodeClassNames[argument(1)->Opcode()],
                      NodeClassNames[argument(3)->Opcode()],
@@@ -382,7 -342,7 +351,7 @@@
  
    // "argument(n + 5)" should be the mask object. We assume it is "null" when no mask
    // is used to control this operation.
--  const Type* vmask_type = gvn().type(argument(n + 5));
++  const Type* vmask_type = gvn().type(argument(n + 7));
    bool is_masked_op = vmask_type != TypePtr::NULL_PTR;
    if (is_masked_op) {
      if (mask_klass == nullptr || mask_klass->const_oop() == nullptr) {
@@@ -480,34 -401,28 +410,28 @@@
    Node* opd1 = nullptr; Node* opd2 = nullptr; Node* opd3 = nullptr;
    switch (n) {
      case 3: {
--      opd3 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);
++      opd3 = unbox_vector(argument(9), vbox_type, elem_bt, num_elem);
        if (opd3 == nullptr) {
-         if (C->print_intrinsics()) {
-           tty->print_cr("  ** unbox failed v3=%s",
+         log_if_needed("  ** unbox failed v3=%s",
                          NodeClassNames[argument(7)->Opcode()]);
-         }
          return false;
        }
        // fall-through
      }
      case 2: {
--      opd2 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);
++      opd2 = unbox_vector(argument(8), vbox_type, elem_bt, num_elem);
        if (opd2 == nullptr) {
-         if (C->print_intrinsics()) {
-           tty->print_cr("  ** unbox failed v2=%s",
+         log_if_needed("  ** unbox failed v2=%s",
                          NodeClassNames[argument(6)->Opcode()]);
-         }
          return false;
        }
        // fall-through
      }
      case 1: {
--      opd1 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);
++      opd1 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);
        if (opd1 == nullptr) {
-         if (C->print_intrinsics()) {
-           tty->print_cr("  ** unbox failed v1=%s",
+         log_if_needed("  ** unbox failed v1=%s",
                          NodeClassNames[argument(5)->Opcode()]);
-         }
          return false;
        }
        break;
@@@ -520,12 -435,10 +444,10 @@@
      ciKlass* mbox_klass = mask_klass->const_oop()->as_instance()->java_lang_Class_klass();
      assert(is_vector_mask(mbox_klass), "argument(2) should be a mask class");
      const TypeInstPtr* mbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, mbox_klass);
--    mask = unbox_vector(argument(n + 5), mbox_type, elem_bt, num_elem);
++    mask = unbox_vector(argument(n + 7), mbox_type, elem_bt, num_elem);
      if (mask == nullptr) {
-       if (C->print_intrinsics()) {
-         tty->print_cr("  ** unbox failed mask=%s",
-                       NodeClassNames[argument(n + 5)->Opcode()]);
-       }
+       log_if_needed("  ** unbox failed mask=%s",
 -                      NodeClassNames[argument(n + 5)->Opcode()]);
++                      NodeClassNames[argument(n + 7)->Opcode()]);
        return false;
      }
    }
@@@ -578,17 -477,123 +486,132 @@@
    return true;
  }
  
- // <E, M>
- // long maskReductionCoerced(int oper, Class<? extends M> maskClass, Class<?> elemClass,
- //                          int length, M m, VectorMaskOp<M> defaultImpl)
 -// public static
 -// <V extends Vector<E>, E>
 -// V libraryUnaryOp(long address, Class<? extends V> vClass, Class<E> elementType, int length, String debugName,
 -//                  V v,
 -//                  UnaryOperation<V, ?> defaultImpl)
+ //
 -// public static
 -// <V extends VectorPayload, E>
 -// V libraryBinaryOp(long address, Class<? extends V> vClass, Class<E> elementType, int length, String debugName,
 -//            V v1, V v2,
 -//            BinaryOperation<V, ?> defaultImpl)
++//  public static
++//  <V extends Vector<E>, E>
++//  V libraryUnaryOp(long addr, Class<? extends V> vClass, Class<?> cClass, Class<E> eClass, int operType, int length, String debugName,
++//                   V v,
++//                   UnaryOperation<V,?> defaultImpl)
++//
++//  public static
++//  <V extends VectorPayload, E>
++//  V libraryBinaryOp(long addr, Class<? extends V> vClass, Class<?> cClass, Class<E> eClass, int operType, int length, String debugName,
++//                    V v1, V v2,
++//                    BinaryOperation<V,?> defaultImpl) 
++//
+ bool LibraryCallKit::inline_vector_call(int arity) {
+   assert(Matcher::supports_vector_calling_convention(), "required");
+ 
+   const TypeLong*    entry          = gvn().type(argument(0))->isa_long();
+   const TypeInstPtr* vector_klass   = gvn().type(argument(2))->isa_instptr();
+   const TypeInstPtr* elem_klass     = gvn().type(argument(3))->isa_instptr();
 -  const TypeInt*     vlen           = gvn().type(argument(4))->isa_int();
 -  const TypeInstPtr* debug_name_oop = gvn().type(argument(5))->isa_instptr();
++  const TypeInt*     vlen           = gvn().type(argument(6))->isa_int();
++  const TypeInstPtr* debug_name_oop = gvn().type(argument(7))->isa_instptr();
+ 
+   if (entry        == nullptr   || !entry->is_con() ||
+       vector_klass == nullptr   || vector_klass->const_oop() == nullptr ||
+       elem_klass   == nullptr   || elem_klass->const_oop() == nullptr ||
+       vlen         == nullptr   || !vlen->is_con() ||
+       debug_name_oop == nullptr || debug_name_oop->const_oop() == nullptr) {
+     log_if_needed("  ** missing constant: opr=%s vclass=%s etype=%s vlen=%s debug_name=%s",
+                   NodeClassNames[argument(0)->Opcode()],
+                   NodeClassNames[argument(2)->Opcode()],
+                   NodeClassNames[argument(3)->Opcode()],
 -                  NodeClassNames[argument(4)->Opcode()],
 -                  NodeClassNames[argument(5)->Opcode()]);
++                  NodeClassNames[argument(6)->Opcode()],
++                  NodeClassNames[argument(7)->Opcode()]);
+     return false; // not enough info for intrinsification
+   }
+ 
+   if (entry->get_con() == 0) {
+     log_if_needed("  ** missing entry point");
+     return false;
+   }
+ 
+   ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();
+   if (!elem_type->is_primitive_type()) {
+     log_if_needed("  ** not a primitive bt=%d", elem_type->basic_type());
+     return false; // should be primitive type
+   }
+   if (!is_klass_initialized(vector_klass)) {
+     log_if_needed("  ** klass argument not initialized");
+     return false;
+   }
+ 
+   BasicType elem_bt = elem_type->basic_type();
+   int num_elem = vlen->get_con();
+   if (!Matcher::vector_size_supported(elem_bt, num_elem)) {
+     log_if_needed("  ** vector size (vlen=%d, etype=%s) is not supported",
+                   num_elem, type2name(elem_bt));
+     return false;
+   }
+ 
+   ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();
+   const TypeInstPtr* vbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);
+ 
 -  Node* opd1 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);
++  Node* opd1 = unbox_vector(argument(8), vbox_type, elem_bt, num_elem);
+   if (opd1 == nullptr) {
 -    log_if_needed("  ** unbox failed v1=%s", NodeClassNames[argument(6)->Opcode()]);
++    log_if_needed("  ** unbox failed v1=%s", NodeClassNames[argument(8)->Opcode()]);
+     return false;
+   }
+ 
+   Node* opd2 = nullptr;
+   if (arity > 1) {
 -    opd2 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);
++    opd2 = unbox_vector(argument(9), vbox_type, elem_bt, num_elem);
+     if (opd2 == nullptr) {
 -      log_if_needed("  ** unbox failed v2=%s", NodeClassNames[argument(7)->Opcode()]);
++      log_if_needed("  ** unbox failed v2=%s", NodeClassNames[argument(9)->Opcode()]);
+       return false;
+     }
+   }
+   assert(arity == 1 || arity == 2, "arity %d not supported", arity);
+   const TypeVect* vt = TypeVect::make(elem_bt, num_elem);
+   const TypeFunc* call_type = OptoRuntime::Math_Vector_Vector_Type(arity, vt, vt);
+   address entry_addr = (address)entry->get_con();
+ 
+   const char* debug_name = "<unknown>";
+   if (!debug_name_oop->const_oop()->is_null_object()) {
+     size_t buflen = 100;
+     char* buf = NEW_ARENA_ARRAY(C->comp_arena(), char, buflen);
+     debug_name = debug_name_oop->const_oop()->as_instance()->java_lang_String_str(buf, buflen);
+   }
+   Node* vcall = make_runtime_call(RC_VECTOR,
+                                   call_type,
+                                   entry_addr,
+                                   debug_name,
+                                   TypePtr::BOTTOM,
+                                   opd1,
+                                   opd2);
+ 
+   vcall = gvn().transform(new ProjNode(gvn().transform(vcall), TypeFunc::Parms));
+ 
+   // Wrap it up in VectorBox to keep object type information.
+   Node* vbox = box_vector(vcall, vbox_type, elem_bt, num_elem);
+   set_result(vbox);
+   C->set_max_vector_size(MAX2(C->max_vector_size(), (uint)(num_elem * type2aelembytes(elem_bt))));
+   return true;
+ }
+ 
 -// <E, M>
 -// long maskReductionCoerced(int oper, Class<? extends M> maskClass, Class<?> elemClass,
 -//                          int length, M m, VectorMaskOp<M> defaultImpl)
++//
++//  public static
++//  <M extends VectorMask<E>,
++//   E>
++//  long maskReductionCoerced(int oper,
++//                            Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,
++//                            int length,
++//                            M m,
++//                            VectorMaskOp<M> defaultImpl)
++//
  bool LibraryCallKit::inline_vector_mask_operation() {
    const TypeInt*     oper       = gvn().type(argument(0))->isa_int();
    const TypeInstPtr* mask_klass = gvn().type(argument(1))->isa_instptr();
    const TypeInstPtr* elem_klass = gvn().type(argument(2))->isa_instptr();
--  const TypeInt*     vlen       = gvn().type(argument(3))->isa_int();
--  Node*              mask       = argument(4);
- 
-   if (mask_klass == nullptr || elem_klass == nullptr || mask->is_top() || vlen == nullptr) {
++  const TypeInt*     vlen       = gvn().type(argument(5))->isa_int();
++  Node*              mask       = argument(6);
+ 
+   if (mask_klass == nullptr || mask_klass->const_oop() == nullptr ||
+       elem_klass == nullptr || elem_klass->const_oop() == nullptr ||
+       vlen       == nullptr || !vlen->is_con() ||
+       oper       == nullptr || !oper->is_con() ||
+       mask->is_top()) {
      return false; // dead code
    }
  
@@@ -623,10 -617,8 +641,8 @@@
    const TypeInstPtr* mask_box_type = TypeInstPtr::make_exact(TypePtr::NotNull, mbox_klass);
    Node* mask_vec = unbox_vector(mask, mask_box_type, elem_bt, num_elem);
    if (mask_vec == nullptr) {
-     if (C->print_intrinsics()) {
-         tty->print_cr("  ** unbox failed mask=%s",
-                       NodeClassNames[argument(4)->Opcode()]);
-     }
+     log_if_needed("  ** unbox failed mask=%s",
 -                      NodeClassNames[argument(4)->Opcode()]);
++                      NodeClassNames[argument(6)->Opcode()]);
      return false;
    }
  
@@@ -644,33 -636,33 +660,36 @@@
    return true;
  }
  
--// public static
--// <M,
--//  S extends VectorSpecies<E>,
--//  E>
--// M fromBitsCoerced(Class<? extends M> vmClass, Class<E> elementType, int length,
--//                    long bits, int mode, S s,
--//                    BroadcastOperation<M, E, S> defaultImpl)
++//
++//  public static
++//  <VM extends VectorPayload,
++//   S extends VectorSpecies<E>,
++//   E>
++//  VM fromBitsCoerced(Class<? extends VM> vmClass, Class<?> cClass, Class<E> eClass, int operType,
++//                     int length,
++//                     long bits, int mode, S s,
++//                     FromBitsCoercedOperation<VM, S> defaultImpl)
++//
  bool LibraryCallKit::inline_vector_frombits_coerced() {
    const TypeInstPtr* vector_klass = gvn().type(argument(0))->isa_instptr();
    const TypeInstPtr* elem_klass   = gvn().type(argument(1))->isa_instptr();
--  const TypeInt*     vlen         = gvn().type(argument(2))->isa_int();
--  const TypeLong*    bits_type    = gvn().type(argument(3))->isa_long();
++  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();
++  const TypeLong*    bits_type    = gvn().type(argument(5))->isa_long();
    // Mode argument determines the mode of operation it can take following values:-
    // MODE_BROADCAST for vector Vector.broadcast and VectorMask.maskAll operations.
    // MODE_BITS_COERCED_LONG_TO_MASK for VectorMask.fromLong operation.
--  const TypeInt*     mode         = gvn().type(argument(5))->isa_int();
- 
-   if (vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr || mode == nullptr ||
-       bits_type == nullptr || vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr ||
-       !vlen->is_con() || !mode->is_con()) {
-     if (C->print_intrinsics()) {
-       tty->print_cr("  ** missing constant: vclass=%s etype=%s vlen=%s bitwise=%s",
++  const TypeInt*     mode         = gvn().type(argument(7))->isa_int();
+ 
+   if (vector_klass == nullptr || vector_klass->const_oop() == nullptr ||
+       elem_klass   == nullptr || elem_klass->const_oop()   == nullptr ||
+       vlen         == nullptr || !vlen->is_con() ||
+       bits_type    == nullptr ||
+       mode         == nullptr || !mode->is_con()) {
+     log_if_needed("  ** missing constant: vclass=%s etype=%s vlen=%s bitwise=%s",
                      NodeClassNames[argument(0)->Opcode()],
                      NodeClassNames[argument(1)->Opcode()],
--                    NodeClassNames[argument(2)->Opcode()],
--                    NodeClassNames[argument(5)->Opcode()]);
-     }
++                    NodeClassNames[argument(4)->Opcode()],
++                    NodeClassNames[argument(7)->Opcode()]);
      return false; // not enough info for intrinsification
    }
  
@@@ -707,8 -703,7 +730,7 @@@
    }
  
    Node* broadcast = nullptr;
--  Node* bits = argument(3);
++  Node* bits = argument(5);
    Node* elem = bits;
  
    if (opc == Op_VectorLongToMask) {
@@@ -771,38 -766,41 +793,43 @@@ static bool elem_consistent_with_arr(Ba
    }
  }
  
- // public static
- // <C,
- //  VM,
- //  E,
- //  S extends VectorSpecies<E>>
- // VM load(Class<? extends VM> vmClass, Class<E> elementType, int length,
- //         Object base, long offset,    // Unsafe addressing
- //         C container, long index, S s,     // Arguments for default implementation
- //         LoadOperation<C, VM, E, S> defaultImpl)
 +//
- // public static
- // <C,
- //  V extends Vector<?>>
- // void store(Class<?> vectorClass, Class<?> elementType, int length,
- //            Object base, long offset,    // Unsafe addressing
- //            V v,
- //            C container, long index,      // Arguments for default implementation
- //            StoreVectorOperation<C, V> defaultImpl)
- 
+ //  public static
+ //  <C,
+ //   VM extends VectorPayload,
+ //   E,
+ //   S extends VectorSpecies<E>>
 -//  VM load(Class<? extends VM> vmClass, Class<E> eClass,
++//  VM load(Class<? extends VM> vmClass, Class<?> cClass, Class<E> eClass, int operType,
+ //          int length,
 -//          Object base, long offset,            // Unsafe addressing
 -//          boolean fromSegment,
 -//          C container, long index, S s,        // Arguments for default implementation
 -//          LoadOperation<C, VM, S> defaultImpl) {
++//          Object base, long offset, boolean fromSegment,
++//          C container, long index, S s,
++//          LoadOperation<C, VM, S> defaultImpl)
++//
++//
+ //  public static
+ //  <C,
+ //   V extends VectorPayload>
 -//  void store(Class<?> vClass, Class<?> eClass,
++//  void store(Class<?> vClass, Class<?> cClass, Class<?> eClass, int operType,
+ //             int length,
 -//             Object base, long offset,        // Unsafe addressing
 -//             boolean fromSegment,
 -//             V v, C container, long index,    // Arguments for default implementation
 -//             StoreVectorOperation<C, V> defaultImpl) {
++//             Object base, long offset, boolean fromSegment,
++//             V v, C container, long index,
++//             StoreVectorOperation<C, V> defaultImpl)
++//
  bool LibraryCallKit::inline_vector_mem_operation(bool is_store) {
    const TypeInstPtr* vector_klass = gvn().type(argument(0))->isa_instptr();
    const TypeInstPtr* elem_klass   = gvn().type(argument(1))->isa_instptr();
--  const TypeInt*     vlen         = gvn().type(argument(2))->isa_int();
 -  const TypeInt*     from_ms      = gvn().type(argument(6))->isa_int();
++  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();
++  const TypeInt*     from_ms      = gvn().type(argument(8))->isa_int();
  
-   if (vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr ||
-       vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !vlen->is_con()) {
-     if (C->print_intrinsics()) {
-       tty->print_cr("  ** missing constant: vclass=%s etype=%s vlen=%s",
+   if (vector_klass == nullptr || vector_klass->const_oop() == nullptr ||
+       elem_klass   == nullptr || elem_klass->const_oop()   == nullptr ||
+       vlen         == nullptr || !vlen->is_con() ||
+       from_ms      == nullptr || !from_ms->is_con()) {
+     log_if_needed("  ** missing constant: vclass=%s etype=%s vlen=%s from_ms=%s",
                      NodeClassNames[argument(0)->Opcode()],
                      NodeClassNames[argument(1)->Opcode()],
-                     NodeClassNames[argument(2)->Opcode()]);
-     }
 -                    NodeClassNames[argument(2)->Opcode()],
 -                    NodeClassNames[argument(6)->Opcode()]);
++                    NodeClassNames[argument(4)->Opcode()],
++                    NodeClassNames[argument(8)->Opcode()]);
      return false; // not enough info for intrinsification
    }
    if (!is_klass_initialized(vector_klass)) {
@@@ -835,12 -827,11 +856,11 @@@
    ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();
    bool is_mask = is_vector_mask(vbox_klass);
  
--  Node* base = argument(3);
--  Node* offset = ConvL2X(argument(4));
++  Node* base = argument(5);
++  Node* offset = ConvL2X(argument(6));
  
    // Save state and restore on bailout
-   uint old_sp = sp();
-   SafePointNode* old_map = clone_map();
+   SavedState old_state(this);
  
    Node* addr = make_unsafe_address(base, offset, (is_mask ? T_BOOLEAN : elem_bt), true);
  
@@@ -912,10 -910,8 +939,8 @@@
    }
  
    if (is_store) {
-     Node* val = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);
 -    Node* val = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);
++    Node* val = unbox_vector(argument(9), vbox_type, elem_bt, num_elem);
      if (val == nullptr) {
-       set_map(old_map);
-       set_sp(old_sp);
        return false; // operand unboxing failed
      }
      set_all_memory(reset_memory());
@@@ -963,44 -958,48 +987,49 @@@
    return true;
  }
  
- // public static
- // <C,
- //  V extends Vector<?>,
- //  E,
- //  S extends VectorSpecies<E>,
- //  M extends VectorMask<E>>
- // V loadMasked(Class<? extends V> vectorClass, Class<M> maskClass, Class<E> elementType,
- //              int length, Object base, long offset, M m, int offsetInRange,
- //              C container, long index, S s,  // Arguments for default implementation
- //              LoadVectorMaskedOperation<C, V, S, M> defaultImpl) {
 +//
- // public static
- // <C,
- //  V extends Vector<E>,
- //  M extends VectorMask<E>,
- //  E>
- // void storeMasked(Class<? extends V> vectorClass, Class<M> maskClass, Class<E> elementType,
- //                  int length, Object base, long offset,
- //                  V v, M m,
- //                  C container, long index,  // Arguments for default implementation
- //                  StoreVectorMaskedOperation<C, V, M, E> defaultImpl) {
+ //  public static
+ //  <C,
+ //   V extends Vector<?>,
+ //   E,
+ //   S extends VectorSpecies<E>,
+ //   M extends VectorMask<E>>
 -//  V loadMasked(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,
 -//               int length, Object base, long offset,          // Unsafe addressing
 -//               boolean fromSegment,
++//  V loadMasked(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,
++//               int length, Object base, long offset, boolean fromSegment,
+ //               M m, int offsetInRange,
 -//               C container, long index, S s,                  // Arguments for default implementation
 -//               LoadVectorMaskedOperation<C, V, S, M> defaultImpl) {
++//               C container, long index, S s,
++//               LoadVectorMaskedOperation<C, V, S, M> defaultImpl)
++//
+ //  public static
+ //  <C,
+ //   V extends Vector<E>,
+ //   M extends VectorMask<E>,
+ //   E>
 -//  void storeMasked(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,
++//  void storeMasked(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,
+ //                   int length,
 -//                   Object base, long offset,                  // Unsafe addressing
 -//                   boolean fromSegment,
 -//                   V v, M m, C container, long index,         // Arguments for default implementation
 -//                   StoreVectorMaskedOperation<C, V, M> defaultImpl) {
++//                   Object base, long offset, boolean fromSegment,
++//                   V v, M m, C container, long index,
++//                   StoreVectorMaskedOperation<C, V, M> defaultImpl)
 +//
+ 
  bool LibraryCallKit::inline_vector_mem_masked_operation(bool is_store) {
    const TypeInstPtr* vector_klass = gvn().type(argument(0))->isa_instptr();
    const TypeInstPtr* mask_klass   = gvn().type(argument(1))->isa_instptr();
    const TypeInstPtr* elem_klass   = gvn().type(argument(2))->isa_instptr();
--  const TypeInt*     vlen         = gvn().type(argument(3))->isa_int();
- 
-   if (vector_klass == nullptr || mask_klass == nullptr || elem_klass == nullptr || vlen == nullptr ||
-       vector_klass->const_oop() == nullptr || mask_klass->const_oop() == nullptr ||
-       elem_klass->const_oop() == nullptr || !vlen->is_con()) {
-     if (C->print_intrinsics()) {
-       tty->print_cr("  ** missing constant: vclass=%s mclass=%s etype=%s vlen=%s",
 -  const TypeInt*     from_ms      = gvn().type(argument(7))->isa_int();
++  const TypeInt*     vlen         = gvn().type(argument(5))->isa_int();
++  const TypeInt*     from_ms      = gvn().type(argument(9))->isa_int();
+ 
+   if (vector_klass == nullptr || vector_klass->const_oop() == nullptr ||
+       mask_klass   == nullptr || mask_klass->const_oop()   == nullptr ||
+       elem_klass   == nullptr || elem_klass->const_oop()   == nullptr ||
+       vlen         == nullptr || !vlen->is_con() ||
+       from_ms      == nullptr || !from_ms->is_con()) {
+     log_if_needed("  ** missing constant: vclass=%s mclass=%s etype=%s vlen=%s from_ms=%s",
                      NodeClassNames[argument(0)->Opcode()],
                      NodeClassNames[argument(1)->Opcode()],
                      NodeClassNames[argument(2)->Opcode()],
-                     NodeClassNames[argument(3)->Opcode()]);
-     }
 -                    NodeClassNames[argument(3)->Opcode()],
 -                    NodeClassNames[argument(7)->Opcode()]);
++                    NodeClassNames[argument(5)->Opcode()],
++                    NodeClassNames[argument(9)->Opcode()]);
      return false; // not enough info for intrinsification
    }
    if (!is_klass_initialized(vector_klass)) {
@@@ -1028,12 -1021,11 +1051,11 @@@
    BasicType elem_bt = elem_type->basic_type();
    int num_elem = vlen->get_con();
  
--  Node* base = argument(4);
--  Node* offset = ConvL2X(argument(5));
++  Node* base = argument(6);
++  Node* offset = ConvL2X(argument(7));
  
    // Save state and restore on bailout
-   uint old_sp = sp();
-   SafePointNode* old_map = clone_map();
+   SavedState old_state(this);
  
    Node* addr = make_unsafe_address(base, offset, elem_bt, true);
    const TypePtr *addr_type = gvn().type(addr)->isa_ptr();
@@@ -1067,14 -1055,10 +1085,10 @@@
        needs_predicate = true;
      } else {
        // Masked vector load with IOOBE always uses the predicated load.
-       const TypeInt* offset_in_range = gvn().type(argument(8))->isa_int();
 -      const TypeInt* offset_in_range = gvn().type(argument(9))->isa_int();
++      const TypeInt* offset_in_range = gvn().type(argument(11))->isa_int();
        if (!offset_in_range->is_con()) {
-         if (C->print_intrinsics()) {
-           tty->print_cr("  ** missing constant: offsetInRange=%s",
-                         NodeClassNames[argument(8)->Opcode()]);
-         }
-         set_map(old_map);
-         set_sp(old_sp);
+         log_if_needed("  ** missing constant: offsetInRange=%s",
 -                        NodeClassNames[argument(8)->Opcode()]);
++                        NodeClassNames[argument(10)->Opcode()]);
          return false;
        }
        needs_predicate = (offset_in_range->get_con() == 0);
@@@ -1145,27 -1113,19 +1143,19 @@@
    const TypeInstPtr* vbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);
    const TypeInstPtr* mbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, mbox_klass);
  
-   Node* mask = unbox_vector(is_store ? argument(8) : argument(7), mbox_type, elem_bt, num_elem);
 -  Node* mask = unbox_vector(is_store ? argument(9) : argument(8), mbox_type, elem_bt, num_elem);
++  Node* mask = unbox_vector(is_store ? argument(11) : argument(10), mbox_type, elem_bt, num_elem);
    if (mask == nullptr) {
-     if (C->print_intrinsics()) {
-       tty->print_cr("  ** unbox failed mask=%s",
-                     is_store ? NodeClassNames[argument(8)->Opcode()]
-                              : NodeClassNames[argument(7)->Opcode()]);
-     }
-     set_map(old_map);
-     set_sp(old_sp);
+     log_if_needed("  ** unbox failed mask=%s",
 -                    is_store ? NodeClassNames[argument(9)->Opcode()]
 -                             : NodeClassNames[argument(8)->Opcode()]);
++                    is_store ? NodeClassNames[argument(11)->Opcode()]
++                             : NodeClassNames[argument(10)->Opcode()]);
      return false;
    }
  
    if (is_store) {
-     Node* val = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);
 -    Node* val = unbox_vector(argument(8), vbox_type, elem_bt, num_elem);
++    Node* val = unbox_vector(argument(10), vbox_type, elem_bt, num_elem);
      if (val == nullptr) {
-       if (C->print_intrinsics()) {
-         tty->print_cr("  ** unbox failed vector=%s",
-                       NodeClassNames[argument(7)->Opcode()]);
-       }
-       set_map(old_map);
-       set_sp(old_sp);
+       log_if_needed("  ** unbox failed vector=%s",
 -                      NodeClassNames[argument(8)->Opcode()]);
++                      NodeClassNames[argument(10)->Opcode()]);
        return false; // operand unboxing failed
      }
      set_all_memory(reset_memory());
@@@ -1222,46 -1182,51 +1212,55 @@@
    return true;
  }
  
- // <C,
- //  V extends Vector<?>,
- //  W extends Vector<Integer>,
- //  S extends VectorSpecies<E>,
- //  M extends VectorMask<E>,
- //  E>
- // V loadWithMap(Class<? extends V> vectorClass, Class<M> maskClass, Class<E> elementType, int length,
- //               Class<? extends Vector<Integer>> vectorIndexClass,
- //               Object base, long offset, // Unsafe addressing
- //               W index_vector, M m,
- //               C container, int index, int[] indexMap, int indexM, S s, // Arguments for default implementation
- //               LoadVectorOperationWithMap<C, V, E, S, M> defaultImpl)
  //
++//  public static
+ //  <C,
+ //   V extends Vector<?>,
+ //   W extends Vector<Integer>,
+ //   S extends VectorSpecies<E>,
+ //   M extends VectorMask<E>,
+ //   E>
 -//   V loadWithMap(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass, int length,
 -//                 Class<? extends Vector<Integer>> vectorIndexClass, int indexLength,
 -//                 Object base, long offset,
 -//                 W indexVector1, W indexVector2, W indexVector3, W indexVector4,
 -//                 M m, C container, int index, int[] indexMap, int indexM, S s,
 -//                 LoadVectorOperationWithMap<C, V, S, M> defaultImpl)
 -//
++//  V loadWithMap(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,
++//                int length,
++//                Class<? extends Vector<Integer>> vectorIndexClass,
++//                int indexLength, Object base, long offset,
++//                W indexVector1, W indexVector2, W indexVector3, W indexVector4,
++//                M m, C container, int index, int[] indexMap, int indexM, S s,
++//                LoadVectorOperationWithMap<C, V, S, M> defaultImpl)
++//  public static
  //  <C,
  //   V extends Vector<E>,
  //   W extends Vector<Integer>,
  //   M extends VectorMask<E>,
  //   E>
- //  void storeWithMap(Class<? extends V> vectorClass, Class<M> maskClass, Class<E> elementType,
- //                    int length, Class<? extends Vector<Integer>> vectorIndexClass, Object base, long offset,    // Unsafe addressing
- //                    W index_vector, V v, M m,
- //                    C container, int index, int[] indexMap, int indexM, // Arguments for default implementation
- //                    StoreVectorOperationWithMap<C, V, M, E> defaultImpl)
 -//   void storeWithMap(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass, int length,
 -//                     Class<? extends Vector<Integer>> vectorIndexClass, int indexLength,
 -//                     Object base, long offset, // Unsafe addressing
 -//                     W indexVector, V v, M m,
 -//                     C container, int index, int[] indexMap, int indexM, // Arguments for default implementation
 -//                     StoreVectorOperationWithMap<C, V, M> defaultImpl)
++//  void storeWithMap(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,
++//                    int length,
++//                    Class<? extends Vector<Integer>> vectorIndexClass,
++//                    int indexLength, Object base, long offset,
++//                    W indexVector,
++//                    V v, M m, C container, int index, int[] indexMap, int indexM,
++//                    StoreVectorOperationWithMap<C, V, M> defaultImpl)
++//
  //
  bool LibraryCallKit::inline_vector_gather_scatter(bool is_scatter) {
    const TypeInstPtr* vector_klass     = gvn().type(argument(0))->isa_instptr();
    const TypeInstPtr* mask_klass       = gvn().type(argument(1))->isa_instptr();
    const TypeInstPtr* elem_klass       = gvn().type(argument(2))->isa_instptr();
--  const TypeInt*     vlen             = gvn().type(argument(3))->isa_int();
--  const TypeInstPtr* vector_idx_klass = gvn().type(argument(4))->isa_instptr();
- 
-   if (vector_klass == nullptr || elem_klass == nullptr || vector_idx_klass == nullptr || vlen == nullptr ||
-       vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || vector_idx_klass->const_oop() == nullptr || !vlen->is_con()) {
-     if (C->print_intrinsics()) {
-       tty->print_cr("  ** missing constant: vclass=%s etype=%s vlen=%s viclass=%s",
 -  const TypeInt*     idx_vlen         = gvn().type(argument(5))->isa_int();
++  const TypeInt*     vlen             = gvn().type(argument(5))->isa_int();
++  const TypeInstPtr* vector_idx_klass = gvn().type(argument(6))->isa_instptr();
++  const TypeInt*     idx_vlen         = gvn().type(argument(7))->isa_int();
+ 
+   if (vector_klass     == nullptr || vector_klass->const_oop()     == nullptr ||
+       elem_klass       == nullptr || elem_klass->const_oop()       == nullptr ||
+       vlen             == nullptr || !vlen->is_con() ||
+       vector_idx_klass == nullptr || vector_idx_klass->const_oop() == nullptr ||
+       idx_vlen         == nullptr || !idx_vlen->is_con()) {
+     log_if_needed("  ** missing constant: vclass=%s etype=%s vlen=%s viclass=%s idx_vlen=%s",
                      NodeClassNames[argument(0)->Opcode()],
                      NodeClassNames[argument(2)->Opcode()],
--                    NodeClassNames[argument(3)->Opcode()],
-                     NodeClassNames[argument(4)->Opcode()]);
-     }
 -                    NodeClassNames[argument(4)->Opcode()],
 -                    NodeClassNames[argument(5)->Opcode()]);
++                    NodeClassNames[argument(5)->Opcode()],
++                    NodeClassNames[argument(6)->Opcode()],
++                    NodeClassNames[argument(7)->Opcode()]);
      return false; // not enough info for intrinsification
    }
  
@@@ -1282,8 -1243,10 +1277,10 @@@
  
    BasicType elem_bt = elem_type->basic_type();
    int num_elem = vlen->get_con();
+   int idx_num_elem = idx_vlen->get_con();
  
-   const Type* vmask_type = gvn().type(is_scatter ? argument(10) : argument(9));
 -  Node* m = is_scatter ? argument(11) : argument(13);
++  Node* m = is_scatter ? argument(13) : argument(15);
+   const Type* vmask_type = gvn().type(m);
    bool is_masked_op = vmask_type != TypePtr::NULL_PTR;
    if (is_masked_op) {
      if (mask_klass == nullptr || mask_klass->const_oop() == nullptr) {
@@@ -1330,25 -1283,33 +1317,33 @@@
    }
  
    // Check that the vector holding indices is supported by architecture
-   if (!arch_supports_vector(Op_LoadVector, num_elem, T_INT, VecMaskNotUsed)) {
-       if (C->print_intrinsics()) {
-         tty->print_cr("  ** not supported: arity=%d op=%s/loadindex vlen=%d etype=int is_masked_op=%d",
-                       is_scatter, is_scatter ? "scatter" : "gather",
-                       num_elem, is_masked_op ? 1 : 0);
-       }
-       return false; // not supported
+   // For sub-word gathers expander receive index array.
+   if (!is_subword_type(elem_bt) && !arch_supports_vector(Op_LoadVector, idx_num_elem, T_INT, VecMaskNotUsed)) {
+     log_if_needed("  ** not supported: arity=%d op=%s/loadindex vlen=%d etype=int is_masked_op=%d",
+                   is_scatter, is_scatter ? "scatter" : "gather",
+                   idx_num_elem, is_masked_op ? 1 : 0);
+     return false; // not supported
    }
  
-   Node* base = argument(5);
-   Node* offset = ConvL2X(argument(6));
 -  Node* base = argument(6);
 -  Node* offset = ConvL2X(argument(7));
++  Node* base = argument(8);
++  Node* offset = ConvL2X(argument(9));
  
    // Save state and restore on bailout
-   uint old_sp = sp();
-   SafePointNode* old_map = clone_map();
+   SavedState old_state(this);
  
-   Node* addr = make_unsafe_address(base, offset, elem_bt, true);
+   Node* addr = nullptr;
+   if (!is_subword_type(elem_bt)) {
+     addr = make_unsafe_address(base, offset, elem_bt, true);
+   } else {
+     assert(!is_scatter, "Only supports gather operation for subword types now");
+     uint header = arrayOopDesc::base_offset_in_bytes(elem_bt);
+     assert(offset->is_Con() && offset->bottom_type()->is_long()->get_con() == header,
+            "offset must be the array base offset");
 -    Node* index = argument(15);
++    Node* index = argument(17);
+     addr = array_element_address(base, index, elem_bt);
+   }
  
-   const TypePtr *addr_type = gvn().type(addr)->isa_ptr();
+   const TypePtr* addr_type = gvn().type(addr)->isa_ptr();
    const TypeAryPtr* arr_type = addr_type->isa_aryptr();
  
    // The array must be consistent with vector type
@@@ -1370,16 -1327,22 +1361,22 @@@
      return false;
    }
  
+   // Get the indexes for gather/scatter.
+   Node* indexes = nullptr;
    const TypeInstPtr* vbox_idx_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_idx_klass);
-   Node* index_vect = unbox_vector(argument(8), vbox_idx_type, T_INT, num_elem);
-   if (index_vect == nullptr) {
-     set_map(old_map);
-     set_sp(old_sp);
-     return false;
+   if (is_subword_type(elem_bt)) {
 -    Node* indexMap = argument(16);
 -    Node* indexM   = argument(17);
++    Node* indexMap = argument(18);
++    Node* indexM   = argument(19);
+     indexes = array_element_address(indexMap, indexM, T_INT);
+   } else {
+     // Get the first index vector.
 -    indexes = unbox_vector(argument(9), vbox_idx_type, T_INT, idx_num_elem);
++    indexes = unbox_vector(argument(11), vbox_idx_type, T_INT, idx_num_elem);
+     if (indexes == nullptr) {
+       return false;
+     }
    }
  
+   // Get the vector mask value.
    Node* mask = nullptr;
    if (is_masked_op) {
      ciKlass* mbox_klass = mask_klass->const_oop()->as_instance()->java_lang_Class_klass();
@@@ -1399,10 -1356,8 +1390,8 @@@
  
    const TypeVect* vector_type = TypeVect::make(elem_bt, num_elem);
    if (is_scatter) {
-     Node* val = unbox_vector(argument(9), vbox_type, elem_bt, num_elem);
 -    Node* val = unbox_vector(argument(10), vbox_type, elem_bt, num_elem);
++    Node* val = unbox_vector(argument(12), vbox_type, elem_bt, num_elem);
      if (val == nullptr) {
-       set_map(old_map);
-       set_sp(old_sp);
        return false; // operand unboxing failed
      }
      set_all_memory(reset_memory());
@@@ -1431,24 -1385,25 +1419,29 @@@
    return true;
  }
  
--// public static
--// <V extends Vector<E>,
--//  M extends VectorMask<E>,
--//  E>
--// long reductionCoerced(int oprId, Class<? extends V> vectorClass, Class<? extends M> maskClass,
--//                       Class<E> elementType, int length, V v, M m,
--//                       ReductionOperation<V, M> defaultImpl)
++//
++//  public static
++//  <V extends Vector<E>,
++//   M extends VectorMask<E>,
++//   E>
++//  long reductionCoerced(int oprId,
++//                        Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,
++//                        int length,
++//                        V v, M m,
++//                        ReductionOperation<V, M> defaultImpl)
++//
  bool LibraryCallKit::inline_vector_reduction() {
    const TypeInt*     opr          = gvn().type(argument(0))->isa_int();
    const TypeInstPtr* vector_klass = gvn().type(argument(1))->isa_instptr();
    const TypeInstPtr* mask_klass   = gvn().type(argument(2))->isa_instptr();
    const TypeInstPtr* elem_klass   = gvn().type(argument(3))->isa_instptr();
--  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();
++  const TypeInt*     vlen         = gvn().type(argument(6))->isa_int();
  
-   if (opr == nullptr || vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr ||
-       !opr->is_con() || vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !vlen->is_con()) {
-     if (C->print_intrinsics()) {
-       tty->print_cr("  ** missing constant: opr=%s vclass=%s etype=%s vlen=%s",
+   if (opr          == nullptr || !opr->is_con() ||
+       vector_klass == nullptr || vector_klass->const_oop() == nullptr ||
+       elem_klass   == nullptr || elem_klass->const_oop()   == nullptr ||
+       vlen         == nullptr || !vlen->is_con()) {
+     log_if_needed("  ** missing constant: opr=%s vclass=%s etype=%s vlen=%s",
                      NodeClassNames[argument(0)->Opcode()],
                      NodeClassNames[argument(1)->Opcode()],
                      NodeClassNames[argument(3)->Opcode()],
@@@ -1470,13 -1420,11 +1458,11 @@@
      return false; // should be primitive type
    }
  
--  const Type* vmask_type = gvn().type(argument(6));
++  const Type* vmask_type = gvn().type(argument(8));
    bool is_masked_op = vmask_type != TypePtr::NULL_PTR;
    if (is_masked_op) {
      if (mask_klass == nullptr || mask_klass->const_oop() == nullptr) {
-       if (C->print_intrinsics()) {
-         tty->print_cr("  ** missing constant: maskclass=%s", NodeClassNames[argument(2)->Opcode()]);
-       }
 -      log_if_needed("  ** missing constant: maskclass=%s", NodeClassNames[argument(2)->Opcode()]);
++      log_if_needed("  ** missing constant: maskclass=%s", NodeClassNames[argument(4)->Opcode()]);
        return false; // not enough info for intrinsification
      }
  
@@@ -1522,7 -1463,7 +1501,7 @@@
    ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();
    const TypeInstPtr* vbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);
  
--  Node* opd = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);
++  Node* opd = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);
    if (opd == nullptr) {
      return false; // operand unboxing failed
    }
@@@ -1532,12 -1473,10 +1511,10 @@@
      ciKlass* mbox_klass = mask_klass->const_oop()->as_instance()->java_lang_Class_klass();
      assert(is_vector_mask(mbox_klass), "argument(2) should be a mask class");
      const TypeInstPtr* mbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, mbox_klass);
--    mask = unbox_vector(argument(6), mbox_type, elem_bt, num_elem);
++    mask = unbox_vector(argument(8), mbox_type, elem_bt, num_elem);
      if (mask == nullptr) {
-       if (C->print_intrinsics()) {
-         tty->print_cr("  ** unbox failed mask=%s",
-                       NodeClassNames[argument(6)->Opcode()]);
-       }
+       log_if_needed("  ** unbox failed mask=%s",
 -                      NodeClassNames[argument(6)->Opcode()]);
++                      NodeClassNames[argument(8)->Opcode()]);
        return false;
      }
    }
@@@ -1588,25 -1529,25 +1567,34 @@@
    return true;
  }
  
--// public static <V> boolean test(int cond, Class<?> vectorClass, Class<?> elementType, int vlen,
--//                                V v1, V v2,
--//                                BiFunction<V, V, Boolean> defaultImpl)
++
++
++//
++//  public static
++//  <M extends VectorMask<E>,
++//   E>
++//  boolean test(int cond,
++//               Class<?> mClass, Class<?> cClass, Class<E> eClass, int opType,
++//               int length,
++//               M m1, M m2,
++//               BiFunction<M, M, Boolean> defaultImpl) 
++//
  //
  bool LibraryCallKit::inline_vector_test() {
    const TypeInt*     cond         = gvn().type(argument(0))->isa_int();
    const TypeInstPtr* vector_klass = gvn().type(argument(1))->isa_instptr();
    const TypeInstPtr* elem_klass   = gvn().type(argument(2))->isa_instptr();
--  const TypeInt*     vlen         = gvn().type(argument(3))->isa_int();
++  const TypeInt*     vlen         = gvn().type(argument(5))->isa_int();
  
-   if (cond == nullptr || vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr ||
-       !cond->is_con() || vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !vlen->is_con()) {
-     if (C->print_intrinsics()) {
-       tty->print_cr("  ** missing constant: cond=%s vclass=%s etype=%s vlen=%s",
+   if (cond         == nullptr || !cond->is_con() ||
+       vector_klass == nullptr || vector_klass->const_oop() == nullptr ||
+       elem_klass   == nullptr || elem_klass->const_oop()   == nullptr ||
+       vlen         == nullptr || !vlen->is_con()) {
+     log_if_needed("  ** missing constant: cond=%s vclass=%s etype=%s vlen=%s",
                      NodeClassNames[argument(0)->Opcode()],
                      NodeClassNames[argument(1)->Opcode()],
                      NodeClassNames[argument(2)->Opcode()],
--                    NodeClassNames[argument(3)->Opcode()]);
-     }
++                    NodeClassNames[argument(5)->Opcode()]);
      return false; // not enough info for intrinsification
    }
    if (!is_klass_initialized(vector_klass)) {
@@@ -1636,12 -1572,11 +1619,11 @@@
      return false;
    }
  
--  Node* opd1 = unbox_vector(argument(4), vbox_type, elem_bt, num_elem);
++  Node* opd1 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);
    Node* opd2;
    if (Matcher::vectortest_needs_second_argument(booltest == BoolTest::overflow,
                                                  opd1->bottom_type()->isa_vectmask())) {
--    opd2 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);
++    opd2 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);
    } else {
      opd2 = opd1;
    }
@@@ -1660,18 -1595,18 +1642,21 @@@
    return true;
  }
  
--// public static
--// <V extends Vector<E>,
--//  M extends VectorMask<E>,
--//  E>
--// V blend(Class<? extends V> vectorClass, Class<M> maskClass, Class<E> elementType, int vlen,
--//         V v1, V v2, M m,
--//         VectorBlendOp<V, M, E> defaultImpl)
++//
++//  public static
++//  <V extends Vector<E>,
++//   M extends VectorMask<E>,
++//   E>
++//  V blend(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,
++//          int length,
++//          V v1, V v2, M m,
++//          VectorBlendOp<V, M> defaultImpl)
++//
  bool LibraryCallKit::inline_vector_blend() {
    const TypeInstPtr* vector_klass = gvn().type(argument(0))->isa_instptr();
    const TypeInstPtr* mask_klass   = gvn().type(argument(1))->isa_instptr();
    const TypeInstPtr* elem_klass   = gvn().type(argument(2))->isa_instptr();
--  const TypeInt*     vlen         = gvn().type(argument(3))->isa_int();
++  const TypeInt*     vlen         = gvn().type(argument(5))->isa_int();
  
    if (mask_klass == nullptr || vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr) {
      return false; // dead code
@@@ -1683,8 -1617,7 +1667,7 @@@
                      NodeClassNames[argument(0)->Opcode()],
                      NodeClassNames[argument(1)->Opcode()],
                      NodeClassNames[argument(2)->Opcode()],
--                    NodeClassNames[argument(3)->Opcode()]);
-     }
++                    NodeClassNames[argument(5)->Opcode()]);
      return false; // not enough info for intrinsification
    }
    if (!is_klass_initialized(vector_klass) || !is_klass_initialized(mask_klass)) {
@@@ -1717,9 -1644,9 +1694,9 @@@
    ciKlass* mbox_klass = mask_klass->const_oop()->as_instance()->java_lang_Class_klass();
    const TypeInstPtr* mbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, mbox_klass);
  
--  Node* v1   = unbox_vector(argument(4), vbox_type, elem_bt, num_elem);
--  Node* v2   = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);
--  Node* mask = unbox_vector(argument(6), mbox_type, mask_bt, num_elem);
++  Node* v1   = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);
++  Node* v2   = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);
++  Node* mask = unbox_vector(argument(8), mbox_type, mask_bt, num_elem);
  
    if (v1 == nullptr || v2 == nullptr || mask == nullptr) {
      return false; // operand unboxing failed
@@@ -1733,19 -1660,19 +1710,24 @@@
    return true;
  }
  
++
++//
  //  public static
  //  <V extends Vector<E>,
  //   M extends VectorMask<E>,
  //   E>
--//  M compare(int cond, Class<? extends V> vectorClass, Class<M> maskClass, Class<E> elementType, int vlen,
++//  M compare(int cond,
++//            Class<? extends V> vectorClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,
++//            int length,
  //            V v1, V v2, M m,
--//            VectorCompareOp<V,M> defaultImpl)
++//            VectorCompareOp<V, M> defaultImpl)
++//
  bool LibraryCallKit::inline_vector_compare() {
    const TypeInt*     cond         = gvn().type(argument(0))->isa_int();
    const TypeInstPtr* vector_klass = gvn().type(argument(1))->isa_instptr();
    const TypeInstPtr* mask_klass   = gvn().type(argument(2))->isa_instptr();
    const TypeInstPtr* elem_klass   = gvn().type(argument(3))->isa_instptr();
--  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();
++  const TypeInt*     vlen         = gvn().type(argument(6))->isa_int();
  
    if (cond == nullptr || vector_klass == nullptr || mask_klass == nullptr || elem_klass == nullptr || vlen == nullptr) {
      return false; // dead code
@@@ -1758,8 -1684,7 +1739,7 @@@
                      NodeClassNames[argument(1)->Opcode()],
                      NodeClassNames[argument(2)->Opcode()],
                      NodeClassNames[argument(3)->Opcode()],
--                    NodeClassNames[argument(4)->Opcode()]);
-     }
++                    NodeClassNames[argument(6)->Opcode()]);
      return false; // not enough info for intrinsification
    }
    if (!is_klass_initialized(vector_klass) || !is_klass_initialized(mask_klass)) {
@@@ -1804,16 -1721,14 +1776,14 @@@
    ciKlass* mbox_klass = mask_klass->const_oop()->as_instance()->java_lang_Class_klass();
    const TypeInstPtr* mbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, mbox_klass);
  
--  Node* v1 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);
--  Node* v2 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);
++  Node* v1 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);
++  Node* v2 = unbox_vector(argument(8), vbox_type, elem_bt, num_elem);
  
--  bool is_masked_op = argument(7)->bottom_type() != TypePtr::NULL_PTR;
--  Node* mask = is_masked_op ? unbox_vector(argument(7), mbox_type, elem_bt, num_elem) : nullptr;
++  bool is_masked_op = argument(9)->bottom_type() != TypePtr::NULL_PTR;
++  Node* mask = is_masked_op ? unbox_vector(argument(9), mbox_type, elem_bt, num_elem) : nullptr;
    if (is_masked_op && mask == nullptr) {
-     if (C->print_intrinsics()) {
-       tty->print_cr("  ** not supported: mask = null arity=2 op=comp/%d vlen=%d etype=%s ismask=usestore is_masked_op=1",
+     log_if_needed("  ** not supported: mask = null arity=2 op=comp/%d vlen=%d etype=%s ismask=usestore is_masked_op=1",
                      cond->get_con(), num_elem, type2name(elem_bt));
-     }
      return false;
    }
  
@@@ -1853,20 -1766,20 +1821,23 @@@
    return true;
  }
  
--// public static
--// <V extends Vector<E>,
--//  Sh extends VectorShuffle<E>,
--//  M extends VectorMask<E>,
--//  E>
--// V rearrangeOp(Class<? extends V> vectorClass, Class<Sh> shuffleClass, Class<M> maskClass, Class<E> elementType, int vlen,
--//               V v1, Sh sh, M m,
--//               VectorRearrangeOp<V, Sh, M, E> defaultImpl)
++//
++//  public static
++//  <V extends Vector<E>,
++//   SH extends VectorShuffle<E>,
++//   M  extends VectorMask<E>,
++//   E>
++//  V rearrangeOp(Class<? extends V> vClass, Class<SH> shClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,
++//                int length,
++//                V v, SH sh, M m,
++//                VectorRearrangeOp<V, SH, M> defaultImpl)
++//
  bool LibraryCallKit::inline_vector_rearrange() {
    const TypeInstPtr* vector_klass  = gvn().type(argument(0))->isa_instptr();
    const TypeInstPtr* shuffle_klass = gvn().type(argument(1))->isa_instptr();
    const TypeInstPtr* mask_klass    = gvn().type(argument(2))->isa_instptr();
    const TypeInstPtr* elem_klass    = gvn().type(argument(3))->isa_instptr();
--  const TypeInt*     vlen          = gvn().type(argument(4))->isa_int();
++  const TypeInt*     vlen          = gvn().type(argument(6))->isa_int();
  
    if (vector_klass == nullptr  || shuffle_klass == nullptr ||  elem_klass == nullptr || vlen == nullptr) {
      return false; // dead code
@@@ -1880,8 -1792,7 +1850,7 @@@
                      NodeClassNames[argument(0)->Opcode()],
                      NodeClassNames[argument(1)->Opcode()],
                      NodeClassNames[argument(3)->Opcode()],
--                    NodeClassNames[argument(4)->Opcode()]);
-     }
++                    NodeClassNames[argument(6)->Opcode()]);
      return false; // not enough info for intrinsification
    }
    if (!is_klass_initialized(vector_klass)  ||
@@@ -1918,7 -1825,7 +1883,7 @@@
      return false; // not supported
    }
  
--  bool is_masked_op = argument(7)->bottom_type() != TypePtr::NULL_PTR;
++  bool is_masked_op = argument(9)->bottom_type() != TypePtr::NULL_PTR;
    bool use_predicate = is_masked_op;
    if (is_masked_op &&
        (mask_klass == nullptr ||
@@@ -1948,9 -1856,8 +1914,8 @@@
    ciKlass* shbox_klass = shuffle_klass->const_oop()->as_instance()->java_lang_Class_klass();
    const TypeInstPtr* shbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, shbox_klass);
  
--  Node* v1 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);
--  Node* shuffle = unbox_vector(argument(6), shbox_type, shuffle_bt, num_elem);
-   const TypeVect* vt = TypeVect::make(elem_bt, num_elem);
++  Node* v1 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);
++  Node* shuffle = unbox_vector(argument(8), shbox_type, shuffle_bt, num_elem);
    const TypeVect* st = TypeVect::make(shuffle_bt, num_elem);
  
    if (v1 == nullptr || shuffle == nullptr) {
@@@ -1961,12 -1873,10 +1931,10 @@@
    if (is_masked_op) {
      ciKlass* mbox_klass = mask_klass->const_oop()->as_instance()->java_lang_Class_klass();
      const TypeInstPtr* mbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, mbox_klass);
--    mask = unbox_vector(argument(7), mbox_type, elem_bt, num_elem);
++    mask = unbox_vector(argument(9), mbox_type, elem_bt, num_elem);
      if (mask == nullptr) {
-       if (C->print_intrinsics()) {
-         tty->print_cr("  ** not supported: arity=3 op=shuffle/rearrange vlen=%d etype=%s ismask=useload is_masked_op=1",
+       log_if_needed("  ** not supported: arity=3 op=shuffle/rearrange vlen=%d etype=%s ismask=useload is_masked_op=1",
                        num_elem, type2name(elem_bt));
-       }
        return false;
      }
    }
@@@ -1995,77 -1905,176 +1963,181 @@@
    return true;
  }
  
- static address get_svml_address(int vop, int bits, BasicType bt, char* name_ptr, int name_len) {
-   address addr = nullptr;
-   assert(UseVectorStubs, "sanity");
-   assert(name_ptr != nullptr, "unexpected");
-   assert((vop >= VectorSupport::VECTOR_OP_SVML_START) && (vop <= VectorSupport::VECTOR_OP_SVML_END), "unexpected");
-   int op = vop - VectorSupport::VECTOR_OP_SVML_START;
- 
-   switch(bits) {
-     case 64:  //fallthough
-     case 128: //fallthough
-     case 256: //fallthough
-     case 512:
-       if (bt == T_FLOAT) {
-         snprintf(name_ptr, name_len, "vector_%s_float%d", VectorSupport::svmlname[op], bits);
-         addr = StubRoutines::_vector_f_math[exact_log2(bits/64)][op];
-       } else {
-         assert(bt == T_DOUBLE, "must be FP type only");
-         snprintf(name_ptr, name_len, "vector_%s_double%d", VectorSupport::svmlname[op], bits);
-         addr = StubRoutines::_vector_d_math[exact_log2(bits/64)][op];
-       }
-       break;
-     default:
-       snprintf(name_ptr, name_len, "invalid");
-       addr = nullptr;
-       Unimplemented();
-       break;
 -//    public static
 -//    <V extends Vector<E>,
 -//     M  extends VectorMask<E>,
 -//     E>
 -//    V selectFromOp(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,
 -//                   int length, V v1, V v2, M m,
 -//                   VectorSelectFromOp<V, M> defaultImpl)
++//
++//  public static
++//  <V extends Vector<E>,
++//   M  extends VectorMask<E>,
++//   E>
++//  V selectFromOp(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,
++//                 int length, V v1, V v2, M m,
++//                 VectorSelectFromOp<V, M> defaultImpl)
++//
+ bool LibraryCallKit::inline_vector_select_from() {
+   const TypeInstPtr* vector_klass  = gvn().type(argument(0))->isa_instptr();
+   const TypeInstPtr* mask_klass    = gvn().type(argument(1))->isa_instptr();
+   const TypeInstPtr* elem_klass    = gvn().type(argument(2))->isa_instptr();
 -  const TypeInt*     vlen          = gvn().type(argument(3))->isa_int();
++  const TypeInt*     vlen          = gvn().type(argument(5))->isa_int();
+ 
+   if (vector_klass == nullptr  || elem_klass == nullptr || vlen == nullptr ||
+       vector_klass->const_oop()  == nullptr ||
+       elem_klass->const_oop()    == nullptr ||
+       !vlen->is_con()) {
+     log_if_needed("  ** missing constant: vclass=%s etype=%s vlen=%s",
+                     NodeClassNames[argument(0)->Opcode()],
+                     NodeClassNames[argument(2)->Opcode()],
 -                    NodeClassNames[argument(3)->Opcode()]);
++                    NodeClassNames[argument(5)->Opcode()]);
+     return false; // not enough info for intrinsification
+   }
+   if (!is_klass_initialized(vector_klass)) {
+     log_if_needed("  ** klass argument not initialized");
+     return false;
+   }
+   ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();
+   if (!elem_type->is_primitive_type()) {
+     log_if_needed("  ** not a primitive bt=%d", elem_type->basic_type());
+     return false; // should be primitive type
+   }
+   BasicType elem_bt = elem_type->basic_type();
+   int num_elem = vlen->get_con();
+   if (!is_power_of_2(num_elem)) {
+     log_if_needed("  ** vlen not power of two=%d", num_elem);
+     return false;
    }
  
-   return addr;
- }
+   BasicType shuffle_bt = elem_bt;
+   if (shuffle_bt == T_FLOAT) {
+     shuffle_bt = T_INT;
+   } else if (shuffle_bt == T_DOUBLE) {
+     shuffle_bt = T_LONG;
+   }
+   bool need_load_shuffle = Matcher::vector_rearrange_requires_load_shuffle(shuffle_bt, num_elem);
+ 
+   int cast_vopc = VectorCastNode::opcode(-1, elem_bt); // from vector of type elem_bt
+   if ((need_load_shuffle && !arch_supports_vector(Op_VectorLoadShuffle, num_elem, elem_bt, VecMaskNotUsed)) ||
+       (elem_bt != shuffle_bt && !arch_supports_vector(cast_vopc, num_elem, shuffle_bt, VecMaskNotUsed))     ||
+       !arch_supports_vector(Op_AndV, num_elem, shuffle_bt, VecMaskNotUsed) ||
+       !arch_supports_vector(Op_Replicate, num_elem, shuffle_bt, VecMaskNotUsed)) {
+     log_if_needed("  ** not supported: arity=0 op=selectFrom vlen=%d etype=%s ismask=no",
+                     num_elem, type2name(elem_bt));
+     return false; // not supported
+   }
+ 
 -  bool is_masked_op = argument(6)->bottom_type() != TypePtr::NULL_PTR;
++  bool is_masked_op = argument(8)->bottom_type() != TypePtr::NULL_PTR;
+   bool use_predicate = is_masked_op;
+   if (is_masked_op &&
+       (mask_klass == nullptr ||
+        mask_klass->const_oop() == nullptr ||
+        !is_klass_initialized(mask_klass))) {
+     log_if_needed("  ** mask_klass argument not initialized");
+     return false; // not supported
+   }
+   VectorMaskUseType checkFlags = (VectorMaskUseType)(is_masked_op ? (VecMaskUseLoad | VecMaskUsePred) : VecMaskNotUsed);
+   if (!arch_supports_vector(Op_VectorRearrange, num_elem, elem_bt, checkFlags)) {
+     use_predicate = false;
+     if(!is_masked_op ||
+        (!arch_supports_vector(Op_VectorRearrange, num_elem, elem_bt, VecMaskNotUsed) ||
+         !arch_supports_vector(Op_VectorBlend, num_elem, elem_bt, VecMaskUseLoad)     ||
+         !arch_supports_vector(Op_Replicate, num_elem, elem_bt, VecMaskNotUsed))) {
+       log_if_needed("  ** not supported: op=selectFrom vlen=%d etype=%s is_masked_op=%d",
+                       num_elem, type2name(elem_bt), is_masked_op);
+       return false; // not supported
+     }
+   }
+   ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();
+   const TypeInstPtr* vbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);
  
- Node* LibraryCallKit::gen_call_to_svml(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2) {
-   assert(UseVectorStubs, "sanity");
-   assert(vector_api_op_id >= VectorSupport::VECTOR_OP_SVML_START && vector_api_op_id <= VectorSupport::VECTOR_OP_SVML_END, "need valid op id");
-   assert(opd1 != nullptr, "must not be null");
-   const TypeVect* vt = TypeVect::make(bt, num_elem);
-   const TypeFunc* call_type = OptoRuntime::Math_Vector_Vector_Type(opd2 != nullptr ? 2 : 1, vt, vt);
-   char name[100] = "";
- 
-   // Get address for svml method.
-   address addr = get_svml_address(vector_api_op_id, vt->length_in_bytes() * BitsPerByte, bt, name, 100);
- 
-   if (addr == nullptr) {
-     return nullptr;
-   }
- 
-   assert(name[0] != '\0', "name must not be null");
-   Node* operation = make_runtime_call(RC_VECTOR,
-                                       call_type,
-                                       addr,
-                                       name,
-                                       TypePtr::BOTTOM,
-                                       opd1,
-                                       opd2);
-   return gvn().transform(new ProjNode(gvn().transform(operation), TypeFunc::Parms));
+   // v1 is the index vector
 -  Node* v1 = unbox_vector(argument(4), vbox_type, elem_bt, num_elem);
++  Node* v1 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);
+   // v2 is the vector being rearranged
 -  Node* v2 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);
++  Node* v2 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);
+ 
+   if (v1 == nullptr) {
 -    log_if_needed("  ** unbox failed v1=%s", NodeClassNames[argument(4)->Opcode()]);
++    log_if_needed("  ** unbox failed v1=%s", NodeClassNames[argument(6)->Opcode()]);
+     return false; // operand unboxing failed
+   }
+ 
+   if (v2 == nullptr) {
 -    log_if_needed("  ** unbox failed v2=%s", NodeClassNames[argument(5)->Opcode()]);
++    log_if_needed("  ** unbox failed v2=%s", NodeClassNames[argument(7)->Opcode()]);
+     return false; // operand unboxing failed
+   }
+ 
+   Node* mask = nullptr;
+   if (is_masked_op) {
+     ciKlass* mbox_klass = mask_klass->const_oop()->as_instance()->java_lang_Class_klass();
+     const TypeInstPtr* mbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, mbox_klass);
 -    mask = unbox_vector(argument(6), mbox_type, elem_bt, num_elem);
++    mask = unbox_vector(argument(8), mbox_type, elem_bt, num_elem);
+     if (mask == nullptr) {
 -      log_if_needed("  ** unbox failed mask=%s", NodeClassNames[argument(6)->Opcode()]);
++      log_if_needed("  ** unbox failed mask=%s", NodeClassNames[argument(8)->Opcode()]);
+       return false;
+     }
+   }
+ 
+   // cast index vector from elem_bt vector to byte vector
+   const TypeVect* shuffle_vt = TypeVect::make(shuffle_bt, num_elem);
+   Node* shuffle = v1;
+ 
+   if (shuffle_bt != elem_bt) {
+     shuffle = gvn().transform(VectorCastNode::make(cast_vopc, v1, shuffle_bt, num_elem));
+   }
+ 
+   // wrap the byte vector lanes to (num_elem - 1) to form the shuffle vector where num_elem is vector length
+   // this is a simple AND operation as we come here only for power of two vector length
+   Node* mod_val = gvn().makecon(TypeInteger::make(num_elem - 1, num_elem - 1, Type::WidenMin, shuffle_bt == T_LONG ? T_LONG : T_INT));
+   Node* bcast_mod = gvn().transform(VectorNode::scalar2vector(mod_val, num_elem, shuffle_bt));
+   shuffle = gvn().transform(VectorNode::make(Op_AndV, shuffle, bcast_mod, shuffle_vt));
+ 
+   // load the shuffle to use in rearrange
+   if (need_load_shuffle) {
+     shuffle = gvn().transform(new VectorLoadShuffleNode(shuffle, shuffle_vt));
+   }
+ 
+   // and finally rearrange
+   Node* rearrange = new VectorRearrangeNode(v2, shuffle);
+   if (is_masked_op) {
+     if (use_predicate) {
+       // masked rearrange is supported so use that directly
+       rearrange->add_req(mask);
+       rearrange->add_flag(Node::Flag_is_predicated_vector);
+     } else {
+       // masked rearrange is not supported so emulate usig blend
+       const TypeVect* vt = v1->bottom_type()->is_vect();
+       rearrange = gvn().transform(rearrange);
+ 
+       // create a zero vector with each lane element set as zero
+       Node* zero = gvn().makecon(Type::get_zero_type(elem_bt));
+       Node* zerovec = gvn().transform(VectorNode::scalar2vector(zero, num_elem, elem_bt));
+ 
+       // For each lane for which mask is set, blend in the rearranged lane into zero vector
+       rearrange = new VectorBlendNode(zerovec, rearrange, mask);
+     }
+   }
+   rearrange = gvn().transform(rearrange);
+ 
+   // box the result
+   Node* box = box_vector(rearrange, vbox_type, elem_bt, num_elem);
+   set_result(box);
+ 
+   C->set_max_vector_size(MAX2(C->max_vector_size(), (uint)(num_elem * type2aelembytes(elem_bt))));
+   return true;
  }
  
--//  public static
--//  <V extends Vector<E>,
--//   M extends VectorMask<E>,
--//   E>
--//  V broadcastInt(int opr, Class<? extends V> vectorClass, Class<? extends M> maskClass,
--//                 Class<E> elementType, int length,
--//                 V v, int n, M m,
--//                 VectorBroadcastIntOp<V, M> defaultImpl)
++//
++//    public static
++//    <V extends Vector<E>,
++//     M extends VectorMask<E>,
++//     E>
++//    V broadcastInt(int opr,
++//                   Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,
++//                   int length,
++//                   V v, int n, M m,
++//                   VectorBroadcastIntOp<V, M> defaultImpl) {
++//
  bool LibraryCallKit::inline_vector_broadcast_int() {
    const TypeInt*     opr          = gvn().type(argument(0))->isa_int();
    const TypeInstPtr* vector_klass = gvn().type(argument(1))->isa_instptr();
    const TypeInstPtr* mask_klass   = gvn().type(argument(2))->isa_instptr();
    const TypeInstPtr* elem_klass   = gvn().type(argument(3))->isa_instptr();
--  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();
++  const TypeInt*     vlen         = gvn().type(argument(6))->isa_int();
  
    if (opr == nullptr || vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr) {
      return false; // dead code
@@@ -2076,8 -2084,7 +2147,7 @@@
                      NodeClassNames[argument(0)->Opcode()],
                      NodeClassNames[argument(1)->Opcode()],
                      NodeClassNames[argument(3)->Opcode()],
--                    NodeClassNames[argument(4)->Opcode()]);
-     }
++                    NodeClassNames[argument(6)->Opcode()]);
      return false; // not enough info for intrinsification
    }
    if (!is_klass_initialized(vector_klass)) {
@@@ -2087,7 -2092,7 +2155,7 @@@
      return false;
    }
  
--  const Type* vmask_type = gvn().type(argument(7));
++  const Type* vmask_type = gvn().type(argument(8));
    bool is_masked_op = vmask_type != TypePtr::NULL_PTR;
    if (is_masked_op) {
      if (mask_klass == nullptr || mask_klass->const_oop() == nullptr) {
@@@ -2142,10 -2135,11 +2198,11 @@@
      return false; // operation not supported
    }
  
--  Node* cnt  = argument(6);
++  Node* cnt  = argument(8);
+   const TypeInt* cnt_type = cnt->bottom_type()->isa_int();
+ 
    ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();
    const TypeInstPtr* vbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);
-   const TypeInt* cnt_type = cnt->bottom_type()->isa_int();
  
    // If CPU supports vector constant rotate instructions pass it directly
    bool is_const_rotate = is_rotate && cnt_type && cnt_type->is_con() &&
@@@ -2169,7 -2161,7 +2224,7 @@@
      }
    }
  
--  Node* opd1 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);
++  Node* opd1 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);
    Node* opd2 = nullptr;
    if (is_shift) {
      opd2 = vector_shift_count(cnt, opc, elem_bt, num_elem);
@@@ -2193,11 -2184,9 +2247,9 @@@
    if (is_masked_op) {
      ciKlass* mbox_klass = mask_klass->const_oop()->as_instance()->java_lang_Class_klass();
      const TypeInstPtr* mbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, mbox_klass);
--    mask = unbox_vector(argument(7), mbox_type, elem_bt, num_elem);
++    mask = unbox_vector(argument(9), mbox_type, elem_bt, num_elem);
      if (mask == nullptr) {
-       if (C->print_intrinsics()) {
-         tty->print_cr("  ** unbox failed mask=%s", NodeClassNames[argument(7)->Opcode()]);
-       }
 -      log_if_needed("  ** unbox failed mask=%s", NodeClassNames[argument(7)->Opcode()]);
++      log_if_needed("  ** unbox failed mask=%s", NodeClassNames[argument(9)->Opcode()]);
        return false;
      }
    }
@@@ -2430,29 -2403,27 +2466,30 @@@ bool LibraryCallKit::inline_vector_conv
    return true;
  }
  
++//
  //  public static
  //  <V extends Vector<E>,
  //   E>
--//  V insert(Class<? extends V> vectorClass, Class<E> elementType, int vlen,
--//           V vec, int ix, long val,
++//  V insert(Class<? extends V> vClass, Class<?> cClass, Class<E> eClass, int operType,
++//           int length,
++//           V v, int i, long val,
  //           VecInsertOp<V> defaultImpl)
++//
  bool LibraryCallKit::inline_vector_insert() {
    const TypeInstPtr* vector_klass = gvn().type(argument(0))->isa_instptr();
    const TypeInstPtr* elem_klass   = gvn().type(argument(1))->isa_instptr();
--  const TypeInt*     vlen         = gvn().type(argument(2))->isa_int();
--  const TypeInt*     idx          = gvn().type(argument(4))->isa_int();
++  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();
++  const TypeInt*     idx          = gvn().type(argument(6))->isa_int();
  
    if (vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr || idx == nullptr) {
      return false; // dead code
    }
    if (vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !vlen->is_con() || !idx->is_con()) {
-     if (C->print_intrinsics()) {
-       tty->print_cr("  ** missing constant: vclass=%s etype=%s vlen=%s idx=%s",
+     log_if_needed("  ** missing constant: vclass=%s etype=%s vlen=%s idx=%s",
                      NodeClassNames[argument(0)->Opcode()],
                      NodeClassNames[argument(1)->Opcode()],
--                    NodeClassNames[argument(2)->Opcode()],
--                    NodeClassNames[argument(4)->Opcode()]);
-     }
++                    NodeClassNames[argument(4)->Opcode()],
++                    NodeClassNames[argument(6)->Opcode()]);
      return false; // not enough info for intrinsification
    }
    if (!is_klass_initialized(vector_klass)) {
@@@ -2481,12 -2446,12 +2512,12 @@@
    ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();
    const TypeInstPtr* vbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);
  
--  Node* opd = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);
++  Node* opd = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);
    if (opd == nullptr) {
      return false;
    }
  
--  Node* insert_val = argument(5);
++  Node* insert_val = argument(7);
    assert(gvn().type(insert_val)->isa_long() != nullptr, "expected to be long");
  
    // Convert insert value back to its appropriate type.
@@@ -2523,60 -2486,287 +2552,291 @@@
    return true;
  }
  
++//
  //  public static
- //  <V extends Vector<E>,
+ //  <VM extends VectorPayload,
  //   E>
- //  long extract(Class<? extends V> vectorClass, Class<E> elementType, int vlen,
- //               V vec, int ix,
- //               VecExtractOp<V> defaultImpl)
 -//  long extract(Class<? extends VM> vClass, Class<E> eClass,
++//  long extract(Class<? extends VM> vClass, Class<?> cClass, Class<E> eClass, int operType,
+ //               int length,
+ //               VM vm, int i,
+ //               VecExtractOp<VM> defaultImpl)
++//
  bool LibraryCallKit::inline_vector_extract() {
    const TypeInstPtr* vector_klass = gvn().type(argument(0))->isa_instptr();
    const TypeInstPtr* elem_klass   = gvn().type(argument(1))->isa_instptr();
--  const TypeInt*     vlen         = gvn().type(argument(2))->isa_int();
--  const TypeInt*     idx          = gvn().type(argument(4))->isa_int();
++  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();
++  const TypeInt*     idx          = gvn().type(argument(6))->isa_int();
  
-   if (vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr || idx == nullptr) {
-     return false; // dead code
+   if (vector_klass == nullptr || vector_klass->const_oop() == nullptr ||
+       elem_klass   == nullptr || elem_klass->const_oop()   == nullptr ||
+       vlen         == nullptr || !vlen->is_con() ||
+       idx          == nullptr || !idx->is_con()) {
+     log_if_needed("  ** missing constant: vclass=%s etype=%s vlen=%s",
+                     NodeClassNames[argument(0)->Opcode()],
+                     NodeClassNames[argument(1)->Opcode()],
+                     NodeClassNames[argument(2)->Opcode()]);
+     return false; // not enough info for intrinsification
    }
-   if (vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !vlen->is_con() || !idx->is_con()) {
-     if (C->print_intrinsics()) {
-       tty->print_cr("  ** missing constant: vclass=%s etype=%s vlen=%s idx=%s",
+   if (!is_klass_initialized(vector_klass)) {
+     log_if_needed("  ** klass argument not initialized");
+     return false;
+   }
+   ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();
+   if (!elem_type->is_primitive_type()) {
+     log_if_needed("  ** not a primitive bt=%d", elem_type->basic_type());
+     return false; // should be primitive type
+   }
+   BasicType elem_bt = elem_type->basic_type();
+   int num_elem = vlen->get_con();
+ 
+   ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();
+   const TypeInstPtr* vbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);
+ 
+   Node* opd = nullptr;
+ 
+   if (is_vector_mask(vbox_klass)) {
+     // vbox_klass is mask. This is used for VectorMask.laneIsSet(int).
+ 
 -    Node* pos = argument(4); // can be variable
++    Node* pos = argument(6); // can be variable
+     if (arch_supports_vector(Op_ExtractUB, num_elem, elem_bt, VecMaskUseAll)) {
+       // Transform mask to vector with type of boolean and utilize ExtractUB node.
 -      opd = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);
++      opd = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);
+       if (opd == nullptr) {
+         return false;
+       }
+       opd = gvn().transform(VectorStoreMaskNode::make(gvn(), opd, elem_bt, num_elem));
+       opd = gvn().transform(new ExtractUBNode(opd, pos));
+       opd = gvn().transform(new ConvI2LNode(opd));
+     } else if (arch_supports_vector(Op_VectorMaskToLong, num_elem, elem_bt, VecMaskUseLoad)) {
 -      opd = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);
++      opd = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);
+       if (opd == nullptr) {
+         return false;
+       }
+       // VectorMaskToLongNode requires the input is either a mask or a vector with BOOLEAN type.
+       if (opd->bottom_type()->isa_vectmask() == nullptr) {
+         opd = gvn().transform(VectorStoreMaskNode::make(gvn(), opd, elem_bt, num_elem));
+       }
+       // ((toLong() >>> pos) & 1L
+       opd = gvn().transform(new VectorMaskToLongNode(opd, TypeLong::LONG));
+       opd = gvn().transform(new URShiftLNode(opd, pos));
+       opd = gvn().transform(new AndLNode(opd, gvn().makecon(TypeLong::ONE)));
+     } else {
+       log_if_needed("  ** Rejected mask extraction because architecture does not support it");
+       return false; // not supported
+     }
+   } else {
+     // vbox_klass is vector. This is used for Vector.lane(int).
+     if (!idx->is_con()) {
 -      log_if_needed("  ** missing constant: idx=%s", NodeClassNames[argument(4)->Opcode()]);
++      log_if_needed("  ** missing constant: idx=%s", NodeClassNames[argument(6)->Opcode()]);
+       return false; // not enough info for intrinsification
+     }
+ 
+     int vopc = ExtractNode::opcode(elem_bt);
+     if (!arch_supports_vector(vopc, num_elem, elem_bt, VecMaskNotUsed)) {
+       log_if_needed("  ** not supported: arity=1 op=extract vlen=%d etype=%s ismask=no",
+                       num_elem, type2name(elem_bt));
+       return false; // not supported
+     }
+ 
 -    opd = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);
++    opd = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);
+     if (opd == nullptr) {
+       return false;
+     }
+     ConINode* idx_con = gvn().intcon(idx->get_con())->as_ConI();
+ 
+     opd = gvn().transform(ExtractNode::make(opd, idx_con, elem_bt));
+     switch (elem_bt) {
+       case T_BYTE:
+       case T_SHORT:
+       case T_INT: {
+         opd = gvn().transform(new ConvI2LNode(opd));
+         break;
+       }
+       case T_FLOAT: {
+         opd = gvn().transform(new MoveF2INode(opd));
+         opd = gvn().transform(new ConvI2LNode(opd));
+         break;
+       }
+       case T_DOUBLE: {
+         opd = gvn().transform(new MoveD2LNode(opd));
+         break;
+       }
+       case T_LONG: {
+         // no conversion needed
+         break;
+       }
+       default: fatal("%s", type2name(elem_bt));
+     }
+   }
+   set_result(opd);
+   return true;
+ }
+ 
+ static Node* LowerSelectFromTwoVectorOperation(PhaseGVN& phase, Node* index_vec, Node* src1, Node* src2, const TypeVect* vt) {
+   int num_elem = vt->length();
+   BasicType elem_bt = vt->element_basic_type();
+ 
+   // Lower selectFrom operation into its constituent operations.
+   //   SelectFromTwoVectorNode =
+   //     (VectorBlend
+   //         (VectorRearrange SRC1 (WRAPED_INDEX AND (VLEN-1))
+   //         (VectorRearrange SRC2 (WRAPED_INDEX AND (VLEN-1))
+   //      MASK)
+   // Where
+   //   WRAPED_INDEX are computed by wrapping incoming indexes
+   //   to two vector index range [0, VLEN*2) and
+   //   MASK = WRAPED_INDEX < VLEN
+   //
+   // IR lowering prevents intrinsification failure and associated argument
+   // boxing penalties.
+   //
+ 
+   BasicType shuffle_bt = elem_bt;
+   if (shuffle_bt == T_FLOAT) {
+     shuffle_bt = T_INT;
+   } else if (shuffle_bt == T_DOUBLE) {
+     shuffle_bt = T_LONG;
+   }
+   const TypeVect* st = TypeVect::make(shuffle_bt, num_elem);
+ 
+   // Cast index vector to the corresponding bit type
+   if (elem_bt != shuffle_bt) {
+     int cast_vopc = VectorCastNode::opcode(0, elem_bt, true);
+     index_vec = phase.transform(VectorCastNode::make(cast_vopc, index_vec, shuffle_bt, num_elem));
+   }
+ 
+   // Wrap indexes into two vector index range [0, VLEN * 2)
+   Node* two_vect_lane_cnt_m1 = phase.makecon(TypeInteger::make(2 * num_elem - 1, 2 * num_elem - 1, Type::WidenMin, shuffle_bt == T_LONG ? T_LONG : T_INT));
+   Node* bcast_two_vect_lane_cnt_m1_vec = phase.transform(VectorNode::scalar2vector(two_vect_lane_cnt_m1, num_elem,
+                                                                                    shuffle_bt, false));
+   index_vec = phase.transform(VectorNode::make(Op_AndV, index_vec, bcast_two_vect_lane_cnt_m1_vec, st));
+ 
+   // Compute the blend mask for merging two independently permitted vectors
+   // using shuffle index in two vector index range [0, VLEN * 2).
+   BoolTest::mask pred = BoolTest::le;
+   ConINode* pred_node = phase.makecon(TypeInt::make(pred))->as_ConI();
+   const TypeVect* vmask_type = TypeVect::makemask(shuffle_bt, num_elem);
+   Node* lane_cnt_m1 = phase.makecon(TypeInteger::make(num_elem - 1, num_elem - 1, Type::WidenMin, shuffle_bt == T_LONG ? T_LONG : T_INT));
+   Node* bcast_lane_cnt_m1_vec = phase.transform(VectorNode::scalar2vector(lane_cnt_m1, num_elem, shuffle_bt, false));
+   Node* mask = phase.transform(new VectorMaskCmpNode(pred, index_vec, bcast_lane_cnt_m1_vec, pred_node, vmask_type));
+ 
+   // Rearrange expects the indexes to lie within single vector index range [0, VLEN).
+   Node* wrapped_index_vec = phase.transform(VectorNode::make(Op_AndV, index_vec, bcast_lane_cnt_m1_vec, st));
+ 
+   // Load indexes from byte vector and appropriately transform them to target
+   // specific permutation index format.
+   if (Matcher::vector_rearrange_requires_load_shuffle(shuffle_bt, num_elem)) {
+     wrapped_index_vec = phase.transform(new VectorLoadShuffleNode(wrapped_index_vec, st));
+   }
+ 
+   vmask_type = TypeVect::makemask(elem_bt, num_elem);
+   mask = phase.transform(new VectorMaskCastNode(mask, vmask_type));
+ 
+   Node* p1 = phase.transform(new VectorRearrangeNode(src1, wrapped_index_vec));
+   Node* p2 = phase.transform(new VectorRearrangeNode(src2, wrapped_index_vec));
+ 
+   return new VectorBlendNode(p2, p1, mask);
+ }
+ 
++//
+ //  public static
+ //  <V extends Vector<E>,
+ //   E>
 -//  V selectFromTwoVectorOp(Class<? extends V> vClass, Class<E> eClass, int length,
++//  V selectFromTwoVectorOp(Class<? extends V> vClass, Class<?> cClass, Class<E> eClass, int operType, int length,
+ //                          V v1, V v2, V v3,
+ //                          SelectFromTwoVector<V> defaultImpl)
++//
+ bool LibraryCallKit::inline_vector_select_from_two_vectors() {
+   const TypeInstPtr* vector_klass = gvn().type(argument(0))->isa_instptr();
+   const TypeInstPtr* elem_klass = gvn().type(argument(1))->isa_instptr();
 -  const TypeInt* vlen = gvn().type(argument(2))->isa_int();
++  const TypeInt* vlen = gvn().type(argument(4))->isa_int();
+ 
+   if (vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr || vector_klass->const_oop() == nullptr ||
+       elem_klass->const_oop() == nullptr ||!vlen->is_con()) {
+     log_if_needed("  ** missing constant: vclass=%s etype=%s vlen=%s",
                      NodeClassNames[argument(0)->Opcode()],
                      NodeClassNames[argument(1)->Opcode()],
-                     NodeClassNames[argument(2)->Opcode()],
 -                    NodeClassNames[argument(2)->Opcode()]);
 +                    NodeClassNames[argument(4)->Opcode()]);
-     }
      return false; // not enough info for intrinsification
    }
+ 
    if (!is_klass_initialized(vector_klass)) {
-     if (C->print_intrinsics()) {
-       tty->print_cr("  ** klass argument not initialized");
-     }
+     log_if_needed("  ** klass argument not initialized");
      return false;
    }
+ 
    ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();
    if (!elem_type->is_primitive_type()) {
-     if (C->print_intrinsics()) {
-       tty->print_cr("  ** not a primitive bt=%d", elem_type->basic_type());
-     }
+     log_if_needed("  ** not a primitive bt=%d", elem_type->basic_type());
      return false; // should be primitive type
    }
-   BasicType elem_bt = elem_type->basic_type();
+ 
    int num_elem = vlen->get_con();
-   int vopc = ExtractNode::opcode(elem_bt);
-   if (!arch_supports_vector(vopc, num_elem, elem_bt, VecMaskNotUsed)) {
-     if (C->print_intrinsics()) {
-       tty->print_cr("  ** not supported: arity=1 op=extract vlen=%d etype=%s ismask=no",
-                     num_elem, type2name(elem_bt));
+   if (!is_power_of_2(num_elem)) {
+     log_if_needed("  ** vlen is not power of two=%d", num_elem);
+     return false;
+   }
+ 
+   BasicType elem_bt = elem_type->basic_type();
+   BasicType index_elem_bt = elem_bt;
+   if (elem_bt == T_FLOAT) {
+     index_elem_bt = T_INT;
+   } else if (elem_bt == T_DOUBLE) {
+     index_elem_bt = T_LONG;
+   }
+ 
+   // Check if the platform requires a VectorLoadShuffle node to be generated
+   bool need_load_shuffle = Matcher::vector_rearrange_requires_load_shuffle(index_elem_bt, num_elem);
+ 
+   bool lowerSelectFromOp = false;
+   if (!arch_supports_vector(Op_SelectFromTwoVector, num_elem, elem_bt, VecMaskNotUsed)) {
+     int cast_vopc = VectorCastNode::opcode(-1, elem_bt, true);
+     if ((elem_bt != index_elem_bt && !arch_supports_vector(cast_vopc, num_elem, index_elem_bt, VecMaskNotUsed)) ||
+         !arch_supports_vector(Op_VectorMaskCmp, num_elem, index_elem_bt, VecMaskNotUsed)     ||
+         !arch_supports_vector(Op_AndV, num_elem, index_elem_bt, VecMaskNotUsed)              ||
+         !arch_supports_vector(Op_VectorMaskCast, num_elem, elem_bt, VecMaskNotUsed)          ||
+         !arch_supports_vector(Op_VectorBlend, num_elem, elem_bt, VecMaskUseLoad)             ||
+         !arch_supports_vector(Op_VectorRearrange, num_elem, elem_bt, VecMaskNotUsed)         ||
+         (need_load_shuffle && !arch_supports_vector(Op_VectorLoadShuffle, num_elem, index_elem_bt, VecMaskNotUsed)) ||
+         !arch_supports_vector(Op_Replicate, num_elem, index_elem_bt, VecMaskNotUsed)) {
+       log_if_needed("  ** not supported: opc=%d vlen=%d etype=%s ismask=useload",
+                     Op_SelectFromTwoVector, num_elem, type2name(elem_bt));
+       return false; // not supported
+     }
+     lowerSelectFromOp = true;
+   }
+ 
+   int cast_vopc = VectorCastNode::opcode(-1, elem_bt, true);
+   if (!lowerSelectFromOp) {
+     if (!arch_supports_vector(Op_AndV, num_elem, index_elem_bt, VecMaskNotUsed)      ||
+         !arch_supports_vector(Op_Replicate, num_elem, index_elem_bt, VecMaskNotUsed) ||
+         (is_floating_point_type(elem_bt) &&
+          !arch_supports_vector(cast_vopc, num_elem, index_elem_bt, VecMaskNotUsed))) {
+       log_if_needed("  ** index wrapping not supported: vlen=%d etype=%s" ,
+                      num_elem, type2name(elem_bt));
+       return false; // not supported
      }
-     return false; // not supported
    }
  
    ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();
    const TypeInstPtr* vbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);
  
-   Node* opd = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);
-   if (opd == nullptr) {
 -  Node* opd1 = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);
++  Node* opd1 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);
+   if (opd1 == nullptr) {
+     log_if_needed("  ** unbox failed v1=%s",
 -                  NodeClassNames[argument(3)->Opcode()]);
++                  NodeClassNames[argument(5)->Opcode()]);
+     return false;
+   }
 -  Node* opd2 = unbox_vector(argument(4), vbox_type, elem_bt, num_elem);
++  Node* opd2 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);
+   if (opd2 == nullptr) {
+     log_if_needed("  ** unbox failed v2=%s",
 -                  NodeClassNames[argument(4)->Opcode()]);
++                  NodeClassNames[argument(6)->Opcode()]);
+     return false;
+   }
 -  Node* opd3 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);
++  Node* opd3 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);
+   if (opd3 == nullptr) {
+     log_if_needed("  ** unbox failed v3=%s",
 -                  NodeClassNames[argument(5)->Opcode()]);
++                  NodeClassNames[argument(7)->Opcode()]);
      return false;
    }
  
@@@ -2611,32 -2793,32 +2863,34 @@@
    return true;
  }
  
--// public static
--// <V extends Vector<E>,
--//  M extends VectorMask<E>,
--//  E>
--//  V compressExpandOp(int opr,
--//                    Class<? extends V> vClass, Class<? extends M> mClass, Class<E> eClass,
--//                    int length, V v, M m,
--//                    CompressExpandOperation<V, M> defaultImpl)
++//
++//  public static
++//  <V extends Vector<E>,
++//   M extends VectorMask<E>,
++//   E>
++//  VectorPayload compressExpandOp(int opr,
++//                                 Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,
++//                                 int length, V v, M m,
++//                                 CompressExpandOperation<V, M> defaultImpl) 
++//
  bool LibraryCallKit::inline_vector_compress_expand() {
    const TypeInt*     opr          = gvn().type(argument(0))->isa_int();
    const TypeInstPtr* vector_klass = gvn().type(argument(1))->isa_instptr();
    const TypeInstPtr* mask_klass   = gvn().type(argument(2))->isa_instptr();
    const TypeInstPtr* elem_klass   = gvn().type(argument(3))->isa_instptr();
--  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();
- 
-   if (vector_klass == nullptr || elem_klass == nullptr || mask_klass == nullptr || vlen == nullptr ||
-       vector_klass->const_oop() == nullptr || mask_klass->const_oop() == nullptr ||
-       elem_klass->const_oop() == nullptr || !vlen->is_con() || !opr->is_con()) {
-     if (C->print_intrinsics()) {
-       tty->print_cr("  ** missing constant: opr=%s vclass=%s mclass=%s etype=%s vlen=%s",
++  const TypeInt*     vlen         = gvn().type(argument(6))->isa_int();
+ 
+   if (opr          == nullptr || !opr->is_con() ||
+       vector_klass == nullptr || vector_klass->const_oop() == nullptr ||
+       mask_klass   == nullptr || mask_klass->const_oop()   == nullptr ||
+       elem_klass   == nullptr || elem_klass->const_oop()   == nullptr ||
+       vlen         == nullptr || !vlen->is_con()) {
+     log_if_needed("  ** missing constant: opr=%s vclass=%s mclass=%s etype=%s vlen=%s",
                      NodeClassNames[argument(0)->Opcode()],
                      NodeClassNames[argument(1)->Opcode()],
                      NodeClassNames[argument(2)->Opcode()],
                      NodeClassNames[argument(3)->Opcode()],
--                    NodeClassNames[argument(4)->Opcode()]);
-     }
++                    NodeClassNames[argument(6)->Opcode()]);
      return false; // not enough info for intrinsification
    }
  
@@@ -2672,26 -2848,22 +2920,22 @@@
    if (opc != Op_CompressM) {
      ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();
      vbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);
--    opd1 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);
++    opd1 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);
      if (opd1 == nullptr) {
-       if (C->print_intrinsics()) {
-         tty->print_cr("  ** unbox failed vector=%s",
-                       NodeClassNames[argument(5)->Opcode()]);
-       }
+       log_if_needed("  ** unbox failed vector=%s",
 -                      NodeClassNames[argument(5)->Opcode()]);
++                      NodeClassNames[argument(7)->Opcode()]);
        return false;
      }
    }
  
    ciKlass* mbox_klass = mask_klass->const_oop()->as_instance()->java_lang_Class_klass();
--  assert(is_vector_mask(mbox_klass), "argument(6) should be a mask class");
++  assert(is_vector_mask(mbox_klass), "argument(8) should be a mask class");
    const TypeInstPtr* mbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, mbox_klass);
  
--  Node* mask = unbox_vector(argument(6), mbox_type, elem_bt, num_elem);
++  Node* mask = unbox_vector(argument(8), mbox_type, elem_bt, num_elem);
    if (mask == nullptr) {
-     if (C->print_intrinsics()) {
-       tty->print_cr("  ** unbox failed mask=%s",
-                     NodeClassNames[argument(6)->Opcode()]);
-     }
+     log_if_needed("  ** unbox failed mask=%s",
 -                    NodeClassNames[argument(6)->Opcode()]);
++                    NodeClassNames[argument(8)->Opcode()]);
      return false;
    }
  
@@@ -2706,28 -2878,26 +2950,28 @@@
    return true;
  }
  
--// public static
--// <V extends Vector<E>,
--//  E,
--//  S extends VectorSpecies<E>>
--//  V indexVector(Class<? extends V> vClass, Class<E> eClass,
++//
++//  public static
++//  <V extends Vector<E>,
++//   E,
++//   S extends VectorSpecies<E>>
++//  V indexVector(Class<? extends V> vClass, Class<?> cClass, Class<E> eClass, int operType,
  //                int length,
  //                V v, int step, S s,
--//                IndexOperation<V, S> defaultImpl)
++//                IndexOperation<V, S> defaultImpl) {
++//
  bool LibraryCallKit::inline_index_vector() {
    const TypeInstPtr* vector_klass = gvn().type(argument(0))->isa_instptr();
    const TypeInstPtr* elem_klass   = gvn().type(argument(1))->isa_instptr();
--  const TypeInt*     vlen         = gvn().type(argument(2))->isa_int();
++  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();
  
-   if (vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr ||
-       vector_klass->const_oop() == nullptr || !vlen->is_con() ||
-       elem_klass->const_oop() == nullptr) {
-     if (C->print_intrinsics()) {
-       tty->print_cr("  ** missing constant: vclass=%s etype=%s vlen=%s",
+   if (vector_klass == nullptr || vector_klass->const_oop() == nullptr ||
+       elem_klass   == nullptr || elem_klass->const_oop()   == nullptr ||
+       vlen         == nullptr || !vlen->is_con() ) {
+     log_if_needed("  ** missing constant: vclass=%s etype=%s vlen=%s",
                      NodeClassNames[argument(0)->Opcode()],
                      NodeClassNames[argument(1)->Opcode()],
--                    NodeClassNames[argument(2)->Opcode()]);
-     }
++                    NodeClassNames[argument(4)->Opcode()]);
      return false; // not enough info for intrinsification
    }
  
@@@ -2760,7 -2924,7 +2998,7 @@@
    int mul_op = VectorSupport::vop2ideal(VectorSupport::VECTOR_OP_MUL, elem_bt);
    int vmul_op = VectorNode::opcode(mul_op, elem_bt);
    bool needs_mul = true;
--  Node* scale = argument(4);
++  Node* scale = argument(6);
    const TypeInt* scale_type = gvn().type(scale)->isa_int();
    // Multiply is not needed if the scale is a constant "1".
    if (scale_type && scale_type->is_con() && scale_type->get_con() == 1) {
@@@ -2790,12 -2950,10 +3024,10 @@@
  
    ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();
    const TypeInstPtr* vbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);
--  Node* opd = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);
++  Node* opd = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);
    if (opd == nullptr) {
-     if (C->print_intrinsics()) {
-       tty->print_cr("  ** unbox failed vector=%s",
-                     NodeClassNames[argument(3)->Opcode()]);
-     }
+     log_if_needed("  ** unbox failed vector=%s",
 -                    NodeClassNames[argument(3)->Opcode()]);
++                    NodeClassNames[argument(5)->Opcode()]);
      return false;
    }
  
@@@ -2858,25 -3014,24 +3088,26 @@@
    return true;
  }
  
--// public static
--// <E,
--//  M extends VectorMask<E>>
--// M indexPartiallyInUpperRange(Class<? extends M> mClass, Class<E> eClass, int length,
--//                              long offset, long limit,
--//                              IndexPartiallyInUpperRangeOperation<E, M> defaultImpl)
++//
++//  public static
++//  <E,
++//   M extends VectorMask<E>>
++//  M indexPartiallyInUpperRange(Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,
++//                               int length, long offset, long limit,
++//                               IndexPartiallyInUpperRangeOperation<E, M> defaultImpl)
++//
  bool LibraryCallKit::inline_index_partially_in_upper_range() {
    const TypeInstPtr* mask_klass   = gvn().type(argument(0))->isa_instptr();
    const TypeInstPtr* elem_klass   = gvn().type(argument(1))->isa_instptr();
--  const TypeInt*     vlen         = gvn().type(argument(2))->isa_int();
++  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();
  
-   if (mask_klass == nullptr || elem_klass == nullptr || vlen == nullptr ||
-       mask_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !vlen->is_con()) {
-     if (C->print_intrinsics()) {
-       tty->print_cr("  ** missing constant: mclass=%s etype=%s vlen=%s",
+   if (mask_klass == nullptr || mask_klass->const_oop() == nullptr ||
+       elem_klass == nullptr || elem_klass->const_oop() == nullptr ||
+       vlen       == nullptr || !vlen->is_con()) {
+     log_if_needed("  ** missing constant: mclass=%s etype=%s vlen=%s",
                      NodeClassNames[argument(0)->Opcode()],
                      NodeClassNames[argument(1)->Opcode()],
--                    NodeClassNames[argument(2)->Opcode()]);
-     }
++                    NodeClassNames[argument(4)->Opcode()]);
      return false; // not enough info for intrinsification
    }
  
@@@ -2924,12 -3071,10 +3147,10 @@@
      }
    }
  
--  Node* offset = argument(3);
--  Node* limit = argument(5);
++  Node* offset = argument(5);
++  Node* limit = argument(7);
    if (offset == nullptr || limit == nullptr) {
-     if (C->print_intrinsics()) {
-       tty->print_cr("  ** offset or limit argument is null");
-     }
+     log_if_needed("  ** offset or limit argument is null");
      return false; // not supported
    }
  
diff --cc src/hotspot/share/opto/vectornode.cpp
index 8caa47ab44b,c126c91da1b..41bab9f402f
--- a/src/hotspot/share/opto/vectornode.cpp
+++ b/src/hotspot/share/opto/vectornode.cpp
@@@ -274,72 -292,124 +292,170 @@@ int VectorNode::opcode(int sopc, BasicT
    }
  }
  
- int VectorNode::replicate_opcode(BasicType bt) {
-   switch(bt) {
-     case T_BOOLEAN:
-     case T_BYTE:
-       return Op_ReplicateB;
-     case T_SHORT:
-     case T_CHAR:
-       return Op_ReplicateS;
-     case T_INT:
-       return Op_ReplicateI;
-     case T_LONG:
-       return Op_ReplicateL;
-     case T_FLOAT:
-       return Op_ReplicateF;
-     case T_DOUBLE:
-       return Op_ReplicateD;
++VectorNode* VectorCastNode::make(int vopc, Node* n1, BasicType bt, uint vlen) {
++  const TypeVect* vt = TypeVect::make(bt, vlen);
++  return VectorNode::make(vopc, n1, nullptr, vt);
++}
++
+ // Return the scalar opcode for the specified vector opcode
+ // and basic type.
+ int VectorNode::scalar_opcode(int sopc, BasicType bt) {
+   switch (sopc) {
+     case Op_AddReductionVI:
+     case Op_AddVI:
+       return Op_AddI;
+     case Op_AddReductionVL:
+     case Op_AddVL:
+       return Op_AddL;
+     case Op_MulReductionVI:
+     case Op_MulVI:
+       return Op_MulI;
+     case Op_MulReductionVL:
+     case Op_MulVL:
+       return Op_MulL;
+     case Op_AndReductionV:
+     case Op_AndV:
+       switch (bt) {
+         case T_BOOLEAN:
+         case T_CHAR:
+         case T_BYTE:
+         case T_SHORT:
+         case T_INT:
+           return Op_AndI;
+         case T_LONG:
+           return Op_AndL;
+         default:
+           assert(false, "basic type not handled");
+           return 0;
+       }
+     case Op_OrReductionV:
+     case Op_OrV:
+       switch (bt) {
+         case T_BOOLEAN:
+         case T_CHAR:
+         case T_BYTE:
+         case T_SHORT:
+         case T_INT:
+           return Op_OrI;
+         case T_LONG:
+           return Op_OrL;
+         default:
+           assert(false, "basic type not handled");
+           return 0;
+       }
+     case Op_XorReductionV:
+     case Op_XorV:
+       switch (bt) {
+         case T_BOOLEAN:
+         case T_CHAR:
+         case T_BYTE:
+         case T_SHORT:
+         case T_INT:
+           return Op_XorI;
+         case T_LONG:
+           return Op_XorL;
+         default:
+           assert(false, "basic type not handled");
+           return 0;
+       }
+     case Op_MinReductionV:
+     case Op_MinV:
+       switch (bt) {
+         case T_BOOLEAN:
+         case T_CHAR:
+           assert(false, "boolean and char are signed, not implemented for Min");
+           return 0;
+         case T_BYTE:
+         case T_SHORT:
+         case T_INT:
+           return Op_MinI;
+         case T_LONG:
+           return Op_MinL;
+         case T_FLOAT:
+           return Op_MinF;
+         case T_DOUBLE:
+           return Op_MinD;
+         default:
+           assert(false, "basic type not handled");
+           return 0;
+       }
+     case Op_MaxReductionV:
+     case Op_MaxV:
+       switch (bt) {
+         case T_BOOLEAN:
+         case T_CHAR:
+           assert(false, "boolean and char are signed, not implemented for Max");
+           return 0;
+         case T_BYTE:
+         case T_SHORT:
+         case T_INT:
+           return Op_MaxI;
+         case T_LONG:
+           return Op_MaxL;
+         case T_FLOAT:
+           return Op_MaxF;
+         case T_DOUBLE:
+           return Op_MaxD;
+         default:
+           assert(false, "basic type not handled");
+           return 0;
+       }
+     case Op_MinVHF:
+       return Op_MinHF;
+     case Op_MaxVHF:
+       return Op_MaxHF;
      default:
-       assert(false, "wrong type: %s", type2name(bt));
-       return 0;
+       assert(false,
+              "Vector node %s is not handled in VectorNode::scalar_opcode",
+              NodeClassNames[sopc]);
+       return 0; // Unimplemented
    }
  }
  
 +// Return the vector operator for the specified scalar operation
 +// and vector length for half float
 +int VectorNode::opcode(int sopc) {
 +  switch (sopc) {
 +    case Op_AddI:
 +      return Op_AddVHF;
 +    case Op_SubI:
 +      return Op_SubVHF;
 +    case Op_MulI:
 +      return Op_MulVHF;
 +    case Op_DivI:
 +      return Op_DivVHF;
 +    case Op_AbsI:
 +      return Op_AbsVHF;
 +    case Op_NegI:
 +      return Op_NegVHF;
 +    case Op_FmaF:
 +      return Op_FmaVHF;
 +    default:
 +      return 0; // Unimplemented
 +  }
 +}
 +
 +// Make a vectornode for half float unary/binary operations
 +VectorNode* VectorNode::make(int vopc, Node* n1, Node* n2, uint vlen) {
 +  const TypeVect* vt = TypeVect::make(T_SHORT, vlen);
 +  // This method should not be called for unimplemented vectors.
 +  switch (vopc) {
 +    case Op_AddVHF: return new AddVHFNode(n1, n2, vt);
 +    case Op_SubVHF: return new SubVHFNode(n1, n2, vt);
 +    case Op_MulVHF: return new MulVHFNode(n1, n2, vt);
 +    case Op_DivVHF: return new DivVHFNode(n1, n2, vt);
 +    case Op_AbsVHF: return new AbsVHFNode(n1, vt);
 +    case Op_NegVHF: return new NegVHFNode(n1, vt);
 +
 +  default:
 +    fatal("Missed vector creation for '%s'", NodeClassNames[vopc]);
 +    return NULL;
 +  }
 +}
 +
  // Limits on vector size (number of elements) for auto-vectorization.
- bool VectorNode::vector_size_supported_superword(const BasicType bt, int size) {
-   return Matcher::superword_max_vector_size(bt) >= size &&
+ bool VectorNode::vector_size_supported_auto_vectorization(const BasicType bt, int size) {
+   return Matcher::max_vector_size_auto_vectorization(bt) >= size &&
           Matcher::min_vector_size(bt) <= size;
  }
  
@@@ -746,6 -803,22 +849,24 @@@ VectorNode* VectorNode::make(int vopc, 
    case Op_ExpandBitsV: return new ExpandBitsVNode(n1, n2, vt);
    case Op_CountLeadingZerosV: return new CountLeadingZerosVNode(n1, vt);
    case Op_CountTrailingZerosV: return new CountTrailingZerosVNode(n1, vt);
+ 
+   case Op_SaturatingAddV: return new SaturatingAddVNode(n1, n2, vt, is_unsigned);
+   case Op_SaturatingSubV: return new SaturatingSubVNode(n1, n2, vt, is_unsigned);
+ 
+   case Op_VectorCastB2X:  return new VectorCastB2XNode(n1, vt);
+   case Op_VectorCastS2X:  return new VectorCastS2XNode(n1, vt);
+   case Op_VectorCastI2X:  return new VectorCastI2XNode(n1, vt);
+   case Op_VectorCastL2X:  return new VectorCastL2XNode(n1, vt);
+   case Op_VectorCastF2X:  return new VectorCastF2XNode(n1, vt);
+   case Op_VectorCastD2X:  return new VectorCastD2XNode(n1, vt);
+   case Op_VectorUCastB2X: return new VectorUCastB2XNode(n1, vt);
+   case Op_VectorUCastS2X: return new VectorUCastS2XNode(n1, vt);
+   case Op_VectorUCastI2X: return new VectorUCastI2XNode(n1, vt);
+   case Op_VectorCastHF2F: return new VectorCastHF2FNode(n1, vt);
+   case Op_VectorCastF2HF: return new VectorCastF2HFNode(n1, vt);
++  case Op_VectorCastD2HF: return new VectorCastD2HFNode(n1, vt);
++  case Op_VectorCastHF2D: return new VectorCastHF2DNode(n1, vt);
+ 
    default:
      fatal("Missed vector creation for '%s'", NodeClassNames[vopc]);
      return nullptr;
@@@ -1318,24 -1476,9 +1537,25 @@@ int ReductionNode::opcode(int opc, Basi
    return vopc;
  }
  
 +//Haffloat reduction nodes.
 +int ReductionNode::opcode(int opc) {
 +  int vopc = opc;
 +  switch (opc) {
 +    case Op_AddI:
 +      vopc = Op_AddReductionVHF;
 +      break;
 +    case Op_MulI:
 +      vopc = Op_MulReductionVF;
 +      break;
 +    default: ShouldNotReachHere(); return 0;
 +  }
 +  return vopc;
 +}
 +
 +
  // Return the appropriate reduction node.
- ReductionNode* ReductionNode::make(int opc, Node *ctrl, Node* n1, Node* n2, BasicType bt) {
+ ReductionNode* ReductionNode::make(int opc, Node* ctrl, Node* n1, Node* n2, BasicType bt,
+                                    bool requires_strict_order) {
  
    int vopc = opcode(opc, bt);
  
@@@ -1345,17 -1488,17 +1565,18 @@@
    switch (vopc) {
    case Op_AddReductionVI: return new AddReductionVINode(ctrl, n1, n2);
    case Op_AddReductionVL: return new AddReductionVLNode(ctrl, n1, n2);
-   case Op_AddReductionVF: return new AddReductionVFNode(ctrl, n1, n2);
-   case Op_AddReductionVD: return new AddReductionVDNode(ctrl, n1, n2);
+   case Op_AddReductionVF: return new AddReductionVFNode(ctrl, n1, n2, requires_strict_order);
+   case Op_AddReductionVD: return new AddReductionVDNode(ctrl, n1, n2, requires_strict_order);
    case Op_MulReductionVI: return new MulReductionVINode(ctrl, n1, n2);
    case Op_MulReductionVL: return new MulReductionVLNode(ctrl, n1, n2);
-   case Op_MulReductionVF: return new MulReductionVFNode(ctrl, n1, n2);
-   case Op_MulReductionVD: return new MulReductionVDNode(ctrl, n1, n2);
-   case Op_MinReductionV:  return new MinReductionVNode(ctrl, n1, n2);
-   case Op_MaxReductionV:  return new MaxReductionVNode(ctrl, n1, n2);
-   case Op_AndReductionV:  return new AndReductionVNode(ctrl, n1, n2);
-   case Op_OrReductionV:   return new OrReductionVNode(ctrl, n1, n2);
-   case Op_XorReductionV:  return new XorReductionVNode(ctrl, n1, n2);
+   case Op_MulReductionVF: return new MulReductionVFNode(ctrl, n1, n2, requires_strict_order);
+   case Op_MulReductionVD: return new MulReductionVDNode(ctrl, n1, n2, requires_strict_order);
+   case Op_MinReductionV:  return new MinReductionVNode (ctrl, n1, n2);
+   case Op_MaxReductionV:  return new MaxReductionVNode (ctrl, n1, n2);
+   case Op_AndReductionV:  return new AndReductionVNode (ctrl, n1, n2);
+   case Op_OrReductionV:   return new OrReductionVNode  (ctrl, n1, n2);
+   case Op_XorReductionV:  return new XorReductionVNode (ctrl, n1, n2);
++  case Op_AddReductionVHF: return new AddReductionVHFNode(ctrl, n1, n2);
    default:
      assert(false, "unknown node: %s", NodeClassNames[vopc]);
      return nullptr;
@@@ -1407,28 -1578,11 +1656,6 @@@ VectorStoreMaskNode* VectorStoreMaskNod
    return new VectorStoreMaskNode(in, gvn.intcon(elem_size), vt);
  }
  
- VectorCastNode* VectorCastNode::make(int vopc, Node* n1, BasicType bt, uint vlen) {
 -VectorNode* VectorCastNode::make(int vopc, Node* n1, BasicType bt, uint vlen) {
--  const TypeVect* vt = TypeVect::make(bt, vlen);
-   switch (vopc) {
-     case Op_VectorCastB2X:  return new VectorCastB2XNode(n1, vt);
-     case Op_VectorCastS2X:  return new VectorCastS2XNode(n1, vt);
-     case Op_VectorCastI2X:  return new VectorCastI2XNode(n1, vt);
-     case Op_VectorCastL2X:  return new VectorCastL2XNode(n1, vt);
-     case Op_VectorCastF2X:  return new VectorCastF2XNode(n1, vt);
-     case Op_VectorCastD2X:  return new VectorCastD2XNode(n1, vt);
-     case Op_VectorUCastB2X: return new VectorUCastB2XNode(n1, vt);
-     case Op_VectorUCastS2X: return new VectorUCastS2XNode(n1, vt);
-     case Op_VectorUCastI2X: return new VectorUCastI2XNode(n1, vt);
-     case Op_VectorCastHF2F: return new VectorCastHF2FNode(n1, vt);
-     case Op_VectorCastF2HF: return new VectorCastF2HFNode(n1, vt);
-     case Op_VectorCastD2HF: return new VectorCastD2HFNode(n1, vt);
-     case Op_VectorCastHF2D: return new VectorCastHF2DNode(n1, vt);
-     default:
-       assert(false, "unknown node: %s", NodeClassNames[vopc]);
-       return nullptr;
-   }
 -  return VectorNode::make(vopc, n1, nullptr, vt);
--}
--
  int VectorCastNode::opcode(int sopc, BasicType bt, bool is_signed) {
    assert((is_integral_type(bt) && bt != T_LONG) || is_signed, "");
  
diff --cc src/hotspot/share/opto/vectornode.hpp
index 05842f800a4,463680d0a52..fe6ce709da1
--- a/src/hotspot/share/opto/vectornode.hpp
+++ b/src/hotspot/share/opto/vectornode.hpp
@@@ -80,11 -82,9 +82,11 @@@ class VectorNode : public TypeNode 
    static VectorNode* make(int opc, Node* n1, Node* n2, Node* n3, uint vlen, BasicType bt);
    static VectorNode* make(int vopc, Node* n1, Node* n2, Node* n3, const TypeVect* vt);
    static VectorNode* make_mask_node(int vopc, Node* n1, Node* n2, uint vlen, BasicType bt);
 +  static VectorNode* make(int vopc, Node* n1, Node* n2, uint vlen);
 +  static VectorNode* make(int vopc, Node* n1, Node* n2, Node* n3, uint vlen);
  
    static bool is_shift_opcode(int opc);
-   static bool can_transform_shift_op(Node* n, BasicType bt);
+   static bool can_use_RShiftI_instead_of_URShiftI(Node* n, BasicType bt);
    static bool is_convert_opcode(int opc);
    static bool is_minmax_opcode(int opc);
  
@@@ -92,12 -94,13 +96,14 @@@
  
    static bool is_rotate_opcode(int opc);
  
-   static int  opcode(int opc, BasicType bt);
+   static int opcode(int sopc, BasicType bt);         // scalar_opc -> vector_opc
 +  static int opcode(int opc);
-   static int replicate_opcode(BasicType bt);
+   static int scalar_opcode(int vopc, BasicType bt);  // vector_opc -> scalar_opc
+ 
+   static int shift_count_opcode(int opc);
  
    // Limits on vector size (number of elements) for auto-vectorization.
-   static bool vector_size_supported_superword(const BasicType bt, int size);
+   static bool vector_size_supported_auto_vectorization(const BasicType bt, int size);
    static bool implemented(int opc, uint vlen, BasicType bt);
    static bool is_shift(Node* n);
    static bool is_vshift_cnt(Node* n);
@@@ -202,14 -243,17 +246,18 @@@ class ReductionNode : public Node 
   public:
    ReductionNode(Node *ctrl, Node* in1, Node* in2) : Node(ctrl, in1, in2),
                 _bottom_type(Type::get_const_basic_type(in1->bottom_type()->basic_type())),
-                _vect_type(in2->bottom_type()->is_vect()) {}
+                _vect_type(in2->bottom_type()->is_vect()) {
+     init_class_id(Class_Reduction);
+   }
  
-   static ReductionNode* make(int opc, Node *ctrl, Node* in1, Node* in2, BasicType bt);
-   static ReductionNode* make(int opc, Node *ctrl, Node* in1, Node* in2);
+   static ReductionNode* make(int opc, Node* ctrl, Node* in1, Node* in2, BasicType bt,
+                              // This only effects floating-point add and mul reductions.
+                              bool requires_strict_order = true);
    static int  opcode(int opc, BasicType bt);
 +  static int  opcode(int opc);
    static bool implemented(int opc, uint vlen, BasicType bt);
-   static Node* make_reduction_input(PhaseGVN& gvn, int opc, BasicType bt);
+   // Make an identity scalar (zero for add, one for mul, etc) for scalar opc.
+   static Node* make_identity_con_scalar(PhaseGVN& gvn, int sopc, BasicType bt);
  
    virtual const Type* bottom_type() const {
      return _bottom_type;
@@@ -248,21 -313,30 +317,40 @@@ public
  //------------------------------AddReductionVFNode--------------------------------------
  // Vector add float as a reduction
  class AddReductionVFNode : public ReductionNode {
+ private:
+   // True if add reduction operation for floats requires strict ordering.
+   // As an example - The value is true when add reduction for floats is auto-vectorized
+   // as auto-vectorization mandates strict ordering but the value is false when this node
+   // is generated through VectorAPI as VectorAPI does not impose any such rules on ordering.
+   const bool _requires_strict_order;
  public:
-   AddReductionVFNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
+   //_requires_strict_order is set to true by default as mandated by auto-vectorization
+   AddReductionVFNode(Node* ctrl, Node* in1, Node* in2, bool requires_strict_order = true) :
+     ReductionNode(ctrl, in1, in2), _requires_strict_order(requires_strict_order) {}
+ 
    virtual int Opcode() const;
+ 
+   virtual bool requires_strict_order() const { return _requires_strict_order; }
+ 
+   virtual uint hash() const { return Node::hash() + _requires_strict_order; }
+ 
+   virtual bool cmp(const Node& n) const {
+     return Node::cmp(n) && _requires_strict_order == ((ReductionNode&)n).requires_strict_order();
+   }
+ 
+   virtual uint size_of() const { return sizeof(*this); }
  };
  
 +//------------------------------AddReductionVHFNode--------------------------------------
 +// Vector add halffloat as a reduction
 +class AddReductionVHFNode : public ReductionNode {
 +public:
 +  AddReductionVHFNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
 +  virtual int Opcode() const;
 +  virtual const Type* bottom_type() const { return TypeInt::SHORT; }
 +  virtual uint ideal_reg() const { return Op_RegF; }
 +};
 +
  //------------------------------AddReductionVDNode--------------------------------------
  // Vector add double as a reduction
  class AddReductionVDNode : public ReductionNode {
@@@ -303,6 -396,31 +410,22 @@@ class SubVLNode : public VectorNode 
    virtual int Opcode() const;
  };
  
+ //------------------------------SaturatingAddVNode-----------------------------
+ // Vector saturating addition.
+ class SaturatingAddVNode : public SaturatingVectorNode {
+  public:
+   SaturatingAddVNode(Node* in1, Node* in2, const TypeVect* vt, bool is_unsigned) : SaturatingVectorNode(in1, in2, vt, is_unsigned) {}
+   virtual int Opcode() const;
+ };
+ 
+ //------------------------------SaturatingSubVNode-----------------------------
+ // Vector saturating subtraction.
+ class SaturatingSubVNode : public SaturatingVectorNode {
+  public:
+   SaturatingSubVNode(Node* in1, Node* in2, const TypeVect* vt, bool is_unsigned) : SaturatingVectorNode(in1, in2, vt, is_unsigned) {}
+   virtual int Opcode() const;
+ };
+ 
 -//------------------------------SubVHFNode--------------------------------------
 -// Vector subtract half float
 -class SubVHFNode : public VectorNode {
 -public:
 -  SubVHFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
 -  virtual int Opcode() const;
 -};
 -
 -
  //------------------------------SubVFNode--------------------------------------
  // Vector subtract float
  class SubVFNode : public VectorNode {
@@@ -408,31 -531,14 +544,30 @@@ public
    virtual int Opcode() const;
  };
  
- //------------------------------FmaVHFNode-------------------------------------
- // Vector multiply halffloat
- class FmaVHFNode : public VectorNode {
- public:
-   FmaVHFNode(Node* in1, Node* in2, Node* in3, const TypeVect* vt) : VectorNode(in1, in2, in3, vt) {}
-   virtual int Opcode() const;
- };
- 
- 
 +//------------------------------CMoveVFNode--------------------------------------
 +// Vector float conditional move
 +class CMoveVFNode : public VectorNode {
 +public:
 +  CMoveVFNode(Node* in1, Node* in2, Node* in3, const TypeVect* vt) : VectorNode(in1, in2, in3, vt) {}
 +  virtual int Opcode() const;
 +};
 +
 +//------------------------------CMoveVDNode--------------------------------------
 +// Vector double conditional move
 +class CMoveVDNode : public VectorNode {
 +public:
 +  CMoveVDNode(Node* in1, Node* in2, Node* in3, const TypeVect* vt) : VectorNode(in1, in2, in3, vt) {}
 +  virtual int Opcode() const;
 +};
 +
+ //------------------------------FmaVHFNode-------------------------------------
+ // Vector fused-multiply-add half-precision float
+ class FmaVHFNode : public FmaVNode {
+ public:
+   FmaVHFNode(Node* in1, Node* in2, Node* in3, const TypeVect* vt) : FmaVNode(in1, in2, in3, vt) {}
+   virtual int Opcode() const;
+ };
+ 
  //------------------------------MulReductionVINode--------------------------------------
  // Vector multiply byte, short and int as a reduction
  class MulReductionVINode : public ReductionNode {
@@@ -460,11 -584,37 +613,29 @@@ public
  //------------------------------MulReductionVDNode--------------------------------------
  // Vector multiply double as a reduction
  class MulReductionVDNode : public ReductionNode {
+   // True if mul reduction operation for doubles requires strict ordering.
+   // As an example - The value is true when mul reduction for doubles is auto-vectorized
+   // as auto-vectorization mandates strict ordering but the value is false when this node
+   // is generated through VectorAPI as VectorAPI does not impose any such rules on ordering.
+   const bool _requires_strict_order;
  public:
-   MulReductionVDNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
+   //_requires_strict_order is set to true by default as mandated by auto-vectorization
+   MulReductionVDNode(Node* ctrl, Node* in1, Node* in2, bool requires_strict_order = true) :
+     ReductionNode(ctrl, in1, in2), _requires_strict_order(requires_strict_order) {}
+ 
    virtual int Opcode() const;
+ 
+   virtual bool requires_strict_order() const { return _requires_strict_order; }
+ 
+   virtual uint hash() const { return Node::hash() + _requires_strict_order; }
+ 
+   virtual bool cmp(const Node& n) const {
+     return Node::cmp(n) && _requires_strict_order == ((ReductionNode&)n).requires_strict_order();
+   }
+ 
+   virtual uint size_of() const { return sizeof(*this); }
  };
  
 -//------------------------------DivVHFNode-------------------------------------
 -// Vector divide half float
 -class DivVHFNode : public VectorNode {
 -public:
 -  DivVHFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
 -  virtual int Opcode() const;
 -};
 -
  //------------------------------DivVFNode--------------------------------------
  // Vector divide float
  class DivVFNode : public VectorNode {
diff --cc src/hotspot/share/prims/vectorSupport.cpp
index 54fb1cf4d49,002f737e788..8bdef69234f
--- a/src/hotspot/share/prims/vectorSupport.cpp
+++ b/src/hotspot/share/prims/vectorSupport.cpp
@@@ -77,7 -55,7 +55,7 @@@ BasicType VectorSupport::klass2bt(Insta
    assert(ik->is_subclass_of(vmClasses::vector_VectorPayload_klass()), "%s not a VectorPayload", ik->name()->as_C_string());
    fieldDescriptor fd; // find_field initializes fd if found
    // static final Class<?> ETYPE;
--  Klass* holder = ik->find_field(vmSymbols::ETYPE_name(), vmSymbols::class_signature(), &fd);
++  Klass* holder = ik->find_field(vmSymbols::CTYPE_name(), vmSymbols::class_signature(), &fd);
  
    assert(holder != nullptr, "sanity");
    assert(fd.is_static(), "");
diff --cc src/hotspot/share/prims/vectorSupport.hpp
index c840a66f7ca,5ba18cdfaa8..8f9bb0db155
--- a/src/hotspot/share/prims/vectorSupport.hpp
+++ b/src/hotspot/share/prims/vectorSupport.hpp
@@@ -131,9 -114,10 +114,17 @@@ class VectorSupport : AllStatic 
      VEC_SIZE_128 = 1,
      VEC_SIZE_256 = 2,
      VEC_SIZE_512 = 3,
-     NUM_VEC_SIZES = 4
+     VEC_SIZE_SCALABLE = 4,
+     NUM_VEC_SIZES = 5
+   };
+ 
++  enum {
++    VECTOR_TYPE_PRIM = 1,
++    VECTOR_TYPE_FP16 = 2,
++    VECTOR_TYPE_FP8  = 3,
++    VECTOR_TYPE_INT8 = 4
 +  };
 +
    enum {
      MODE_BROADCAST = 0,
      MODE_BITS_COERCED_LONG_TO_MASK = 1
diff --cc src/java.base/share/classes/jdk/internal/misc/X-ScopedMemoryAccess.java.template
index 773b3200a60,158df7c8bb3..7a6bd66ca25
--- a/src/java.base/share/classes/jdk/internal/misc/X-ScopedMemoryAccess.java.template
+++ b/src/java.base/share/classes/jdk/internal/misc/X-ScopedMemoryAccess.java.template
@@@ -325,7 -326,7 +326,7 @@@ public final class ScopedMemoryAccess 
      @ForceInline
      public static
      <V extends VectorSupport.Vector<E>, E, S extends VectorSupport.VectorSpecies<E>>
--    V loadFromMemorySegment(Class<? extends V> vmClass, Class<E> e, int length,
++    V loadFromMemorySegment(Class<? extends V> vmClass, Class<?> c, Class<E> e, int operType, int length,
                           AbstractMemorySegmentImpl msp, long offset,
                           S s,
                           VectorSupport.LoadOperation<AbstractMemorySegmentImpl, V, S> defaultImpl) {
@@@ -337,7 -334,7 +334,7 @@@
          try {
              return loadFromMemorySegmentScopedInternal(
                      msp.sessionImpl(),
--                    vmClass, e, length,
++                    vmClass, c, e, operType, length,
                      msp, offset,
                      s,
                      defaultImpl);
@@@ -351,15 -348,15 +348,15 @@@
      private static
      <V extends VectorSupport.Vector<E>, E, S extends VectorSupport.VectorSpecies<E>>
      V loadFromMemorySegmentScopedInternal(MemorySessionImpl session,
--                                          Class<? extends V> vmClass, Class<E> e, int length,
++                                          Class<? extends V> vmClass, Class<?> c, Class<E> e, int operType, int length,
                                            AbstractMemorySegmentImpl msp, long offset,
                                            S s,
                                            VectorSupport.LoadOperation<AbstractMemorySegmentImpl, V, S> defaultImpl) {
          try {
              session.checkValidStateRaw();
  
--            return VectorSupport.load(vmClass, e, length,
-                     msp.unsafeGetBase(), msp.unsafeGetOffset() + offset,
++            return VectorSupport.load(vmClass, c, e, operType, length,
+                     msp.unsafeGetBase(), msp.unsafeGetOffset() + offset, true,
                      msp, offset, s,
                      defaultImpl);
          } finally {
@@@ -371,18 -368,14 +368,14 @@@
      public static
      <V extends VectorSupport.Vector<E>, E, S extends VectorSupport.VectorSpecies<E>,
       M extends VectorSupport.VectorMask<E>>
--    V loadFromMemorySegmentMasked(Class<? extends V> vmClass, Class<M> maskClass, Class<E> e,
++    V loadFromMemorySegmentMasked(Class<? extends V> vmClass, Class<M> maskClass, Class<?> c, Class<E> e, int operType,
                                    int length, AbstractMemorySegmentImpl msp, long offset, M m, S s, int offsetInRange,
                                    VectorSupport.LoadVectorMaskedOperation<AbstractMemorySegmentImpl, V, S, M> defaultImpl) {
-         // @@@ Smarter alignment checking if accessing heap segment backing non-byte[] array
-         if (msp.maxAlignMask() > 1) {
-             throw new IllegalArgumentException();
-         }
  
          try {
              return loadFromMemorySegmentMaskedScopedInternal(
                      msp.sessionImpl(),
--                    vmClass, maskClass, e, length,
++                    vmClass, maskClass, c, e, operType, length,
                      msp, offset, m,
                      s, offsetInRange,
                      defaultImpl);
@@@ -397,15 -390,15 +390,15 @@@
      <V extends VectorSupport.Vector<E>, E, S extends VectorSupport.VectorSpecies<E>,
       M extends VectorSupport.VectorMask<E>>
      V loadFromMemorySegmentMaskedScopedInternal(MemorySessionImpl session, Class<? extends V> vmClass,
--                                                Class<M> maskClass, Class<E> e, int length,
++                                                Class<M> maskClass, Class<?> c, Class<E> e, int operType, int length,
                                                  AbstractMemorySegmentImpl msp, long offset, M m,
                                                  S s, int offsetInRange,
                                                  VectorSupport.LoadVectorMaskedOperation<AbstractMemorySegmentImpl, V, S, M> defaultImpl) {
          try {
              session.checkValidStateRaw();
  
--            return VectorSupport.loadMasked(vmClass, maskClass, e, length,
-                     msp.unsafeGetBase(), msp.unsafeGetOffset() + offset, m, offsetInRange,
++            return VectorSupport.loadMasked(vmClass, maskClass, c, e, operType, length,
+                     msp.unsafeGetBase(), msp.unsafeGetOffset() + offset, true, m, offsetInRange,
                      msp, offset, s,
                      defaultImpl);
          } finally {
@@@ -416,7 -409,7 +409,7 @@@
      @ForceInline
      public static
      <V extends VectorSupport.Vector<E>, E>
--    void storeIntoMemorySegment(Class<? extends V> vmClass, Class<E> e, int length,
++    void storeIntoMemorySegment(Class<? extends V> vmClass, Class<?> c, Class<E> e, int operType, int length,
                                  V v,
                                  AbstractMemorySegmentImpl msp, long offset,
                                  VectorSupport.StoreVectorOperation<AbstractMemorySegmentImpl, V> defaultImpl) {
@@@ -428,7 -417,7 +417,7 @@@
          try {
              storeIntoMemorySegmentScopedInternal(
                      msp.sessionImpl(),
--                    vmClass, e, length,
++                    vmClass, c, e, operType, length,
                      v,
                      msp, offset,
                      defaultImpl);
@@@ -442,15 -431,15 +431,15 @@@
      private static
      <V extends VectorSupport.Vector<E>, E>
      void storeIntoMemorySegmentScopedInternal(MemorySessionImpl session,
--                                              Class<? extends V> vmClass, Class<E> e, int length,
++                                              Class<? extends V> vmClass, Class<?> c, Class<E> e, int operType, int length,
                                                V v,
                                                AbstractMemorySegmentImpl msp, long offset,
                                                VectorSupport.StoreVectorOperation<AbstractMemorySegmentImpl, V> defaultImpl) {
          try {
              session.checkValidStateRaw();
  
--            VectorSupport.store(vmClass, e, length,
-                     msp.unsafeGetBase(), msp.unsafeGetOffset() + offset,
++            VectorSupport.store(vmClass, c, e, operType, length,
+                     msp.unsafeGetBase(), msp.unsafeGetOffset() + offset, true,
                      v,
                      msp, offset,
                      defaultImpl);
@@@ -462,19 -451,15 +451,15 @@@
      @ForceInline
      public static
      <V extends VectorSupport.Vector<E>, E, M extends VectorSupport.VectorMask<E>>
--    void storeIntoMemorySegmentMasked(Class<? extends V> vmClass, Class<M> maskClass, Class<E> e,
--                                      int length, V v, M m,
++    void storeIntoMemorySegmentMasked(Class<? extends V> vmClass, Class<M> maskClass, Class<?> c, Class<E> e,
++                                      int operType, int length, V v, M m,
                                        AbstractMemorySegmentImpl msp, long offset,
                                        VectorSupport.StoreVectorMaskedOperation<AbstractMemorySegmentImpl, V, M> defaultImpl) {
-         // @@@ Smarter alignment checking if accessing heap segment backing non-byte[] array
-         if (msp.maxAlignMask() > 1) {
-             throw new IllegalArgumentException();
-         }
  
          try {
              storeIntoMemorySegmentMaskedScopedInternal(
                      msp.sessionImpl(),
--                    vmClass, maskClass, e, length,
++                    vmClass, maskClass, c, e, operType, length,
                      v, m,
                      msp, offset,
                      defaultImpl);
@@@ -489,14 -474,14 +474,14 @@@
      <V extends VectorSupport.Vector<E>, E, M extends VectorSupport.VectorMask<E>>
      void storeIntoMemorySegmentMaskedScopedInternal(MemorySessionImpl session,
                                                      Class<? extends V> vmClass, Class<M> maskClass,
--                                                    Class<E> e, int length, V v, M m,
++                                                    Class<?> c, Class<E> e, int operType, int length, V v, M m,
                                                      AbstractMemorySegmentImpl msp, long offset,
                                                      VectorSupport.StoreVectorMaskedOperation<AbstractMemorySegmentImpl, V, M> defaultImpl) {
          try {
              session.checkValidStateRaw();
  
--            VectorSupport.storeMasked(vmClass, maskClass, e, length,
-                     msp.unsafeGetBase(), msp.unsafeGetOffset() + offset,
++            VectorSupport.storeMasked(vmClass, maskClass, c, e, operType, length,
+                     msp.unsafeGetBase(), msp.unsafeGetOffset() + offset, true,
                      v, m,
                      msp, offset,
                      defaultImpl);
diff --cc src/java.base/share/classes/jdk/internal/vm/vector/VectorSupport.java
index ad64e707af3,d3705a279ca..b8bb054e756
--- a/src/java.base/share/classes/jdk/internal/vm/vector/VectorSupport.java
+++ b/src/java.base/share/classes/jdk/internal/vm/vector/VectorSupport.java
@@@ -137,15 -149,14 +149,21 @@@ public class VectorSupport 
      public static final int MODE_BROADCAST = 0;
      public static final int MODE_BITS_COERCED_LONG_TO_MASK = 1;
  
++    // Vector operation types.
++    public static final int VECTOR_TYPE_PRIM = 1;
++    public static final int VECTOR_TYPE_FP16 = 2;
++    public static final int VECTOR_TYPE_FP8  = 3;
++    public static final int VECTOR_TYPE_INT8 = 4;
++
      // BasicType codes, for primitives only:
      public static final int
 -        T_FLOAT   = 6,
 -        T_DOUBLE  = 7,
 -        T_BYTE    = 8,
 -        T_SHORT   = 9,
 -        T_INT     = 10,
 -        T_LONG    = 11;
 +        T_HALFFLOAT = 5,
 +        T_FLOAT     = 6,
 +        T_DOUBLE    = 7,
 +        T_BYTE      = 8,
 +        T_SHORT     = 9,
 +        T_INT       = 10,
 +        T_LONG      = 11;
  
      /* ============================================================================ */
  
@@@ -203,7 -203,7 +210,7 @@@
      <VM extends VectorPayload,
       S extends VectorSpecies<E>,
       E>
--    VM fromBitsCoerced(Class<? extends VM> vmClass, Class<E> eClass,
++    VM fromBitsCoerced(Class<? extends VM> vmClass, Class<?> cClass, Class<E> eClass, int operType,
                         int length,
                         long bits, int mode, S s,
                         FromBitsCoercedOperation<VM, S> defaultImpl) {
@@@ -221,7 -221,7 +228,7 @@@
      public static
      <E,
       M extends VectorMask<E>>
--    M indexPartiallyInUpperRange(Class<? extends M> mClass, Class<E> eClass,
++    M indexPartiallyInUpperRange(Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,
                                   int length, long offset, long limit,
                                   IndexPartiallyInUpperRangeOperation<E, M> defaultImpl) {
          assert isNonCapturingLambda(defaultImpl) : defaultImpl;
@@@ -239,7 -239,7 +246,7 @@@
      <V extends Vector<E>,
       E,
       S extends VectorSpecies<E>>
--    V indexVector(Class<? extends V> vClass, Class<E> eClass,
++    V indexVector(Class<? extends V> vClass, Class<?> cClass, Class<E> eClass, int operType,
                    int length,
                    V v, int step, S s,
                    IndexOperation<V, S> defaultImpl) {
@@@ -260,7 -260,7 +267,7 @@@
       M extends VectorMask<E>,
       E>
      long reductionCoerced(int oprId,
--                          Class<? extends V> vClass, Class<? extends M> mClass, Class<E> eClass,
++                          Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,
                            int length,
                            V v, M m,
                            ReductionOperation<V, M> defaultImpl) {
@@@ -277,14 -277,14 +284,14 @@@
  
      @IntrinsicCandidate
      public static
-     <V extends Vector<E>,
+     <VM extends VectorPayload,
       E>
-     long extract(Class<? extends V> vClass, Class<E> eClass,
 -    long extract(Class<? extends VM> vClass, Class<E> eClass,
++    long extract(Class<? extends VM> vClass, Class<?> cClass, Class<E> eClass, int operType,
                   int length,
-                  V v, int i,
-                  VecExtractOp<V> defaultImpl) {
+                  VM vm, int i,
+                  VecExtractOp<VM> defaultImpl) {
          assert isNonCapturingLambda(defaultImpl) : defaultImpl;
-         return defaultImpl.apply(v, i);
+         return defaultImpl.apply(vm, i);
      }
  
      /* ============================================================================ */
@@@ -297,7 -297,7 +304,7 @@@
      public static
      <V extends Vector<E>,
       E>
--    V insert(Class<? extends V> vClass, Class<E> eClass,
++    V insert(Class<? extends V> vClass, Class<?> cClass, Class<E> eClass, int operType,
               int length,
               V v, int i, long val,
               VecInsertOp<V> defaultImpl) {
@@@ -318,7 -318,7 +325,7 @@@
       M extends VectorMask<E>,
       E>
      V unaryOp(int oprId,
--              Class<? extends V> vClass, Class<? extends M> mClass, Class<E> eClass,
++              Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,
                int length,
                V v, M m,
                UnaryOperation<V, M> defaultImpl) {
@@@ -339,7 -356,7 +363,7 @@@
       M extends VectorMask<E>,
       E>
      VM binaryOp(int oprId,
--                Class<? extends VM> vmClass, Class<? extends M> mClass, Class<E> eClass,
++                Class<? extends VM> vmClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,
                  int length,
                  VM v1, VM v2, M m,
                  BinaryOperation<VM, M> defaultImpl) {
@@@ -349,6 -366,42 +373,42 @@@
  
      /* ============================================================================ */
  
+ //    public interface LibraryBinaryOperation<V extends VectorPayload,
+ //            M extends VectorMask<?>> {
+ //        V apply(MemorySegment entry, V v1, V v2, M m);
+ //    }
+ 
+     @IntrinsicCandidate
+     public static
+     <V extends VectorPayload, E>
+     V libraryBinaryOp(long addr, Class<? extends V> vClass, Class<E> eClass, int length, String debugName,
+                       V v1, V v2,
+                       BinaryOperation<V,?> defaultImpl) {
+         assert isNonCapturingLambda(defaultImpl) : defaultImpl;
+         return defaultImpl.apply(v1, v2, null);
+     }
+ 
+     /* ============================================================================ */
+ 
+     public interface SelectFromTwoVector<V extends Vector<?>> {
+         V apply(V v1, V v2, V v3);
+     }
+ 
+     @IntrinsicCandidate
+     public static
+     <V extends Vector<E>,
+      E>
 -    V selectFromTwoVectorOp(Class<? extends V> vClass, Class<E> eClass, int length,
++    V selectFromTwoVectorOp(Class<? extends V> vClass, Class<?> cClass, Class<E> eClass, int operType, int length,
+                             V v1, V v2, V v3,
+                             SelectFromTwoVector<V> defaultImpl) {
+         assert isNonCapturingLambda(defaultImpl) : defaultImpl;
+         return defaultImpl.apply(v1, v2, v3);
+     }
+ 
+     /* ============================================================================ */
+ 
+     /* ============================================================================ */
+ 
      public interface TernaryOperation<V extends Vector<?>,
                                        M extends VectorMask<?>> {
          V apply(V v1, V v2, V v3, M m);
@@@ -360,7 -413,7 +420,7 @@@
       M extends VectorMask<E>,
       E>
      V ternaryOp(int oprId,
--                Class<? extends V> vClass, Class<? extends M> mClass, Class<E> eClass,
++                Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,
                  int length,
                  V v1, V v2, V v3, M m,
                  TernaryOperation<V, M> defaultImpl) {
@@@ -384,9 -437,9 +444,9 @@@
       VM extends VectorPayload,
       E,
       S extends VectorSpecies<E>>
--    VM load(Class<? extends VM> vmClass, Class<E> eClass,
++    VM load(Class<? extends VM> vmClass, Class<?> cClass, Class<E> eClass, int operType,
              int length,
-             Object base, long offset,
+             Object base, long offset, boolean fromSegment,
              C container, long index, S s,
              LoadOperation<C, VM, S> defaultImpl) {
          assert isNonCapturingLambda(defaultImpl) : defaultImpl;
@@@ -409,8 -462,8 +469,8 @@@
       E,
       S extends VectorSpecies<E>,
       M extends VectorMask<E>>
--    V loadMasked(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,
-                  int length, Object base, long offset,
++    V loadMasked(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,
+                  int length, Object base, long offset, boolean fromSegment,
                   M m, int offsetInRange,
                   C container, long index, S s,
                   LoadVectorMaskedOperation<C, V, S, M> defaultImpl) {
@@@ -435,11 -488,11 +495,11 @@@
       S extends VectorSpecies<E>,
       M extends VectorMask<E>,
       E>
--    V loadWithMap(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,
++    V loadWithMap(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,
                    int length,
                    Class<? extends Vector<Integer>> vectorIndexClass,
-                   Object base, long offset,
-                   W index_vector,
+                   int indexLength, Object base, long offset,
+                   W indexVector1, W indexVector2, W indexVector3, W indexVector4,
                    M m, C container, int index, int[] indexMap, int indexM, S s,
                    LoadVectorOperationWithMap<C, V, S, M> defaultImpl) {
          assert isNonCapturingLambda(defaultImpl) : defaultImpl;
@@@ -457,9 -510,9 +517,9 @@@
      public static
      <C,
       V extends VectorPayload>
--    void store(Class<?> vClass, Class<?> eClass,
++    void store(Class<?> vClass, Class<?> cClass, Class<?> eClass, int operType,
                 int length,
-                Object base, long offset,
+                Object base, long offset, boolean fromSegment,
                 V v, C container, long index,
                 StoreVectorOperation<C, V> defaultImpl) {
          assert isNonCapturingLambda(defaultImpl) : defaultImpl;
@@@ -478,9 -531,9 +538,9 @@@
       V extends Vector<E>,
       M extends VectorMask<E>,
       E>
--    void storeMasked(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,
++    void storeMasked(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,
                       int length,
-                      Object base, long offset,
+                      Object base, long offset, boolean fromSegment,
                       V v, M m, C container, long index,
                       StoreVectorMaskedOperation<C, V, M> defaultImpl) {
          assert isNonCapturingLambda(defaultImpl) : defaultImpl;
@@@ -502,11 -555,11 +562,11 @@@
       W extends Vector<Integer>,
       M extends VectorMask<E>,
       E>
--    void storeWithMap(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,
++    void storeWithMap(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,
                        int length,
                        Class<? extends Vector<Integer>> vectorIndexClass,
-                       Object base, long offset,
-                       W index_vector,
+                       int indexLength, Object base, long offset,
+                       W indexVector,
                        V v, M m, C container, int index, int[] indexMap, int indexM,
                        StoreVectorOperationWithMap<C, V, M> defaultImpl) {
          assert isNonCapturingLambda(defaultImpl) : defaultImpl;
@@@ -520,7 -573,7 +580,7 @@@
      <M extends VectorMask<E>,
       E>
      boolean test(int cond,
--                 Class<?> mClass, Class<?> eClass,
++                 Class<?> mClass, Class<?> cClass, Class<E> eClass, int opType,
                   int length,
                   M m1, M m2,
                   BiFunction<M, M, Boolean> defaultImpl) {
@@@ -541,7 -594,7 +601,7 @@@
       M extends VectorMask<E>,
       E>
      M compare(int cond,
--              Class<? extends V> vectorClass, Class<M> mClass, Class<E> eClass,
++              Class<? extends V> vectorClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,
                int length,
                V v1, V v2, M m,
                VectorCompareOp<V, M> defaultImpl) {
@@@ -562,7 -615,7 +622,7 @@@
       SH extends VectorShuffle<E>,
       M  extends VectorMask<E>,
       E>
--    V rearrangeOp(Class<? extends V> vClass, Class<SH> shClass, Class<M> mClass, Class<E> eClass,
++    V rearrangeOp(Class<? extends V> vClass, Class<SH> shClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,
                    int length,
                    V v, SH sh, M m,
                    VectorRearrangeOp<V, SH, M> defaultImpl) {
@@@ -570,6 -623,23 +630,23 @@@
          return defaultImpl.apply(v, sh, m);
      }
  
+     public interface VectorSelectFromOp<V extends Vector<?>,
+                                         M extends VectorMask<?>> {
+         V apply(V v1, V v2, M m);
+     }
+ 
+     @IntrinsicCandidate
+     public static
+     <V extends Vector<E>,
+      M  extends VectorMask<E>,
+      E>
 -    V selectFromOp(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,
++    V selectFromOp(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,
+                    int length, V v1, V v2, M m,
+                    VectorSelectFromOp<V, M> defaultImpl) {
+         assert isNonCapturingLambda(defaultImpl) : defaultImpl;
+         return defaultImpl.apply(v1, v2, m);
+     }
+ 
      /* ============================================================================ */
  
      public interface VectorBlendOp<V extends Vector<?>,
@@@ -582,7 -652,7 +659,7 @@@
      <V extends Vector<E>,
       M extends VectorMask<E>,
       E>
--    V blend(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,
++    V blend(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,
              int length,
              V v1, V v2, M m,
              VectorBlendOp<V, M> defaultImpl) {
@@@ -603,7 -673,7 +680,7 @@@
       M extends VectorMask<E>,
       E>
      V broadcastInt(int opr,
--                   Class<? extends V> vClass, Class<? extends M> mClass, Class<E> eClass,
++                   Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,
                     int length,
                     V v, int n, M m,
                     VectorBroadcastIntOp<V, M> defaultImpl) {
@@@ -649,7 -719,7 +726,7 @@@
       M extends VectorMask<E>,
       E>
      VectorPayload compressExpandOp(int opr,
--                                   Class<? extends V> vClass, Class<? extends M> mClass, Class<E> eClass,
++                                   Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,
                                     int length, V v, M m,
                                     CompressExpandOperation<V, M> defaultImpl) {
          assert isNonCapturingLambda(defaultImpl) : defaultImpl;
@@@ -678,7 -748,7 +755,7 @@@
      <M extends VectorMask<E>,
       E>
      long maskReductionCoerced(int oper,
--                              Class<? extends M> mClass, Class<?> eClass,
++                              Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,
                                int length,
                                M m,
                                VectorMaskOp<M> defaultImpl) {
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractMask.java
index 395123ef2bf,30297b24db0..730d7e0f43a
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractMask.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractMask.java
@@@ -85,8 -73,8 +73,8 @@@ abstract class AbstractMask<E> extends 
          int laneCount = vsp.laneCount();
          i = VectorIntrinsics.checkFromIndexSize(i, laneCount, bits.length);
          VectorSupport.store(
--            vsp.maskType(), vsp.elementType(), laneCount,
-             bits, (long) i + Unsafe.ARRAY_BOOLEAN_BASE_OFFSET,
++            vsp.maskType(), vsp.carrierType(), vsp.elementType(), vsp.operType(), laneCount,
+             bits, (long) i + Unsafe.ARRAY_BOOLEAN_BASE_OFFSET, false,
              this, bits, i,
              (c, idx, s) -> System.arraycopy(s.getBits(), 0, c, (int) idx, s.length()));
  
@@@ -314,14 -302,8 +302,14 @@@
          // converting, clip the comparison value to [0..vlength]
          // inclusive.
          int indexLimit = Math.max(0, Math.min(length - offset, vlength));
 -        VectorMask<E> badMask =
 -            iota.compare(GE, iota.broadcast(indexLimit));
 +        VectorMask<E> badMask = null, badMask2 = null;
-         if (vectorSpecies().elementType() == Halffloat.class) {
++        if (vectorSpecies().elementType() == Float16.class) {
 +            badMask =
 +                iota.compare(GE, Float.floatToFloat16((float)indexLimit));
 +        } else {
 +            badMask =
 +                iota.compare(GE, iota.broadcast(indexLimit));
 +        }
          if (offset < 0) {
              // An active lane is bad if its number is less than
              // -offset, because when added to offset it will then
@@@ -330,13 -312,8 +318,13 @@@
              // vlength.  This specific expression works correctly even
              // when offset is Integer.MIN_VALUE.
              int firstGoodIndex = -Math.max(offset, -vlength);
-             if (vectorSpecies().elementType() == Halffloat.class) {
 -            VectorMask<E> badMask2 =
 -                iota.compare(LT, iota.broadcast(firstGoodIndex));
++            if (vectorSpecies().elementType() == Float16.class) {
 +                badMask2 =
 +                    iota.compare(LT, iota.broadcast(Float.floatToFloat16((float)firstGoodIndex)));
 +            } else {
 +                badMask2 =
 +                    iota.compare(LT, iota.broadcast(firstGoodIndex));
 +            }
              if (indexLimit >= vlength) {
                  badMask = badMask2;  // 1st badMask is all true
              } else {
@@@ -400,14 -377,8 +388,14 @@@
          // inclusive.
          // 0 <= indexLimit <= vlength
          int indexLimit = (int) Math.max(0, Math.min(length - offset, vlength));
 -        VectorMask<E> badMask =
 +        VectorMask<E> badMask = null, badMask2 = null;
-         if (vectorSpecies().elementType() == Halffloat.class) {
++        if (vectorSpecies().elementType() == Float16.class) {
 +            badMask =
 +                iota.compare(GE, Float.floatToFloat16((float)indexLimit));
 +        } else {
 +            badMask =
                  iota.compare(GE, iota.broadcast(indexLimit));
 +        }
          if (offset < 0) {
              // An active lane is bad if its number is less than
              // -offset, because when added to offset it will then
@@@ -417,13 -388,8 +405,13 @@@
              // when offset is Integer.MIN_VALUE.
              // 0 <= firstGoodIndex <= vlength
              int firstGoodIndex = (int) -Math.max(offset, -vlength);
-             if (vectorSpecies().elementType() == Halffloat.class) {
 -            VectorMask<E> badMask2 =
++            if (vectorSpecies().elementType() == Float16.class) {
 +                badMask2 =
 +                    iota.compare(LT, iota.broadcast(Float.floatToFloat16((float)firstGoodIndex)));
 +            } else {
 +                badMask2 =
                      iota.compare(LT, iota.broadcast(firstGoodIndex));
 +            }
              if (indexLimit >= vlength) {
                  badMask = badMask2;  // 1st badMask is all true
              } else {
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractSpecies.java
index eff63b0fc7a,bdc72c64ce5..68f0ff3fcf7
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractSpecies.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractSpecies.java
@@@ -303,6 -303,6 +303,12 @@@ abstract class AbstractSpecies<E> exten
      /*package-private*/
      abstract Vector<E> fromIntValues(int[] values);
  
++    /*package-private*/
++    abstract Class<?> carrierType();
++
++    /*package-private*/
++    abstract int operType();
++
      /**
       * Do not use a dummy except to call methods on it when you don't
       * care about the lane values.  The main benefit of it is to
@@@ -320,15 -320,7 +326,7 @@@
          return makeDummyVector();
      }
      private AbstractVector<E> makeDummyVector() {
-         Object za;
-         // FIXME: Remove the following special handling for
-         // Halffloat till Valhalla integration when Halffloat
-         // will become a primitive class.
-         if (elementType() == Halffloat.class) {
-            za = Array.newInstance(short.class, laneCount);
-         } else {
-            za = Array.newInstance(elementType(), laneCount);
-         }
 -        Object za = Array.newInstance(elementType(), laneCount);
++        Object za = Array.newInstance(carrierType(), laneCount);
          return dummyVector = vectorFactory.apply(za);
          // This is the only use of vectorFactory.
          // All other factory requests are routed
@@@ -431,30 -415,18 +421,31 @@@
      Object iotaArray() {
          // Create an iota array.  It's OK if this is really slow,
          // because it happens only once per species.
 -        Object ia = Array.newInstance(laneType.elementType,
 -                                      laneCount);
 -        assert(ia.getClass() == laneType.arrayType);
 -        checkValue(laneCount-1);  // worst case
 -        for (int i = 0; i < laneCount; i++) {
 -            if ((byte)i == i)
 -                Array.setByte(ia, i, (byte)i);
 -            else if ((short)i == i)
 -                Array.setShort(ia, i, (short)i);
 -            else
 -                Array.setInt(ia, i, i);
 -            assert(Array.getDouble(ia, i) == i);
 +        Object ia = null;
-         if (elementType() == Halffloat.class) {
-             ia = Array.newInstance(short.class, laneCount);
-             checkValue(laneCount-1);  // worst case
++        if (elementType() == Float16.class) {
++            ia = Array.newInstance(carrierType(), laneCount);
++            checkValue(laneCount - 1);  // worst case
 +            for (int i = 0; i < laneCount; i++) {
 +                // All the numbers in the range [0 2048] are directly representable in FP16 format without the precision loss.
-                 if (i < 2049)
++                if (i < 2049) {
 +                    Array.setShort(ia, i, Float.floatToFloat16((float)i));
-                 else
-                     assert(Array.getShort(ia, i) == i);
++                } else {
++                    assert(Float16.valueOf(i).intValue() == i);
++                }
 +            }
 +        } else {
 +            ia = Array.newInstance(laneType.elementType, laneCount);
 +            assert(ia.getClass() == laneType.arrayType);
 +            checkValue(laneCount-1);  // worst case
 +            for (int i = 0; i < laneCount; i++) {
 +                if ((byte)i == i)
 +                    Array.setByte(ia, i, (byte)i);
 +                else if ((short)i == i)
 +                    Array.setShort(ia, i, (short)i);
 +                else
 +                    Array.setInt(ia, i, i);
 +                assert(Array.getDouble(ia, i) == i);
 +            }
          }
          return ia;
      }
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractVector.java
index 361387e3cca,45773cd29db..7c740dd9887
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractVector.java
@@@ -581,8 -565,6 +574,8 @@@ abstract class AbstractVector<E> extend
              return FloatVector.fromMemorySegment(rsp.check(float.class), ms, 0, bo, m.check(float.class)).check0(rsp);
          case LaneType.SK_DOUBLE:
              return DoubleVector.fromMemorySegment(rsp.check(double.class), ms, 0, bo, m.check(double.class)).check0(rsp);
 +        case LaneType.SK_HALFFLOAT:
-             return HalffloatVector.fromMemorySegment(rsp.check(Halffloat.class), ms, 0, bo, m.check(Halffloat.class)).check0(rsp);
++            return HalffloatVector.fromMemorySegment(rsp.check(Float16.class), ms, 0, bo, m.check(Float16.class)).check0(rsp);
          default:
              throw new AssertionError(rsp.toString());
          }
@@@ -645,13 -627,6 +638,13 @@@
                  }
                  return DoubleVector.fromArray(dsp.check(double.class), a, 0).check0(dsp);
              }
 +            case LaneType.SK_HALFFLOAT: {
 +                short[] a = new short[rlength];
 +                for (int i = 0; i < limit; i++) {
-                     a[i] = Halffloat.valueOf((float) lanes[i]);
++                    a[i] = Float16.float16ToRawShortBits(Float16.valueOf((float) lanes[i]));
 +                }
-                 return HalffloatVector.fromArray(dsp.check(Halffloat.class), a, 0).check0(dsp);
++                return HalffloatVector.fromArray(dsp.check(Float16.class), a, 0).check0(dsp);
 +            }
              default: break;
              }
          } else {
@@@ -702,13 -677,6 +695,13 @@@
                  }
                  return DoubleVector.fromArray(dsp.check(double.class), a, 0).check0(dsp);
              }
 +            case LaneType.SK_HALFFLOAT: {
 +                short[] a = new short[rlength];
 +                for (int i = 0; i < limit; i++) {
-                     a[i] = Halffloat.valueOf((float) lanes[i]);
++                    a[i] = Float16.float16ToRawShortBits(Float16.valueOf((float) lanes[i]));
 +                }
-                 return HalffloatVector.fromArray(dsp.check(Halffloat.class), a, 0).check0(dsp);
++                return HalffloatVector.fromArray(dsp.check(Float16.class), a, 0).check0(dsp);
 +            }
              default: break;
              }
          }
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte128Vector.java
index 3b6ad2f42c4,3569ed00f1f..aef787495d2
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte128Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte128Vector.java
@@@ -52,7 -54,7 +54,11 @@@ final class Byte128Vector extends ByteV
  
      static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
  
--    static final Class<Byte> ETYPE = byte.class; // used by the JVM
++    static final Class<Byte> CTYPE = byte.class; // carrier type used by the JVM
++
++    static final Class<Byte> ETYPE = byte.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
  
      Byte128Vector(byte[] v) {
          super(v);
@@@ -86,9 -88,9 +92,12 @@@
          return VSPECIES;
      }
  
++    @ForceInline
++    final Class<Byte> carrierType() { return CTYPE; }
++
      @ForceInline
      @Override
--    public final Class<Byte> elementType() { return byte.class; }
++    public final Class<Byte> elementType() { return ETYPE; }
  
      @ForceInline
      @Override
@@@ -518,9 -538,10 +545,10 @@@
          }
      }
  
+     @ForceInline
      public byte laneHelper(int i) {
          return (byte) VectorSupport.extract(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i,
                                  (vec, ix) -> {
                                      byte[] vecarr = vec.vec();
@@@ -552,9 -573,10 +580,10 @@@
          }
      }
  
+     @ForceInline
      public Byte128Vector withLaneHelper(int i, byte e) {
          return VectorSupport.insert(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i, (long)e,
                                  (v, ix, bits) -> {
                                      byte[] res = v.vec().clone();
@@@ -567,7 -589,7 +596,7 @@@
  
      static final class Byte128Mask extends AbstractMask<Byte> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Byte> ETYPE = byte.class; // used by the JVM
++        static final Class<Byte> CTYPE = byte.class; // used by the JVM
  
          Byte128Mask(boolean[] bits) {
              this(bits, 0);
@@@ -669,7 -691,7 +698,7 @@@
          /*package-private*/
          Byte128Mask indexPartiallyInUpperRange(long offset, long limit) {
              return (Byte128Mask) VectorSupport.indexPartiallyInUpperRange(
-                 Byte128Mask.class, ETYPE, VLENGTH, offset, limit,
 -                Byte128Mask.class, byte.class, VLENGTH, offset, limit,
++                Byte128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                  (o, l) -> (Byte128Mask) TRUE_MASK.indexPartiallyInRange(o, l));
          }
  
@@@ -685,8 -707,8 +714,9 @@@
          @ForceInline
          public Byte128Mask compress() {
              return (Byte128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
--                Byte128Vector.class, Byte128Mask.class, ETYPE, VLENGTH, null, this,
--                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
++                Byte128Vector.class, Byte128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                m1.trueCount()));
          }
  
  
@@@ -697,7 -719,7 +727,7 @@@
          public Byte128Mask and(VectorMask<Byte> mask) {
              Objects.requireNonNull(mask);
              Byte128Mask m = (Byte128Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte128Mask.class, null, byte.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte128Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
          }
@@@ -707,7 -729,7 +737,7 @@@
          public Byte128Mask or(VectorMask<Byte> mask) {
              Objects.requireNonNull(mask);
              Byte128Mask m = (Byte128Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte128Mask.class, null, byte.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte128Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
          }
@@@ -717,7 -739,7 +747,7 @@@
          public Byte128Mask xor(VectorMask<Byte> mask) {
              Objects.requireNonNull(mask);
              Byte128Mask m = (Byte128Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte128Mask.class, null, byte.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte128Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
          }
@@@ -727,22 -749,22 +757,25 @@@
          @Override
          @ForceInline
          public int trueCount() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte128Mask.class, byte.class, VLENGTH, this,
--                                                      (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte128Mask.class, byte.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int firstTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte128Mask.class, byte.class, VLENGTH, this,
--                                                      (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte128Mask.class, byte.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int lastTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte128Mask.class, byte.class, VLENGTH, this,
--                                                      (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte128Mask.class, byte.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
          }
  
          @Override
@@@ -751,32 -773,42 +784,43 @@@
              if (length() > Long.SIZE) {
                  throw new UnsupportedOperationException("too many lanes for one long");
              }
--            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Byte128Mask.class, byte.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Byte128Mask.class, byte.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
                                                        (m) -> toLongHelper(m.getBits()));
          }
  
+         // laneIsSet
+ 
+         @Override
+         @ForceInline
+         public boolean laneIsSet(int i) {
+             Objects.checkIndex(i, length());
 -            return VectorSupport.extract(Byte128Mask.class, byte.class, VLENGTH,
++            return VectorSupport.extract(Byte128Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
+         }
+ 
          // Reductions
  
          @Override
          @ForceInline
          public boolean anyTrue() {
--            return VectorSupport.test(BT_ne, Byte128Mask.class, byte.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> anyTrueHelper(((Byte128Mask)m).getBits()));
++            return VectorSupport.test(BT_ne, Byte128Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper(((Byte128Mask)m).getBits()));
          }
  
          @Override
          @ForceInline
          public boolean allTrue() {
--            return VectorSupport.test(BT_overflow, Byte128Mask.class, byte.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> allTrueHelper(((Byte128Mask)m).getBits()));
++            return VectorSupport.test(BT_overflow, Byte128Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper(((Byte128Mask)m).getBits()));
          }
  
          @ForceInline
          /*package-private*/
          static Byte128Mask maskAll(boolean bit) {
--            return VectorSupport.fromBitsCoerced(Byte128Mask.class, byte.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced(Byte128Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                                   (bit ? -1 : 0), MODE_BROADCAST, null,
                                                   (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
          }
@@@ -789,7 -821,7 +833,7 @@@
  
      static final class Byte128Shuffle extends AbstractShuffle<Byte> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Byte> ETYPE = byte.class; // used by the JVM
++        static final Class<Byte> CTYPE = byte.class; // used by the JVM
  
          Byte128Shuffle(byte[] indices) {
              super(indices);
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte256Vector.java
index f5a8de521a4,70a3306731e..7c1c8a04c15
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte256Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte256Vector.java
@@@ -52,7 -54,7 +54,11 @@@ final class Byte256Vector extends ByteV
  
      static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
  
--    static final Class<Byte> ETYPE = byte.class; // used by the JVM
++    static final Class<Byte> CTYPE = byte.class; // carrier type used by the JVM
++
++    static final Class<Byte> ETYPE = byte.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
  
      Byte256Vector(byte[] v) {
          super(v);
@@@ -86,9 -88,9 +92,12 @@@
          return VSPECIES;
      }
  
++    @ForceInline
++    final Class<Byte> carrierType() { return CTYPE; }
++
      @ForceInline
      @Override
--    public final Class<Byte> elementType() { return byte.class; }
++    public final Class<Byte> elementType() { return ETYPE; }
  
      @ForceInline
      @Override
@@@ -534,9 -554,10 +561,10 @@@
          }
      }
  
+     @ForceInline
      public byte laneHelper(int i) {
          return (byte) VectorSupport.extract(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i,
                                  (vec, ix) -> {
                                      byte[] vecarr = vec.vec();
@@@ -584,9 -605,10 +612,10 @@@
          }
      }
  
+     @ForceInline
      public Byte256Vector withLaneHelper(int i, byte e) {
          return VectorSupport.insert(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i, (long)e,
                                  (v, ix, bits) -> {
                                      byte[] res = v.vec().clone();
@@@ -599,7 -621,7 +628,7 @@@
  
      static final class Byte256Mask extends AbstractMask<Byte> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Byte> ETYPE = byte.class; // used by the JVM
++        static final Class<Byte> CTYPE = byte.class; // used by the JVM
  
          Byte256Mask(boolean[] bits) {
              this(bits, 0);
@@@ -701,7 -723,7 +730,7 @@@
          /*package-private*/
          Byte256Mask indexPartiallyInUpperRange(long offset, long limit) {
              return (Byte256Mask) VectorSupport.indexPartiallyInUpperRange(
-                 Byte256Mask.class, ETYPE, VLENGTH, offset, limit,
 -                Byte256Mask.class, byte.class, VLENGTH, offset, limit,
++                Byte256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                  (o, l) -> (Byte256Mask) TRUE_MASK.indexPartiallyInRange(o, l));
          }
  
@@@ -717,8 -739,8 +746,9 @@@
          @ForceInline
          public Byte256Mask compress() {
              return (Byte256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
--                Byte256Vector.class, Byte256Mask.class, ETYPE, VLENGTH, null, this,
--                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
++                Byte256Vector.class, Byte256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                m1.trueCount()));
          }
  
  
@@@ -729,7 -751,7 +759,7 @@@
          public Byte256Mask and(VectorMask<Byte> mask) {
              Objects.requireNonNull(mask);
              Byte256Mask m = (Byte256Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte256Mask.class, null, byte.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte256Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
          }
@@@ -739,7 -761,7 +769,7 @@@
          public Byte256Mask or(VectorMask<Byte> mask) {
              Objects.requireNonNull(mask);
              Byte256Mask m = (Byte256Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte256Mask.class, null, byte.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte256Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
          }
@@@ -749,7 -771,7 +779,7 @@@
          public Byte256Mask xor(VectorMask<Byte> mask) {
              Objects.requireNonNull(mask);
              Byte256Mask m = (Byte256Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte256Mask.class, null, byte.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte256Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
          }
@@@ -759,22 -781,22 +789,25 @@@
          @Override
          @ForceInline
          public int trueCount() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte256Mask.class, byte.class, VLENGTH, this,
--                                                      (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte256Mask.class, byte.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int firstTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte256Mask.class, byte.class, VLENGTH, this,
--                                                      (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte256Mask.class, byte.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int lastTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte256Mask.class, byte.class, VLENGTH, this,
--                                                      (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte256Mask.class, byte.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
          }
  
          @Override
@@@ -783,32 -805,42 +816,43 @@@
              if (length() > Long.SIZE) {
                  throw new UnsupportedOperationException("too many lanes for one long");
              }
--            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Byte256Mask.class, byte.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Byte256Mask.class, byte.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
                                                        (m) -> toLongHelper(m.getBits()));
          }
  
+         // laneIsSet
+ 
+         @Override
+         @ForceInline
+         public boolean laneIsSet(int i) {
+             Objects.checkIndex(i, length());
 -            return VectorSupport.extract(Byte256Mask.class, byte.class, VLENGTH,
++            return VectorSupport.extract(Byte256Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
+         }
+ 
          // Reductions
  
          @Override
          @ForceInline
          public boolean anyTrue() {
--            return VectorSupport.test(BT_ne, Byte256Mask.class, byte.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> anyTrueHelper(((Byte256Mask)m).getBits()));
++            return VectorSupport.test(BT_ne, Byte256Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper(((Byte256Mask)m).getBits()));
          }
  
          @Override
          @ForceInline
          public boolean allTrue() {
--            return VectorSupport.test(BT_overflow, Byte256Mask.class, byte.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> allTrueHelper(((Byte256Mask)m).getBits()));
++            return VectorSupport.test(BT_overflow, Byte256Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper(((Byte256Mask)m).getBits()));
          }
  
          @ForceInline
          /*package-private*/
          static Byte256Mask maskAll(boolean bit) {
--            return VectorSupport.fromBitsCoerced(Byte256Mask.class, byte.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced(Byte256Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                                   (bit ? -1 : 0), MODE_BROADCAST, null,
                                                   (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
          }
@@@ -821,7 -853,7 +865,7 @@@
  
      static final class Byte256Shuffle extends AbstractShuffle<Byte> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Byte> ETYPE = byte.class; // used by the JVM
++        static final Class<Byte> CTYPE = byte.class; // used by the JVM
  
          Byte256Shuffle(byte[] indices) {
              super(indices);
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte512Vector.java
index 43f6a4f1708,a093fe18289..ebe2995b292
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte512Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte512Vector.java
@@@ -52,7 -54,7 +54,11 @@@ final class Byte512Vector extends ByteV
  
      static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
  
--    static final Class<Byte> ETYPE = byte.class; // used by the JVM
++    static final Class<Byte> CTYPE = byte.class; // carrier type used by the JVM
++
++    static final Class<Byte> ETYPE = byte.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
  
      Byte512Vector(byte[] v) {
          super(v);
@@@ -86,9 -88,9 +92,12 @@@
          return VSPECIES;
      }
  
++    @ForceInline
++    final Class<Byte> carrierType() { return CTYPE; }
++
      @ForceInline
      @Override
--    public final Class<Byte> elementType() { return byte.class; }
++    public final Class<Byte> elementType() { return ETYPE; }
  
      @ForceInline
      @Override
@@@ -566,9 -586,10 +593,10 @@@
          }
      }
  
+     @ForceInline
      public byte laneHelper(int i) {
          return (byte) VectorSupport.extract(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i,
                                  (vec, ix) -> {
                                      byte[] vecarr = vec.vec();
@@@ -648,9 -669,10 +676,10 @@@
          }
      }
  
+     @ForceInline
      public Byte512Vector withLaneHelper(int i, byte e) {
          return VectorSupport.insert(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i, (long)e,
                                  (v, ix, bits) -> {
                                      byte[] res = v.vec().clone();
@@@ -663,7 -685,7 +692,7 @@@
  
      static final class Byte512Mask extends AbstractMask<Byte> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Byte> ETYPE = byte.class; // used by the JVM
++        static final Class<Byte> CTYPE = byte.class; // used by the JVM
  
          Byte512Mask(boolean[] bits) {
              this(bits, 0);
@@@ -765,7 -787,7 +794,7 @@@
          /*package-private*/
          Byte512Mask indexPartiallyInUpperRange(long offset, long limit) {
              return (Byte512Mask) VectorSupport.indexPartiallyInUpperRange(
-                 Byte512Mask.class, ETYPE, VLENGTH, offset, limit,
 -                Byte512Mask.class, byte.class, VLENGTH, offset, limit,
++                Byte512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                  (o, l) -> (Byte512Mask) TRUE_MASK.indexPartiallyInRange(o, l));
          }
  
@@@ -781,8 -803,8 +810,9 @@@
          @ForceInline
          public Byte512Mask compress() {
              return (Byte512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
--                Byte512Vector.class, Byte512Mask.class, ETYPE, VLENGTH, null, this,
--                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
++                Byte512Vector.class, Byte512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                m1.trueCount()));
          }
  
  
@@@ -793,7 -815,7 +823,7 @@@
          public Byte512Mask and(VectorMask<Byte> mask) {
              Objects.requireNonNull(mask);
              Byte512Mask m = (Byte512Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte512Mask.class, null, byte.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte512Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
          }
@@@ -803,7 -825,7 +833,7 @@@
          public Byte512Mask or(VectorMask<Byte> mask) {
              Objects.requireNonNull(mask);
              Byte512Mask m = (Byte512Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte512Mask.class, null, byte.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte512Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
          }
@@@ -813,7 -835,7 +843,7 @@@
          public Byte512Mask xor(VectorMask<Byte> mask) {
              Objects.requireNonNull(mask);
              Byte512Mask m = (Byte512Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte512Mask.class, null, byte.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte512Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
          }
@@@ -823,22 -845,22 +853,25 @@@
          @Override
          @ForceInline
          public int trueCount() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte512Mask.class, byte.class, VLENGTH, this,
--                                                      (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte512Mask.class, byte.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int firstTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte512Mask.class, byte.class, VLENGTH, this,
--                                                      (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte512Mask.class, byte.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int lastTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte512Mask.class, byte.class, VLENGTH, this,
--                                                      (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte512Mask.class, byte.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
          }
  
          @Override
@@@ -847,32 -869,42 +880,43 @@@
              if (length() > Long.SIZE) {
                  throw new UnsupportedOperationException("too many lanes for one long");
              }
--            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Byte512Mask.class, byte.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Byte512Mask.class, byte.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
                                                        (m) -> toLongHelper(m.getBits()));
          }
  
+         // laneIsSet
+ 
+         @Override
+         @ForceInline
+         public boolean laneIsSet(int i) {
+             Objects.checkIndex(i, length());
 -            return VectorSupport.extract(Byte512Mask.class, byte.class, VLENGTH,
++            return VectorSupport.extract(Byte512Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
+         }
+ 
          // Reductions
  
          @Override
          @ForceInline
          public boolean anyTrue() {
--            return VectorSupport.test(BT_ne, Byte512Mask.class, byte.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> anyTrueHelper(((Byte512Mask)m).getBits()));
++            return VectorSupport.test(BT_ne, Byte512Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper(((Byte512Mask)m).getBits()));
          }
  
          @Override
          @ForceInline
          public boolean allTrue() {
--            return VectorSupport.test(BT_overflow, Byte512Mask.class, byte.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> allTrueHelper(((Byte512Mask)m).getBits()));
++            return VectorSupport.test(BT_overflow, Byte512Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper(((Byte512Mask)m).getBits()));
          }
  
          @ForceInline
          /*package-private*/
          static Byte512Mask maskAll(boolean bit) {
--            return VectorSupport.fromBitsCoerced(Byte512Mask.class, byte.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced(Byte512Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                                   (bit ? -1 : 0), MODE_BROADCAST, null,
                                                   (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
          }
@@@ -885,7 -917,7 +929,7 @@@
  
      static final class Byte512Shuffle extends AbstractShuffle<Byte> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Byte> ETYPE = byte.class; // used by the JVM
++        static final Class<Byte> CTYPE = byte.class; // used by the JVM
  
          Byte512Shuffle(byte[] indices) {
              super(indices);
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte64Vector.java
index 53233e3151c,cd75ee9f610..92bf6316e96
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte64Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte64Vector.java
@@@ -52,7 -54,7 +54,11 @@@ final class Byte64Vector extends ByteVe
  
      static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
  
--    static final Class<Byte> ETYPE = byte.class; // used by the JVM
++    static final Class<Byte> CTYPE = byte.class; // carrier type used by the JVM
++
++    static final Class<Byte> ETYPE = byte.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
  
      Byte64Vector(byte[] v) {
          super(v);
@@@ -86,9 -88,9 +92,12 @@@
          return VSPECIES;
      }
  
++    @ForceInline
++    final Class<Byte> carrierType() { return CTYPE; }
++
      @ForceInline
      @Override
--    public final Class<Byte> elementType() { return byte.class; }
++    public final Class<Byte> elementType() { return ETYPE; }
  
      @ForceInline
      @Override
@@@ -510,9 -530,10 +537,10 @@@
          }
      }
  
+     @ForceInline
      public byte laneHelper(int i) {
          return (byte) VectorSupport.extract(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i,
                                  (vec, ix) -> {
                                      byte[] vecarr = vec.vec();
@@@ -536,9 -557,10 +564,10 @@@
          }
      }
  
+     @ForceInline
      public Byte64Vector withLaneHelper(int i, byte e) {
          return VectorSupport.insert(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i, (long)e,
                                  (v, ix, bits) -> {
                                      byte[] res = v.vec().clone();
@@@ -551,7 -573,7 +580,7 @@@
  
      static final class Byte64Mask extends AbstractMask<Byte> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Byte> ETYPE = byte.class; // used by the JVM
++        static final Class<Byte> CTYPE = byte.class; // used by the JVM
  
          Byte64Mask(boolean[] bits) {
              this(bits, 0);
@@@ -653,7 -675,7 +682,7 @@@
          /*package-private*/
          Byte64Mask indexPartiallyInUpperRange(long offset, long limit) {
              return (Byte64Mask) VectorSupport.indexPartiallyInUpperRange(
-                 Byte64Mask.class, ETYPE, VLENGTH, offset, limit,
 -                Byte64Mask.class, byte.class, VLENGTH, offset, limit,
++                Byte64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                  (o, l) -> (Byte64Mask) TRUE_MASK.indexPartiallyInRange(o, l));
          }
  
@@@ -669,8 -691,8 +698,9 @@@
          @ForceInline
          public Byte64Mask compress() {
              return (Byte64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
--                Byte64Vector.class, Byte64Mask.class, ETYPE, VLENGTH, null, this,
--                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
++                Byte64Vector.class, Byte64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                m1.trueCount()));
          }
  
  
@@@ -681,7 -703,7 +711,7 @@@
          public Byte64Mask and(VectorMask<Byte> mask) {
              Objects.requireNonNull(mask);
              Byte64Mask m = (Byte64Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte64Mask.class, null, byte.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte64Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
          }
@@@ -691,7 -713,7 +721,7 @@@
          public Byte64Mask or(VectorMask<Byte> mask) {
              Objects.requireNonNull(mask);
              Byte64Mask m = (Byte64Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte64Mask.class, null, byte.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte64Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
          }
@@@ -701,7 -723,7 +731,7 @@@
          public Byte64Mask xor(VectorMask<Byte> mask) {
              Objects.requireNonNull(mask);
              Byte64Mask m = (Byte64Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte64Mask.class, null, byte.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte64Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
          }
@@@ -711,22 -733,22 +741,25 @@@
          @Override
          @ForceInline
          public int trueCount() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte64Mask.class, byte.class, VLENGTH, this,
--                                                      (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte64Mask.class, byte.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int firstTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte64Mask.class, byte.class, VLENGTH, this,
--                                                      (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte64Mask.class, byte.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int lastTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte64Mask.class, byte.class, VLENGTH, this,
--                                                      (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte64Mask.class, byte.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
          }
  
          @Override
@@@ -735,32 -757,42 +768,43 @@@
              if (length() > Long.SIZE) {
                  throw new UnsupportedOperationException("too many lanes for one long");
              }
--            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Byte64Mask.class, byte.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Byte64Mask.class, byte.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
                                                        (m) -> toLongHelper(m.getBits()));
          }
  
+         // laneIsSet
+ 
+         @Override
+         @ForceInline
+         public boolean laneIsSet(int i) {
+             Objects.checkIndex(i, length());
 -            return VectorSupport.extract(Byte64Mask.class, byte.class, VLENGTH,
++            return VectorSupport.extract(Byte64Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
+         }
+ 
          // Reductions
  
          @Override
          @ForceInline
          public boolean anyTrue() {
--            return VectorSupport.test(BT_ne, Byte64Mask.class, byte.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> anyTrueHelper(((Byte64Mask)m).getBits()));
++            return VectorSupport.test(BT_ne, Byte64Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper(((Byte64Mask)m).getBits()));
          }
  
          @Override
          @ForceInline
          public boolean allTrue() {
--            return VectorSupport.test(BT_overflow, Byte64Mask.class, byte.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> allTrueHelper(((Byte64Mask)m).getBits()));
++            return VectorSupport.test(BT_overflow, Byte64Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper(((Byte64Mask)m).getBits()));
          }
  
          @ForceInline
          /*package-private*/
          static Byte64Mask maskAll(boolean bit) {
--            return VectorSupport.fromBitsCoerced(Byte64Mask.class, byte.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced(Byte64Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                                   (bit ? -1 : 0), MODE_BROADCAST, null,
                                                   (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
          }
@@@ -773,7 -805,7 +817,7 @@@
  
      static final class Byte64Shuffle extends AbstractShuffle<Byte> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Byte> ETYPE = byte.class; // used by the JVM
++        static final Class<Byte> CTYPE = byte.class; // used by the JVM
  
          Byte64Shuffle(byte[] indices) {
              super(indices);
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ByteMaxVector.java
index 99a919b969d,3ac62409a95..e74cc31cae5
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ByteMaxVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ByteMaxVector.java
@@@ -52,7 -54,7 +54,11 @@@ final class ByteMaxVector extends ByteV
  
      static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
  
--    static final Class<Byte> ETYPE = byte.class; // used by the JVM
++    static final Class<Byte> CTYPE = byte.class; // carrier type used by the JVM
++
++    static final Class<Byte> ETYPE = byte.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
  
      ByteMaxVector(byte[] v) {
          super(v);
@@@ -86,9 -88,9 +92,12 @@@
          return VSPECIES;
      }
  
++    @ForceInline
++    final Class<Byte> carrierType() { return CTYPE; }
++
      @ForceInline
      @Override
--    public final Class<Byte> elementType() { return byte.class; }
++    public final Class<Byte> elementType() { return ETYPE; }
  
      @ForceInline
      @Override
@@@ -503,9 -523,10 +530,10 @@@
          return laneHelper(i);
      }
  
+     @ForceInline
      public byte laneHelper(int i) {
          return (byte) VectorSupport.extract(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i,
                                  (vec, ix) -> {
                                      byte[] vecarr = vec.vec();
@@@ -522,9 -543,10 +550,10 @@@
          return withLaneHelper(i, e);
      }
  
+     @ForceInline
      public ByteMaxVector withLaneHelper(int i, byte e) {
          return VectorSupport.insert(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i, (long)e,
                                  (v, ix, bits) -> {
                                      byte[] res = v.vec().clone();
@@@ -537,7 -559,7 +566,7 @@@
  
      static final class ByteMaxMask extends AbstractMask<Byte> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Byte> ETYPE = byte.class; // used by the JVM
++        static final Class<Byte> CTYPE = byte.class; // used by the JVM
  
          ByteMaxMask(boolean[] bits) {
              this(bits, 0);
@@@ -639,7 -661,7 +668,7 @@@
          /*package-private*/
          ByteMaxMask indexPartiallyInUpperRange(long offset, long limit) {
              return (ByteMaxMask) VectorSupport.indexPartiallyInUpperRange(
-                 ByteMaxMask.class, ETYPE, VLENGTH, offset, limit,
 -                ByteMaxMask.class, byte.class, VLENGTH, offset, limit,
++                ByteMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                  (o, l) -> (ByteMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));
          }
  
@@@ -655,8 -677,8 +684,9 @@@
          @ForceInline
          public ByteMaxMask compress() {
              return (ByteMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
--                ByteMaxVector.class, ByteMaxMask.class, ETYPE, VLENGTH, null, this,
--                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
++                ByteMaxVector.class, ByteMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                m1.trueCount()));
          }
  
  
@@@ -667,7 -689,7 +697,7 @@@
          public ByteMaxMask and(VectorMask<Byte> mask) {
              Objects.requireNonNull(mask);
              ByteMaxMask m = (ByteMaxMask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_AND, ByteMaxMask.class, null, byte.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, ByteMaxMask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
          }
@@@ -677,7 -699,7 +707,7 @@@
          public ByteMaxMask or(VectorMask<Byte> mask) {
              Objects.requireNonNull(mask);
              ByteMaxMask m = (ByteMaxMask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_OR, ByteMaxMask.class, null, byte.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, ByteMaxMask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
          }
@@@ -687,7 -709,7 +717,7 @@@
          public ByteMaxMask xor(VectorMask<Byte> mask) {
              Objects.requireNonNull(mask);
              ByteMaxMask m = (ByteMaxMask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_XOR, ByteMaxMask.class, null, byte.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, ByteMaxMask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
          }
@@@ -697,22 -719,22 +727,25 @@@
          @Override
          @ForceInline
          public int trueCount() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, ByteMaxMask.class, byte.class, VLENGTH, this,
--                                                      (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, ByteMaxMask.class, byte.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int firstTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, ByteMaxMask.class, byte.class, VLENGTH, this,
--                                                      (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, ByteMaxMask.class, byte.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int lastTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, ByteMaxMask.class, byte.class, VLENGTH, this,
--                                                      (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, ByteMaxMask.class, byte.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
          }
  
          @Override
@@@ -721,32 -743,42 +754,43 @@@
              if (length() > Long.SIZE) {
                  throw new UnsupportedOperationException("too many lanes for one long");
              }
--            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, ByteMaxMask.class, byte.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, ByteMaxMask.class, byte.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
                                                        (m) -> toLongHelper(m.getBits()));
          }
  
+         // laneIsSet
+ 
+         @Override
+         @ForceInline
+         public boolean laneIsSet(int i) {
+             Objects.checkIndex(i, length());
 -            return VectorSupport.extract(ByteMaxMask.class, byte.class, VLENGTH,
++            return VectorSupport.extract(ByteMaxMask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
+         }
+ 
          // Reductions
  
          @Override
          @ForceInline
          public boolean anyTrue() {
--            return VectorSupport.test(BT_ne, ByteMaxMask.class, byte.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> anyTrueHelper(((ByteMaxMask)m).getBits()));
++            return VectorSupport.test(BT_ne, ByteMaxMask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper(((ByteMaxMask)m).getBits()));
          }
  
          @Override
          @ForceInline
          public boolean allTrue() {
--            return VectorSupport.test(BT_overflow, ByteMaxMask.class, byte.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> allTrueHelper(((ByteMaxMask)m).getBits()));
++            return VectorSupport.test(BT_overflow, ByteMaxMask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper(((ByteMaxMask)m).getBits()));
          }
  
          @ForceInline
          /*package-private*/
          static ByteMaxMask maskAll(boolean bit) {
--            return VectorSupport.fromBitsCoerced(ByteMaxMask.class, byte.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced(ByteMaxMask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                                   (bit ? -1 : 0), MODE_BROADCAST, null,
                                                   (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
          }
@@@ -759,7 -791,7 +803,7 @@@
  
      static final class ByteMaxShuffle extends AbstractShuffle<Byte> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Byte> ETYPE = byte.class; // used by the JVM
++        static final Class<Byte> CTYPE = byte.class; // used by the JVM
  
          ByteMaxShuffle(byte[] indices) {
              super(indices);
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ByteVector.java
index 87a70e8c28e,08406fef518..8651fa70763
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ByteVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ByteVector.java
@@@ -57,7 -57,7 +57,9 @@@ public abstract class ByteVector extend
  
      static final int FORBID_OPCODE_KIND = VO_ONLYFP;
  
-     static final ValueLayout.OfByte ELEMENT_LAYOUT = ValueLayout.JAVA_BYTE.withBitAlignment(8);
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
++
+     static final ValueLayout.OfByte ELEMENT_LAYOUT = ValueLayout.JAVA_BYTE.withByteAlignment(1);
  
      @ForceInline
      static int opCode(Operator op) {
@@@ -560,7 -573,7 +575,7 @@@
      @ForceInline
      public static ByteVector zero(VectorSpecies<Byte> species) {
          ByteSpecies vsp = (ByteSpecies) species;
--        return VectorSupport.fromBitsCoerced(vsp.vectorType(), byte.class, species.length(),
++        return VectorSupport.fromBitsCoerced(vsp.vectorType(), byte.class, byte.class, VECTOR_OPER_TYPE, species.length(),
                                  0, MODE_BROADCAST, vsp,
                                  ((bits_, s_) -> s_.rvOp(i -> bits_)));
      }
@@@ -682,7 -695,7 +697,7 @@@
          }
          int opc = opCode(op);
          return VectorSupport.unaryOp(
--            opc, getClass(), null, byte.class, length(),
++            opc, getClass(), null, byte.class, byte.class, VECTOR_OPER_TYPE, length(),
              this, null,
              UN_IMPL.find(op, opc, ByteVector::unaryOperations));
      }
@@@ -710,7 -723,7 +725,7 @@@
          }
          int opc = opCode(op);
          return VectorSupport.unaryOp(
--            opc, getClass(), maskClass, byte.class, length(),
++            opc, getClass(), maskClass, byte.class, byte.class, VECTOR_OPER_TYPE, length(),
              this, m,
              UN_IMPL.find(op, opc, ByteVector::unaryOperations));
      }
@@@ -782,7 -796,7 +798,7 @@@
  
          int opc = opCode(op);
          return VectorSupport.binaryOp(
--            opc, getClass(), null, byte.class, length(),
++            opc, getClass(), null, byte.class, byte.class, VECTOR_OPER_TYPE, length(),
              this, that, null,
              BIN_IMPL.find(op, opc, ByteVector::binaryOperations));
      }
@@@ -832,7 -847,7 +849,7 @@@
  
          int opc = opCode(op);
          return VectorSupport.binaryOp(
--            opc, getClass(), maskClass, byte.class, length(),
++            opc, getClass(), maskClass, byte.class, byte.class, VECTOR_OPER_TYPE, length(),
              this, that, m,
              BIN_IMPL.find(op, opc, ByteVector::binaryOperations));
      }
@@@ -1006,7 -1034,7 +1036,7 @@@
          e &= SHIFT_MASK;
          int opc = opCode(op);
          return VectorSupport.broadcastInt(
--            opc, getClass(), null, byte.class, length(),
++            opc, getClass(), null, byte.class, byte.class, VECTOR_OPER_TYPE, length(),
              this, e, null,
              BIN_INT_IMPL.find(op, opc, ByteVector::broadcastIntOperations));
      }
@@@ -1027,7 -1055,7 +1057,7 @@@
          e &= SHIFT_MASK;
          int opc = opCode(op);
          return VectorSupport.broadcastInt(
--            opc, getClass(), maskClass, byte.class, length(),
++            opc, getClass(), maskClass, byte.class, byte.class, VECTOR_OPER_TYPE, length(),
              this, e, m,
              BIN_INT_IMPL.find(op, opc, ByteVector::broadcastIntOperations));
      }
@@@ -1104,7 -1132,7 +1134,7 @@@
          }
          int opc = opCode(op);
          return VectorSupport.ternaryOp(
--            opc, getClass(), null, byte.class, length(),
++            opc, getClass(), null, byte.class, byte.class, VECTOR_OPER_TYPE, length(),
              this, that, tother, null,
              TERN_IMPL.find(op, opc, ByteVector::ternaryOperations));
      }
@@@ -1144,7 -1172,7 +1174,7 @@@
          }
          int opc = opCode(op);
          return VectorSupport.ternaryOp(
--            opc, getClass(), maskClass, byte.class, length(),
++            opc, getClass(), maskClass, byte.class, byte.class, VECTOR_OPER_TYPE, length(),
              this, that, tother, m,
              TERN_IMPL.find(op, opc, ByteVector::ternaryOperations));
      }
@@@ -2042,7 -2070,7 +2072,7 @@@
          that.check(this);
          int opc = opCode(op);
          return VectorSupport.compare(
--            opc, getClass(), maskType, byte.class, length(),
++            opc, getClass(), maskType, byte.class, byte.class, VECTOR_OPER_TYPE, length(),
              this, that, null,
              (cond, v0, v1, m1) -> {
                  AbstractMask<Byte> m
@@@ -2064,7 -2092,7 +2094,7 @@@
          m.check(maskType, this);
          int opc = opCode(op);
          return VectorSupport.compare(
--            opc, getClass(), maskType, byte.class, length(),
++            opc, getClass(), maskType, byte.class, byte.class, VECTOR_OPER_TYPE, length(),
              this, that, m,
              (cond, v0, v1, m1) -> {
                  AbstractMask<Byte> cmpM
@@@ -2195,7 -2223,7 +2225,7 @@@
      blendTemplate(Class<M> maskType, ByteVector v, M m) {
          v.check(this);
          return VectorSupport.blend(
--            getClass(), maskType, byte.class, length(),
++            getClass(), maskType, byte.class, byte.class, VECTOR_OPER_TYPE, length(),
              this, v, m,
              (v0, v1, m_) -> v0.bOp(v1, m_, (i, a, b) -> b));
      }
@@@ -2212,7 -2240,7 +2242,7 @@@
          // make sure VLENGTH*scale doesn't overflow:
          vsp.checkScale(scale);
          return VectorSupport.indexVector(
--            getClass(), byte.class, length(),
++            getClass(), byte.class, byte.class, VECTOR_OPER_TYPE, length(),
              this, scale, vsp,
              (v, scale_, s)
              -> {
@@@ -2400,12 -2430,12 +2432,12 @@@
      final
      <S extends VectorShuffle<Byte>>
      ByteVector rearrangeTemplate(Class<S> shuffletype, S shuffle) {
-         shuffle.checkIndexes();
+         Objects.requireNonNull(shuffle);
          return VectorSupport.rearrangeOp(
--            getClass(), shuffletype, null, byte.class, length(),
++            getClass(), shuffletype, null, byte.class, byte.class, VECTOR_OPER_TYPE, length(),
              this, shuffle, null,
              (v1, s_, m_) -> v1.uOp((i, a) -> {
-                 int ei = s_.laneSource(i);
+                 int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
                  return v1.lane(ei);
              }));
      }
@@@ -2426,19 -2456,14 +2458,14 @@@
                                             Class<M> masktype,
                                             S shuffle,
                                             M m) {
- 
+         Objects.requireNonNull(shuffle);
          m.check(masktype, this);
-         VectorMask<Byte> valid = shuffle.laneIsValid();
-         if (m.andNot(valid).anyTrue()) {
-             shuffle.checkIndexes();
-             throw new AssertionError();
-         }
          return VectorSupport.rearrangeOp(
--                   getClass(), shuffletype, masktype, byte.class, length(),
++                   getClass(), shuffletype, masktype, byte.class, byte.class, VECTOR_OPER_TYPE, length(),
                     this, shuffle, m,
                     (v1, s_, m_) -> v1.uOp((i, a) -> {
-                         int ei = s_.laneSource(i);
-                         return ei < 0  || !m_.laneIsSet(i) ? 0 : v1.lane(ei);
+                         int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
+                         return !m_.laneIsSet(i) ? 0 : v1.lane(ei);
                     }));
      }
  
@@@ -2458,22 -2483,20 +2485,20 @@@
                                             S shuffle,
                                             ByteVector v) {
          VectorMask<Byte> valid = shuffle.laneIsValid();
-         @SuppressWarnings("unchecked")
-         S ws = (S) shuffle.wrapIndexes();
          ByteVector r0 =
              VectorSupport.rearrangeOp(
--                getClass(), shuffletype, null, byte.class, length(),
-                 this, ws, null,
++                getClass(), shuffletype, null, byte.class, byte.class, VECTOR_OPER_TYPE, length(),
+                 this, shuffle, null,
                  (v0, s_, m_) -> v0.uOp((i, a) -> {
-                     int ei = s_.laneSource(i);
+                     int ei = Integer.remainderUnsigned(s_.laneSource(i), v0.length());
                      return v0.lane(ei);
                  }));
          ByteVector r1 =
              VectorSupport.rearrangeOp(
--                getClass(), shuffletype, null, byte.class, length(),
-                 v, ws, null,
++                getClass(), shuffletype, null, byte.class, byte.class, VECTOR_OPER_TYPE, length(),
+                 v, shuffle, null,
                  (v1, s_, m_) -> v1.uOp((i, a) -> {
-                     int ei = s_.laneSource(i);
+                     int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
                      return v1.lane(ei);
                  }));
          return r1.blend(r0, valid);
@@@ -2505,7 -2543,7 +2545,7 @@@
      ByteVector compressTemplate(Class<M> masktype, M m) {
        m.check(masktype, this);
        return (ByteVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,
--                                                        byte.class, length(), this, m,
++                                                        byte.class, byte.class, VECTOR_OPER_TYPE, length(), this, m,
                                                          (v1, m1) -> compressHelper(v1, m1));
      }
  
@@@ -2524,7 -2562,7 +2564,7 @@@
      ByteVector expandTemplate(Class<M> masktype, M m) {
        m.check(masktype, this);
        return (ByteVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,
--                                                        byte.class, length(), this, m,
++                                                        byte.class, byte.class, VECTOR_OPER_TYPE, length(), this, m,
                                                          (v1, m1) -> expandHelper(v1, m1));
      }
  
@@@ -2539,7 -2577,10 +2579,10 @@@
      /*package-private*/
      @ForceInline
      final ByteVector selectFromTemplate(ByteVector v) {
-         return v.rearrange(this.toShuffle());
 -        return (ByteVector)VectorSupport.selectFromOp(getClass(), null, byte.class,
++        return (ByteVector)VectorSupport.selectFromOp(getClass(), null, byte.class, byte.class, VECTOR_OPER_TYPE,
+                                                         length(), this, v, null,
+                                                         (v1, v2, _m) ->
+                                                          v2.rearrange(v1.toShuffle()));
      }
  
      /**
@@@ -2551,9 -2592,31 +2594,31 @@@
  
      /*package-private*/
      @ForceInline
-     final ByteVector selectFromTemplate(ByteVector v,
-                                                   AbstractMask<Byte> m) {
-         return v.rearrange(this.toShuffle(), m);
+     final
+     <M extends VectorMask<Byte>>
+     ByteVector selectFromTemplate(ByteVector v,
+                                             Class<M> masktype, M m) {
+         m.check(masktype, this);
 -        return (ByteVector)VectorSupport.selectFromOp(getClass(), masktype, byte.class,
++        return (ByteVector)VectorSupport.selectFromOp(getClass(), masktype, byte.class, byte.class, VECTOR_OPER_TYPE,
+                                                         length(), this, v, m,
+                                                         (v1, v2, _m) ->
+                                                          v2.rearrange(v1.toShuffle(), _m));
+     }
+ 
+ 
+     /**
+      * {@inheritDoc} <!--workaround-->
+      */
+     @Override
+     public abstract
+     ByteVector selectFrom(Vector<Byte> v1, Vector<Byte> v2);
+ 
+ 
+     /*package-private*/
+     @ForceInline
+     final ByteVector selectFromTemplate(ByteVector v1, ByteVector v2) {
 -        return VectorSupport.selectFromTwoVectorOp(getClass(), byte.class, length(), this, v1, v2,
++        return VectorSupport.selectFromTwoVectorOp(getClass(), byte.class, byte.class, VECTOR_OPER_TYPE, length(), this, v1, v2,
+                                                    (vec1, vec2, vec3) -> selectFromTwoVectorHelper(vec1, vec2, vec3));
      }
  
      /// Ternary operations
@@@ -2772,7 -2835,7 +2837,7 @@@
          }
          int opc = opCode(op);
          return fromBits(VectorSupport.reductionCoerced(
--            opc, getClass(), maskClass, byte.class, length(),
++            opc, getClass(), maskClass, byte.class, byte.class, VECTOR_OPER_TYPE, length(),
              this, m,
              REDUCE_IMPL.find(op, opc, ByteVector::reductionOperations)));
      }
@@@ -2790,7 -2853,7 +2855,7 @@@
          }
          int opc = opCode(op);
          return fromBits(VectorSupport.reductionCoerced(
--            opc, getClass(), null, byte.class, length(),
++            opc, getClass(), null, byte.class, byte.class, VECTOR_OPER_TYPE, length(),
              this, null,
              REDUCE_IMPL.find(op, opc, ByteVector::reductionOperations)));
      }
@@@ -3037,7 -3107,48 +3109,48 @@@
                                     byte[] a, int offset,
                                     int[] indexMap, int mapOffset) {
          ByteSpecies vsp = (ByteSpecies) species;
-         return vsp.vOp(n -> a[offset + indexMap[mapOffset + n]]);
+         IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());
+         Objects.requireNonNull(a);
+         Objects.requireNonNull(indexMap);
+         Class<? extends ByteVector> vectorType = vsp.vectorType();
+ 
+ 
+         // Constant folding should sweep out following conditonal logic.
+         VectorSpecies<Integer> lsp;
+         if (isp.length() > IntVector.SPECIES_PREFERRED.length()) {
+             lsp = IntVector.SPECIES_PREFERRED;
+         } else {
+             lsp = isp;
+         }
+ 
+         // Check indices are within array bounds.
+         IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);
+         VectorIntrinsics.checkIndex(vix0, a.length);
+ 
+         int vlen = vsp.length();
+         int idx_vlen = lsp.length();
+         IntVector vix1 = null;
+         if (vlen >= idx_vlen * 2) {
+             vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);
+             VectorIntrinsics.checkIndex(vix1, a.length);
+         }
+ 
+         IntVector vix2 = null;
+         IntVector vix3 = null;
+         if (vlen == idx_vlen * 4) {
+             vix2 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 2).add(offset);
+             VectorIntrinsics.checkIndex(vix2, a.length);
+             vix3 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 3).add(offset);
+             VectorIntrinsics.checkIndex(vix3, a.length);
+         }
+ 
+         return VectorSupport.loadWithMap(
 -            vectorType, null, byte.class, vsp.laneCount(),
++            vectorType, null, byte.class, byte.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+             lsp.vectorType(), lsp.length(),
+             a, ARRAY_BASE, vix0, vix1, vix2, vix3, null,
+             a, offset, indexMap, mapOffset, vsp,
+             (c, idx, iMap, idy, s, vm) ->
+             s.vOp(n -> c[idx + iMap[idy+n]]));
      }
  
      /**
@@@ -3364,8 -3478,8 +3480,8 @@@
          offset = checkFromIndexSize(offset, length(), a.length);
          ByteSpecies vsp = vspecies();
          VectorSupport.store(
--            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset),
++            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, arrayAddress(a, offset), false,
              this,
              a, offset,
              (arr, off, v)
@@@ -3517,8 -3632,8 +3634,8 @@@
          ByteSpecies vsp = vspecies();
          ByteVector normalized = this.and((byte) 1);
          VectorSupport.store(
--            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
-             a, booleanArrayAddress(a, offset),
++            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, booleanArrayAddress(a, offset), false,
              normalized,
              a, offset,
              (arr, off, v)
@@@ -3728,8 -3845,8 +3847,8 @@@
      ByteVector fromArray0Template(byte[] a, int offset) {
          ByteSpecies vsp = vspecies();
          return VectorSupport.load(
--            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset),
++            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, arrayAddress(a, offset), false,
              a, offset, vsp,
              (arr, off, s) -> s.ldOp(arr, (int) off,
                                      (arr_, off_, i) -> arr_[off_ + i]));
@@@ -3745,13 -3862,69 +3864,69 @@@
          m.check(species());
          ByteSpecies vsp = vspecies();
          return VectorSupport.loadMasked(
--            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset), m, offsetInRange,
++            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, arrayAddress(a, offset), false, m, offsetInRange,
              a, offset, vsp,
              (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,
                                          (arr_, off_, i) -> arr_[off_ + i]));
      }
  
+     /*package-private*/
+     abstract
+     ByteVector fromArray0(byte[] a, int offset,
+                                     int[] indexMap, int mapOffset,
+                                     VectorMask<Byte> m);
+     @ForceInline
+     final
+     <M extends VectorMask<Byte>>
+     ByteVector fromArray0Template(Class<M> maskClass, byte[] a, int offset,
+                                             int[] indexMap, int mapOffset, M m) {
+         ByteSpecies vsp = vspecies();
+         IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());
+         Objects.requireNonNull(a);
+         Objects.requireNonNull(indexMap);
+         m.check(vsp);
+         Class<? extends ByteVector> vectorType = vsp.vectorType();
+ 
+ 
+         // Constant folding should sweep out following conditonal logic.
+         VectorSpecies<Integer> lsp;
+         if (isp.length() > IntVector.SPECIES_PREFERRED.length()) {
+             lsp = IntVector.SPECIES_PREFERRED;
+         } else {
+             lsp = isp;
+         }
+ 
+         // Check indices are within array bounds.
+         // FIXME: Check index under mask controlling.
+         IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);
+         VectorIntrinsics.checkIndex(vix0, a.length);
+ 
+         int vlen = vsp.length();
+         int idx_vlen = lsp.length();
+         IntVector vix1 = null;
+         if (vlen >= idx_vlen * 2) {
+             vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);
+             VectorIntrinsics.checkIndex(vix1, a.length);
+         }
+ 
+         IntVector vix2 = null;
+         IntVector vix3 = null;
+         if (vlen == idx_vlen * 4) {
+             vix2 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 2).add(offset);
+             VectorIntrinsics.checkIndex(vix2, a.length);
+             vix3 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 3).add(offset);
+             VectorIntrinsics.checkIndex(vix3, a.length);
+         }
+ 
+         return VectorSupport.loadWithMap(
 -            vectorType, maskClass, byte.class, vsp.laneCount(),
++            vectorType, maskClass, byte.class, byte.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+             lsp.vectorType(), lsp.length(),
+             a, ARRAY_BASE, vix0, vix1, vix2, vix3, m,
+             a, offset, indexMap, mapOffset, vsp,
+             (c, idx, iMap, idy, s, vm) ->
+             s.vOp(vm, n -> c[idx + iMap[idy+n]]));
+     }
  
  
      /*package-private*/
@@@ -3762,8 -3935,8 +3937,8 @@@
      ByteVector fromBooleanArray0Template(boolean[] a, int offset) {
          ByteSpecies vsp = vspecies();
          return VectorSupport.load(
--            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
-             a, booleanArrayAddress(a, offset),
++            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, booleanArrayAddress(a, offset), false,
              a, offset, vsp,
              (arr, off, s) -> s.ldOp(arr, (int) off,
                                      (arr_, off_, i) -> (byte) (arr_[off_ + i] ? 1 : 0)));
@@@ -3779,8 -3952,8 +3954,8 @@@
          m.check(species());
          ByteSpecies vsp = vspecies();
          return VectorSupport.loadMasked(
--            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
-             a, booleanArrayAddress(a, offset), m, offsetInRange,
++            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, booleanArrayAddress(a, offset), false, m, offsetInRange,
              a, offset, vsp,
              (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,
                                          (arr_, off_, i) -> (byte) (arr_[off_ + i] ? 1 : 0)));
@@@ -3793,7 -3966,7 +3968,7 @@@
      ByteVector fromMemorySegment0Template(MemorySegment ms, long offset) {
          ByteSpecies vsp = vspecies();
          return ScopedMemoryAccess.loadFromMemorySegment(
--                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
++                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                  (AbstractMemorySegmentImpl) ms, offset, vsp,
                  (msp, off, s) -> {
                      return s.ldLongOp((MemorySegment) msp, off, ByteVector::memorySegmentGet);
@@@ -3809,7 -3982,7 +3984,7 @@@
          ByteSpecies vsp = vspecies();
          m.check(vsp);
          return ScopedMemoryAccess.loadFromMemorySegmentMasked(
--                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
++                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                  (AbstractMemorySegmentImpl) ms, offset, m, vsp, offsetInRange,
                  (msp, off, s, vm) -> {
                      return s.ldLongOp((MemorySegment) msp, off, vm, ByteVector::memorySegmentGet);
@@@ -3827,8 -4000,8 +4002,8 @@@
      void intoArray0Template(byte[] a, int offset) {
          ByteSpecies vsp = vspecies();
          VectorSupport.store(
--            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset),
++            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, arrayAddress(a, offset), false,
              this, a, offset,
              (arr, off, v)
              -> v.stOp(arr, (int) off,
@@@ -3844,8 -4017,8 +4019,8 @@@
          m.check(species());
          ByteSpecies vsp = vspecies();
          VectorSupport.storeMasked(
--            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset),
++            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, arrayAddress(a, offset), false,
              this, m, a, offset,
              (arr, off, v, vm)
              -> v.stOp(arr, (int) off, vm,
@@@ -3863,8 -4036,8 +4038,8 @@@
          ByteSpecies vsp = vspecies();
          ByteVector normalized = this.and((byte) 1);
          VectorSupport.storeMasked(
--            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
-             a, booleanArrayAddress(a, offset),
++            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, booleanArrayAddress(a, offset), false,
              normalized, m, a, offset,
              (arr, off, v, vm)
              -> v.stOp(arr, (int) off, vm,
@@@ -3876,7 -4049,7 +4051,7 @@@
      void intoMemorySegment0(MemorySegment ms, long offset) {
          ByteSpecies vsp = vspecies();
          ScopedMemoryAccess.storeIntoMemorySegment(
--                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
++                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                  this,
                  (AbstractMemorySegmentImpl) ms, offset,
                  (msp, off, v) -> {
@@@ -3893,7 -4066,7 +4068,7 @@@
          ByteSpecies vsp = vspecies();
          m.check(vsp);
          ScopedMemoryAccess.storeIntoMemorySegmentMasked(
--                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
++                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                  this, m,
                  (AbstractMemorySegmentImpl) ms, offset,
                  (msp, off, v, vm) -> {
@@@ -4094,6 -4247,6 +4249,19 @@@
  
          // Specializing overrides:
  
++        @ForceInline
++        final Class<?> carrierType() {
++            return byte.class;
++        }
++
++        @ForceInline
++        final int operType() {
++            if (byte.class.equals(Float16.class)) {
++                return VECTOR_TYPE_FP16;
++            }
++            return VECTOR_TYPE_PRIM;
++        }
++
          @Override
          @ForceInline
          public final Class<Byte> elementType() {
@@@ -4126,7 -4279,7 +4294,7 @@@
          final ByteVector broadcastBits(long bits) {
              return (ByteVector)
                  VectorSupport.fromBitsCoerced(
--                    vectorType, byte.class, laneCount,
++                    vectorType, byte.class, byte.class, VECTOR_OPER_TYPE, laneCount,
                      bits, MODE_BROADCAST, this,
                      (bits_, s_) -> s_.rvOp(i -> bits_));
          }
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double128Vector.java
index 2a36396aee7,eaf77d59a23..f9b600c48e8
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double128Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double128Vector.java
@@@ -52,7 -54,7 +54,11 @@@ final class Double128Vector extends Dou
  
      static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
  
--    static final Class<Double> ETYPE = double.class; // used by the JVM
++    static final Class<Double> CTYPE = double.class; // carrier type used by the JVM
++
++    static final Class<Double> ETYPE = double.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
  
      Double128Vector(double[] v) {
          super(v);
@@@ -86,9 -88,9 +92,12 @@@
          return VSPECIES;
      }
  
++    @ForceInline
++    final Class<Double> carrierType() { return CTYPE; }
++
      @ForceInline
      @Override
--    public final Class<Double> elementType() { return double.class; }
++    public final Class<Double> elementType() { return ETYPE; }
  
      @ForceInline
      @Override
@@@ -493,9 -513,10 +520,10 @@@
          return Double.longBitsToDouble(bits);
      }
  
+     @ForceInline
      public long laneHelper(int i) {
          return (long) VectorSupport.extract(
--                     VCLASS, ETYPE, VLENGTH,
++                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                       this, i,
                       (vec, ix) -> {
                       double[] vecarr = vec.vec();
@@@ -513,10 -534,11 +541,11 @@@
          }
      }
  
+     @ForceInline
      public Double128Vector withLaneHelper(int i, double e) {
          return VectorSupport.insert(
--                                VCLASS, ETYPE, VLENGTH,
-                                 this, i, (long)Double.doubleToLongBits(e),
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                 this, i, (long)Double.doubleToRawLongBits(e),
                                  (v, ix, bits) -> {
                                      double[] res = v.vec().clone();
                                      res[ix] = Double.longBitsToDouble((long)bits);
@@@ -528,7 -550,7 +557,7 @@@
  
      static final class Double128Mask extends AbstractMask<Double> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Double> ETYPE = double.class; // used by the JVM
++        static final Class<Double> CTYPE = double.class; // used by the JVM
  
          Double128Mask(boolean[] bits) {
              this(bits, 0);
@@@ -630,7 -652,7 +659,7 @@@
          /*package-private*/
          Double128Mask indexPartiallyInUpperRange(long offset, long limit) {
              return (Double128Mask) VectorSupport.indexPartiallyInUpperRange(
-                 Double128Mask.class, ETYPE, VLENGTH, offset, limit,
 -                Double128Mask.class, double.class, VLENGTH, offset, limit,
++                Double128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                  (o, l) -> (Double128Mask) TRUE_MASK.indexPartiallyInRange(o, l));
          }
  
@@@ -646,8 -668,8 +675,9 @@@
          @ForceInline
          public Double128Mask compress() {
              return (Double128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
--                Double128Vector.class, Double128Mask.class, ETYPE, VLENGTH, null, this,
--                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
++                Double128Vector.class, Double128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                m1.trueCount()));
          }
  
  
@@@ -658,7 -680,7 +688,7 @@@
          public Double128Mask and(VectorMask<Double> mask) {
              Objects.requireNonNull(mask);
              Double128Mask m = (Double128Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_AND, Double128Mask.class, null, long.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, Double128Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
          }
@@@ -668,7 -690,7 +698,7 @@@
          public Double128Mask or(VectorMask<Double> mask) {
              Objects.requireNonNull(mask);
              Double128Mask m = (Double128Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_OR, Double128Mask.class, null, long.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, Double128Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
          }
@@@ -678,7 -700,7 +708,7 @@@
          public Double128Mask xor(VectorMask<Double> mask) {
              Objects.requireNonNull(mask);
              Double128Mask m = (Double128Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double128Mask.class, null, long.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double128Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
          }
@@@ -688,22 -710,22 +718,25 @@@
          @Override
          @ForceInline
          public int trueCount() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double128Mask.class, long.class, VLENGTH, this,
--                                                      (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double128Mask.class, long.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int firstTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double128Mask.class, long.class, VLENGTH, this,
--                                                      (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double128Mask.class, long.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int lastTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double128Mask.class, long.class, VLENGTH, this,
--                                                      (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double128Mask.class, long.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
          }
  
          @Override
@@@ -712,32 -734,42 +745,43 @@@
              if (length() > Long.SIZE) {
                  throw new UnsupportedOperationException("too many lanes for one long");
              }
--            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Double128Mask.class, long.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Double128Mask.class, long.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
                                                        (m) -> toLongHelper(m.getBits()));
          }
  
+         // laneIsSet
+ 
+         @Override
+         @ForceInline
+         public boolean laneIsSet(int i) {
+             Objects.checkIndex(i, length());
 -            return VectorSupport.extract(Double128Mask.class, double.class, VLENGTH,
++            return VectorSupport.extract(Double128Mask.class, double.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
+         }
+ 
          // Reductions
  
          @Override
          @ForceInline
          public boolean anyTrue() {
--            return VectorSupport.test(BT_ne, Double128Mask.class, long.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> anyTrueHelper(((Double128Mask)m).getBits()));
++            return VectorSupport.test(BT_ne, Double128Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper(((Double128Mask)m).getBits()));
          }
  
          @Override
          @ForceInline
          public boolean allTrue() {
--            return VectorSupport.test(BT_overflow, Double128Mask.class, long.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> allTrueHelper(((Double128Mask)m).getBits()));
++            return VectorSupport.test(BT_overflow, Double128Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper(((Double128Mask)m).getBits()));
          }
  
          @ForceInline
          /*package-private*/
          static Double128Mask maskAll(boolean bit) {
--            return VectorSupport.fromBitsCoerced(Double128Mask.class, long.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced(Double128Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                                   (bit ? -1 : 0), MODE_BROADCAST, null,
                                                   (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
          }
@@@ -750,7 -782,7 +794,7 @@@
  
      static final class Double128Shuffle extends AbstractShuffle<Double> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Long> ETYPE = long.class; // used by the JVM
++        static final Class<Long> CTYPE = long.class; // used by the JVM
  
          Double128Shuffle(long[] indices) {
              super(indices);
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double256Vector.java
index 64805663d31,cf9c8794ce4..f364343b09b
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double256Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double256Vector.java
@@@ -52,7 -54,7 +54,11 @@@ final class Double256Vector extends Dou
  
      static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
  
--    static final Class<Double> ETYPE = double.class; // used by the JVM
++    static final Class<Double> CTYPE = double.class; // carrier type used by the JVM
++
++    static final Class<Double> ETYPE = double.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
  
      Double256Vector(double[] v) {
          super(v);
@@@ -86,9 -88,9 +92,12 @@@
          return VSPECIES;
      }
  
++    @ForceInline
++    final Class<Double> carrierType() { return CTYPE; }
++
      @ForceInline
      @Override
--    public final Class<Double> elementType() { return double.class; }
++    public final Class<Double> elementType() { return ETYPE; }
  
      @ForceInline
      @Override
@@@ -495,9 -515,10 +522,10 @@@
          return Double.longBitsToDouble(bits);
      }
  
+     @ForceInline
      public long laneHelper(int i) {
          return (long) VectorSupport.extract(
--                     VCLASS, ETYPE, VLENGTH,
++                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                       this, i,
                       (vec, ix) -> {
                       double[] vecarr = vec.vec();
@@@ -517,10 -538,11 +545,11 @@@
          }
      }
  
+     @ForceInline
      public Double256Vector withLaneHelper(int i, double e) {
          return VectorSupport.insert(
--                                VCLASS, ETYPE, VLENGTH,
-                                 this, i, (long)Double.doubleToLongBits(e),
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                 this, i, (long)Double.doubleToRawLongBits(e),
                                  (v, ix, bits) -> {
                                      double[] res = v.vec().clone();
                                      res[ix] = Double.longBitsToDouble((long)bits);
@@@ -532,7 -554,7 +561,7 @@@
  
      static final class Double256Mask extends AbstractMask<Double> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Double> ETYPE = double.class; // used by the JVM
++        static final Class<Double> CTYPE = double.class; // used by the JVM
  
          Double256Mask(boolean[] bits) {
              this(bits, 0);
@@@ -634,7 -656,7 +663,7 @@@
          /*package-private*/
          Double256Mask indexPartiallyInUpperRange(long offset, long limit) {
              return (Double256Mask) VectorSupport.indexPartiallyInUpperRange(
-                 Double256Mask.class, ETYPE, VLENGTH, offset, limit,
 -                Double256Mask.class, double.class, VLENGTH, offset, limit,
++                Double256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                  (o, l) -> (Double256Mask) TRUE_MASK.indexPartiallyInRange(o, l));
          }
  
@@@ -650,8 -672,8 +679,9 @@@
          @ForceInline
          public Double256Mask compress() {
              return (Double256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
--                Double256Vector.class, Double256Mask.class, ETYPE, VLENGTH, null, this,
--                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
++                Double256Vector.class, Double256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                m1.trueCount()));
          }
  
  
@@@ -662,7 -684,7 +692,7 @@@
          public Double256Mask and(VectorMask<Double> mask) {
              Objects.requireNonNull(mask);
              Double256Mask m = (Double256Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_AND, Double256Mask.class, null, long.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, Double256Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
          }
@@@ -672,7 -694,7 +702,7 @@@
          public Double256Mask or(VectorMask<Double> mask) {
              Objects.requireNonNull(mask);
              Double256Mask m = (Double256Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_OR, Double256Mask.class, null, long.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, Double256Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
          }
@@@ -682,7 -704,7 +712,7 @@@
          public Double256Mask xor(VectorMask<Double> mask) {
              Objects.requireNonNull(mask);
              Double256Mask m = (Double256Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double256Mask.class, null, long.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double256Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
          }
@@@ -692,22 -714,22 +722,25 @@@
          @Override
          @ForceInline
          public int trueCount() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double256Mask.class, long.class, VLENGTH, this,
--                                                      (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double256Mask.class, long.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int firstTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double256Mask.class, long.class, VLENGTH, this,
--                                                      (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double256Mask.class, long.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int lastTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double256Mask.class, long.class, VLENGTH, this,
--                                                      (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double256Mask.class, long.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
          }
  
          @Override
@@@ -716,32 -738,42 +749,43 @@@
              if (length() > Long.SIZE) {
                  throw new UnsupportedOperationException("too many lanes for one long");
              }
--            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Double256Mask.class, long.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Double256Mask.class, long.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
                                                        (m) -> toLongHelper(m.getBits()));
          }
  
+         // laneIsSet
+ 
+         @Override
+         @ForceInline
+         public boolean laneIsSet(int i) {
+             Objects.checkIndex(i, length());
 -            return VectorSupport.extract(Double256Mask.class, double.class, VLENGTH,
++            return VectorSupport.extract(Double256Mask.class, double.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
+         }
+ 
          // Reductions
  
          @Override
          @ForceInline
          public boolean anyTrue() {
--            return VectorSupport.test(BT_ne, Double256Mask.class, long.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> anyTrueHelper(((Double256Mask)m).getBits()));
++            return VectorSupport.test(BT_ne, Double256Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper(((Double256Mask)m).getBits()));
          }
  
          @Override
          @ForceInline
          public boolean allTrue() {
--            return VectorSupport.test(BT_overflow, Double256Mask.class, long.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> allTrueHelper(((Double256Mask)m).getBits()));
++            return VectorSupport.test(BT_overflow, Double256Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper(((Double256Mask)m).getBits()));
          }
  
          @ForceInline
          /*package-private*/
          static Double256Mask maskAll(boolean bit) {
--            return VectorSupport.fromBitsCoerced(Double256Mask.class, long.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced(Double256Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                                   (bit ? -1 : 0), MODE_BROADCAST, null,
                                                   (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
          }
@@@ -754,7 -786,7 +798,7 @@@
  
      static final class Double256Shuffle extends AbstractShuffle<Double> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Long> ETYPE = long.class; // used by the JVM
++        static final Class<Long> CTYPE = long.class; // used by the JVM
  
          Double256Shuffle(long[] indices) {
              super(indices);
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double512Vector.java
index ff311495466,a7a86c25841..637839cc44f
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double512Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double512Vector.java
@@@ -52,7 -54,7 +54,11 @@@ final class Double512Vector extends Dou
  
      static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
  
--    static final Class<Double> ETYPE = double.class; // used by the JVM
++    static final Class<Double> CTYPE = double.class; // carrier type used by the JVM
++
++    static final Class<Double> ETYPE = double.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
  
      Double512Vector(double[] v) {
          super(v);
@@@ -86,9 -88,9 +92,12 @@@
          return VSPECIES;
      }
  
++    @ForceInline
++    final Class<Double> carrierType() { return CTYPE; }
++
      @ForceInline
      @Override
--    public final Class<Double> elementType() { return double.class; }
++    public final Class<Double> elementType() { return ETYPE; }
  
      @ForceInline
      @Override
@@@ -499,9 -519,10 +526,10 @@@
          return Double.longBitsToDouble(bits);
      }
  
+     @ForceInline
      public long laneHelper(int i) {
          return (long) VectorSupport.extract(
--                     VCLASS, ETYPE, VLENGTH,
++                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                       this, i,
                       (vec, ix) -> {
                       double[] vecarr = vec.vec();
@@@ -525,10 -546,11 +553,11 @@@
          }
      }
  
+     @ForceInline
      public Double512Vector withLaneHelper(int i, double e) {
          return VectorSupport.insert(
--                                VCLASS, ETYPE, VLENGTH,
-                                 this, i, (long)Double.doubleToLongBits(e),
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                 this, i, (long)Double.doubleToRawLongBits(e),
                                  (v, ix, bits) -> {
                                      double[] res = v.vec().clone();
                                      res[ix] = Double.longBitsToDouble((long)bits);
@@@ -540,7 -562,7 +569,7 @@@
  
      static final class Double512Mask extends AbstractMask<Double> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Double> ETYPE = double.class; // used by the JVM
++        static final Class<Double> CTYPE = double.class; // used by the JVM
  
          Double512Mask(boolean[] bits) {
              this(bits, 0);
@@@ -642,7 -664,7 +671,7 @@@
          /*package-private*/
          Double512Mask indexPartiallyInUpperRange(long offset, long limit) {
              return (Double512Mask) VectorSupport.indexPartiallyInUpperRange(
-                 Double512Mask.class, ETYPE, VLENGTH, offset, limit,
 -                Double512Mask.class, double.class, VLENGTH, offset, limit,
++                Double512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                  (o, l) -> (Double512Mask) TRUE_MASK.indexPartiallyInRange(o, l));
          }
  
@@@ -658,8 -680,8 +687,9 @@@
          @ForceInline
          public Double512Mask compress() {
              return (Double512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
--                Double512Vector.class, Double512Mask.class, ETYPE, VLENGTH, null, this,
--                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
++                Double512Vector.class, Double512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                m1.trueCount()));
          }
  
  
@@@ -670,7 -692,7 +700,7 @@@
          public Double512Mask and(VectorMask<Double> mask) {
              Objects.requireNonNull(mask);
              Double512Mask m = (Double512Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_AND, Double512Mask.class, null, long.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, Double512Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
          }
@@@ -680,7 -702,7 +710,7 @@@
          public Double512Mask or(VectorMask<Double> mask) {
              Objects.requireNonNull(mask);
              Double512Mask m = (Double512Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_OR, Double512Mask.class, null, long.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, Double512Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
          }
@@@ -690,7 -712,7 +720,7 @@@
          public Double512Mask xor(VectorMask<Double> mask) {
              Objects.requireNonNull(mask);
              Double512Mask m = (Double512Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double512Mask.class, null, long.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double512Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
          }
@@@ -700,22 -722,22 +730,25 @@@
          @Override
          @ForceInline
          public int trueCount() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double512Mask.class, long.class, VLENGTH, this,
--                                                      (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double512Mask.class, long.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int firstTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double512Mask.class, long.class, VLENGTH, this,
--                                                      (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double512Mask.class, long.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int lastTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double512Mask.class, long.class, VLENGTH, this,
--                                                      (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double512Mask.class, long.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
          }
  
          @Override
@@@ -724,32 -746,42 +757,43 @@@
              if (length() > Long.SIZE) {
                  throw new UnsupportedOperationException("too many lanes for one long");
              }
--            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Double512Mask.class, long.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Double512Mask.class, long.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
                                                        (m) -> toLongHelper(m.getBits()));
          }
  
+         // laneIsSet
+ 
+         @Override
+         @ForceInline
+         public boolean laneIsSet(int i) {
+             Objects.checkIndex(i, length());
 -            return VectorSupport.extract(Double512Mask.class, double.class, VLENGTH,
++            return VectorSupport.extract(Double512Mask.class, double.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
+         }
+ 
          // Reductions
  
          @Override
          @ForceInline
          public boolean anyTrue() {
--            return VectorSupport.test(BT_ne, Double512Mask.class, long.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> anyTrueHelper(((Double512Mask)m).getBits()));
++            return VectorSupport.test(BT_ne, Double512Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper(((Double512Mask)m).getBits()));
          }
  
          @Override
          @ForceInline
          public boolean allTrue() {
--            return VectorSupport.test(BT_overflow, Double512Mask.class, long.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> allTrueHelper(((Double512Mask)m).getBits()));
++            return VectorSupport.test(BT_overflow, Double512Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper(((Double512Mask)m).getBits()));
          }
  
          @ForceInline
          /*package-private*/
          static Double512Mask maskAll(boolean bit) {
--            return VectorSupport.fromBitsCoerced(Double512Mask.class, long.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced(Double512Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                                   (bit ? -1 : 0), MODE_BROADCAST, null,
                                                   (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
          }
@@@ -762,7 -794,7 +806,7 @@@
  
      static final class Double512Shuffle extends AbstractShuffle<Double> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Long> ETYPE = long.class; // used by the JVM
++        static final Class<Long> CTYPE = long.class; // used by the JVM
  
          Double512Shuffle(long[] indices) {
              super(indices);
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double64Vector.java
index 8791d2bad64,df6b627cc18..b5ace52e89b
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double64Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double64Vector.java
@@@ -52,7 -54,7 +54,11 @@@ final class Double64Vector extends Doub
  
      static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
  
--    static final Class<Double> ETYPE = double.class; // used by the JVM
++    static final Class<Double> CTYPE = double.class; // carrier type used by the JVM
++
++    static final Class<Double> ETYPE = double.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
  
      Double64Vector(double[] v) {
          super(v);
@@@ -86,9 -88,9 +92,12 @@@
          return VSPECIES;
      }
  
++    @ForceInline
++    final Class<Double> carrierType() { return CTYPE; }
++
      @ForceInline
      @Override
--    public final Class<Double> elementType() { return double.class; }
++    public final Class<Double> elementType() { return ETYPE; }
  
      @ForceInline
      @Override
@@@ -492,9 -512,10 +519,10 @@@
          return Double.longBitsToDouble(bits);
      }
  
+     @ForceInline
      public long laneHelper(int i) {
          return (long) VectorSupport.extract(
--                     VCLASS, ETYPE, VLENGTH,
++                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                       this, i,
                       (vec, ix) -> {
                       double[] vecarr = vec.vec();
@@@ -511,10 -532,11 +539,11 @@@
          }
      }
  
+     @ForceInline
      public Double64Vector withLaneHelper(int i, double e) {
          return VectorSupport.insert(
--                                VCLASS, ETYPE, VLENGTH,
-                                 this, i, (long)Double.doubleToLongBits(e),
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                 this, i, (long)Double.doubleToRawLongBits(e),
                                  (v, ix, bits) -> {
                                      double[] res = v.vec().clone();
                                      res[ix] = Double.longBitsToDouble((long)bits);
@@@ -526,7 -548,7 +555,7 @@@
  
      static final class Double64Mask extends AbstractMask<Double> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Double> ETYPE = double.class; // used by the JVM
++        static final Class<Double> CTYPE = double.class; // used by the JVM
  
          Double64Mask(boolean[] bits) {
              this(bits, 0);
@@@ -628,7 -650,7 +657,7 @@@
          /*package-private*/
          Double64Mask indexPartiallyInUpperRange(long offset, long limit) {
              return (Double64Mask) VectorSupport.indexPartiallyInUpperRange(
-                 Double64Mask.class, ETYPE, VLENGTH, offset, limit,
 -                Double64Mask.class, double.class, VLENGTH, offset, limit,
++                Double64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                  (o, l) -> (Double64Mask) TRUE_MASK.indexPartiallyInRange(o, l));
          }
  
@@@ -644,8 -666,8 +673,9 @@@
          @ForceInline
          public Double64Mask compress() {
              return (Double64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
--                Double64Vector.class, Double64Mask.class, ETYPE, VLENGTH, null, this,
--                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
++                Double64Vector.class, Double64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                m1.trueCount()));
          }
  
  
@@@ -656,7 -678,7 +686,7 @@@
          public Double64Mask and(VectorMask<Double> mask) {
              Objects.requireNonNull(mask);
              Double64Mask m = (Double64Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_AND, Double64Mask.class, null, long.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, Double64Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
          }
@@@ -666,7 -688,7 +696,7 @@@
          public Double64Mask or(VectorMask<Double> mask) {
              Objects.requireNonNull(mask);
              Double64Mask m = (Double64Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_OR, Double64Mask.class, null, long.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, Double64Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
          }
@@@ -676,7 -698,7 +706,7 @@@
          public Double64Mask xor(VectorMask<Double> mask) {
              Objects.requireNonNull(mask);
              Double64Mask m = (Double64Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double64Mask.class, null, long.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double64Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
          }
@@@ -686,22 -708,22 +716,25 @@@
          @Override
          @ForceInline
          public int trueCount() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double64Mask.class, long.class, VLENGTH, this,
--                                                      (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double64Mask.class, long.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int firstTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double64Mask.class, long.class, VLENGTH, this,
--                                                      (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double64Mask.class, long.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int lastTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double64Mask.class, long.class, VLENGTH, this,
--                                                      (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double64Mask.class, long.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
          }
  
          @Override
@@@ -710,32 -732,42 +743,43 @@@
              if (length() > Long.SIZE) {
                  throw new UnsupportedOperationException("too many lanes for one long");
              }
--            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Double64Mask.class, long.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Double64Mask.class, long.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
                                                        (m) -> toLongHelper(m.getBits()));
          }
  
+         // laneIsSet
+ 
+         @Override
+         @ForceInline
+         public boolean laneIsSet(int i) {
+             Objects.checkIndex(i, length());
 -            return VectorSupport.extract(Double64Mask.class, double.class, VLENGTH,
++            return VectorSupport.extract(Double64Mask.class, double.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
+         }
+ 
          // Reductions
  
          @Override
          @ForceInline
          public boolean anyTrue() {
--            return VectorSupport.test(BT_ne, Double64Mask.class, long.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> anyTrueHelper(((Double64Mask)m).getBits()));
++            return VectorSupport.test(BT_ne, Double64Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper(((Double64Mask)m).getBits()));
          }
  
          @Override
          @ForceInline
          public boolean allTrue() {
--            return VectorSupport.test(BT_overflow, Double64Mask.class, long.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> allTrueHelper(((Double64Mask)m).getBits()));
++            return VectorSupport.test(BT_overflow, Double64Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper(((Double64Mask)m).getBits()));
          }
  
          @ForceInline
          /*package-private*/
          static Double64Mask maskAll(boolean bit) {
--            return VectorSupport.fromBitsCoerced(Double64Mask.class, long.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced(Double64Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                                   (bit ? -1 : 0), MODE_BROADCAST, null,
                                                   (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
          }
@@@ -748,7 -780,7 +792,7 @@@
  
      static final class Double64Shuffle extends AbstractShuffle<Double> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Long> ETYPE = long.class; // used by the JVM
++        static final Class<Long> CTYPE = long.class; // used by the JVM
  
          Double64Shuffle(long[] indices) {
              super(indices);
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/DoubleMaxVector.java
index 1c53fe75881,47be1f609d8..06f3a632ee0
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/DoubleMaxVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/DoubleMaxVector.java
@@@ -52,7 -54,7 +54,11 @@@ final class DoubleMaxVector extends Dou
  
      static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
  
--    static final Class<Double> ETYPE = double.class; // used by the JVM
++    static final Class<Double> CTYPE = double.class; // carrier type used by the JVM
++
++    static final Class<Double> ETYPE = double.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
  
      DoubleMaxVector(double[] v) {
          super(v);
@@@ -86,9 -88,9 +92,12 @@@
          return VSPECIES;
      }
  
++    @ForceInline
++    final Class<Double> carrierType() { return CTYPE; }
++
      @ForceInline
      @Override
--    public final Class<Double> elementType() { return double.class; }
++    public final Class<Double> elementType() { return ETYPE; }
  
      @ForceInline
      @Override
@@@ -491,9 -511,10 +518,10 @@@
          return Double.longBitsToDouble(bits);
      }
  
+     @ForceInline
      public long laneHelper(int i) {
          return (long) VectorSupport.extract(
--                     VCLASS, ETYPE, VLENGTH,
++                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                       this, i,
                       (vec, ix) -> {
                       double[] vecarr = vec.vec();
@@@ -510,10 -531,11 +538,11 @@@
          return withLaneHelper(i, e);
      }
  
+     @ForceInline
      public DoubleMaxVector withLaneHelper(int i, double e) {
          return VectorSupport.insert(
--                                VCLASS, ETYPE, VLENGTH,
-                                 this, i, (long)Double.doubleToLongBits(e),
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                 this, i, (long)Double.doubleToRawLongBits(e),
                                  (v, ix, bits) -> {
                                      double[] res = v.vec().clone();
                                      res[ix] = Double.longBitsToDouble((long)bits);
@@@ -525,7 -547,7 +554,7 @@@
  
      static final class DoubleMaxMask extends AbstractMask<Double> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Double> ETYPE = double.class; // used by the JVM
++        static final Class<Double> CTYPE = double.class; // used by the JVM
  
          DoubleMaxMask(boolean[] bits) {
              this(bits, 0);
@@@ -627,7 -649,7 +656,7 @@@
          /*package-private*/
          DoubleMaxMask indexPartiallyInUpperRange(long offset, long limit) {
              return (DoubleMaxMask) VectorSupport.indexPartiallyInUpperRange(
-                 DoubleMaxMask.class, ETYPE, VLENGTH, offset, limit,
 -                DoubleMaxMask.class, double.class, VLENGTH, offset, limit,
++                DoubleMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                  (o, l) -> (DoubleMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));
          }
  
@@@ -643,8 -665,8 +672,9 @@@
          @ForceInline
          public DoubleMaxMask compress() {
              return (DoubleMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
--                DoubleMaxVector.class, DoubleMaxMask.class, ETYPE, VLENGTH, null, this,
--                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
++                DoubleMaxVector.class, DoubleMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                m1.trueCount()));
          }
  
  
@@@ -655,7 -677,7 +685,7 @@@
          public DoubleMaxMask and(VectorMask<Double> mask) {
              Objects.requireNonNull(mask);
              DoubleMaxMask m = (DoubleMaxMask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_AND, DoubleMaxMask.class, null, long.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, DoubleMaxMask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
          }
@@@ -665,7 -687,7 +695,7 @@@
          public DoubleMaxMask or(VectorMask<Double> mask) {
              Objects.requireNonNull(mask);
              DoubleMaxMask m = (DoubleMaxMask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_OR, DoubleMaxMask.class, null, long.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, DoubleMaxMask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
          }
@@@ -675,7 -697,7 +705,7 @@@
          public DoubleMaxMask xor(VectorMask<Double> mask) {
              Objects.requireNonNull(mask);
              DoubleMaxMask m = (DoubleMaxMask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_XOR, DoubleMaxMask.class, null, long.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, DoubleMaxMask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
          }
@@@ -685,22 -707,22 +715,25 @@@
          @Override
          @ForceInline
          public int trueCount() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, DoubleMaxMask.class, long.class, VLENGTH, this,
--                                                      (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, DoubleMaxMask.class, long.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int firstTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, DoubleMaxMask.class, long.class, VLENGTH, this,
--                                                      (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, DoubleMaxMask.class, long.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int lastTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, DoubleMaxMask.class, long.class, VLENGTH, this,
--                                                      (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, DoubleMaxMask.class, long.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
          }
  
          @Override
@@@ -709,32 -731,42 +742,43 @@@
              if (length() > Long.SIZE) {
                  throw new UnsupportedOperationException("too many lanes for one long");
              }
--            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, DoubleMaxMask.class, long.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, DoubleMaxMask.class, long.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
                                                        (m) -> toLongHelper(m.getBits()));
          }
  
+         // laneIsSet
+ 
+         @Override
+         @ForceInline
+         public boolean laneIsSet(int i) {
+             Objects.checkIndex(i, length());
 -            return VectorSupport.extract(DoubleMaxMask.class, double.class, VLENGTH,
++            return VectorSupport.extract(DoubleMaxMask.class, double.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
+         }
+ 
          // Reductions
  
          @Override
          @ForceInline
          public boolean anyTrue() {
--            return VectorSupport.test(BT_ne, DoubleMaxMask.class, long.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> anyTrueHelper(((DoubleMaxMask)m).getBits()));
++            return VectorSupport.test(BT_ne, DoubleMaxMask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper(((DoubleMaxMask)m).getBits()));
          }
  
          @Override
          @ForceInline
          public boolean allTrue() {
--            return VectorSupport.test(BT_overflow, DoubleMaxMask.class, long.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> allTrueHelper(((DoubleMaxMask)m).getBits()));
++            return VectorSupport.test(BT_overflow, DoubleMaxMask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper(((DoubleMaxMask)m).getBits()));
          }
  
          @ForceInline
          /*package-private*/
          static DoubleMaxMask maskAll(boolean bit) {
--            return VectorSupport.fromBitsCoerced(DoubleMaxMask.class, long.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced(DoubleMaxMask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                                   (bit ? -1 : 0), MODE_BROADCAST, null,
                                                   (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
          }
@@@ -747,7 -779,7 +791,7 @@@
  
      static final class DoubleMaxShuffle extends AbstractShuffle<Double> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Long> ETYPE = long.class; // used by the JVM
++        static final Class<Long> CTYPE = long.class; // used by the JVM
  
          DoubleMaxShuffle(long[] indices) {
              super(indices);
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/DoubleVector.java
index 1f4c0a49d45,786cd089ebe..83a295c9e7a
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/DoubleVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/DoubleVector.java
@@@ -57,7 -57,7 +57,9 @@@ public abstract class DoubleVector exte
  
      static final int FORBID_OPCODE_KIND = VO_NOFP;
  
-     static final ValueLayout.OfDouble ELEMENT_LAYOUT = ValueLayout.JAVA_DOUBLE.withBitAlignment(8);
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
++
+     static final ValueLayout.OfDouble ELEMENT_LAYOUT = ValueLayout.JAVA_DOUBLE.withByteAlignment(1);
  
      @ForceInline
      static int opCode(Operator op) {
@@@ -549,7 -562,7 +564,7 @@@
      @ForceInline
      public static DoubleVector zero(VectorSpecies<Double> species) {
          DoubleSpecies vsp = (DoubleSpecies) species;
--        return VectorSupport.fromBitsCoerced(vsp.vectorType(), double.class, species.length(),
++        return VectorSupport.fromBitsCoerced(vsp.vectorType(), double.class, double.class, VECTOR_OPER_TYPE, species.length(),
                          toBits(0.0f), MODE_BROADCAST, vsp,
                          ((bits_, s_) -> s_.rvOp(i -> bits_)));
      }
@@@ -668,7 -684,7 +686,7 @@@
          }
          int opc = opCode(op);
          return VectorSupport.unaryOp(
--            opc, getClass(), null, double.class, length(),
++            opc, getClass(), null, double.class, double.class, VECTOR_OPER_TYPE, length(),
              this, null,
              UN_IMPL.find(op, opc, DoubleVector::unaryOperations));
      }
@@@ -693,7 -712,7 +714,7 @@@
          }
          int opc = opCode(op);
          return VectorSupport.unaryOp(
--            opc, getClass(), maskClass, double.class, length(),
++            opc, getClass(), maskClass, double.class, double.class, VECTOR_OPER_TYPE, length(),
              this, m,
              UN_IMPL.find(op, opc, DoubleVector::unaryOperations));
      }
@@@ -772,7 -801,7 +803,7 @@@
  
          int opc = opCode(op);
          return VectorSupport.binaryOp(
--            opc, getClass(), null, double.class, length(),
++            opc, getClass(), null, double.class, double.class, VECTOR_OPER_TYPE, length(),
              this, that, null,
              BIN_IMPL.find(op, opc, DoubleVector::binaryOperations));
      }
@@@ -806,7 -839,7 +841,7 @@@
  
          int opc = opCode(op);
          return VectorSupport.binaryOp(
--            opc, getClass(), maskClass, double.class, length(),
++            opc, getClass(), maskClass, double.class, double.class, VECTOR_OPER_TYPE, length(),
              this, that, m,
              BIN_IMPL.find(op, opc, DoubleVector::binaryOperations));
      }
@@@ -981,7 -1021,7 +1023,7 @@@
          tother.check(this);
          int opc = opCode(op);
          return VectorSupport.ternaryOp(
--            opc, getClass(), null, double.class, length(),
++            opc, getClass(), null, double.class, double.class, VECTOR_OPER_TYPE, length(),
              this, that, tother, null,
              TERN_IMPL.find(op, opc, DoubleVector::ternaryOperations));
      }
@@@ -1016,7 -1056,7 +1058,7 @@@
  
          int opc = opCode(op);
          return VectorSupport.ternaryOp(
--            opc, getClass(), maskClass, double.class, length(),
++            opc, getClass(), maskClass, double.class, double.class, VECTOR_OPER_TYPE, length(),
              this, that, tother, m,
              TERN_IMPL.find(op, opc, DoubleVector::ternaryOperations));
      }
@@@ -1888,7 -1928,7 +1930,7 @@@
          that.check(this);
          int opc = opCode(op);
          return VectorSupport.compare(
--            opc, getClass(), maskType, double.class, length(),
++            opc, getClass(), maskType, double.class, double.class, VECTOR_OPER_TYPE, length(),
              this, that, null,
              (cond, v0, v1, m1) -> {
                  AbstractMask<Double> m
@@@ -1910,7 -1950,7 +1952,7 @@@
          m.check(maskType, this);
          int opc = opCode(op);
          return VectorSupport.compare(
--            opc, getClass(), maskType, double.class, length(),
++            opc, getClass(), maskType, double.class, double.class, VECTOR_OPER_TYPE, length(),
              this, that, m,
              (cond, v0, v1, m1) -> {
                  AbstractMask<Double> cmpM
@@@ -2037,7 -2077,7 +2079,7 @@@
      blendTemplate(Class<M> maskType, DoubleVector v, M m) {
          v.check(this);
          return VectorSupport.blend(
--            getClass(), maskType, double.class, length(),
++            getClass(), maskType, double.class, double.class, VECTOR_OPER_TYPE, length(),
              this, v, m,
              (v0, v1, m_) -> v0.bOp(v1, m_, (i, a, b) -> b));
      }
@@@ -2054,7 -2094,7 +2096,7 @@@
          // make sure VLENGTH*scale doesn't overflow:
          vsp.checkScale(scale);
          return VectorSupport.indexVector(
--            getClass(), double.class, length(),
++            getClass(), double.class, double.class, VECTOR_OPER_TYPE, length(),
              this, scale, vsp,
              (v, scale_, s)
              -> {
@@@ -2242,12 -2284,12 +2286,12 @@@
      final
      <S extends VectorShuffle<Double>>
      DoubleVector rearrangeTemplate(Class<S> shuffletype, S shuffle) {
-         shuffle.checkIndexes();
+         Objects.requireNonNull(shuffle);
          return VectorSupport.rearrangeOp(
--            getClass(), shuffletype, null, double.class, length(),
++            getClass(), shuffletype, null, double.class, double.class, VECTOR_OPER_TYPE, length(),
              this, shuffle, null,
              (v1, s_, m_) -> v1.uOp((i, a) -> {
-                 int ei = s_.laneSource(i);
+                 int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
                  return v1.lane(ei);
              }));
      }
@@@ -2268,19 -2310,14 +2312,14 @@@
                                             Class<M> masktype,
                                             S shuffle,
                                             M m) {
- 
+         Objects.requireNonNull(shuffle);
          m.check(masktype, this);
-         VectorMask<Double> valid = shuffle.laneIsValid();
-         if (m.andNot(valid).anyTrue()) {
-             shuffle.checkIndexes();
-             throw new AssertionError();
-         }
          return VectorSupport.rearrangeOp(
--                   getClass(), shuffletype, masktype, double.class, length(),
++                   getClass(), shuffletype, masktype, double.class, double.class, VECTOR_OPER_TYPE, length(),
                     this, shuffle, m,
                     (v1, s_, m_) -> v1.uOp((i, a) -> {
-                         int ei = s_.laneSource(i);
-                         return ei < 0  || !m_.laneIsSet(i) ? 0 : v1.lane(ei);
+                         int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
+                         return !m_.laneIsSet(i) ? 0 : v1.lane(ei);
                     }));
      }
  
@@@ -2300,22 -2337,20 +2339,20 @@@
                                             S shuffle,
                                             DoubleVector v) {
          VectorMask<Double> valid = shuffle.laneIsValid();
-         @SuppressWarnings("unchecked")
-         S ws = (S) shuffle.wrapIndexes();
          DoubleVector r0 =
              VectorSupport.rearrangeOp(
--                getClass(), shuffletype, null, double.class, length(),
-                 this, ws, null,
++                getClass(), shuffletype, null, double.class, double.class, VECTOR_OPER_TYPE, length(),
+                 this, shuffle, null,
                  (v0, s_, m_) -> v0.uOp((i, a) -> {
-                     int ei = s_.laneSource(i);
+                     int ei = Integer.remainderUnsigned(s_.laneSource(i), v0.length());
                      return v0.lane(ei);
                  }));
          DoubleVector r1 =
              VectorSupport.rearrangeOp(
--                getClass(), shuffletype, null, double.class, length(),
-                 v, ws, null,
++                getClass(), shuffletype, null, double.class, double.class, VECTOR_OPER_TYPE, length(),
+                 v, shuffle, null,
                  (v1, s_, m_) -> v1.uOp((i, a) -> {
-                     int ei = s_.laneSource(i);
+                     int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
                      return v1.lane(ei);
                  }));
          return r1.blend(r0, valid);
@@@ -2347,7 -2391,7 +2393,7 @@@
      DoubleVector compressTemplate(Class<M> masktype, M m) {
        m.check(masktype, this);
        return (DoubleVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,
--                                                        double.class, length(), this, m,
++                                                        double.class, double.class, VECTOR_OPER_TYPE, length(), this, m,
                                                          (v1, m1) -> compressHelper(v1, m1));
      }
  
@@@ -2366,7 -2410,7 +2412,7 @@@
      DoubleVector expandTemplate(Class<M> masktype, M m) {
        m.check(masktype, this);
        return (DoubleVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,
--                                                        double.class, length(), this, m,
++                                                        double.class, double.class, VECTOR_OPER_TYPE, length(), this, m,
                                                          (v1, m1) -> expandHelper(v1, m1));
      }
  
@@@ -2381,7 -2425,10 +2427,10 @@@
      /*package-private*/
      @ForceInline
      final DoubleVector selectFromTemplate(DoubleVector v) {
-         return v.rearrange(this.toShuffle());
 -        return (DoubleVector)VectorSupport.selectFromOp(getClass(), null, double.class,
++        return (DoubleVector)VectorSupport.selectFromOp(getClass(), null, double.class, double.class, VECTOR_OPER_TYPE,
+                                                         length(), this, v, null,
+                                                         (v1, v2, _m) ->
+                                                          v2.rearrange(v1.toShuffle()));
      }
  
      /**
@@@ -2393,9 -2440,31 +2442,31 @@@
  
      /*package-private*/
      @ForceInline
-     final DoubleVector selectFromTemplate(DoubleVector v,
-                                                   AbstractMask<Double> m) {
-         return v.rearrange(this.toShuffle(), m);
+     final
+     <M extends VectorMask<Double>>
+     DoubleVector selectFromTemplate(DoubleVector v,
+                                             Class<M> masktype, M m) {
+         m.check(masktype, this);
 -        return (DoubleVector)VectorSupport.selectFromOp(getClass(), masktype, double.class,
++        return (DoubleVector)VectorSupport.selectFromOp(getClass(), masktype, double.class, double.class, VECTOR_OPER_TYPE,
+                                                         length(), this, v, m,
+                                                         (v1, v2, _m) ->
+                                                          v2.rearrange(v1.toShuffle(), _m));
+     }
+ 
+ 
+     /**
+      * {@inheritDoc} <!--workaround-->
+      */
+     @Override
+     public abstract
+     DoubleVector selectFrom(Vector<Double> v1, Vector<Double> v2);
+ 
+ 
+     /*package-private*/
+     @ForceInline
+     final DoubleVector selectFromTemplate(DoubleVector v1, DoubleVector v2) {
 -        return VectorSupport.selectFromTwoVectorOp(getClass(), double.class, length(), this, v1, v2,
++        return VectorSupport.selectFromTwoVectorOp(getClass(), double.class, double.class, VECTOR_OPER_TYPE, length(), this, v1, v2,
+                                                    (vec1, vec2, vec3) -> selectFromTwoVectorHelper(vec1, vec2, vec3));
      }
  
      /// Ternary operations
@@@ -2592,7 -2661,7 +2663,7 @@@
          }
          int opc = opCode(op);
          return fromBits(VectorSupport.reductionCoerced(
--            opc, getClass(), maskClass, double.class, length(),
++            opc, getClass(), maskClass, double.class, double.class, VECTOR_OPER_TYPE, length(),
              this, m,
              REDUCE_IMPL.find(op, opc, DoubleVector::reductionOperations)));
      }
@@@ -2610,7 -2679,7 +2681,7 @@@
          }
          int opc = opCode(op);
          return fromBits(VectorSupport.reductionCoerced(
--            opc, getClass(), null, double.class, length(),
++            opc, getClass(), null, double.class, double.class, VECTOR_OPER_TYPE, length(),
              this, null,
              REDUCE_IMPL.find(op, opc, DoubleVector::reductionOperations)));
      }
@@@ -2866,9 -2936,9 +2938,9 @@@
          vix = VectorIntrinsics.checkIndex(vix, a.length);
  
          return VectorSupport.loadWithMap(
--            vectorType, null, double.class, vsp.laneCount(),
-             isp.vectorType(),
-             a, ARRAY_BASE, vix, null,
++            vectorType, null, double.class, double.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+             isp.vectorType(), isp.length(),
+             a, ARRAY_BASE, vix, null, null, null, null,
              a, offset, indexMap, mapOffset, vsp,
              (c, idx, iMap, idy, s, vm) ->
              s.vOp(n -> c[idx + iMap[idy+n]]));
@@@ -3052,8 -3119,8 +3121,8 @@@
          offset = checkFromIndexSize(offset, length(), a.length);
          DoubleSpecies vsp = vspecies();
          VectorSupport.store(
--            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset),
++            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, arrayAddress(a, offset), false,
              this,
              a, offset,
              (arr, off, v)
@@@ -3159,8 -3227,8 +3229,8 @@@
          vix = VectorIntrinsics.checkIndex(vix, a.length);
  
          VectorSupport.storeWithMap(
--            vsp.vectorType(), null, vsp.elementType(), vsp.laneCount(),
-             isp.vectorType(),
++            vsp.vectorType(), null, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             isp.vectorType(), isp.length(),
              a, arrayAddress(a, 0), vix,
              this, null,
              a, offset, indexMap, mapOffset,
@@@ -3285,8 -3354,8 +3356,8 @@@
      DoubleVector fromArray0Template(double[] a, int offset) {
          DoubleSpecies vsp = vspecies();
          return VectorSupport.load(
--            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset),
++            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, arrayAddress(a, offset), false,
              a, offset, vsp,
              (arr, off, s) -> s.ldOp(arr, (int) off,
                                      (arr_, off_, i) -> arr_[off_ + i]));
@@@ -3302,8 -3371,8 +3373,8 @@@
          m.check(species());
          DoubleSpecies vsp = vspecies();
          return VectorSupport.loadMasked(
--            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset), m, offsetInRange,
++            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, arrayAddress(a, offset), false, m, offsetInRange,
              a, offset, vsp,
              (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,
                                          (arr_, off_, i) -> arr_[off_ + i]));
@@@ -3353,9 -3422,9 +3424,9 @@@
          vix = VectorIntrinsics.checkIndex(vix, a.length);
  
          return VectorSupport.loadWithMap(
--            vectorType, maskClass, double.class, vsp.laneCount(),
-             isp.vectorType(),
-             a, ARRAY_BASE, vix, m,
++            vectorType, maskClass, double.class, double.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+             isp.vectorType(), isp.length(),
+             a, ARRAY_BASE, vix, null, null, null, m,
              a, offset, indexMap, mapOffset, vsp,
              (c, idx, iMap, idy, s, vm) ->
              s.vOp(vm, n -> c[idx + iMap[idy+n]]));
@@@ -3370,7 -3439,7 +3441,7 @@@
      DoubleVector fromMemorySegment0Template(MemorySegment ms, long offset) {
          DoubleSpecies vsp = vspecies();
          return ScopedMemoryAccess.loadFromMemorySegment(
--                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
++                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                  (AbstractMemorySegmentImpl) ms, offset, vsp,
                  (msp, off, s) -> {
                      return s.ldLongOp((MemorySegment) msp, off, DoubleVector::memorySegmentGet);
@@@ -3386,7 -3455,7 +3457,7 @@@
          DoubleSpecies vsp = vspecies();
          m.check(vsp);
          return ScopedMemoryAccess.loadFromMemorySegmentMasked(
--                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
++                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                  (AbstractMemorySegmentImpl) ms, offset, m, vsp, offsetInRange,
                  (msp, off, s, vm) -> {
                      return s.ldLongOp((MemorySegment) msp, off, vm, DoubleVector::memorySegmentGet);
@@@ -3404,8 -3473,8 +3475,8 @@@
      void intoArray0Template(double[] a, int offset) {
          DoubleSpecies vsp = vspecies();
          VectorSupport.store(
--            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset),
++            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, arrayAddress(a, offset), false,
              this, a, offset,
              (arr, off, v)
              -> v.stOp(arr, (int) off,
@@@ -3421,8 -3490,8 +3492,8 @@@
          m.check(species());
          DoubleSpecies vsp = vspecies();
          VectorSupport.storeMasked(
--            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset),
++            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, arrayAddress(a, offset), false,
              this, m, a, offset,
              (arr, off, v, vm)
              -> v.stOp(arr, (int) off, vm,
@@@ -3469,8 -3538,8 +3540,8 @@@
          vix = VectorIntrinsics.checkIndex(vix, a.length);
  
          VectorSupport.storeWithMap(
--            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
-             isp.vectorType(),
++            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             isp.vectorType(), isp.length(),
              a, arrayAddress(a, 0), vix,
              this, m,
              a, offset, indexMap, mapOffset,
@@@ -3488,7 -3557,7 +3559,7 @@@
      void intoMemorySegment0(MemorySegment ms, long offset) {
          DoubleSpecies vsp = vspecies();
          ScopedMemoryAccess.storeIntoMemorySegment(
--                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
++                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                  this,
                  (AbstractMemorySegmentImpl) ms, offset,
                  (msp, off, v) -> {
@@@ -3505,7 -3574,7 +3576,7 @@@
          DoubleSpecies vsp = vspecies();
          m.check(vsp);
          ScopedMemoryAccess.storeIntoMemorySegmentMasked(
--                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
++                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                  this, m,
                  (AbstractMemorySegmentImpl) ms, offset,
                  (msp, off, v, vm) -> {
@@@ -3697,6 -3746,6 +3748,19 @@@
  
          // Specializing overrides:
  
++        @ForceInline
++        final Class<?> carrierType() {
++            return double.class;
++        }
++
++        @ForceInline
++        final int operType() {
++            if (double.class.equals(Float16.class)) {
++                return VECTOR_TYPE_FP16;
++            }
++            return VECTOR_TYPE_PRIM;
++        }
++
          @Override
          @ForceInline
          public final Class<Double> elementType() {
@@@ -3729,7 -3778,7 +3793,7 @@@
          final DoubleVector broadcastBits(long bits) {
              return (DoubleVector)
                  VectorSupport.fromBitsCoerced(
--                    vectorType, double.class, laneCount,
++                    vectorType, double.class, double.class, VECTOR_OPER_TYPE, laneCount,
                      bits, MODE_BROADCAST, this,
                      (bits_, s_) -> s_.rvOp(i -> bits_));
          }
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float128Vector.java
index cb1c44e148d,fdfd234cb47..9202d6548f7
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float128Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float128Vector.java
@@@ -52,7 -54,7 +54,11 @@@ final class Float128Vector extends Floa
  
      static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
  
--    static final Class<Float> ETYPE = float.class; // used by the JVM
++    static final Class<Float> CTYPE = float.class; // carrier type used by the JVM
++
++    static final Class<Float> ETYPE = float.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
  
      Float128Vector(float[] v) {
          super(v);
@@@ -86,9 -88,9 +92,12 @@@
          return VSPECIES;
      }
  
++    @ForceInline
++    final Class<Float> carrierType() { return CTYPE; }
++
      @ForceInline
      @Override
--    public final Class<Float> elementType() { return float.class; }
++    public final Class<Float> elementType() { return ETYPE; }
  
      @ForceInline
      @Override
@@@ -495,9 -515,10 +522,10 @@@
          return Float.intBitsToFloat(bits);
      }
  
+     @ForceInline
      public int laneHelper(int i) {
          return (int) VectorSupport.extract(
--                     VCLASS, ETYPE, VLENGTH,
++                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                       this, i,
                       (vec, ix) -> {
                       float[] vecarr = vec.vec();
@@@ -517,10 -538,11 +545,11 @@@
          }
      }
  
+     @ForceInline
      public Float128Vector withLaneHelper(int i, float e) {
          return VectorSupport.insert(
--                                VCLASS, ETYPE, VLENGTH,
-                                 this, i, (long)Float.floatToIntBits(e),
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                 this, i, (long)Float.floatToRawIntBits(e),
                                  (v, ix, bits) -> {
                                      float[] res = v.vec().clone();
                                      res[ix] = Float.intBitsToFloat((int)bits);
@@@ -532,7 -554,7 +561,7 @@@
  
      static final class Float128Mask extends AbstractMask<Float> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Float> ETYPE = float.class; // used by the JVM
++        static final Class<Float> CTYPE = float.class; // used by the JVM
  
          Float128Mask(boolean[] bits) {
              this(bits, 0);
@@@ -634,7 -656,7 +663,7 @@@
          /*package-private*/
          Float128Mask indexPartiallyInUpperRange(long offset, long limit) {
              return (Float128Mask) VectorSupport.indexPartiallyInUpperRange(
-                 Float128Mask.class, ETYPE, VLENGTH, offset, limit,
 -                Float128Mask.class, float.class, VLENGTH, offset, limit,
++                Float128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                  (o, l) -> (Float128Mask) TRUE_MASK.indexPartiallyInRange(o, l));
          }
  
@@@ -650,8 -672,8 +679,9 @@@
          @ForceInline
          public Float128Mask compress() {
              return (Float128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
--                Float128Vector.class, Float128Mask.class, ETYPE, VLENGTH, null, this,
--                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
++                Float128Vector.class, Float128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                m1.trueCount()));
          }
  
  
@@@ -662,7 -684,7 +692,7 @@@
          public Float128Mask and(VectorMask<Float> mask) {
              Objects.requireNonNull(mask);
              Float128Mask m = (Float128Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_AND, Float128Mask.class, null, int.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, Float128Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
          }
@@@ -672,7 -694,7 +702,7 @@@
          public Float128Mask or(VectorMask<Float> mask) {
              Objects.requireNonNull(mask);
              Float128Mask m = (Float128Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_OR, Float128Mask.class, null, int.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, Float128Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
          }
@@@ -682,7 -704,7 +712,7 @@@
          public Float128Mask xor(VectorMask<Float> mask) {
              Objects.requireNonNull(mask);
              Float128Mask m = (Float128Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float128Mask.class, null, int.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float128Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
          }
@@@ -692,22 -714,22 +722,25 @@@
          @Override
          @ForceInline
          public int trueCount() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float128Mask.class, int.class, VLENGTH, this,
--                                                      (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float128Mask.class, int.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int firstTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float128Mask.class, int.class, VLENGTH, this,
--                                                      (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float128Mask.class, int.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int lastTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float128Mask.class, int.class, VLENGTH, this,
--                                                      (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float128Mask.class, int.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
          }
  
          @Override
@@@ -716,32 -738,42 +749,43 @@@
              if (length() > Long.SIZE) {
                  throw new UnsupportedOperationException("too many lanes for one long");
              }
--            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Float128Mask.class, int.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Float128Mask.class, int.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
                                                        (m) -> toLongHelper(m.getBits()));
          }
  
+         // laneIsSet
+ 
+         @Override
+         @ForceInline
+         public boolean laneIsSet(int i) {
+             Objects.checkIndex(i, length());
 -            return VectorSupport.extract(Float128Mask.class, float.class, VLENGTH,
++            return VectorSupport.extract(Float128Mask.class, float.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
+         }
+ 
          // Reductions
  
          @Override
          @ForceInline
          public boolean anyTrue() {
--            return VectorSupport.test(BT_ne, Float128Mask.class, int.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> anyTrueHelper(((Float128Mask)m).getBits()));
++            return VectorSupport.test(BT_ne, Float128Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper(((Float128Mask)m).getBits()));
          }
  
          @Override
          @ForceInline
          public boolean allTrue() {
--            return VectorSupport.test(BT_overflow, Float128Mask.class, int.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> allTrueHelper(((Float128Mask)m).getBits()));
++            return VectorSupport.test(BT_overflow, Float128Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper(((Float128Mask)m).getBits()));
          }
  
          @ForceInline
          /*package-private*/
          static Float128Mask maskAll(boolean bit) {
--            return VectorSupport.fromBitsCoerced(Float128Mask.class, int.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced(Float128Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                                   (bit ? -1 : 0), MODE_BROADCAST, null,
                                                   (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
          }
@@@ -754,7 -786,7 +798,7 @@@
  
      static final class Float128Shuffle extends AbstractShuffle<Float> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Integer> ETYPE = int.class; // used by the JVM
++        static final Class<Integer> CTYPE = int.class; // used by the JVM
  
          Float128Shuffle(int[] indices) {
              super(indices);
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float256Vector.java
index fcb982f2f7c,2543382ca14..f5383fff60a
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float256Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float256Vector.java
@@@ -52,7 -54,7 +54,11 @@@ final class Float256Vector extends Floa
  
      static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
  
--    static final Class<Float> ETYPE = float.class; // used by the JVM
++    static final Class<Float> CTYPE = float.class; // carrier type used by the JVM
++
++    static final Class<Float> ETYPE = float.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
  
      Float256Vector(float[] v) {
          super(v);
@@@ -86,9 -88,9 +92,12 @@@
          return VSPECIES;
      }
  
++    @ForceInline
++    final Class<Float> carrierType() { return CTYPE; }
++
      @ForceInline
      @Override
--    public final Class<Float> elementType() { return float.class; }
++    public final Class<Float> elementType() { return ETYPE; }
  
      @ForceInline
      @Override
@@@ -499,9 -519,10 +526,10 @@@
          return Float.intBitsToFloat(bits);
      }
  
+     @ForceInline
      public int laneHelper(int i) {
          return (int) VectorSupport.extract(
--                     VCLASS, ETYPE, VLENGTH,
++                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                       this, i,
                       (vec, ix) -> {
                       float[] vecarr = vec.vec();
@@@ -525,10 -546,11 +553,11 @@@
          }
      }
  
+     @ForceInline
      public Float256Vector withLaneHelper(int i, float e) {
          return VectorSupport.insert(
--                                VCLASS, ETYPE, VLENGTH,
-                                 this, i, (long)Float.floatToIntBits(e),
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                 this, i, (long)Float.floatToRawIntBits(e),
                                  (v, ix, bits) -> {
                                      float[] res = v.vec().clone();
                                      res[ix] = Float.intBitsToFloat((int)bits);
@@@ -540,7 -562,7 +569,7 @@@
  
      static final class Float256Mask extends AbstractMask<Float> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Float> ETYPE = float.class; // used by the JVM
++        static final Class<Float> CTYPE = float.class; // used by the JVM
  
          Float256Mask(boolean[] bits) {
              this(bits, 0);
@@@ -642,7 -664,7 +671,7 @@@
          /*package-private*/
          Float256Mask indexPartiallyInUpperRange(long offset, long limit) {
              return (Float256Mask) VectorSupport.indexPartiallyInUpperRange(
-                 Float256Mask.class, ETYPE, VLENGTH, offset, limit,
 -                Float256Mask.class, float.class, VLENGTH, offset, limit,
++                Float256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                  (o, l) -> (Float256Mask) TRUE_MASK.indexPartiallyInRange(o, l));
          }
  
@@@ -658,8 -680,8 +687,9 @@@
          @ForceInline
          public Float256Mask compress() {
              return (Float256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
--                Float256Vector.class, Float256Mask.class, ETYPE, VLENGTH, null, this,
--                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
++                Float256Vector.class, Float256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                m1.trueCount()));
          }
  
  
@@@ -670,7 -692,7 +700,7 @@@
          public Float256Mask and(VectorMask<Float> mask) {
              Objects.requireNonNull(mask);
              Float256Mask m = (Float256Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_AND, Float256Mask.class, null, int.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, Float256Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
          }
@@@ -680,7 -702,7 +710,7 @@@
          public Float256Mask or(VectorMask<Float> mask) {
              Objects.requireNonNull(mask);
              Float256Mask m = (Float256Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_OR, Float256Mask.class, null, int.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, Float256Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
          }
@@@ -690,7 -712,7 +720,7 @@@
          public Float256Mask xor(VectorMask<Float> mask) {
              Objects.requireNonNull(mask);
              Float256Mask m = (Float256Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float256Mask.class, null, int.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float256Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
          }
@@@ -700,22 -722,22 +730,25 @@@
          @Override
          @ForceInline
          public int trueCount() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float256Mask.class, int.class, VLENGTH, this,
--                                                      (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float256Mask.class, int.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int firstTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float256Mask.class, int.class, VLENGTH, this,
--                                                      (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float256Mask.class, int.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int lastTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float256Mask.class, int.class, VLENGTH, this,
--                                                      (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float256Mask.class, int.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
          }
  
          @Override
@@@ -724,32 -746,42 +757,43 @@@
              if (length() > Long.SIZE) {
                  throw new UnsupportedOperationException("too many lanes for one long");
              }
--            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Float256Mask.class, int.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Float256Mask.class, int.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
                                                        (m) -> toLongHelper(m.getBits()));
          }
  
+         // laneIsSet
+ 
+         @Override
+         @ForceInline
+         public boolean laneIsSet(int i) {
+             Objects.checkIndex(i, length());
 -            return VectorSupport.extract(Float256Mask.class, float.class, VLENGTH,
++            return VectorSupport.extract(Float256Mask.class, float.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
+         }
+ 
          // Reductions
  
          @Override
          @ForceInline
          public boolean anyTrue() {
--            return VectorSupport.test(BT_ne, Float256Mask.class, int.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> anyTrueHelper(((Float256Mask)m).getBits()));
++            return VectorSupport.test(BT_ne, Float256Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper(((Float256Mask)m).getBits()));
          }
  
          @Override
          @ForceInline
          public boolean allTrue() {
--            return VectorSupport.test(BT_overflow, Float256Mask.class, int.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> allTrueHelper(((Float256Mask)m).getBits()));
++            return VectorSupport.test(BT_overflow, Float256Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper(((Float256Mask)m).getBits()));
          }
  
          @ForceInline
          /*package-private*/
          static Float256Mask maskAll(boolean bit) {
--            return VectorSupport.fromBitsCoerced(Float256Mask.class, int.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced(Float256Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                                   (bit ? -1 : 0), MODE_BROADCAST, null,
                                                   (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
          }
@@@ -762,7 -794,7 +806,7 @@@
  
      static final class Float256Shuffle extends AbstractShuffle<Float> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Integer> ETYPE = int.class; // used by the JVM
++        static final Class<Integer> CTYPE = int.class; // used by the JVM
  
          Float256Shuffle(int[] indices) {
              super(indices);
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float512Vector.java
index 62b594e2c96,627b1e0a237..f491ea350fa
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float512Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float512Vector.java
@@@ -52,7 -54,7 +54,11 @@@ final class Float512Vector extends Floa
  
      static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
  
--    static final Class<Float> ETYPE = float.class; // used by the JVM
++    static final Class<Float> CTYPE = float.class; // carrier type used by the JVM
++
++    static final Class<Float> ETYPE = float.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
  
      Float512Vector(float[] v) {
          super(v);
@@@ -86,9 -88,9 +92,12 @@@
          return VSPECIES;
      }
  
++    @ForceInline
++    final Class<Float> carrierType() { return CTYPE; }
++
      @ForceInline
      @Override
--    public final Class<Float> elementType() { return float.class; }
++    public final Class<Float> elementType() { return ETYPE; }
  
      @ForceInline
      @Override
@@@ -507,9 -527,10 +534,10 @@@
          return Float.intBitsToFloat(bits);
      }
  
+     @ForceInline
      public int laneHelper(int i) {
          return (int) VectorSupport.extract(
--                     VCLASS, ETYPE, VLENGTH,
++                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                       this, i,
                       (vec, ix) -> {
                       float[] vecarr = vec.vec();
@@@ -541,10 -562,11 +569,11 @@@
          }
      }
  
+     @ForceInline
      public Float512Vector withLaneHelper(int i, float e) {
          return VectorSupport.insert(
--                                VCLASS, ETYPE, VLENGTH,
-                                 this, i, (long)Float.floatToIntBits(e),
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                 this, i, (long)Float.floatToRawIntBits(e),
                                  (v, ix, bits) -> {
                                      float[] res = v.vec().clone();
                                      res[ix] = Float.intBitsToFloat((int)bits);
@@@ -556,7 -578,7 +585,7 @@@
  
      static final class Float512Mask extends AbstractMask<Float> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Float> ETYPE = float.class; // used by the JVM
++        static final Class<Float> CTYPE = float.class; // used by the JVM
  
          Float512Mask(boolean[] bits) {
              this(bits, 0);
@@@ -658,7 -680,7 +687,7 @@@
          /*package-private*/
          Float512Mask indexPartiallyInUpperRange(long offset, long limit) {
              return (Float512Mask) VectorSupport.indexPartiallyInUpperRange(
-                 Float512Mask.class, ETYPE, VLENGTH, offset, limit,
 -                Float512Mask.class, float.class, VLENGTH, offset, limit,
++                Float512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                  (o, l) -> (Float512Mask) TRUE_MASK.indexPartiallyInRange(o, l));
          }
  
@@@ -674,8 -696,8 +703,9 @@@
          @ForceInline
          public Float512Mask compress() {
              return (Float512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
--                Float512Vector.class, Float512Mask.class, ETYPE, VLENGTH, null, this,
--                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
++                Float512Vector.class, Float512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                m1.trueCount()));
          }
  
  
@@@ -686,7 -708,7 +716,7 @@@
          public Float512Mask and(VectorMask<Float> mask) {
              Objects.requireNonNull(mask);
              Float512Mask m = (Float512Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_AND, Float512Mask.class, null, int.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, Float512Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
          }
@@@ -696,7 -718,7 +726,7 @@@
          public Float512Mask or(VectorMask<Float> mask) {
              Objects.requireNonNull(mask);
              Float512Mask m = (Float512Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_OR, Float512Mask.class, null, int.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, Float512Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
          }
@@@ -706,7 -728,7 +736,7 @@@
          public Float512Mask xor(VectorMask<Float> mask) {
              Objects.requireNonNull(mask);
              Float512Mask m = (Float512Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float512Mask.class, null, int.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float512Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
          }
@@@ -716,22 -738,22 +746,25 @@@
          @Override
          @ForceInline
          public int trueCount() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float512Mask.class, int.class, VLENGTH, this,
--                                                      (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float512Mask.class, int.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int firstTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float512Mask.class, int.class, VLENGTH, this,
--                                                      (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float512Mask.class, int.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int lastTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float512Mask.class, int.class, VLENGTH, this,
--                                                      (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float512Mask.class, int.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
          }
  
          @Override
@@@ -740,32 -762,42 +773,43 @@@
              if (length() > Long.SIZE) {
                  throw new UnsupportedOperationException("too many lanes for one long");
              }
--            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Float512Mask.class, int.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Float512Mask.class, int.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
                                                        (m) -> toLongHelper(m.getBits()));
          }
  
+         // laneIsSet
+ 
+         @Override
+         @ForceInline
+         public boolean laneIsSet(int i) {
+             Objects.checkIndex(i, length());
 -            return VectorSupport.extract(Float512Mask.class, float.class, VLENGTH,
++            return VectorSupport.extract(Float512Mask.class, float.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
+         }
+ 
          // Reductions
  
          @Override
          @ForceInline
          public boolean anyTrue() {
--            return VectorSupport.test(BT_ne, Float512Mask.class, int.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> anyTrueHelper(((Float512Mask)m).getBits()));
++            return VectorSupport.test(BT_ne, Float512Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper(((Float512Mask)m).getBits()));
          }
  
          @Override
          @ForceInline
          public boolean allTrue() {
--            return VectorSupport.test(BT_overflow, Float512Mask.class, int.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> allTrueHelper(((Float512Mask)m).getBits()));
++            return VectorSupport.test(BT_overflow, Float512Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper(((Float512Mask)m).getBits()));
          }
  
          @ForceInline
          /*package-private*/
          static Float512Mask maskAll(boolean bit) {
--            return VectorSupport.fromBitsCoerced(Float512Mask.class, int.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced(Float512Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                                   (bit ? -1 : 0), MODE_BROADCAST, null,
                                                   (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
          }
@@@ -778,7 -810,7 +822,7 @@@
  
      static final class Float512Shuffle extends AbstractShuffle<Float> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Integer> ETYPE = int.class; // used by the JVM
++        static final Class<Integer> CTYPE = int.class; // used by the JVM
  
          Float512Shuffle(int[] indices) {
              super(indices);
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float64Vector.java
index ecf934df35f,3360fdb537a..6d76e8b7640
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float64Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float64Vector.java
@@@ -52,7 -54,7 +54,11 @@@ final class Float64Vector extends Float
  
      static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
  
--    static final Class<Float> ETYPE = float.class; // used by the JVM
++    static final Class<Float> CTYPE = float.class; // carrier type used by the JVM
++
++    static final Class<Float> ETYPE = float.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
  
      Float64Vector(float[] v) {
          super(v);
@@@ -86,9 -88,9 +92,12 @@@
          return VSPECIES;
      }
  
++    @ForceInline
++    final Class<Float> carrierType() { return CTYPE; }
++
      @ForceInline
      @Override
--    public final Class<Float> elementType() { return float.class; }
++    public final Class<Float> elementType() { return ETYPE; }
  
      @ForceInline
      @Override
@@@ -493,9 -513,10 +520,10 @@@
          return Float.intBitsToFloat(bits);
      }
  
+     @ForceInline
      public int laneHelper(int i) {
          return (int) VectorSupport.extract(
--                     VCLASS, ETYPE, VLENGTH,
++                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                       this, i,
                       (vec, ix) -> {
                       float[] vecarr = vec.vec();
@@@ -513,10 -534,11 +541,11 @@@
          }
      }
  
+     @ForceInline
      public Float64Vector withLaneHelper(int i, float e) {
          return VectorSupport.insert(
--                                VCLASS, ETYPE, VLENGTH,
-                                 this, i, (long)Float.floatToIntBits(e),
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                 this, i, (long)Float.floatToRawIntBits(e),
                                  (v, ix, bits) -> {
                                      float[] res = v.vec().clone();
                                      res[ix] = Float.intBitsToFloat((int)bits);
@@@ -528,7 -550,7 +557,7 @@@
  
      static final class Float64Mask extends AbstractMask<Float> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Float> ETYPE = float.class; // used by the JVM
++        static final Class<Float> CTYPE = float.class; // used by the JVM
  
          Float64Mask(boolean[] bits) {
              this(bits, 0);
@@@ -630,7 -652,7 +659,7 @@@
          /*package-private*/
          Float64Mask indexPartiallyInUpperRange(long offset, long limit) {
              return (Float64Mask) VectorSupport.indexPartiallyInUpperRange(
-                 Float64Mask.class, ETYPE, VLENGTH, offset, limit,
 -                Float64Mask.class, float.class, VLENGTH, offset, limit,
++                Float64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                  (o, l) -> (Float64Mask) TRUE_MASK.indexPartiallyInRange(o, l));
          }
  
@@@ -646,8 -668,8 +675,9 @@@
          @ForceInline
          public Float64Mask compress() {
              return (Float64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
--                Float64Vector.class, Float64Mask.class, ETYPE, VLENGTH, null, this,
--                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
++                Float64Vector.class, Float64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                m1.trueCount()));
          }
  
  
@@@ -658,7 -680,7 +688,7 @@@
          public Float64Mask and(VectorMask<Float> mask) {
              Objects.requireNonNull(mask);
              Float64Mask m = (Float64Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_AND, Float64Mask.class, null, int.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, Float64Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
          }
@@@ -668,7 -690,7 +698,7 @@@
          public Float64Mask or(VectorMask<Float> mask) {
              Objects.requireNonNull(mask);
              Float64Mask m = (Float64Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_OR, Float64Mask.class, null, int.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, Float64Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
          }
@@@ -678,7 -700,7 +708,7 @@@
          public Float64Mask xor(VectorMask<Float> mask) {
              Objects.requireNonNull(mask);
              Float64Mask m = (Float64Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float64Mask.class, null, int.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float64Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
          }
@@@ -688,22 -710,22 +718,25 @@@
          @Override
          @ForceInline
          public int trueCount() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float64Mask.class, int.class, VLENGTH, this,
--                                                      (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float64Mask.class, int.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int firstTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float64Mask.class, int.class, VLENGTH, this,
--                                                      (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float64Mask.class, int.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int lastTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float64Mask.class, int.class, VLENGTH, this,
--                                                      (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float64Mask.class, int.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
          }
  
          @Override
@@@ -712,32 -734,42 +745,43 @@@
              if (length() > Long.SIZE) {
                  throw new UnsupportedOperationException("too many lanes for one long");
              }
--            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Float64Mask.class, int.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Float64Mask.class, int.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
                                                        (m) -> toLongHelper(m.getBits()));
          }
  
+         // laneIsSet
+ 
+         @Override
+         @ForceInline
+         public boolean laneIsSet(int i) {
+             Objects.checkIndex(i, length());
 -            return VectorSupport.extract(Float64Mask.class, float.class, VLENGTH,
++            return VectorSupport.extract(Float64Mask.class, float.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
+         }
+ 
          // Reductions
  
          @Override
          @ForceInline
          public boolean anyTrue() {
--            return VectorSupport.test(BT_ne, Float64Mask.class, int.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> anyTrueHelper(((Float64Mask)m).getBits()));
++            return VectorSupport.test(BT_ne, Float64Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper(((Float64Mask)m).getBits()));
          }
  
          @Override
          @ForceInline
          public boolean allTrue() {
--            return VectorSupport.test(BT_overflow, Float64Mask.class, int.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> allTrueHelper(((Float64Mask)m).getBits()));
++            return VectorSupport.test(BT_overflow, Float64Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper(((Float64Mask)m).getBits()));
          }
  
          @ForceInline
          /*package-private*/
          static Float64Mask maskAll(boolean bit) {
--            return VectorSupport.fromBitsCoerced(Float64Mask.class, int.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced(Float64Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                                   (bit ? -1 : 0), MODE_BROADCAST, null,
                                                   (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
          }
@@@ -750,7 -782,7 +794,7 @@@
  
      static final class Float64Shuffle extends AbstractShuffle<Float> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Integer> ETYPE = int.class; // used by the JVM
++        static final Class<Integer> CTYPE = int.class; // used by the JVM
  
          Float64Shuffle(int[] indices) {
              super(indices);
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/FloatMaxVector.java
index a63ad3eb0d5,4a72661ce8b..dd1ae255054
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/FloatMaxVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/FloatMaxVector.java
@@@ -52,7 -54,7 +54,11 @@@ final class FloatMaxVector extends Floa
  
      static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
  
--    static final Class<Float> ETYPE = float.class; // used by the JVM
++    static final Class<Float> CTYPE = float.class; // carrier type used by the JVM
++
++    static final Class<Float> ETYPE = float.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
  
      FloatMaxVector(float[] v) {
          super(v);
@@@ -86,9 -88,9 +92,12 @@@
          return VSPECIES;
      }
  
++    @ForceInline
++    final Class<Float> carrierType() { return CTYPE; }
++
      @ForceInline
      @Override
--    public final Class<Float> elementType() { return float.class; }
++    public final Class<Float> elementType() { return ETYPE; }
  
      @ForceInline
      @Override
@@@ -491,9 -511,10 +518,10 @@@
          return Float.intBitsToFloat(bits);
      }
  
+     @ForceInline
      public int laneHelper(int i) {
          return (int) VectorSupport.extract(
--                     VCLASS, ETYPE, VLENGTH,
++                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                       this, i,
                       (vec, ix) -> {
                       float[] vecarr = vec.vec();
@@@ -510,10 -531,11 +538,11 @@@
          return withLaneHelper(i, e);
      }
  
+     @ForceInline
      public FloatMaxVector withLaneHelper(int i, float e) {
          return VectorSupport.insert(
--                                VCLASS, ETYPE, VLENGTH,
-                                 this, i, (long)Float.floatToIntBits(e),
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                 this, i, (long)Float.floatToRawIntBits(e),
                                  (v, ix, bits) -> {
                                      float[] res = v.vec().clone();
                                      res[ix] = Float.intBitsToFloat((int)bits);
@@@ -525,7 -547,7 +554,7 @@@
  
      static final class FloatMaxMask extends AbstractMask<Float> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Float> ETYPE = float.class; // used by the JVM
++        static final Class<Float> CTYPE = float.class; // used by the JVM
  
          FloatMaxMask(boolean[] bits) {
              this(bits, 0);
@@@ -627,7 -649,7 +656,7 @@@
          /*package-private*/
          FloatMaxMask indexPartiallyInUpperRange(long offset, long limit) {
              return (FloatMaxMask) VectorSupport.indexPartiallyInUpperRange(
-                 FloatMaxMask.class, ETYPE, VLENGTH, offset, limit,
 -                FloatMaxMask.class, float.class, VLENGTH, offset, limit,
++                FloatMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                  (o, l) -> (FloatMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));
          }
  
@@@ -643,8 -665,8 +672,9 @@@
          @ForceInline
          public FloatMaxMask compress() {
              return (FloatMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
--                FloatMaxVector.class, FloatMaxMask.class, ETYPE, VLENGTH, null, this,
--                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
++                FloatMaxVector.class, FloatMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                m1.trueCount()));
          }
  
  
@@@ -655,7 -677,7 +685,7 @@@
          public FloatMaxMask and(VectorMask<Float> mask) {
              Objects.requireNonNull(mask);
              FloatMaxMask m = (FloatMaxMask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_AND, FloatMaxMask.class, null, int.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, FloatMaxMask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
          }
@@@ -665,7 -687,7 +695,7 @@@
          public FloatMaxMask or(VectorMask<Float> mask) {
              Objects.requireNonNull(mask);
              FloatMaxMask m = (FloatMaxMask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_OR, FloatMaxMask.class, null, int.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, FloatMaxMask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
          }
@@@ -675,7 -697,7 +705,7 @@@
          public FloatMaxMask xor(VectorMask<Float> mask) {
              Objects.requireNonNull(mask);
              FloatMaxMask m = (FloatMaxMask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_XOR, FloatMaxMask.class, null, int.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, FloatMaxMask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
          }
@@@ -685,22 -707,22 +715,25 @@@
          @Override
          @ForceInline
          public int trueCount() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, FloatMaxMask.class, int.class, VLENGTH, this,
--                                                      (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, FloatMaxMask.class, int.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int firstTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, FloatMaxMask.class, int.class, VLENGTH, this,
--                                                      (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, FloatMaxMask.class, int.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int lastTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, FloatMaxMask.class, int.class, VLENGTH, this,
--                                                      (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, FloatMaxMask.class, int.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
          }
  
          @Override
@@@ -709,32 -731,42 +742,43 @@@
              if (length() > Long.SIZE) {
                  throw new UnsupportedOperationException("too many lanes for one long");
              }
--            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, FloatMaxMask.class, int.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, FloatMaxMask.class, int.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
                                                        (m) -> toLongHelper(m.getBits()));
          }
  
+         // laneIsSet
+ 
+         @Override
+         @ForceInline
+         public boolean laneIsSet(int i) {
+             Objects.checkIndex(i, length());
 -            return VectorSupport.extract(FloatMaxMask.class, float.class, VLENGTH,
++            return VectorSupport.extract(FloatMaxMask.class, float.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
+         }
+ 
          // Reductions
  
          @Override
          @ForceInline
          public boolean anyTrue() {
--            return VectorSupport.test(BT_ne, FloatMaxMask.class, int.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> anyTrueHelper(((FloatMaxMask)m).getBits()));
++            return VectorSupport.test(BT_ne, FloatMaxMask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper(((FloatMaxMask)m).getBits()));
          }
  
          @Override
          @ForceInline
          public boolean allTrue() {
--            return VectorSupport.test(BT_overflow, FloatMaxMask.class, int.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> allTrueHelper(((FloatMaxMask)m).getBits()));
++            return VectorSupport.test(BT_overflow, FloatMaxMask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper(((FloatMaxMask)m).getBits()));
          }
  
          @ForceInline
          /*package-private*/
          static FloatMaxMask maskAll(boolean bit) {
--            return VectorSupport.fromBitsCoerced(FloatMaxMask.class, int.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced(FloatMaxMask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                                   (bit ? -1 : 0), MODE_BROADCAST, null,
                                                   (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
          }
@@@ -747,7 -779,7 +791,7 @@@
  
      static final class FloatMaxShuffle extends AbstractShuffle<Float> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Integer> ETYPE = int.class; // used by the JVM
++        static final Class<Integer> CTYPE = int.class; // used by the JVM
  
          FloatMaxShuffle(int[] indices) {
              super(indices);
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/FloatVector.java
index e86523870ad,b481d5a51d7..be7abaac806
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/FloatVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/FloatVector.java
@@@ -57,7 -57,7 +57,9 @@@ public abstract class FloatVector exten
  
      static final int FORBID_OPCODE_KIND = VO_NOFP;
  
-     static final ValueLayout.OfFloat ELEMENT_LAYOUT = ValueLayout.JAVA_FLOAT.withBitAlignment(8);
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
++
+     static final ValueLayout.OfFloat ELEMENT_LAYOUT = ValueLayout.JAVA_FLOAT.withByteAlignment(1);
  
      @ForceInline
      static int opCode(Operator op) {
@@@ -549,7 -562,7 +564,7 @@@
      @ForceInline
      public static FloatVector zero(VectorSpecies<Float> species) {
          FloatSpecies vsp = (FloatSpecies) species;
--        return VectorSupport.fromBitsCoerced(vsp.vectorType(), float.class, species.length(),
++        return VectorSupport.fromBitsCoerced(vsp.vectorType(), float.class, float.class, VECTOR_OPER_TYPE, species.length(),
                          toBits(0.0f), MODE_BROADCAST, vsp,
                          ((bits_, s_) -> s_.rvOp(i -> bits_)));
      }
@@@ -668,7 -684,7 +686,7 @@@
          }
          int opc = opCode(op);
          return VectorSupport.unaryOp(
--            opc, getClass(), null, float.class, length(),
++            opc, getClass(), null, float.class, float.class, VECTOR_OPER_TYPE, length(),
              this, null,
              UN_IMPL.find(op, opc, FloatVector::unaryOperations));
      }
@@@ -693,7 -712,7 +714,7 @@@
          }
          int opc = opCode(op);
          return VectorSupport.unaryOp(
--            opc, getClass(), maskClass, float.class, length(),
++            opc, getClass(), maskClass, float.class, float.class, VECTOR_OPER_TYPE, length(),
              this, m,
              UN_IMPL.find(op, opc, FloatVector::unaryOperations));
      }
@@@ -772,7 -801,7 +803,7 @@@
  
          int opc = opCode(op);
          return VectorSupport.binaryOp(
--            opc, getClass(), null, float.class, length(),
++            opc, getClass(), null, float.class, float.class, VECTOR_OPER_TYPE, length(),
              this, that, null,
              BIN_IMPL.find(op, opc, FloatVector::binaryOperations));
      }
@@@ -806,7 -839,7 +841,7 @@@
  
          int opc = opCode(op);
          return VectorSupport.binaryOp(
--            opc, getClass(), maskClass, float.class, length(),
++            opc, getClass(), maskClass, float.class, float.class, VECTOR_OPER_TYPE, length(),
              this, that, m,
              BIN_IMPL.find(op, opc, FloatVector::binaryOperations));
      }
@@@ -981,7 -1021,7 +1023,7 @@@
          tother.check(this);
          int opc = opCode(op);
          return VectorSupport.ternaryOp(
--            opc, getClass(), null, float.class, length(),
++            opc, getClass(), null, float.class, float.class, VECTOR_OPER_TYPE, length(),
              this, that, tother, null,
              TERN_IMPL.find(op, opc, FloatVector::ternaryOperations));
      }
@@@ -1016,7 -1056,7 +1058,7 @@@
  
          int opc = opCode(op);
          return VectorSupport.ternaryOp(
--            opc, getClass(), maskClass, float.class, length(),
++            opc, getClass(), maskClass, float.class, float.class, VECTOR_OPER_TYPE, length(),
              this, that, tother, m,
              TERN_IMPL.find(op, opc, FloatVector::ternaryOperations));
      }
@@@ -1900,7 -1940,7 +1942,7 @@@
          that.check(this);
          int opc = opCode(op);
          return VectorSupport.compare(
--            opc, getClass(), maskType, float.class, length(),
++            opc, getClass(), maskType, float.class, float.class, VECTOR_OPER_TYPE, length(),
              this, that, null,
              (cond, v0, v1, m1) -> {
                  AbstractMask<Float> m
@@@ -1922,7 -1962,7 +1964,7 @@@
          m.check(maskType, this);
          int opc = opCode(op);
          return VectorSupport.compare(
--            opc, getClass(), maskType, float.class, length(),
++            opc, getClass(), maskType, float.class, float.class, VECTOR_OPER_TYPE, length(),
              this, that, m,
              (cond, v0, v1, m1) -> {
                  AbstractMask<Float> cmpM
@@@ -2049,7 -2089,7 +2091,7 @@@
      blendTemplate(Class<M> maskType, FloatVector v, M m) {
          v.check(this);
          return VectorSupport.blend(
--            getClass(), maskType, float.class, length(),
++            getClass(), maskType, float.class, float.class, VECTOR_OPER_TYPE, length(),
              this, v, m,
              (v0, v1, m_) -> v0.bOp(v1, m_, (i, a, b) -> b));
      }
@@@ -2066,7 -2106,7 +2108,7 @@@
          // make sure VLENGTH*scale doesn't overflow:
          vsp.checkScale(scale);
          return VectorSupport.indexVector(
--            getClass(), float.class, length(),
++            getClass(), float.class, float.class, VECTOR_OPER_TYPE, length(),
              this, scale, vsp,
              (v, scale_, s)
              -> {
@@@ -2254,12 -2296,12 +2298,12 @@@
      final
      <S extends VectorShuffle<Float>>
      FloatVector rearrangeTemplate(Class<S> shuffletype, S shuffle) {
-         shuffle.checkIndexes();
+         Objects.requireNonNull(shuffle);
          return VectorSupport.rearrangeOp(
--            getClass(), shuffletype, null, float.class, length(),
++            getClass(), shuffletype, null, float.class, float.class, VECTOR_OPER_TYPE, length(),
              this, shuffle, null,
              (v1, s_, m_) -> v1.uOp((i, a) -> {
-                 int ei = s_.laneSource(i);
+                 int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
                  return v1.lane(ei);
              }));
      }
@@@ -2280,19 -2322,14 +2324,14 @@@
                                             Class<M> masktype,
                                             S shuffle,
                                             M m) {
- 
+         Objects.requireNonNull(shuffle);
          m.check(masktype, this);
-         VectorMask<Float> valid = shuffle.laneIsValid();
-         if (m.andNot(valid).anyTrue()) {
-             shuffle.checkIndexes();
-             throw new AssertionError();
-         }
          return VectorSupport.rearrangeOp(
--                   getClass(), shuffletype, masktype, float.class, length(),
++                   getClass(), shuffletype, masktype, float.class, float.class, VECTOR_OPER_TYPE, length(),
                     this, shuffle, m,
                     (v1, s_, m_) -> v1.uOp((i, a) -> {
-                         int ei = s_.laneSource(i);
-                         return ei < 0  || !m_.laneIsSet(i) ? 0 : v1.lane(ei);
+                         int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
+                         return !m_.laneIsSet(i) ? 0 : v1.lane(ei);
                     }));
      }
  
@@@ -2312,22 -2349,20 +2351,20 @@@
                                             S shuffle,
                                             FloatVector v) {
          VectorMask<Float> valid = shuffle.laneIsValid();
-         @SuppressWarnings("unchecked")
-         S ws = (S) shuffle.wrapIndexes();
          FloatVector r0 =
              VectorSupport.rearrangeOp(
--                getClass(), shuffletype, null, float.class, length(),
-                 this, ws, null,
++                getClass(), shuffletype, null, float.class, float.class, VECTOR_OPER_TYPE, length(),
+                 this, shuffle, null,
                  (v0, s_, m_) -> v0.uOp((i, a) -> {
-                     int ei = s_.laneSource(i);
+                     int ei = Integer.remainderUnsigned(s_.laneSource(i), v0.length());
                      return v0.lane(ei);
                  }));
          FloatVector r1 =
              VectorSupport.rearrangeOp(
--                getClass(), shuffletype, null, float.class, length(),
-                 v, ws, null,
++                getClass(), shuffletype, null, float.class, float.class, VECTOR_OPER_TYPE, length(),
+                 v, shuffle, null,
                  (v1, s_, m_) -> v1.uOp((i, a) -> {
-                     int ei = s_.laneSource(i);
+                     int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
                      return v1.lane(ei);
                  }));
          return r1.blend(r0, valid);
@@@ -2359,7 -2403,7 +2405,7 @@@
      FloatVector compressTemplate(Class<M> masktype, M m) {
        m.check(masktype, this);
        return (FloatVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,
--                                                        float.class, length(), this, m,
++                                                        float.class, float.class, VECTOR_OPER_TYPE, length(), this, m,
                                                          (v1, m1) -> compressHelper(v1, m1));
      }
  
@@@ -2378,7 -2422,7 +2424,7 @@@
      FloatVector expandTemplate(Class<M> masktype, M m) {
        m.check(masktype, this);
        return (FloatVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,
--                                                        float.class, length(), this, m,
++                                                        float.class, float.class, VECTOR_OPER_TYPE, length(), this, m,
                                                          (v1, m1) -> expandHelper(v1, m1));
      }
  
@@@ -2393,7 -2437,10 +2439,10 @@@
      /*package-private*/
      @ForceInline
      final FloatVector selectFromTemplate(FloatVector v) {
-         return v.rearrange(this.toShuffle());
 -        return (FloatVector)VectorSupport.selectFromOp(getClass(), null, float.class,
++        return (FloatVector)VectorSupport.selectFromOp(getClass(), null, float.class, float.class, VECTOR_OPER_TYPE,
+                                                         length(), this, v, null,
+                                                         (v1, v2, _m) ->
+                                                          v2.rearrange(v1.toShuffle()));
      }
  
      /**
@@@ -2405,9 -2452,31 +2454,31 @@@
  
      /*package-private*/
      @ForceInline
-     final FloatVector selectFromTemplate(FloatVector v,
-                                                   AbstractMask<Float> m) {
-         return v.rearrange(this.toShuffle(), m);
+     final
+     <M extends VectorMask<Float>>
+     FloatVector selectFromTemplate(FloatVector v,
+                                             Class<M> masktype, M m) {
+         m.check(masktype, this);
 -        return (FloatVector)VectorSupport.selectFromOp(getClass(), masktype, float.class,
++        return (FloatVector)VectorSupport.selectFromOp(getClass(), masktype, float.class, float.class, VECTOR_OPER_TYPE,
+                                                         length(), this, v, m,
+                                                         (v1, v2, _m) ->
+                                                          v2.rearrange(v1.toShuffle(), _m));
+     }
+ 
+ 
+     /**
+      * {@inheritDoc} <!--workaround-->
+      */
+     @Override
+     public abstract
+     FloatVector selectFrom(Vector<Float> v1, Vector<Float> v2);
+ 
+ 
+     /*package-private*/
+     @ForceInline
+     final FloatVector selectFromTemplate(FloatVector v1, FloatVector v2) {
 -        return VectorSupport.selectFromTwoVectorOp(getClass(), float.class, length(), this, v1, v2,
++        return VectorSupport.selectFromTwoVectorOp(getClass(), float.class, float.class, VECTOR_OPER_TYPE, length(), this, v1, v2,
+                                                    (vec1, vec2, vec3) -> selectFromTwoVectorHelper(vec1, vec2, vec3));
      }
  
      /// Ternary operations
@@@ -2612,7 -2681,7 +2683,7 @@@
          }
          int opc = opCode(op);
          return fromBits(VectorSupport.reductionCoerced(
--            opc, getClass(), maskClass, float.class, length(),
++            opc, getClass(), maskClass, float.class, float.class, VECTOR_OPER_TYPE, length(),
              this, m,
              REDUCE_IMPL.find(op, opc, FloatVector::reductionOperations)));
      }
@@@ -2630,7 -2699,7 +2701,7 @@@
          }
          int opc = opCode(op);
          return fromBits(VectorSupport.reductionCoerced(
--            opc, getClass(), null, float.class, length(),
++            opc, getClass(), null, float.class, float.class, VECTOR_OPER_TYPE, length(),
              this, null,
              REDUCE_IMPL.find(op, opc, FloatVector::reductionOperations)));
      }
@@@ -2872,9 -2942,9 +2944,9 @@@
          vix = VectorIntrinsics.checkIndex(vix, a.length);
  
          return VectorSupport.loadWithMap(
--            vectorType, null, float.class, vsp.laneCount(),
-             isp.vectorType(),
-             a, ARRAY_BASE, vix, null,
++            vectorType, null, float.class, float.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+             isp.vectorType(), isp.length(),
+             a, ARRAY_BASE, vix, null, null, null, null,
              a, offset, indexMap, mapOffset, vsp,
              (c, idx, iMap, idy, s, vm) ->
              s.vOp(n -> c[idx + iMap[idy+n]]));
@@@ -3058,8 -3125,8 +3127,8 @@@
          offset = checkFromIndexSize(offset, length(), a.length);
          FloatSpecies vsp = vspecies();
          VectorSupport.store(
--            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset),
++            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, arrayAddress(a, offset), false,
              this,
              a, offset,
              (arr, off, v)
@@@ -3146,8 -3214,8 +3216,8 @@@
          vix = VectorIntrinsics.checkIndex(vix, a.length);
  
          VectorSupport.storeWithMap(
--            vsp.vectorType(), null, vsp.elementType(), vsp.laneCount(),
-             isp.vectorType(),
++            vsp.vectorType(), null, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             isp.vectorType(), isp.length(),
              a, arrayAddress(a, 0), vix,
              this, null,
              a, offset, indexMap, mapOffset,
@@@ -3272,8 -3341,8 +3343,8 @@@
      FloatVector fromArray0Template(float[] a, int offset) {
          FloatSpecies vsp = vspecies();
          return VectorSupport.load(
--            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset),
++            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, arrayAddress(a, offset), false,
              a, offset, vsp,
              (arr, off, s) -> s.ldOp(arr, (int) off,
                                      (arr_, off_, i) -> arr_[off_ + i]));
@@@ -3289,8 -3358,8 +3360,8 @@@
          m.check(species());
          FloatSpecies vsp = vspecies();
          return VectorSupport.loadMasked(
--            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset), m, offsetInRange,
++            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, arrayAddress(a, offset), false, m, offsetInRange,
              a, offset, vsp,
              (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,
                                          (arr_, off_, i) -> arr_[off_ + i]));
@@@ -3322,9 -3391,9 +3393,9 @@@
          vix = VectorIntrinsics.checkIndex(vix, a.length);
  
          return VectorSupport.loadWithMap(
--            vectorType, maskClass, float.class, vsp.laneCount(),
-             isp.vectorType(),
-             a, ARRAY_BASE, vix, m,
++            vectorType, maskClass, float.class, float.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+             isp.vectorType(), isp.length(),
+             a, ARRAY_BASE, vix, null, null, null, m,
              a, offset, indexMap, mapOffset, vsp,
              (c, idx, iMap, idy, s, vm) ->
              s.vOp(vm, n -> c[idx + iMap[idy+n]]));
@@@ -3339,7 -3408,7 +3410,7 @@@
      FloatVector fromMemorySegment0Template(MemorySegment ms, long offset) {
          FloatSpecies vsp = vspecies();
          return ScopedMemoryAccess.loadFromMemorySegment(
--                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
++                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                  (AbstractMemorySegmentImpl) ms, offset, vsp,
                  (msp, off, s) -> {
                      return s.ldLongOp((MemorySegment) msp, off, FloatVector::memorySegmentGet);
@@@ -3355,7 -3424,7 +3426,7 @@@
          FloatSpecies vsp = vspecies();
          m.check(vsp);
          return ScopedMemoryAccess.loadFromMemorySegmentMasked(
--                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
++                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                  (AbstractMemorySegmentImpl) ms, offset, m, vsp, offsetInRange,
                  (msp, off, s, vm) -> {
                      return s.ldLongOp((MemorySegment) msp, off, vm, FloatVector::memorySegmentGet);
@@@ -3373,8 -3442,8 +3444,8 @@@
      void intoArray0Template(float[] a, int offset) {
          FloatSpecies vsp = vspecies();
          VectorSupport.store(
--            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset),
++            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, arrayAddress(a, offset), false,
              this, a, offset,
              (arr, off, v)
              -> v.stOp(arr, (int) off,
@@@ -3390,8 -3459,8 +3461,8 @@@
          m.check(species());
          FloatSpecies vsp = vspecies();
          VectorSupport.storeMasked(
--            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset),
++            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, arrayAddress(a, offset), false,
              this, m, a, offset,
              (arr, off, v, vm)
              -> v.stOp(arr, (int) off, vm,
@@@ -3419,8 -3488,8 +3490,8 @@@
          vix = VectorIntrinsics.checkIndex(vix, a.length);
  
          VectorSupport.storeWithMap(
--            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
-             isp.vectorType(),
++            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             isp.vectorType(), isp.length(),
              a, arrayAddress(a, 0), vix,
              this, m,
              a, offset, indexMap, mapOffset,
@@@ -3438,7 -3507,7 +3509,7 @@@
      void intoMemorySegment0(MemorySegment ms, long offset) {
          FloatSpecies vsp = vspecies();
          ScopedMemoryAccess.storeIntoMemorySegment(
--                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
++                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                  this,
                  (AbstractMemorySegmentImpl) ms, offset,
                  (msp, off, v) -> {
@@@ -3455,7 -3524,7 +3526,7 @@@
          FloatSpecies vsp = vspecies();
          m.check(vsp);
          ScopedMemoryAccess.storeIntoMemorySegmentMasked(
--                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
++                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                  this, m,
                  (AbstractMemorySegmentImpl) ms, offset,
                  (msp, off, v, vm) -> {
@@@ -3647,6 -3696,6 +3698,19 @@@
  
          // Specializing overrides:
  
++        @ForceInline
++        final Class<?> carrierType() {
++            return float.class;
++        }
++
++        @ForceInline
++        final int operType() {
++            if (float.class.equals(Float16.class)) {
++                return VECTOR_TYPE_FP16;
++            }
++            return VECTOR_TYPE_PRIM;
++        }
++
          @Override
          @ForceInline
          public final Class<Float> elementType() {
@@@ -3679,7 -3728,7 +3743,7 @@@
          final FloatVector broadcastBits(long bits) {
              return (FloatVector)
                  VectorSupport.fromBitsCoerced(
--                    vectorType, float.class, laneCount,
++                    vectorType, float.class, float.class, VECTOR_OPER_TYPE, laneCount,
                      bits, MODE_BROADCAST, this,
                      (bits_, s_) -> s_.rvOp(i -> bits_));
          }
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Halffloat128Vector.java
index 4cba74bea9a,00000000000..45f851a11e7
mode 100644,000000..100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Halffloat128Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Halffloat128Vector.java
@@@ -1,951 -1,0 +1,1042 @@@
 +/*
-  * Copyright (c) 2017, 2023, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
 + * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 + *
 + * This code is free software; you can redistribute it and/or modify it
 + * under the terms of the GNU General Public License version 2 only, as
 + * published by the Free Software Foundation.  Oracle designates this
 + * particular file as subject to the "Classpath" exception as provided
 + * by Oracle in the LICENSE file that accompanied this code.
 + *
 + * This code is distributed in the hope that it will be useful, but WITHOUT
 + * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 + * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 + * version 2 for more details (a copy is included in the LICENSE file that
 + * accompanied this code).
 + *
 + * You should have received a copy of the GNU General Public License version
 + * 2 along with this work; if not, write to the Free Software Foundation,
 + * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 + *
 + * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 + * or visit www.oracle.com if you need additional information or have any
 + * questions.
 + */
 +package jdk.incubator.vector;
 +
 +import java.lang.foreign.MemorySegment;
++import java.lang.foreign.ValueLayout;
++import java.nio.ByteOrder;
 +import java.util.Arrays;
 +import java.util.Objects;
 +import java.util.function.IntUnaryOperator;
 +
 +import jdk.internal.vm.annotation.ForceInline;
 +import jdk.internal.vm.vector.VectorSupport;
 +
 +import static jdk.internal.vm.vector.VectorSupport.*;
 +
 +import static jdk.incubator.vector.VectorOperators.*;
 +
 +// -- This file was mechanically generated: Do not edit! -- //
 +
 +@SuppressWarnings("cast")  // warning: redundant cast
 +final class Halffloat128Vector extends HalffloatVector {
 +    static final HalffloatSpecies VSPECIES =
 +        (HalffloatSpecies) HalffloatVector.SPECIES_128;
 +
 +    static final VectorShape VSHAPE =
 +        VSPECIES.vectorShape();
 +
 +    static final Class<Halffloat128Vector> VCLASS = Halffloat128Vector.class;
 +
 +    static final int VSIZE = VSPECIES.vectorBitSize();
 +
 +    static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
 +
-     static final Class<Halffloat> ETYPE = Halffloat.class; // used by the JVM
++    static final Class<Short> CTYPE = short.class; // carrier type used by the JVM
++
++    static final Class<Float16> ETYPE = Float16.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_FP16;
 +
 +    Halffloat128Vector(short[] v) {
 +        super(v);
 +    }
 +
 +    // For compatibility as Halffloat128Vector::new,
 +    // stored into species.vectorFactory.
 +    Halffloat128Vector(Object v) {
 +        this((short[]) v);
 +    }
 +
 +    static final Halffloat128Vector ZERO = new Halffloat128Vector(new short[VLENGTH]);
 +    static final Halffloat128Vector IOTA = new Halffloat128Vector(VSPECIES.iotaArray());
 +
 +    static {
 +        // Warm up a few species caches.
 +        // If we do this too much we will
 +        // get NPEs from bootstrap circularity.
 +        VSPECIES.dummyVector();
 +        VSPECIES.withLanes(LaneType.BYTE);
 +    }
 +
 +    // Specialized extractors
 +
 +    @ForceInline
 +    final @Override
 +    public HalffloatSpecies vspecies() {
 +        // ISSUE:  This should probably be a @Stable
 +        // field inside AbstractVector, rather than
 +        // a megamorphic method.
 +        return VSPECIES;
 +    }
 +
++    @ForceInline
++    final Class<Short> carrierType() { return CTYPE; }
++
 +    @ForceInline
 +    @Override
-     public final Class<Halffloat> elementType() { return Halffloat.class; }
++    public final Class<Float16> elementType() { return ETYPE; }
 +
 +    @ForceInline
 +    @Override
-     public final int elementSize() { return Halffloat.SIZE; }
++    public final int elementSize() { return Float16.SIZE; }
 +
 +    @ForceInline
 +    @Override
 +    public final VectorShape shape() { return VSHAPE; }
 +
 +    @ForceInline
 +    @Override
 +    public final int length() { return VLENGTH; }
 +
 +    @ForceInline
 +    @Override
 +    public final int bitSize() { return VSIZE; }
 +
 +    @ForceInline
 +    @Override
 +    public final int byteSize() { return VSIZE / Byte.SIZE; }
 +
 +    /*package-private*/
 +    @ForceInline
 +    final @Override
 +    short[] vec() {
 +        return (short[])getPayload();
 +    }
 +
 +    // Virtualized constructors
 +
 +    @Override
 +    @ForceInline
 +    public final Halffloat128Vector broadcast(short e) {
 +        return (Halffloat128Vector) super.broadcastTemplate(e);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final Halffloat128Vector broadcast(long e) {
 +        return (Halffloat128Vector) super.broadcastTemplate(e);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    Halffloat128Mask maskFromArray(boolean[] bits) {
 +        return new Halffloat128Mask(bits);
 +    }
 +
 +    @Override
 +    @ForceInline
 +    Halffloat128Shuffle iotaShuffle() { return Halffloat128Shuffle.IOTA; }
 +
++    @Override
++    @ForceInline
++    Halffloat128Shuffle iotaShuffle(int start, int step, boolean wrap) {
++        return (Halffloat128Shuffle) iotaShuffleTemplate((short) start, (short) step, wrap);
++    }
++
 +    @Override
 +    @ForceInline
 +    Halffloat128Shuffle shuffleFromArray(int[] indices, int i) { return new Halffloat128Shuffle(indices, i); }
 +
 +    @Override
 +    @ForceInline
 +    Halffloat128Shuffle shuffleFromOp(IntUnaryOperator fn) { return new Halffloat128Shuffle(fn); }
 +
 +    // Make a vector of the same species but the given elements:
 +    @ForceInline
 +    final @Override
 +    Halffloat128Vector vectorFactory(short[] vec) {
 +        return new Halffloat128Vector(vec);
 +    }
 +
 +    @ForceInline
 +    final @Override
 +    Byte128Vector asByteVectorRaw() {
 +        return (Byte128Vector) super.asByteVectorRawTemplate();  // specialize
 +    }
 +
 +    @ForceInline
 +    final @Override
 +    AbstractVector<?> asVectorRaw(LaneType laneType) {
 +        return super.asVectorRawTemplate(laneType);  // specialize
 +    }
 +
 +    // Unary operator
 +
 +    @ForceInline
 +    final @Override
 +    Halffloat128Vector uOp(FUnOp f) {
 +        return (Halffloat128Vector) super.uOpTemplate(f);  // specialize
 +    }
 +
 +    @ForceInline
 +    final @Override
-     Halffloat128Vector uOp(VectorMask<Halffloat> m, FUnOp f) {
++    Halffloat128Vector uOp(VectorMask<Float16> m, FUnOp f) {
 +        return (Halffloat128Vector)
 +            super.uOpTemplate((Halffloat128Mask)m, f);  // specialize
 +    }
 +
 +    // Binary operator
 +
 +    @ForceInline
 +    final @Override
-     Halffloat128Vector bOp(Vector<Halffloat> v, FBinOp f) {
++    Halffloat128Vector bOp(Vector<Float16> v, FBinOp f) {
 +        return (Halffloat128Vector) super.bOpTemplate((Halffloat128Vector)v, f);  // specialize
 +    }
 +
 +    @ForceInline
 +    final @Override
-     Halffloat128Vector bOp(Vector<Halffloat> v,
-                      VectorMask<Halffloat> m, FBinOp f) {
++    Halffloat128Vector bOp(Vector<Float16> v,
++                     VectorMask<Float16> m, FBinOp f) {
 +        return (Halffloat128Vector)
 +            super.bOpTemplate((Halffloat128Vector)v, (Halffloat128Mask)m,
 +                              f);  // specialize
 +    }
 +
 +    // Ternary operator
 +
 +    @ForceInline
 +    final @Override
-     Halffloat128Vector tOp(Vector<Halffloat> v1, Vector<Halffloat> v2, FTriOp f) {
++    Halffloat128Vector tOp(Vector<Float16> v1, Vector<Float16> v2, FTriOp f) {
 +        return (Halffloat128Vector)
 +            super.tOpTemplate((Halffloat128Vector)v1, (Halffloat128Vector)v2,
 +                              f);  // specialize
 +    }
 +
 +    @ForceInline
 +    final @Override
-     Halffloat128Vector tOp(Vector<Halffloat> v1, Vector<Halffloat> v2,
-                      VectorMask<Halffloat> m, FTriOp f) {
++    Halffloat128Vector tOp(Vector<Float16> v1, Vector<Float16> v2,
++                     VectorMask<Float16> m, FTriOp f) {
 +        return (Halffloat128Vector)
 +            super.tOpTemplate((Halffloat128Vector)v1, (Halffloat128Vector)v2,
 +                              (Halffloat128Mask)m, f);  // specialize
 +    }
 +
 +    @ForceInline
 +    final @Override
-     short rOp(short v, VectorMask<Halffloat> m, FBinOp f) {
++    short rOp(short v, VectorMask<Float16> m, FBinOp f) {
 +        return super.rOpTemplate(v, m, f);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final <F>
-     Vector<F> convertShape(VectorOperators.Conversion<Halffloat,F> conv,
++    Vector<F> convertShape(VectorOperators.Conversion<Float16,F> conv,
 +                           VectorSpecies<F> rsp, int part) {
 +        return super.convertShapeTemplate(conv, rsp, part);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final <F>
 +    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {
 +        return super.reinterpretShapeTemplate(toSpecies, part);  // specialize
 +    }
 +
 +    // Specialized algebraic operations:
 +
 +    // The following definition forces a specialized version of this
 +    // crucial method into the v-table of this class.  A call to add()
 +    // will inline to a call to lanewise(ADD,), at which point the JIT
 +    // intrinsic will have the opcode of ADD, plus all the metadata
 +    // for this particular class, enabling it to generate precise
 +    // code.
 +    //
 +    // There is probably no benefit to the JIT to specialize the
 +    // masked or broadcast versions of the lanewise method.
 +
 +    @Override
 +    @ForceInline
 +    public Halffloat128Vector lanewise(Unary op) {
 +        return (Halffloat128Vector) super.lanewiseTemplate(op);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat128Vector lanewise(Unary op, VectorMask<Halffloat> m) {
++    public Halffloat128Vector lanewise(Unary op, VectorMask<Float16> m) {
 +        return (Halffloat128Vector) super.lanewiseTemplate(op, Halffloat128Mask.class, (Halffloat128Mask) m);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat128Vector lanewise(Binary op, Vector<Halffloat> v) {
++    public Halffloat128Vector lanewise(Binary op, Vector<Float16> v) {
 +        return (Halffloat128Vector) super.lanewiseTemplate(op, v);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat128Vector lanewise(Binary op, Vector<Halffloat> v, VectorMask<Halffloat> m) {
++    public Halffloat128Vector lanewise(Binary op, Vector<Float16> v, VectorMask<Float16> m) {
 +        return (Halffloat128Vector) super.lanewiseTemplate(op, Halffloat128Mask.class, v, (Halffloat128Mask) m);  // specialize
 +    }
 +
 +
 +    /*package-private*/
 +    @Override
 +    @ForceInline
 +    public final
 +    Halffloat128Vector
-     lanewise(Ternary op, Vector<Halffloat> v1, Vector<Halffloat> v2) {
++    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2) {
 +        return (Halffloat128Vector) super.lanewiseTemplate(op, v1, v2);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final
 +    Halffloat128Vector
-     lanewise(Ternary op, Vector<Halffloat> v1, Vector<Halffloat> v2, VectorMask<Halffloat> m) {
++    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2, VectorMask<Float16> m) {
 +        return (Halffloat128Vector) super.lanewiseTemplate(op, Halffloat128Mask.class, v1, v2, (Halffloat128Mask) m);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final
 +    Halffloat128Vector addIndex(int scale) {
 +        return (Halffloat128Vector) super.addIndexTemplate(scale);  // specialize
 +    }
 +
 +    // Type specific horizontal reductions
 +
 +    @Override
 +    @ForceInline
 +    public final short reduceLanes(VectorOperators.Associative op) {
 +        return super.reduceLanesTemplate(op);  // specialized
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final short reduceLanes(VectorOperators.Associative op,
-                                     VectorMask<Halffloat> m) {
++                                    VectorMask<Float16> m) {
 +        return super.reduceLanesTemplate(op, Halffloat128Mask.class, (Halffloat128Mask) m);  // specialized
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final long reduceLanesToLong(VectorOperators.Associative op) {
 +        return (long) super.reduceLanesTemplate(op);  // specialized
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final long reduceLanesToLong(VectorOperators.Associative op,
-                                         VectorMask<Halffloat> m) {
++                                        VectorMask<Float16> m) {
 +        return (long) super.reduceLanesTemplate(op, Halffloat128Mask.class, (Halffloat128Mask) m);  // specialized
 +    }
 +
 +    @Override
 +    @ForceInline
-     public final
-     <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {
-         return super.toShuffleTemplate(dsp);
++    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {
++        throw new AssertionError();
++    }
++
++    @Override
++    @ForceInline
++    public final Halffloat128Shuffle toShuffle() {
++        return (Halffloat128Shuffle) toShuffle(vspecies(), false);
 +    }
 +
 +    // Specialized unary testing
 +
 +    @Override
 +    @ForceInline
 +    public final Halffloat128Mask test(Test op) {
 +        return super.testTemplate(Halffloat128Mask.class, op);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public final Halffloat128Mask test(Test op, VectorMask<Halffloat> m) {
++    public final Halffloat128Mask test(Test op, VectorMask<Float16> m) {
 +        return super.testTemplate(Halffloat128Mask.class, op, (Halffloat128Mask) m);  // specialize
 +    }
 +
 +    // Specialized comparisons
 +
 +    @Override
 +    @ForceInline
-     public final Halffloat128Mask compare(Comparison op, Vector<Halffloat> v) {
++    public final Halffloat128Mask compare(Comparison op, Vector<Float16> v) {
 +        return super.compareTemplate(Halffloat128Mask.class, op, v);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final Halffloat128Mask compare(Comparison op, short s) {
 +        return super.compareTemplate(Halffloat128Mask.class, op, s);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final Halffloat128Mask compare(Comparison op, long s) {
 +        return super.compareTemplate(Halffloat128Mask.class, op, s);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public final Halffloat128Mask compare(Comparison op, Vector<Halffloat> v, VectorMask<Halffloat> m) {
++    public final Halffloat128Mask compare(Comparison op, Vector<Float16> v, VectorMask<Float16> m) {
 +        return super.compareTemplate(Halffloat128Mask.class, op, v, (Halffloat128Mask) m);
 +    }
 +
 +
 +    @Override
 +    @ForceInline
-     public Halffloat128Vector blend(Vector<Halffloat> v, VectorMask<Halffloat> m) {
++    public Halffloat128Vector blend(Vector<Float16> v, VectorMask<Float16> m) {
 +        return (Halffloat128Vector)
 +            super.blendTemplate(Halffloat128Mask.class,
 +                                (Halffloat128Vector) v,
 +                                (Halffloat128Mask) m);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat128Vector slice(int origin, Vector<Halffloat> v) {
++    public Halffloat128Vector slice(int origin, Vector<Float16> v) {
 +        return (Halffloat128Vector) super.sliceTemplate(origin, v);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public Halffloat128Vector slice(int origin) {
 +        return (Halffloat128Vector) super.sliceTemplate(origin);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat128Vector unslice(int origin, Vector<Halffloat> w, int part) {
++    public Halffloat128Vector unslice(int origin, Vector<Float16> w, int part) {
 +        return (Halffloat128Vector) super.unsliceTemplate(origin, w, part);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat128Vector unslice(int origin, Vector<Halffloat> w, int part, VectorMask<Halffloat> m) {
++    public Halffloat128Vector unslice(int origin, Vector<Float16> w, int part, VectorMask<Float16> m) {
 +        return (Halffloat128Vector)
 +            super.unsliceTemplate(Halffloat128Mask.class,
 +                                  origin, w, part,
 +                                  (Halffloat128Mask) m);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public Halffloat128Vector unslice(int origin) {
 +        return (Halffloat128Vector) super.unsliceTemplate(origin);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat128Vector rearrange(VectorShuffle<Halffloat> s) {
++    public Halffloat128Vector rearrange(VectorShuffle<Float16> s) {
 +        return (Halffloat128Vector)
 +            super.rearrangeTemplate(Halffloat128Shuffle.class,
 +                                    (Halffloat128Shuffle) s);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat128Vector rearrange(VectorShuffle<Halffloat> shuffle,
-                                   VectorMask<Halffloat> m) {
++    public Halffloat128Vector rearrange(VectorShuffle<Float16> shuffle,
++                                  VectorMask<Float16> m) {
 +        return (Halffloat128Vector)
 +            super.rearrangeTemplate(Halffloat128Shuffle.class,
 +                                    Halffloat128Mask.class,
 +                                    (Halffloat128Shuffle) shuffle,
 +                                    (Halffloat128Mask) m);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat128Vector rearrange(VectorShuffle<Halffloat> s,
-                                   Vector<Halffloat> v) {
++    public Halffloat128Vector rearrange(VectorShuffle<Float16> s,
++                                  Vector<Float16> v) {
 +        return (Halffloat128Vector)
 +            super.rearrangeTemplate(Halffloat128Shuffle.class,
 +                                    (Halffloat128Shuffle) s,
 +                                    (Halffloat128Vector) v);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat128Vector compress(VectorMask<Halffloat> m) {
++    public Halffloat128Vector compress(VectorMask<Float16> m) {
 +        return (Halffloat128Vector)
 +            super.compressTemplate(Halffloat128Mask.class,
 +                                   (Halffloat128Mask) m);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat128Vector expand(VectorMask<Halffloat> m) {
++    public Halffloat128Vector expand(VectorMask<Float16> m) {
 +        return (Halffloat128Vector)
 +            super.expandTemplate(Halffloat128Mask.class,
 +                                   (Halffloat128Mask) m);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat128Vector selectFrom(Vector<Halffloat> v) {
++    public Halffloat128Vector selectFrom(Vector<Float16> v) {
 +        return (Halffloat128Vector)
 +            super.selectFromTemplate((Halffloat128Vector) v);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat128Vector selectFrom(Vector<Halffloat> v,
-                                    VectorMask<Halffloat> m) {
++    public Halffloat128Vector selectFrom(Vector<Float16> v,
++                                   VectorMask<Float16> m) {
 +        return (Halffloat128Vector)
 +            super.selectFromTemplate((Halffloat128Vector) v,
-                                      (Halffloat128Mask) m);  // specialize
++                                     Halffloat128Mask.class, (Halffloat128Mask) m);  // specialize
 +    }
 +
++    @Override
++    @ForceInline
++    public Halffloat128Vector selectFrom(Vector<Float16> v1,
++                                   Vector<Float16> v2) {
++        return (Halffloat128Vector)
++            super.selectFromTemplate((Halffloat128Vector) v1, (Halffloat128Vector) v2);  // specialize
++    }
 +
 +    @ForceInline
 +    @Override
 +    public short lane(int i) {
 +        short bits;
 +        switch(i) {
 +            case 0: bits = laneHelper(0); break;
 +            case 1: bits = laneHelper(1); break;
 +            case 2: bits = laneHelper(2); break;
 +            case 3: bits = laneHelper(3); break;
 +            case 4: bits = laneHelper(4); break;
 +            case 5: bits = laneHelper(5); break;
 +            case 6: bits = laneHelper(6); break;
 +            case 7: bits = laneHelper(7); break;
 +            default: throw new IllegalArgumentException("Index " + i + " must be zero or positive, and less than " + VLENGTH);
 +        }
-         return Halffloat.shortBitsToHalffloat(bits);
++        return bits;
 +    }
 +
++    @ForceInline
 +    public short laneHelper(int i) {
 +        return (short) VectorSupport.extract(
-                      VCLASS, ETYPE, VLENGTH,
++                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
 +                     this, i,
 +                     (vec, ix) -> {
 +                     short[] vecarr = vec.vec();
-                      return (long)Halffloat.shortToShortBits(vecarr[ix]);
++                     return vecarr[ix];
 +                     });
 +    }
 +
 +    @ForceInline
 +    @Override
 +    public Halffloat128Vector withLane(int i, short e) {
 +        switch(i) {
 +            case 0: return withLaneHelper(0, e);
 +            case 1: return withLaneHelper(1, e);
 +            case 2: return withLaneHelper(2, e);
 +            case 3: return withLaneHelper(3, e);
 +            case 4: return withLaneHelper(4, e);
 +            case 5: return withLaneHelper(5, e);
 +            case 6: return withLaneHelper(6, e);
 +            case 7: return withLaneHelper(7, e);
 +            default: throw new IllegalArgumentException("Index " + i + " must be zero or positive, and less than " + VLENGTH);
 +        }
 +    }
 +
++    @ForceInline
 +    public Halffloat128Vector withLaneHelper(int i, short e) {
 +        return VectorSupport.insert(
-                                 VCLASS, ETYPE, VLENGTH,
-                                 this, i, (long)Halffloat.shortToShortBits(e),
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                this, i, (long)e,
 +                                (v, ix, bits) -> {
 +                                    short[] res = v.vec().clone();
-                                     res[ix] = Halffloat.shortBitsToHalffloat((short)bits);
++                                    res[ix] = e;
 +                                    return v.vectorFactory(res);
 +                                });
 +    }
 +
 +    // Mask
 +
-     static final class Halffloat128Mask extends AbstractMask<Halffloat> {
++    static final class Halffloat128Mask extends AbstractMask<Float16> {
 +        static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
-         static final Class<Halffloat> ETYPE = Halffloat.class; // used by the JVM
++        static final Class<Short> CTYPE = short.class; // used by the JVM
 +
 +        Halffloat128Mask(boolean[] bits) {
 +            this(bits, 0);
 +        }
 +
 +        Halffloat128Mask(boolean[] bits, int offset) {
 +            super(prepare(bits, offset));
 +        }
 +
 +        Halffloat128Mask(boolean val) {
 +            super(prepare(val));
 +        }
 +
 +        private static boolean[] prepare(boolean[] bits, int offset) {
 +            boolean[] newBits = new boolean[VSPECIES.laneCount()];
 +            for (int i = 0; i < newBits.length; i++) {
 +                newBits[i] = bits[offset + i];
 +            }
 +            return newBits;
 +        }
 +
 +        private static boolean[] prepare(boolean val) {
 +            boolean[] bits = new boolean[VSPECIES.laneCount()];
 +            Arrays.fill(bits, val);
 +            return bits;
 +        }
 +
 +        @ForceInline
 +        final @Override
 +        public HalffloatSpecies vspecies() {
 +            // ISSUE:  This should probably be a @Stable
 +            // field inside AbstractMask, rather than
 +            // a megamorphic method.
 +            return VSPECIES;
 +        }
 +
 +        @ForceInline
 +        boolean[] getBits() {
 +            return (boolean[])getPayload();
 +        }
 +
 +        @Override
 +        Halffloat128Mask uOp(MUnOp f) {
 +            boolean[] res = new boolean[vspecies().laneCount()];
 +            boolean[] bits = getBits();
 +            for (int i = 0; i < res.length; i++) {
 +                res[i] = f.apply(i, bits[i]);
 +            }
 +            return new Halffloat128Mask(res);
 +        }
 +
 +        @Override
-         Halffloat128Mask bOp(VectorMask<Halffloat> m, MBinOp f) {
++        Halffloat128Mask bOp(VectorMask<Float16> m, MBinOp f) {
 +            boolean[] res = new boolean[vspecies().laneCount()];
 +            boolean[] bits = getBits();
 +            boolean[] mbits = ((Halffloat128Mask)m).getBits();
 +            for (int i = 0; i < res.length; i++) {
 +                res[i] = f.apply(i, bits[i], mbits[i]);
 +            }
 +            return new Halffloat128Mask(res);
 +        }
 +
 +        @ForceInline
 +        @Override
 +        public final
 +        Halffloat128Vector toVector() {
 +            return (Halffloat128Vector) super.toVectorTemplate();  // specialize
 +        }
 +
 +        /**
 +         * Helper function for lane-wise mask conversions.
 +         * This function kicks in after intrinsic failure.
 +         */
 +        @ForceInline
 +        private final <E>
 +        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {
 +            if (length() != dsp.laneCount())
 +                throw new IllegalArgumentException("VectorMask length and species length differ");
 +            boolean[] maskArray = toArray();
 +            return  dsp.maskFactory(maskArray).check(dsp);
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
 +            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;
 +            if (length() != species.laneCount())
 +                throw new IllegalArgumentException("VectorMask length and species length differ");
 +
 +            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,
 +                this.getClass(), ETYPE, VLENGTH,
 +                species.maskType(), species.elementType(), VLENGTH,
 +                this, species,
 +                (m, s) -> s.maskFactory(m.toArray()).check(s));
 +        }
 +
 +        @Override
 +        @ForceInline
 +        /*package-private*/
 +        Halffloat128Mask indexPartiallyInUpperRange(long offset, long limit) {
 +            return (Halffloat128Mask) VectorSupport.indexPartiallyInUpperRange(
-                 Halffloat128Mask.class, ETYPE, VLENGTH, offset, limit,
++                Halffloat128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
 +                (o, l) -> (Halffloat128Mask) TRUE_MASK.indexPartiallyInRange(o, l));
 +        }
 +
 +        // Unary operations
 +
 +        @Override
 +        @ForceInline
 +        public Halffloat128Mask not() {
 +            return xor(maskAll(true));
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public Halffloat128Mask compress() {
 +            return (Halffloat128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                 Halffloat128Vector.class, Halffloat128Mask.class, ETYPE, VLENGTH, null, this,
-                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, Float.floatToFloat16(m1.trueCount())));
++                Halffloat128Vector.class, Halffloat128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                Float16.float16ToShortBits(Float16.valueOf(m1.trueCount()))));
 +        }
 +
 +
 +        // Binary operations
 +
 +        @Override
 +        @ForceInline
-         public Halffloat128Mask and(VectorMask<Halffloat> mask) {
++        public Halffloat128Mask and(VectorMask<Float16> mask) {
 +            Objects.requireNonNull(mask);
 +            Halffloat128Mask m = (Halffloat128Mask)mask;
-             return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat128Mask.class, null, Halffloat.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat128Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
 +                                          this, m, null,
 +                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
 +        }
 +
 +        @Override
 +        @ForceInline
-         public Halffloat128Mask or(VectorMask<Halffloat> mask) {
++        public Halffloat128Mask or(VectorMask<Float16> mask) {
 +            Objects.requireNonNull(mask);
 +            Halffloat128Mask m = (Halffloat128Mask)mask;
-             return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat128Mask.class, null, Halffloat.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat128Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
 +                                          this, m, null,
 +                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
 +        }
 +
 +        @Override
 +        @ForceInline
-         public Halffloat128Mask xor(VectorMask<Halffloat> mask) {
++        public Halffloat128Mask xor(VectorMask<Float16> mask) {
 +            Objects.requireNonNull(mask);
 +            Halffloat128Mask m = (Halffloat128Mask)mask;
-             return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat128Mask.class, null, Halffloat.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat128Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
 +                                          this, m, null,
 +                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
 +        }
 +
 +        // Mask Query operations
 +
 +        @Override
 +        @ForceInline
 +        public int trueCount() {
-             return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat128Mask.class, Halffloat.class, VLENGTH, this,
-                                                       (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat128Mask.class, short.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public int firstTrue() {
-             return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat128Mask.class, Halffloat.class, VLENGTH, this,
-                                                       (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat128Mask.class, short.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public int lastTrue() {
-             return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat128Mask.class, Halffloat.class, VLENGTH, this,
-                                                       (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat128Mask.class, short.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public long toLong() {
 +            if (length() > Long.SIZE) {
 +                throw new UnsupportedOperationException("too many lanes for one long");
 +            }
-             return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat128Mask.class, Halffloat.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat128Mask.class, short.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
 +                                                      (m) -> toLongHelper(m.getBits()));
 +        }
 +
++        // laneIsSet
++
++        @Override
++        @ForceInline
++        public boolean laneIsSet(int i) {
++            Objects.checkIndex(i, length());
++            return VectorSupport.extract(Halffloat128Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
++        }
++
 +        // Reductions
 +
 +        @Override
 +        @ForceInline
 +        public boolean anyTrue() {
-             return VectorSupport.test(BT_ne, Halffloat128Mask.class, Halffloat.class, VLENGTH,
-                                          this, vspecies().maskAll(true),
-                                          (m, __) -> anyTrueHelper(((Halffloat128Mask)m).getBits()));
++            return VectorSupport.test(BT_ne, Halffloat128Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper(((Halffloat128Mask)m).getBits()));
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public boolean allTrue() {
-             return VectorSupport.test(BT_overflow, Halffloat128Mask.class, Halffloat.class, VLENGTH,
-                                          this, vspecies().maskAll(true),
-                                          (m, __) -> allTrueHelper(((Halffloat128Mask)m).getBits()));
++            return VectorSupport.test(BT_overflow, Halffloat128Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper(((Halffloat128Mask)m).getBits()));
 +        }
 +
 +        @ForceInline
 +        /*package-private*/
 +        static Halffloat128Mask maskAll(boolean bit) {
-             return VectorSupport.fromBitsCoerced(Halffloat128Mask.class, Halffloat.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced(Halffloat128Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
 +                                                 (bit ? -1 : 0), MODE_BROADCAST, null,
 +                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
 +        }
 +        private static final Halffloat128Mask  TRUE_MASK = new Halffloat128Mask(true);
 +        private static final Halffloat128Mask FALSE_MASK = new Halffloat128Mask(false);
 +
 +    }
 +
 +    // Shuffle
 +
-     static final class Halffloat128Shuffle extends AbstractShuffle<Halffloat> {
++    static final class Halffloat128Shuffle extends AbstractShuffle<Float16> {
 +        static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
-         static final Class<Short> ETYPE = short.class; // used by the JVM
++        static final Class<Short> CTYPE = short.class; // used by the JVM
 +
 +        Halffloat128Shuffle(short[] indices) {
 +            super(indices);
 +            assert(VLENGTH == indices.length);
 +            assert(indicesInRange(indices));
 +        }
 +
 +        Halffloat128Shuffle(int[] indices, int i) {
 +            this(prepare(indices, i));
 +        }
 +
 +        Halffloat128Shuffle(IntUnaryOperator fn) {
 +            this(prepare(fn));
 +        }
 +
 +        short[] indices() {
 +            return (short[])getPayload();
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public HalffloatSpecies vspecies() {
 +            return VSPECIES;
 +        }
 +
 +        static {
 +            // There must be enough bits in the shuffle lanes to encode
 +            // VLENGTH valid indexes and VLENGTH exceptional ones.
 +            assert(VLENGTH < Short.MAX_VALUE);
 +            assert(Short.MIN_VALUE <= -VLENGTH);
 +        }
 +        static final Halffloat128Shuffle IOTA = new Halffloat128Shuffle(IDENTITY);
 +
++        @Override
++        @ForceInline
++        public Halffloat128Vector toVector() {
++            return (Halffloat128Vector) toBitsVector().castShape(vspecies(), 0);
++        }
++
 +        @Override
 +        @ForceInline
 +        Short128Vector toBitsVector() {
 +            return (Short128Vector) super.toBitsVectorTemplate();
 +        }
 +
 +        @Override
-         @ForceInline
-         ShortVector toBitsVector0() {
-             return Short128Vector.VSPECIES.dummyVector().vectorFactory(indices());
++        Short128Vector toBitsVector0() {
++            return ((Short128Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public int laneSource(int i) {
 +            return (int)toBitsVector().lane(i);
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public void intoArray(int[] a, int offset) {
 +            VectorSpecies<Integer> species = IntVector.SPECIES_128;
 +            Vector<Short> v = toBitsVector();
 +            v.convertShape(VectorOperators.S2I, species, 0)
 +                    .reinterpretAsInts()
 +                    .intoArray(a, offset);
 +            v.convertShape(VectorOperators.S2I, species, 1)
 +                    .reinterpretAsInts()
 +                    .intoArray(a, offset + species.length());
 +        }
 +
++        @Override
++        @ForceInline
++        public void intoMemorySegment(MemorySegment ms, long offset, ByteOrder bo) {
++            VectorSpecies<Integer> species = IntVector.SPECIES_128;
++            Vector<Short> v = toBitsVector();
++            v.convertShape(VectorOperators.S2I, species, 0)
++                    .reinterpretAsInts()
++                    .intoMemorySegment(ms, offset, bo);
++            v.convertShape(VectorOperators.S2I, species, 1)
++                    .reinterpretAsInts()
++                    .intoMemorySegment(ms, offset + species.vectorByteSize(), bo);
++         }
++
++        @Override
++        @ForceInline
++        public final Halffloat128Mask laneIsValid() {
++            return (Halffloat128Mask) toBitsVector().compare(VectorOperators.GE, 0)
++                    .cast(vspecies());
++        }
++
++        @ForceInline
++        @Override
++        public final Halffloat128Shuffle rearrange(VectorShuffle<Float16> shuffle) {
++            Halffloat128Shuffle concreteShuffle = (Halffloat128Shuffle) shuffle;
++            return (Halffloat128Shuffle) toBitsVector().rearrange(concreteShuffle.cast(ShortVector.SPECIES_128))
++                    .toShuffle(vspecies(), false);
++        }
++
++        @ForceInline
++        @Override
++        public final Halffloat128Shuffle wrapIndexes() {
++            Short128Vector v = toBitsVector();
++            if ((length() & (length() - 1)) == 0) {
++                v = (Short128Vector) v.lanewise(VectorOperators.AND, length() - 1);
++            } else {
++                v = (Short128Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),
++                            v.compare(VectorOperators.LT, 0));
++            }
++            return (Halffloat128Shuffle) v.toShuffle(vspecies(), false);
++        }
++
 +        private static short[] prepare(int[] indices, int offset) {
 +            short[] a = new short[VLENGTH];
 +            for (int i = 0; i < VLENGTH; i++) {
 +                int si = indices[offset + i];
 +                si = partiallyWrapIndex(si, VLENGTH);
 +                a[i] = (short)si;
 +            }
 +            return a;
 +        }
 +
 +        private static short[] prepare(IntUnaryOperator f) {
 +            short[] a = new short[VLENGTH];
 +            for (int i = 0; i < VLENGTH; i++) {
 +                int si = f.applyAsInt(i);
 +                si = partiallyWrapIndex(si, VLENGTH);
 +                a[i] = (short)si;
 +            }
 +            return a;
 +        }
 +
 +        private static boolean indicesInRange(short[] indices) {
 +            int length = indices.length;
 +            for (short si : indices) {
 +                if (si >= (short)length || si < (short)(-length)) {
-                     boolean assertsEnabled = false;
-                     assert(assertsEnabled = true);
-                     if (assertsEnabled) {
-                         String msg = ("index "+si+"out of range ["+length+"] in "+
++                    String msg = ("index "+si+"out of range ["+length+"] in "+
 +                                  java.util.Arrays.toString(indices));
-                         throw new AssertionError(msg);
-                     }
-                     return false;
++                    throw new AssertionError(msg);
 +                }
 +            }
 +            return true;
 +        }
 +    }
 +
 +    // ================================================
 +
 +    // Specialized low-level memory operations.
 +
 +    @ForceInline
 +    @Override
 +    final
 +    HalffloatVector fromArray0(short[] a, int offset) {
 +        return super.fromArray0Template(a, offset);  // specialize
 +    }
 +
 +    @ForceInline
 +    @Override
 +    final
-     HalffloatVector fromArray0(short[] a, int offset, VectorMask<Halffloat> m, int offsetInRange) {
++    HalffloatVector fromArray0(short[] a, int offset, VectorMask<Float16> m, int offsetInRange) {
 +        return super.fromArray0Template(Halffloat128Mask.class, a, offset, (Halffloat128Mask) m, offsetInRange);  // specialize
 +    }
 +
++    @ForceInline
++    @Override
++    final
++    HalffloatVector fromArray0(short[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float16> m) {
++        return super.fromArray0Template(Halffloat128Mask.class, a, offset, indexMap, mapOffset, (Halffloat128Mask) m);
++    }
 +
 +    @ForceInline
 +    @Override
 +    final
 +    HalffloatVector fromCharArray0(char[] a, int offset) {
 +        return super.fromCharArray0Template(a, offset);  // specialize
 +    }
 +
 +    @ForceInline
 +    @Override
 +    final
-     HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Halffloat> m, int offsetInRange) {
++    HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Float16> m, int offsetInRange) {
 +        return super.fromCharArray0Template(Halffloat128Mask.class, a, offset, (Halffloat128Mask) m, offsetInRange);  // specialize
 +    }
 +
 +
 +    @ForceInline
 +    @Override
 +    final
 +    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset) {
 +        return super.fromMemorySegment0Template(ms, offset);  // specialize
 +    }
 +
 +    @ForceInline
 +    @Override
 +    final
-     HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Halffloat> m, int offsetInRange) {
++    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m, int offsetInRange) {
 +        return super.fromMemorySegment0Template(Halffloat128Mask.class, ms, offset, (Halffloat128Mask) m, offsetInRange);  // specialize
 +    }
 +
 +    @ForceInline
 +    @Override
 +    final
 +    void intoArray0(short[] a, int offset) {
 +        super.intoArray0Template(a, offset);  // specialize
 +    }
 +
 +    @ForceInline
 +    @Override
 +    final
-     void intoArray0(short[] a, int offset, VectorMask<Halffloat> m) {
++    void intoArray0(short[] a, int offset, VectorMask<Float16> m) {
 +        super.intoArray0Template(Halffloat128Mask.class, a, offset, (Halffloat128Mask) m);
 +    }
 +
 +
 +
 +    @ForceInline
 +    @Override
 +    final
-     void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Halffloat> m) {
++    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m) {
 +        super.intoMemorySegment0Template(Halffloat128Mask.class, ms, offset, (Halffloat128Mask) m);
 +    }
 +
 +    @ForceInline
 +    @Override
 +    final
-     void intoCharArray0(char[] a, int offset, VectorMask<Halffloat> m) {
++    void intoCharArray0(char[] a, int offset, VectorMask<Float16> m) {
 +        super.intoCharArray0Template(Halffloat128Mask.class, a, offset, (Halffloat128Mask) m);
 +    }
 +
 +    // End of specialized low-level memory operations.
 +
 +    // ================================================
 +
 +}
 +
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Halffloat256Vector.java
index 04b5281615a,00000000000..149c19e7626
mode 100644,000000..100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Halffloat256Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Halffloat256Vector.java
@@@ -1,967 -1,0 +1,1058 @@@
 +/*
-  * Copyright (c) 2017, 2023, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
 + * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 + *
 + * This code is free software; you can redistribute it and/or modify it
 + * under the terms of the GNU General Public License version 2 only, as
 + * published by the Free Software Foundation.  Oracle designates this
 + * particular file as subject to the "Classpath" exception as provided
 + * by Oracle in the LICENSE file that accompanied this code.
 + *
 + * This code is distributed in the hope that it will be useful, but WITHOUT
 + * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 + * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 + * version 2 for more details (a copy is included in the LICENSE file that
 + * accompanied this code).
 + *
 + * You should have received a copy of the GNU General Public License version
 + * 2 along with this work; if not, write to the Free Software Foundation,
 + * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 + *
 + * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 + * or visit www.oracle.com if you need additional information or have any
 + * questions.
 + */
 +package jdk.incubator.vector;
 +
 +import java.lang.foreign.MemorySegment;
++import java.lang.foreign.ValueLayout;
++import java.nio.ByteOrder;
 +import java.util.Arrays;
 +import java.util.Objects;
 +import java.util.function.IntUnaryOperator;
 +
 +import jdk.internal.vm.annotation.ForceInline;
 +import jdk.internal.vm.vector.VectorSupport;
 +
 +import static jdk.internal.vm.vector.VectorSupport.*;
 +
 +import static jdk.incubator.vector.VectorOperators.*;
 +
 +// -- This file was mechanically generated: Do not edit! -- //
 +
 +@SuppressWarnings("cast")  // warning: redundant cast
 +final class Halffloat256Vector extends HalffloatVector {
 +    static final HalffloatSpecies VSPECIES =
 +        (HalffloatSpecies) HalffloatVector.SPECIES_256;
 +
 +    static final VectorShape VSHAPE =
 +        VSPECIES.vectorShape();
 +
 +    static final Class<Halffloat256Vector> VCLASS = Halffloat256Vector.class;
 +
 +    static final int VSIZE = VSPECIES.vectorBitSize();
 +
 +    static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
 +
-     static final Class<Halffloat> ETYPE = Halffloat.class; // used by the JVM
++    static final Class<Short> CTYPE = short.class; // carrier type used by the JVM
++
++    static final Class<Float16> ETYPE = Float16.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_FP16;
 +
 +    Halffloat256Vector(short[] v) {
 +        super(v);
 +    }
 +
 +    // For compatibility as Halffloat256Vector::new,
 +    // stored into species.vectorFactory.
 +    Halffloat256Vector(Object v) {
 +        this((short[]) v);
 +    }
 +
 +    static final Halffloat256Vector ZERO = new Halffloat256Vector(new short[VLENGTH]);
 +    static final Halffloat256Vector IOTA = new Halffloat256Vector(VSPECIES.iotaArray());
 +
 +    static {
 +        // Warm up a few species caches.
 +        // If we do this too much we will
 +        // get NPEs from bootstrap circularity.
 +        VSPECIES.dummyVector();
 +        VSPECIES.withLanes(LaneType.BYTE);
 +    }
 +
 +    // Specialized extractors
 +
 +    @ForceInline
 +    final @Override
 +    public HalffloatSpecies vspecies() {
 +        // ISSUE:  This should probably be a @Stable
 +        // field inside AbstractVector, rather than
 +        // a megamorphic method.
 +        return VSPECIES;
 +    }
 +
++    @ForceInline
++    final Class<Short> carrierType() { return CTYPE; }
++
 +    @ForceInline
 +    @Override
-     public final Class<Halffloat> elementType() { return Halffloat.class; }
++    public final Class<Float16> elementType() { return ETYPE; }
 +
 +    @ForceInline
 +    @Override
-     public final int elementSize() { return Halffloat.SIZE; }
++    public final int elementSize() { return Float16.SIZE; }
 +
 +    @ForceInline
 +    @Override
 +    public final VectorShape shape() { return VSHAPE; }
 +
 +    @ForceInline
 +    @Override
 +    public final int length() { return VLENGTH; }
 +
 +    @ForceInline
 +    @Override
 +    public final int bitSize() { return VSIZE; }
 +
 +    @ForceInline
 +    @Override
 +    public final int byteSize() { return VSIZE / Byte.SIZE; }
 +
 +    /*package-private*/
 +    @ForceInline
 +    final @Override
 +    short[] vec() {
 +        return (short[])getPayload();
 +    }
 +
 +    // Virtualized constructors
 +
 +    @Override
 +    @ForceInline
 +    public final Halffloat256Vector broadcast(short e) {
 +        return (Halffloat256Vector) super.broadcastTemplate(e);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final Halffloat256Vector broadcast(long e) {
 +        return (Halffloat256Vector) super.broadcastTemplate(e);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    Halffloat256Mask maskFromArray(boolean[] bits) {
 +        return new Halffloat256Mask(bits);
 +    }
 +
 +    @Override
 +    @ForceInline
 +    Halffloat256Shuffle iotaShuffle() { return Halffloat256Shuffle.IOTA; }
 +
++    @Override
++    @ForceInline
++    Halffloat256Shuffle iotaShuffle(int start, int step, boolean wrap) {
++        return (Halffloat256Shuffle) iotaShuffleTemplate((short) start, (short) step, wrap);
++    }
++
 +    @Override
 +    @ForceInline
 +    Halffloat256Shuffle shuffleFromArray(int[] indices, int i) { return new Halffloat256Shuffle(indices, i); }
 +
 +    @Override
 +    @ForceInline
 +    Halffloat256Shuffle shuffleFromOp(IntUnaryOperator fn) { return new Halffloat256Shuffle(fn); }
 +
 +    // Make a vector of the same species but the given elements:
 +    @ForceInline
 +    final @Override
 +    Halffloat256Vector vectorFactory(short[] vec) {
 +        return new Halffloat256Vector(vec);
 +    }
 +
 +    @ForceInline
 +    final @Override
 +    Byte256Vector asByteVectorRaw() {
 +        return (Byte256Vector) super.asByteVectorRawTemplate();  // specialize
 +    }
 +
 +    @ForceInline
 +    final @Override
 +    AbstractVector<?> asVectorRaw(LaneType laneType) {
 +        return super.asVectorRawTemplate(laneType);  // specialize
 +    }
 +
 +    // Unary operator
 +
 +    @ForceInline
 +    final @Override
 +    Halffloat256Vector uOp(FUnOp f) {
 +        return (Halffloat256Vector) super.uOpTemplate(f);  // specialize
 +    }
 +
 +    @ForceInline
 +    final @Override
-     Halffloat256Vector uOp(VectorMask<Halffloat> m, FUnOp f) {
++    Halffloat256Vector uOp(VectorMask<Float16> m, FUnOp f) {
 +        return (Halffloat256Vector)
 +            super.uOpTemplate((Halffloat256Mask)m, f);  // specialize
 +    }
 +
 +    // Binary operator
 +
 +    @ForceInline
 +    final @Override
-     Halffloat256Vector bOp(Vector<Halffloat> v, FBinOp f) {
++    Halffloat256Vector bOp(Vector<Float16> v, FBinOp f) {
 +        return (Halffloat256Vector) super.bOpTemplate((Halffloat256Vector)v, f);  // specialize
 +    }
 +
 +    @ForceInline
 +    final @Override
-     Halffloat256Vector bOp(Vector<Halffloat> v,
-                      VectorMask<Halffloat> m, FBinOp f) {
++    Halffloat256Vector bOp(Vector<Float16> v,
++                     VectorMask<Float16> m, FBinOp f) {
 +        return (Halffloat256Vector)
 +            super.bOpTemplate((Halffloat256Vector)v, (Halffloat256Mask)m,
 +                              f);  // specialize
 +    }
 +
 +    // Ternary operator
 +
 +    @ForceInline
 +    final @Override
-     Halffloat256Vector tOp(Vector<Halffloat> v1, Vector<Halffloat> v2, FTriOp f) {
++    Halffloat256Vector tOp(Vector<Float16> v1, Vector<Float16> v2, FTriOp f) {
 +        return (Halffloat256Vector)
 +            super.tOpTemplate((Halffloat256Vector)v1, (Halffloat256Vector)v2,
 +                              f);  // specialize
 +    }
 +
 +    @ForceInline
 +    final @Override
-     Halffloat256Vector tOp(Vector<Halffloat> v1, Vector<Halffloat> v2,
-                      VectorMask<Halffloat> m, FTriOp f) {
++    Halffloat256Vector tOp(Vector<Float16> v1, Vector<Float16> v2,
++                     VectorMask<Float16> m, FTriOp f) {
 +        return (Halffloat256Vector)
 +            super.tOpTemplate((Halffloat256Vector)v1, (Halffloat256Vector)v2,
 +                              (Halffloat256Mask)m, f);  // specialize
 +    }
 +
 +    @ForceInline
 +    final @Override
-     short rOp(short v, VectorMask<Halffloat> m, FBinOp f) {
++    short rOp(short v, VectorMask<Float16> m, FBinOp f) {
 +        return super.rOpTemplate(v, m, f);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final <F>
-     Vector<F> convertShape(VectorOperators.Conversion<Halffloat,F> conv,
++    Vector<F> convertShape(VectorOperators.Conversion<Float16,F> conv,
 +                           VectorSpecies<F> rsp, int part) {
 +        return super.convertShapeTemplate(conv, rsp, part);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final <F>
 +    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {
 +        return super.reinterpretShapeTemplate(toSpecies, part);  // specialize
 +    }
 +
 +    // Specialized algebraic operations:
 +
 +    // The following definition forces a specialized version of this
 +    // crucial method into the v-table of this class.  A call to add()
 +    // will inline to a call to lanewise(ADD,), at which point the JIT
 +    // intrinsic will have the opcode of ADD, plus all the metadata
 +    // for this particular class, enabling it to generate precise
 +    // code.
 +    //
 +    // There is probably no benefit to the JIT to specialize the
 +    // masked or broadcast versions of the lanewise method.
 +
 +    @Override
 +    @ForceInline
 +    public Halffloat256Vector lanewise(Unary op) {
 +        return (Halffloat256Vector) super.lanewiseTemplate(op);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat256Vector lanewise(Unary op, VectorMask<Halffloat> m) {
++    public Halffloat256Vector lanewise(Unary op, VectorMask<Float16> m) {
 +        return (Halffloat256Vector) super.lanewiseTemplate(op, Halffloat256Mask.class, (Halffloat256Mask) m);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat256Vector lanewise(Binary op, Vector<Halffloat> v) {
++    public Halffloat256Vector lanewise(Binary op, Vector<Float16> v) {
 +        return (Halffloat256Vector) super.lanewiseTemplate(op, v);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat256Vector lanewise(Binary op, Vector<Halffloat> v, VectorMask<Halffloat> m) {
++    public Halffloat256Vector lanewise(Binary op, Vector<Float16> v, VectorMask<Float16> m) {
 +        return (Halffloat256Vector) super.lanewiseTemplate(op, Halffloat256Mask.class, v, (Halffloat256Mask) m);  // specialize
 +    }
 +
 +
 +    /*package-private*/
 +    @Override
 +    @ForceInline
 +    public final
 +    Halffloat256Vector
-     lanewise(Ternary op, Vector<Halffloat> v1, Vector<Halffloat> v2) {
++    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2) {
 +        return (Halffloat256Vector) super.lanewiseTemplate(op, v1, v2);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final
 +    Halffloat256Vector
-     lanewise(Ternary op, Vector<Halffloat> v1, Vector<Halffloat> v2, VectorMask<Halffloat> m) {
++    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2, VectorMask<Float16> m) {
 +        return (Halffloat256Vector) super.lanewiseTemplate(op, Halffloat256Mask.class, v1, v2, (Halffloat256Mask) m);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final
 +    Halffloat256Vector addIndex(int scale) {
 +        return (Halffloat256Vector) super.addIndexTemplate(scale);  // specialize
 +    }
 +
 +    // Type specific horizontal reductions
 +
 +    @Override
 +    @ForceInline
 +    public final short reduceLanes(VectorOperators.Associative op) {
 +        return super.reduceLanesTemplate(op);  // specialized
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final short reduceLanes(VectorOperators.Associative op,
-                                     VectorMask<Halffloat> m) {
++                                    VectorMask<Float16> m) {
 +        return super.reduceLanesTemplate(op, Halffloat256Mask.class, (Halffloat256Mask) m);  // specialized
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final long reduceLanesToLong(VectorOperators.Associative op) {
 +        return (long) super.reduceLanesTemplate(op);  // specialized
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final long reduceLanesToLong(VectorOperators.Associative op,
-                                         VectorMask<Halffloat> m) {
++                                        VectorMask<Float16> m) {
 +        return (long) super.reduceLanesTemplate(op, Halffloat256Mask.class, (Halffloat256Mask) m);  // specialized
 +    }
 +
 +    @Override
 +    @ForceInline
-     public final
-     <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {
-         return super.toShuffleTemplate(dsp);
++    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {
++        throw new AssertionError();
++    }
++
++    @Override
++    @ForceInline
++    public final Halffloat256Shuffle toShuffle() {
++        return (Halffloat256Shuffle) toShuffle(vspecies(), false);
 +    }
 +
 +    // Specialized unary testing
 +
 +    @Override
 +    @ForceInline
 +    public final Halffloat256Mask test(Test op) {
 +        return super.testTemplate(Halffloat256Mask.class, op);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public final Halffloat256Mask test(Test op, VectorMask<Halffloat> m) {
++    public final Halffloat256Mask test(Test op, VectorMask<Float16> m) {
 +        return super.testTemplate(Halffloat256Mask.class, op, (Halffloat256Mask) m);  // specialize
 +    }
 +
 +    // Specialized comparisons
 +
 +    @Override
 +    @ForceInline
-     public final Halffloat256Mask compare(Comparison op, Vector<Halffloat> v) {
++    public final Halffloat256Mask compare(Comparison op, Vector<Float16> v) {
 +        return super.compareTemplate(Halffloat256Mask.class, op, v);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final Halffloat256Mask compare(Comparison op, short s) {
 +        return super.compareTemplate(Halffloat256Mask.class, op, s);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final Halffloat256Mask compare(Comparison op, long s) {
 +        return super.compareTemplate(Halffloat256Mask.class, op, s);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public final Halffloat256Mask compare(Comparison op, Vector<Halffloat> v, VectorMask<Halffloat> m) {
++    public final Halffloat256Mask compare(Comparison op, Vector<Float16> v, VectorMask<Float16> m) {
 +        return super.compareTemplate(Halffloat256Mask.class, op, v, (Halffloat256Mask) m);
 +    }
 +
 +
 +    @Override
 +    @ForceInline
-     public Halffloat256Vector blend(Vector<Halffloat> v, VectorMask<Halffloat> m) {
++    public Halffloat256Vector blend(Vector<Float16> v, VectorMask<Float16> m) {
 +        return (Halffloat256Vector)
 +            super.blendTemplate(Halffloat256Mask.class,
 +                                (Halffloat256Vector) v,
 +                                (Halffloat256Mask) m);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat256Vector slice(int origin, Vector<Halffloat> v) {
++    public Halffloat256Vector slice(int origin, Vector<Float16> v) {
 +        return (Halffloat256Vector) super.sliceTemplate(origin, v);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public Halffloat256Vector slice(int origin) {
 +        return (Halffloat256Vector) super.sliceTemplate(origin);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat256Vector unslice(int origin, Vector<Halffloat> w, int part) {
++    public Halffloat256Vector unslice(int origin, Vector<Float16> w, int part) {
 +        return (Halffloat256Vector) super.unsliceTemplate(origin, w, part);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat256Vector unslice(int origin, Vector<Halffloat> w, int part, VectorMask<Halffloat> m) {
++    public Halffloat256Vector unslice(int origin, Vector<Float16> w, int part, VectorMask<Float16> m) {
 +        return (Halffloat256Vector)
 +            super.unsliceTemplate(Halffloat256Mask.class,
 +                                  origin, w, part,
 +                                  (Halffloat256Mask) m);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public Halffloat256Vector unslice(int origin) {
 +        return (Halffloat256Vector) super.unsliceTemplate(origin);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat256Vector rearrange(VectorShuffle<Halffloat> s) {
++    public Halffloat256Vector rearrange(VectorShuffle<Float16> s) {
 +        return (Halffloat256Vector)
 +            super.rearrangeTemplate(Halffloat256Shuffle.class,
 +                                    (Halffloat256Shuffle) s);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat256Vector rearrange(VectorShuffle<Halffloat> shuffle,
-                                   VectorMask<Halffloat> m) {
++    public Halffloat256Vector rearrange(VectorShuffle<Float16> shuffle,
++                                  VectorMask<Float16> m) {
 +        return (Halffloat256Vector)
 +            super.rearrangeTemplate(Halffloat256Shuffle.class,
 +                                    Halffloat256Mask.class,
 +                                    (Halffloat256Shuffle) shuffle,
 +                                    (Halffloat256Mask) m);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat256Vector rearrange(VectorShuffle<Halffloat> s,
-                                   Vector<Halffloat> v) {
++    public Halffloat256Vector rearrange(VectorShuffle<Float16> s,
++                                  Vector<Float16> v) {
 +        return (Halffloat256Vector)
 +            super.rearrangeTemplate(Halffloat256Shuffle.class,
 +                                    (Halffloat256Shuffle) s,
 +                                    (Halffloat256Vector) v);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat256Vector compress(VectorMask<Halffloat> m) {
++    public Halffloat256Vector compress(VectorMask<Float16> m) {
 +        return (Halffloat256Vector)
 +            super.compressTemplate(Halffloat256Mask.class,
 +                                   (Halffloat256Mask) m);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat256Vector expand(VectorMask<Halffloat> m) {
++    public Halffloat256Vector expand(VectorMask<Float16> m) {
 +        return (Halffloat256Vector)
 +            super.expandTemplate(Halffloat256Mask.class,
 +                                   (Halffloat256Mask) m);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat256Vector selectFrom(Vector<Halffloat> v) {
++    public Halffloat256Vector selectFrom(Vector<Float16> v) {
 +        return (Halffloat256Vector)
 +            super.selectFromTemplate((Halffloat256Vector) v);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat256Vector selectFrom(Vector<Halffloat> v,
-                                    VectorMask<Halffloat> m) {
++    public Halffloat256Vector selectFrom(Vector<Float16> v,
++                                   VectorMask<Float16> m) {
 +        return (Halffloat256Vector)
 +            super.selectFromTemplate((Halffloat256Vector) v,
-                                      (Halffloat256Mask) m);  // specialize
++                                     Halffloat256Mask.class, (Halffloat256Mask) m);  // specialize
 +    }
 +
++    @Override
++    @ForceInline
++    public Halffloat256Vector selectFrom(Vector<Float16> v1,
++                                   Vector<Float16> v2) {
++        return (Halffloat256Vector)
++            super.selectFromTemplate((Halffloat256Vector) v1, (Halffloat256Vector) v2);  // specialize
++    }
 +
 +    @ForceInline
 +    @Override
 +    public short lane(int i) {
 +        short bits;
 +        switch(i) {
 +            case 0: bits = laneHelper(0); break;
 +            case 1: bits = laneHelper(1); break;
 +            case 2: bits = laneHelper(2); break;
 +            case 3: bits = laneHelper(3); break;
 +            case 4: bits = laneHelper(4); break;
 +            case 5: bits = laneHelper(5); break;
 +            case 6: bits = laneHelper(6); break;
 +            case 7: bits = laneHelper(7); break;
 +            case 8: bits = laneHelper(8); break;
 +            case 9: bits = laneHelper(9); break;
 +            case 10: bits = laneHelper(10); break;
 +            case 11: bits = laneHelper(11); break;
 +            case 12: bits = laneHelper(12); break;
 +            case 13: bits = laneHelper(13); break;
 +            case 14: bits = laneHelper(14); break;
 +            case 15: bits = laneHelper(15); break;
 +            default: throw new IllegalArgumentException("Index " + i + " must be zero or positive, and less than " + VLENGTH);
 +        }
-         return Halffloat.shortBitsToHalffloat(bits);
++        return bits;
 +    }
 +
++    @ForceInline
 +    public short laneHelper(int i) {
 +        return (short) VectorSupport.extract(
-                      VCLASS, ETYPE, VLENGTH,
++                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
 +                     this, i,
 +                     (vec, ix) -> {
 +                     short[] vecarr = vec.vec();
-                      return (long)Halffloat.shortToShortBits(vecarr[ix]);
++                     return vecarr[ix];
 +                     });
 +    }
 +
 +    @ForceInline
 +    @Override
 +    public Halffloat256Vector withLane(int i, short e) {
 +        switch(i) {
 +            case 0: return withLaneHelper(0, e);
 +            case 1: return withLaneHelper(1, e);
 +            case 2: return withLaneHelper(2, e);
 +            case 3: return withLaneHelper(3, e);
 +            case 4: return withLaneHelper(4, e);
 +            case 5: return withLaneHelper(5, e);
 +            case 6: return withLaneHelper(6, e);
 +            case 7: return withLaneHelper(7, e);
 +            case 8: return withLaneHelper(8, e);
 +            case 9: return withLaneHelper(9, e);
 +            case 10: return withLaneHelper(10, e);
 +            case 11: return withLaneHelper(11, e);
 +            case 12: return withLaneHelper(12, e);
 +            case 13: return withLaneHelper(13, e);
 +            case 14: return withLaneHelper(14, e);
 +            case 15: return withLaneHelper(15, e);
 +            default: throw new IllegalArgumentException("Index " + i + " must be zero or positive, and less than " + VLENGTH);
 +        }
 +    }
 +
++    @ForceInline
 +    public Halffloat256Vector withLaneHelper(int i, short e) {
 +        return VectorSupport.insert(
-                                 VCLASS, ETYPE, VLENGTH,
-                                 this, i, (long)Halffloat.shortToShortBits(e),
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                this, i, (long)e,
 +                                (v, ix, bits) -> {
 +                                    short[] res = v.vec().clone();
-                                     res[ix] = Halffloat.shortBitsToHalffloat((short)bits);
++                                    res[ix] = e;
 +                                    return v.vectorFactory(res);
 +                                });
 +    }
 +
 +    // Mask
 +
-     static final class Halffloat256Mask extends AbstractMask<Halffloat> {
++    static final class Halffloat256Mask extends AbstractMask<Float16> {
 +        static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
-         static final Class<Halffloat> ETYPE = Halffloat.class; // used by the JVM
++        static final Class<Short> CTYPE = short.class; // used by the JVM
 +
 +        Halffloat256Mask(boolean[] bits) {
 +            this(bits, 0);
 +        }
 +
 +        Halffloat256Mask(boolean[] bits, int offset) {
 +            super(prepare(bits, offset));
 +        }
 +
 +        Halffloat256Mask(boolean val) {
 +            super(prepare(val));
 +        }
 +
 +        private static boolean[] prepare(boolean[] bits, int offset) {
 +            boolean[] newBits = new boolean[VSPECIES.laneCount()];
 +            for (int i = 0; i < newBits.length; i++) {
 +                newBits[i] = bits[offset + i];
 +            }
 +            return newBits;
 +        }
 +
 +        private static boolean[] prepare(boolean val) {
 +            boolean[] bits = new boolean[VSPECIES.laneCount()];
 +            Arrays.fill(bits, val);
 +            return bits;
 +        }
 +
 +        @ForceInline
 +        final @Override
 +        public HalffloatSpecies vspecies() {
 +            // ISSUE:  This should probably be a @Stable
 +            // field inside AbstractMask, rather than
 +            // a megamorphic method.
 +            return VSPECIES;
 +        }
 +
 +        @ForceInline
 +        boolean[] getBits() {
 +            return (boolean[])getPayload();
 +        }
 +
 +        @Override
 +        Halffloat256Mask uOp(MUnOp f) {
 +            boolean[] res = new boolean[vspecies().laneCount()];
 +            boolean[] bits = getBits();
 +            for (int i = 0; i < res.length; i++) {
 +                res[i] = f.apply(i, bits[i]);
 +            }
 +            return new Halffloat256Mask(res);
 +        }
 +
 +        @Override
-         Halffloat256Mask bOp(VectorMask<Halffloat> m, MBinOp f) {
++        Halffloat256Mask bOp(VectorMask<Float16> m, MBinOp f) {
 +            boolean[] res = new boolean[vspecies().laneCount()];
 +            boolean[] bits = getBits();
 +            boolean[] mbits = ((Halffloat256Mask)m).getBits();
 +            for (int i = 0; i < res.length; i++) {
 +                res[i] = f.apply(i, bits[i], mbits[i]);
 +            }
 +            return new Halffloat256Mask(res);
 +        }
 +
 +        @ForceInline
 +        @Override
 +        public final
 +        Halffloat256Vector toVector() {
 +            return (Halffloat256Vector) super.toVectorTemplate();  // specialize
 +        }
 +
 +        /**
 +         * Helper function for lane-wise mask conversions.
 +         * This function kicks in after intrinsic failure.
 +         */
 +        @ForceInline
 +        private final <E>
 +        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {
 +            if (length() != dsp.laneCount())
 +                throw new IllegalArgumentException("VectorMask length and species length differ");
 +            boolean[] maskArray = toArray();
 +            return  dsp.maskFactory(maskArray).check(dsp);
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
 +            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;
 +            if (length() != species.laneCount())
 +                throw new IllegalArgumentException("VectorMask length and species length differ");
 +
 +            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,
 +                this.getClass(), ETYPE, VLENGTH,
 +                species.maskType(), species.elementType(), VLENGTH,
 +                this, species,
 +                (m, s) -> s.maskFactory(m.toArray()).check(s));
 +        }
 +
 +        @Override
 +        @ForceInline
 +        /*package-private*/
 +        Halffloat256Mask indexPartiallyInUpperRange(long offset, long limit) {
 +            return (Halffloat256Mask) VectorSupport.indexPartiallyInUpperRange(
-                 Halffloat256Mask.class, ETYPE, VLENGTH, offset, limit,
++                Halffloat256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
 +                (o, l) -> (Halffloat256Mask) TRUE_MASK.indexPartiallyInRange(o, l));
 +        }
 +
 +        // Unary operations
 +
 +        @Override
 +        @ForceInline
 +        public Halffloat256Mask not() {
 +            return xor(maskAll(true));
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public Halffloat256Mask compress() {
 +            return (Halffloat256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                 Halffloat256Vector.class, Halffloat256Mask.class, ETYPE, VLENGTH, null, this,
-                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, Float.floatToFloat16(m1.trueCount())));
++                Halffloat256Vector.class, Halffloat256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                Float16.float16ToShortBits(Float16.valueOf(m1.trueCount()))));
 +        }
 +
 +
 +        // Binary operations
 +
 +        @Override
 +        @ForceInline
-         public Halffloat256Mask and(VectorMask<Halffloat> mask) {
++        public Halffloat256Mask and(VectorMask<Float16> mask) {
 +            Objects.requireNonNull(mask);
 +            Halffloat256Mask m = (Halffloat256Mask)mask;
-             return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat256Mask.class, null, Halffloat.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat256Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
 +                                          this, m, null,
 +                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
 +        }
 +
 +        @Override
 +        @ForceInline
-         public Halffloat256Mask or(VectorMask<Halffloat> mask) {
++        public Halffloat256Mask or(VectorMask<Float16> mask) {
 +            Objects.requireNonNull(mask);
 +            Halffloat256Mask m = (Halffloat256Mask)mask;
-             return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat256Mask.class, null, Halffloat.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat256Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
 +                                          this, m, null,
 +                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
 +        }
 +
 +        @Override
 +        @ForceInline
-         public Halffloat256Mask xor(VectorMask<Halffloat> mask) {
++        public Halffloat256Mask xor(VectorMask<Float16> mask) {
 +            Objects.requireNonNull(mask);
 +            Halffloat256Mask m = (Halffloat256Mask)mask;
-             return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat256Mask.class, null, Halffloat.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat256Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
 +                                          this, m, null,
 +                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
 +        }
 +
 +        // Mask Query operations
 +
 +        @Override
 +        @ForceInline
 +        public int trueCount() {
-             return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat256Mask.class, Halffloat.class, VLENGTH, this,
-                                                       (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat256Mask.class, short.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public int firstTrue() {
-             return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat256Mask.class, Halffloat.class, VLENGTH, this,
-                                                       (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat256Mask.class, short.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public int lastTrue() {
-             return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat256Mask.class, Halffloat.class, VLENGTH, this,
-                                                       (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat256Mask.class, short.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public long toLong() {
 +            if (length() > Long.SIZE) {
 +                throw new UnsupportedOperationException("too many lanes for one long");
 +            }
-             return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat256Mask.class, Halffloat.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat256Mask.class, short.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
 +                                                      (m) -> toLongHelper(m.getBits()));
 +        }
 +
++        // laneIsSet
++
++        @Override
++        @ForceInline
++        public boolean laneIsSet(int i) {
++            Objects.checkIndex(i, length());
++            return VectorSupport.extract(Halffloat256Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
++        }
++
 +        // Reductions
 +
 +        @Override
 +        @ForceInline
 +        public boolean anyTrue() {
-             return VectorSupport.test(BT_ne, Halffloat256Mask.class, Halffloat.class, VLENGTH,
-                                          this, vspecies().maskAll(true),
-                                          (m, __) -> anyTrueHelper(((Halffloat256Mask)m).getBits()));
++            return VectorSupport.test(BT_ne, Halffloat256Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper(((Halffloat256Mask)m).getBits()));
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public boolean allTrue() {
-             return VectorSupport.test(BT_overflow, Halffloat256Mask.class, Halffloat.class, VLENGTH,
-                                          this, vspecies().maskAll(true),
-                                          (m, __) -> allTrueHelper(((Halffloat256Mask)m).getBits()));
++            return VectorSupport.test(BT_overflow, Halffloat256Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper(((Halffloat256Mask)m).getBits()));
 +        }
 +
 +        @ForceInline
 +        /*package-private*/
 +        static Halffloat256Mask maskAll(boolean bit) {
-             return VectorSupport.fromBitsCoerced(Halffloat256Mask.class, Halffloat.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced(Halffloat256Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
 +                                                 (bit ? -1 : 0), MODE_BROADCAST, null,
 +                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
 +        }
 +        private static final Halffloat256Mask  TRUE_MASK = new Halffloat256Mask(true);
 +        private static final Halffloat256Mask FALSE_MASK = new Halffloat256Mask(false);
 +
 +    }
 +
 +    // Shuffle
 +
-     static final class Halffloat256Shuffle extends AbstractShuffle<Halffloat> {
++    static final class Halffloat256Shuffle extends AbstractShuffle<Float16> {
 +        static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
-         static final Class<Short> ETYPE = short.class; // used by the JVM
++        static final Class<Short> CTYPE = short.class; // used by the JVM
 +
 +        Halffloat256Shuffle(short[] indices) {
 +            super(indices);
 +            assert(VLENGTH == indices.length);
 +            assert(indicesInRange(indices));
 +        }
 +
 +        Halffloat256Shuffle(int[] indices, int i) {
 +            this(prepare(indices, i));
 +        }
 +
 +        Halffloat256Shuffle(IntUnaryOperator fn) {
 +            this(prepare(fn));
 +        }
 +
 +        short[] indices() {
 +            return (short[])getPayload();
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public HalffloatSpecies vspecies() {
 +            return VSPECIES;
 +        }
 +
 +        static {
 +            // There must be enough bits in the shuffle lanes to encode
 +            // VLENGTH valid indexes and VLENGTH exceptional ones.
 +            assert(VLENGTH < Short.MAX_VALUE);
 +            assert(Short.MIN_VALUE <= -VLENGTH);
 +        }
 +        static final Halffloat256Shuffle IOTA = new Halffloat256Shuffle(IDENTITY);
 +
++        @Override
++        @ForceInline
++        public Halffloat256Vector toVector() {
++            return (Halffloat256Vector) toBitsVector().castShape(vspecies(), 0);
++        }
++
 +        @Override
 +        @ForceInline
 +        Short256Vector toBitsVector() {
 +            return (Short256Vector) super.toBitsVectorTemplate();
 +        }
 +
 +        @Override
-         @ForceInline
-         ShortVector toBitsVector0() {
-             return Short256Vector.VSPECIES.dummyVector().vectorFactory(indices());
++        Short256Vector toBitsVector0() {
++            return ((Short256Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public int laneSource(int i) {
 +            return (int)toBitsVector().lane(i);
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public void intoArray(int[] a, int offset) {
 +            VectorSpecies<Integer> species = IntVector.SPECIES_256;
 +            Vector<Short> v = toBitsVector();
 +            v.convertShape(VectorOperators.S2I, species, 0)
 +                    .reinterpretAsInts()
 +                    .intoArray(a, offset);
 +            v.convertShape(VectorOperators.S2I, species, 1)
 +                    .reinterpretAsInts()
 +                    .intoArray(a, offset + species.length());
 +        }
 +
++        @Override
++        @ForceInline
++        public void intoMemorySegment(MemorySegment ms, long offset, ByteOrder bo) {
++            VectorSpecies<Integer> species = IntVector.SPECIES_256;
++            Vector<Short> v = toBitsVector();
++            v.convertShape(VectorOperators.S2I, species, 0)
++                    .reinterpretAsInts()
++                    .intoMemorySegment(ms, offset, bo);
++            v.convertShape(VectorOperators.S2I, species, 1)
++                    .reinterpretAsInts()
++                    .intoMemorySegment(ms, offset + species.vectorByteSize(), bo);
++         }
++
++        @Override
++        @ForceInline
++        public final Halffloat256Mask laneIsValid() {
++            return (Halffloat256Mask) toBitsVector().compare(VectorOperators.GE, 0)
++                    .cast(vspecies());
++        }
++
++        @ForceInline
++        @Override
++        public final Halffloat256Shuffle rearrange(VectorShuffle<Float16> shuffle) {
++            Halffloat256Shuffle concreteShuffle = (Halffloat256Shuffle) shuffle;
++            return (Halffloat256Shuffle) toBitsVector().rearrange(concreteShuffle.cast(ShortVector.SPECIES_256))
++                    .toShuffle(vspecies(), false);
++        }
++
++        @ForceInline
++        @Override
++        public final Halffloat256Shuffle wrapIndexes() {
++            Short256Vector v = toBitsVector();
++            if ((length() & (length() - 1)) == 0) {
++                v = (Short256Vector) v.lanewise(VectorOperators.AND, length() - 1);
++            } else {
++                v = (Short256Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),
++                            v.compare(VectorOperators.LT, 0));
++            }
++            return (Halffloat256Shuffle) v.toShuffle(vspecies(), false);
++        }
++
 +        private static short[] prepare(int[] indices, int offset) {
 +            short[] a = new short[VLENGTH];
 +            for (int i = 0; i < VLENGTH; i++) {
 +                int si = indices[offset + i];
 +                si = partiallyWrapIndex(si, VLENGTH);
 +                a[i] = (short)si;
 +            }
 +            return a;
 +        }
 +
 +        private static short[] prepare(IntUnaryOperator f) {
 +            short[] a = new short[VLENGTH];
 +            for (int i = 0; i < VLENGTH; i++) {
 +                int si = f.applyAsInt(i);
 +                si = partiallyWrapIndex(si, VLENGTH);
 +                a[i] = (short)si;
 +            }
 +            return a;
 +        }
 +
 +        private static boolean indicesInRange(short[] indices) {
 +            int length = indices.length;
 +            for (short si : indices) {
 +                if (si >= (short)length || si < (short)(-length)) {
-                     boolean assertsEnabled = false;
-                     assert(assertsEnabled = true);
-                     if (assertsEnabled) {
-                         String msg = ("index "+si+"out of range ["+length+"] in "+
++                    String msg = ("index "+si+"out of range ["+length+"] in "+
 +                                  java.util.Arrays.toString(indices));
-                         throw new AssertionError(msg);
-                     }
-                     return false;
++                    throw new AssertionError(msg);
 +                }
 +            }
 +            return true;
 +        }
 +    }
 +
 +    // ================================================
 +
 +    // Specialized low-level memory operations.
 +
 +    @ForceInline
 +    @Override
 +    final
 +    HalffloatVector fromArray0(short[] a, int offset) {
 +        return super.fromArray0Template(a, offset);  // specialize
 +    }
 +
 +    @ForceInline
 +    @Override
 +    final
-     HalffloatVector fromArray0(short[] a, int offset, VectorMask<Halffloat> m, int offsetInRange) {
++    HalffloatVector fromArray0(short[] a, int offset, VectorMask<Float16> m, int offsetInRange) {
 +        return super.fromArray0Template(Halffloat256Mask.class, a, offset, (Halffloat256Mask) m, offsetInRange);  // specialize
 +    }
 +
++    @ForceInline
++    @Override
++    final
++    HalffloatVector fromArray0(short[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float16> m) {
++        return super.fromArray0Template(Halffloat256Mask.class, a, offset, indexMap, mapOffset, (Halffloat256Mask) m);
++    }
 +
 +    @ForceInline
 +    @Override
 +    final
 +    HalffloatVector fromCharArray0(char[] a, int offset) {
 +        return super.fromCharArray0Template(a, offset);  // specialize
 +    }
 +
 +    @ForceInline
 +    @Override
 +    final
-     HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Halffloat> m, int offsetInRange) {
++    HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Float16> m, int offsetInRange) {
 +        return super.fromCharArray0Template(Halffloat256Mask.class, a, offset, (Halffloat256Mask) m, offsetInRange);  // specialize
 +    }
 +
 +
 +    @ForceInline
 +    @Override
 +    final
 +    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset) {
 +        return super.fromMemorySegment0Template(ms, offset);  // specialize
 +    }
 +
 +    @ForceInline
 +    @Override
 +    final
-     HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Halffloat> m, int offsetInRange) {
++    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m, int offsetInRange) {
 +        return super.fromMemorySegment0Template(Halffloat256Mask.class, ms, offset, (Halffloat256Mask) m, offsetInRange);  // specialize
 +    }
 +
 +    @ForceInline
 +    @Override
 +    final
 +    void intoArray0(short[] a, int offset) {
 +        super.intoArray0Template(a, offset);  // specialize
 +    }
 +
 +    @ForceInline
 +    @Override
 +    final
-     void intoArray0(short[] a, int offset, VectorMask<Halffloat> m) {
++    void intoArray0(short[] a, int offset, VectorMask<Float16> m) {
 +        super.intoArray0Template(Halffloat256Mask.class, a, offset, (Halffloat256Mask) m);
 +    }
 +
 +
 +
 +    @ForceInline
 +    @Override
 +    final
-     void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Halffloat> m) {
++    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m) {
 +        super.intoMemorySegment0Template(Halffloat256Mask.class, ms, offset, (Halffloat256Mask) m);
 +    }
 +
 +    @ForceInline
 +    @Override
 +    final
-     void intoCharArray0(char[] a, int offset, VectorMask<Halffloat> m) {
++    void intoCharArray0(char[] a, int offset, VectorMask<Float16> m) {
 +        super.intoCharArray0Template(Halffloat256Mask.class, a, offset, (Halffloat256Mask) m);
 +    }
 +
 +    // End of specialized low-level memory operations.
 +
 +    // ================================================
 +
 +}
 +
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Halffloat512Vector.java
index 24498111a19,00000000000..74c9aa2ec9d
mode 100644,000000..100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Halffloat512Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Halffloat512Vector.java
@@@ -1,999 -1,0 +1,1090 @@@
 +/*
-  * Copyright (c) 2017, 2023, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
 + * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 + *
 + * This code is free software; you can redistribute it and/or modify it
 + * under the terms of the GNU General Public License version 2 only, as
 + * published by the Free Software Foundation.  Oracle designates this
 + * particular file as subject to the "Classpath" exception as provided
 + * by Oracle in the LICENSE file that accompanied this code.
 + *
 + * This code is distributed in the hope that it will be useful, but WITHOUT
 + * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 + * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 + * version 2 for more details (a copy is included in the LICENSE file that
 + * accompanied this code).
 + *
 + * You should have received a copy of the GNU General Public License version
 + * 2 along with this work; if not, write to the Free Software Foundation,
 + * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 + *
 + * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 + * or visit www.oracle.com if you need additional information or have any
 + * questions.
 + */
 +package jdk.incubator.vector;
 +
 +import java.lang.foreign.MemorySegment;
++import java.lang.foreign.ValueLayout;
++import java.nio.ByteOrder;
 +import java.util.Arrays;
 +import java.util.Objects;
 +import java.util.function.IntUnaryOperator;
 +
 +import jdk.internal.vm.annotation.ForceInline;
 +import jdk.internal.vm.vector.VectorSupport;
 +
 +import static jdk.internal.vm.vector.VectorSupport.*;
 +
 +import static jdk.incubator.vector.VectorOperators.*;
 +
 +// -- This file was mechanically generated: Do not edit! -- //
 +
 +@SuppressWarnings("cast")  // warning: redundant cast
 +final class Halffloat512Vector extends HalffloatVector {
 +    static final HalffloatSpecies VSPECIES =
 +        (HalffloatSpecies) HalffloatVector.SPECIES_512;
 +
 +    static final VectorShape VSHAPE =
 +        VSPECIES.vectorShape();
 +
 +    static final Class<Halffloat512Vector> VCLASS = Halffloat512Vector.class;
 +
 +    static final int VSIZE = VSPECIES.vectorBitSize();
 +
 +    static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
 +
-     static final Class<Halffloat> ETYPE = Halffloat.class; // used by the JVM
++    static final Class<Short> CTYPE = short.class; // carrier type used by the JVM
++
++    static final Class<Float16> ETYPE = Float16.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_FP16;
 +
 +    Halffloat512Vector(short[] v) {
 +        super(v);
 +    }
 +
 +    // For compatibility as Halffloat512Vector::new,
 +    // stored into species.vectorFactory.
 +    Halffloat512Vector(Object v) {
 +        this((short[]) v);
 +    }
 +
 +    static final Halffloat512Vector ZERO = new Halffloat512Vector(new short[VLENGTH]);
 +    static final Halffloat512Vector IOTA = new Halffloat512Vector(VSPECIES.iotaArray());
 +
 +    static {
 +        // Warm up a few species caches.
 +        // If we do this too much we will
 +        // get NPEs from bootstrap circularity.
 +        VSPECIES.dummyVector();
 +        VSPECIES.withLanes(LaneType.BYTE);
 +    }
 +
 +    // Specialized extractors
 +
 +    @ForceInline
 +    final @Override
 +    public HalffloatSpecies vspecies() {
 +        // ISSUE:  This should probably be a @Stable
 +        // field inside AbstractVector, rather than
 +        // a megamorphic method.
 +        return VSPECIES;
 +    }
 +
++    @ForceInline
++    final Class<Short> carrierType() { return CTYPE; }
++
 +    @ForceInline
 +    @Override
-     public final Class<Halffloat> elementType() { return Halffloat.class; }
++    public final Class<Float16> elementType() { return ETYPE; }
 +
 +    @ForceInline
 +    @Override
-     public final int elementSize() { return Halffloat.SIZE; }
++    public final int elementSize() { return Float16.SIZE; }
 +
 +    @ForceInline
 +    @Override
 +    public final VectorShape shape() { return VSHAPE; }
 +
 +    @ForceInline
 +    @Override
 +    public final int length() { return VLENGTH; }
 +
 +    @ForceInline
 +    @Override
 +    public final int bitSize() { return VSIZE; }
 +
 +    @ForceInline
 +    @Override
 +    public final int byteSize() { return VSIZE / Byte.SIZE; }
 +
 +    /*package-private*/
 +    @ForceInline
 +    final @Override
 +    short[] vec() {
 +        return (short[])getPayload();
 +    }
 +
 +    // Virtualized constructors
 +
 +    @Override
 +    @ForceInline
 +    public final Halffloat512Vector broadcast(short e) {
 +        return (Halffloat512Vector) super.broadcastTemplate(e);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final Halffloat512Vector broadcast(long e) {
 +        return (Halffloat512Vector) super.broadcastTemplate(e);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    Halffloat512Mask maskFromArray(boolean[] bits) {
 +        return new Halffloat512Mask(bits);
 +    }
 +
 +    @Override
 +    @ForceInline
 +    Halffloat512Shuffle iotaShuffle() { return Halffloat512Shuffle.IOTA; }
 +
++    @Override
++    @ForceInline
++    Halffloat512Shuffle iotaShuffle(int start, int step, boolean wrap) {
++        return (Halffloat512Shuffle) iotaShuffleTemplate((short) start, (short) step, wrap);
++    }
++
 +    @Override
 +    @ForceInline
 +    Halffloat512Shuffle shuffleFromArray(int[] indices, int i) { return new Halffloat512Shuffle(indices, i); }
 +
 +    @Override
 +    @ForceInline
 +    Halffloat512Shuffle shuffleFromOp(IntUnaryOperator fn) { return new Halffloat512Shuffle(fn); }
 +
 +    // Make a vector of the same species but the given elements:
 +    @ForceInline
 +    final @Override
 +    Halffloat512Vector vectorFactory(short[] vec) {
 +        return new Halffloat512Vector(vec);
 +    }
 +
 +    @ForceInline
 +    final @Override
 +    Byte512Vector asByteVectorRaw() {
 +        return (Byte512Vector) super.asByteVectorRawTemplate();  // specialize
 +    }
 +
 +    @ForceInline
 +    final @Override
 +    AbstractVector<?> asVectorRaw(LaneType laneType) {
 +        return super.asVectorRawTemplate(laneType);  // specialize
 +    }
 +
 +    // Unary operator
 +
 +    @ForceInline
 +    final @Override
 +    Halffloat512Vector uOp(FUnOp f) {
 +        return (Halffloat512Vector) super.uOpTemplate(f);  // specialize
 +    }
 +
 +    @ForceInline
 +    final @Override
-     Halffloat512Vector uOp(VectorMask<Halffloat> m, FUnOp f) {
++    Halffloat512Vector uOp(VectorMask<Float16> m, FUnOp f) {
 +        return (Halffloat512Vector)
 +            super.uOpTemplate((Halffloat512Mask)m, f);  // specialize
 +    }
 +
 +    // Binary operator
 +
 +    @ForceInline
 +    final @Override
-     Halffloat512Vector bOp(Vector<Halffloat> v, FBinOp f) {
++    Halffloat512Vector bOp(Vector<Float16> v, FBinOp f) {
 +        return (Halffloat512Vector) super.bOpTemplate((Halffloat512Vector)v, f);  // specialize
 +    }
 +
 +    @ForceInline
 +    final @Override
-     Halffloat512Vector bOp(Vector<Halffloat> v,
-                      VectorMask<Halffloat> m, FBinOp f) {
++    Halffloat512Vector bOp(Vector<Float16> v,
++                     VectorMask<Float16> m, FBinOp f) {
 +        return (Halffloat512Vector)
 +            super.bOpTemplate((Halffloat512Vector)v, (Halffloat512Mask)m,
 +                              f);  // specialize
 +    }
 +
 +    // Ternary operator
 +
 +    @ForceInline
 +    final @Override
-     Halffloat512Vector tOp(Vector<Halffloat> v1, Vector<Halffloat> v2, FTriOp f) {
++    Halffloat512Vector tOp(Vector<Float16> v1, Vector<Float16> v2, FTriOp f) {
 +        return (Halffloat512Vector)
 +            super.tOpTemplate((Halffloat512Vector)v1, (Halffloat512Vector)v2,
 +                              f);  // specialize
 +    }
 +
 +    @ForceInline
 +    final @Override
-     Halffloat512Vector tOp(Vector<Halffloat> v1, Vector<Halffloat> v2,
-                      VectorMask<Halffloat> m, FTriOp f) {
++    Halffloat512Vector tOp(Vector<Float16> v1, Vector<Float16> v2,
++                     VectorMask<Float16> m, FTriOp f) {
 +        return (Halffloat512Vector)
 +            super.tOpTemplate((Halffloat512Vector)v1, (Halffloat512Vector)v2,
 +                              (Halffloat512Mask)m, f);  // specialize
 +    }
 +
 +    @ForceInline
 +    final @Override
-     short rOp(short v, VectorMask<Halffloat> m, FBinOp f) {
++    short rOp(short v, VectorMask<Float16> m, FBinOp f) {
 +        return super.rOpTemplate(v, m, f);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final <F>
-     Vector<F> convertShape(VectorOperators.Conversion<Halffloat,F> conv,
++    Vector<F> convertShape(VectorOperators.Conversion<Float16,F> conv,
 +                           VectorSpecies<F> rsp, int part) {
 +        return super.convertShapeTemplate(conv, rsp, part);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final <F>
 +    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {
 +        return super.reinterpretShapeTemplate(toSpecies, part);  // specialize
 +    }
 +
 +    // Specialized algebraic operations:
 +
 +    // The following definition forces a specialized version of this
 +    // crucial method into the v-table of this class.  A call to add()
 +    // will inline to a call to lanewise(ADD,), at which point the JIT
 +    // intrinsic will have the opcode of ADD, plus all the metadata
 +    // for this particular class, enabling it to generate precise
 +    // code.
 +    //
 +    // There is probably no benefit to the JIT to specialize the
 +    // masked or broadcast versions of the lanewise method.
 +
 +    @Override
 +    @ForceInline
 +    public Halffloat512Vector lanewise(Unary op) {
 +        return (Halffloat512Vector) super.lanewiseTemplate(op);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat512Vector lanewise(Unary op, VectorMask<Halffloat> m) {
++    public Halffloat512Vector lanewise(Unary op, VectorMask<Float16> m) {
 +        return (Halffloat512Vector) super.lanewiseTemplate(op, Halffloat512Mask.class, (Halffloat512Mask) m);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat512Vector lanewise(Binary op, Vector<Halffloat> v) {
++    public Halffloat512Vector lanewise(Binary op, Vector<Float16> v) {
 +        return (Halffloat512Vector) super.lanewiseTemplate(op, v);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat512Vector lanewise(Binary op, Vector<Halffloat> v, VectorMask<Halffloat> m) {
++    public Halffloat512Vector lanewise(Binary op, Vector<Float16> v, VectorMask<Float16> m) {
 +        return (Halffloat512Vector) super.lanewiseTemplate(op, Halffloat512Mask.class, v, (Halffloat512Mask) m);  // specialize
 +    }
 +
 +
 +    /*package-private*/
 +    @Override
 +    @ForceInline
 +    public final
 +    Halffloat512Vector
-     lanewise(Ternary op, Vector<Halffloat> v1, Vector<Halffloat> v2) {
++    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2) {
 +        return (Halffloat512Vector) super.lanewiseTemplate(op, v1, v2);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final
 +    Halffloat512Vector
-     lanewise(Ternary op, Vector<Halffloat> v1, Vector<Halffloat> v2, VectorMask<Halffloat> m) {
++    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2, VectorMask<Float16> m) {
 +        return (Halffloat512Vector) super.lanewiseTemplate(op, Halffloat512Mask.class, v1, v2, (Halffloat512Mask) m);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final
 +    Halffloat512Vector addIndex(int scale) {
 +        return (Halffloat512Vector) super.addIndexTemplate(scale);  // specialize
 +    }
 +
 +    // Type specific horizontal reductions
 +
 +    @Override
 +    @ForceInline
 +    public final short reduceLanes(VectorOperators.Associative op) {
 +        return super.reduceLanesTemplate(op);  // specialized
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final short reduceLanes(VectorOperators.Associative op,
-                                     VectorMask<Halffloat> m) {
++                                    VectorMask<Float16> m) {
 +        return super.reduceLanesTemplate(op, Halffloat512Mask.class, (Halffloat512Mask) m);  // specialized
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final long reduceLanesToLong(VectorOperators.Associative op) {
 +        return (long) super.reduceLanesTemplate(op);  // specialized
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final long reduceLanesToLong(VectorOperators.Associative op,
-                                         VectorMask<Halffloat> m) {
++                                        VectorMask<Float16> m) {
 +        return (long) super.reduceLanesTemplate(op, Halffloat512Mask.class, (Halffloat512Mask) m);  // specialized
 +    }
 +
 +    @Override
 +    @ForceInline
-     public final
-     <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {
-         return super.toShuffleTemplate(dsp);
++    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {
++        throw new AssertionError();
++    }
++
++    @Override
++    @ForceInline
++    public final Halffloat512Shuffle toShuffle() {
++        return (Halffloat512Shuffle) toShuffle(vspecies(), false);
 +    }
 +
 +    // Specialized unary testing
 +
 +    @Override
 +    @ForceInline
 +    public final Halffloat512Mask test(Test op) {
 +        return super.testTemplate(Halffloat512Mask.class, op);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public final Halffloat512Mask test(Test op, VectorMask<Halffloat> m) {
++    public final Halffloat512Mask test(Test op, VectorMask<Float16> m) {
 +        return super.testTemplate(Halffloat512Mask.class, op, (Halffloat512Mask) m);  // specialize
 +    }
 +
 +    // Specialized comparisons
 +
 +    @Override
 +    @ForceInline
-     public final Halffloat512Mask compare(Comparison op, Vector<Halffloat> v) {
++    public final Halffloat512Mask compare(Comparison op, Vector<Float16> v) {
 +        return super.compareTemplate(Halffloat512Mask.class, op, v);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final Halffloat512Mask compare(Comparison op, short s) {
 +        return super.compareTemplate(Halffloat512Mask.class, op, s);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final Halffloat512Mask compare(Comparison op, long s) {
 +        return super.compareTemplate(Halffloat512Mask.class, op, s);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public final Halffloat512Mask compare(Comparison op, Vector<Halffloat> v, VectorMask<Halffloat> m) {
++    public final Halffloat512Mask compare(Comparison op, Vector<Float16> v, VectorMask<Float16> m) {
 +        return super.compareTemplate(Halffloat512Mask.class, op, v, (Halffloat512Mask) m);
 +    }
 +
 +
 +    @Override
 +    @ForceInline
-     public Halffloat512Vector blend(Vector<Halffloat> v, VectorMask<Halffloat> m) {
++    public Halffloat512Vector blend(Vector<Float16> v, VectorMask<Float16> m) {
 +        return (Halffloat512Vector)
 +            super.blendTemplate(Halffloat512Mask.class,
 +                                (Halffloat512Vector) v,
 +                                (Halffloat512Mask) m);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat512Vector slice(int origin, Vector<Halffloat> v) {
++    public Halffloat512Vector slice(int origin, Vector<Float16> v) {
 +        return (Halffloat512Vector) super.sliceTemplate(origin, v);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public Halffloat512Vector slice(int origin) {
 +        return (Halffloat512Vector) super.sliceTemplate(origin);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat512Vector unslice(int origin, Vector<Halffloat> w, int part) {
++    public Halffloat512Vector unslice(int origin, Vector<Float16> w, int part) {
 +        return (Halffloat512Vector) super.unsliceTemplate(origin, w, part);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat512Vector unslice(int origin, Vector<Halffloat> w, int part, VectorMask<Halffloat> m) {
++    public Halffloat512Vector unslice(int origin, Vector<Float16> w, int part, VectorMask<Float16> m) {
 +        return (Halffloat512Vector)
 +            super.unsliceTemplate(Halffloat512Mask.class,
 +                                  origin, w, part,
 +                                  (Halffloat512Mask) m);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public Halffloat512Vector unslice(int origin) {
 +        return (Halffloat512Vector) super.unsliceTemplate(origin);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat512Vector rearrange(VectorShuffle<Halffloat> s) {
++    public Halffloat512Vector rearrange(VectorShuffle<Float16> s) {
 +        return (Halffloat512Vector)
 +            super.rearrangeTemplate(Halffloat512Shuffle.class,
 +                                    (Halffloat512Shuffle) s);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat512Vector rearrange(VectorShuffle<Halffloat> shuffle,
-                                   VectorMask<Halffloat> m) {
++    public Halffloat512Vector rearrange(VectorShuffle<Float16> shuffle,
++                                  VectorMask<Float16> m) {
 +        return (Halffloat512Vector)
 +            super.rearrangeTemplate(Halffloat512Shuffle.class,
 +                                    Halffloat512Mask.class,
 +                                    (Halffloat512Shuffle) shuffle,
 +                                    (Halffloat512Mask) m);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat512Vector rearrange(VectorShuffle<Halffloat> s,
-                                   Vector<Halffloat> v) {
++    public Halffloat512Vector rearrange(VectorShuffle<Float16> s,
++                                  Vector<Float16> v) {
 +        return (Halffloat512Vector)
 +            super.rearrangeTemplate(Halffloat512Shuffle.class,
 +                                    (Halffloat512Shuffle) s,
 +                                    (Halffloat512Vector) v);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat512Vector compress(VectorMask<Halffloat> m) {
++    public Halffloat512Vector compress(VectorMask<Float16> m) {
 +        return (Halffloat512Vector)
 +            super.compressTemplate(Halffloat512Mask.class,
 +                                   (Halffloat512Mask) m);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat512Vector expand(VectorMask<Halffloat> m) {
++    public Halffloat512Vector expand(VectorMask<Float16> m) {
 +        return (Halffloat512Vector)
 +            super.expandTemplate(Halffloat512Mask.class,
 +                                   (Halffloat512Mask) m);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat512Vector selectFrom(Vector<Halffloat> v) {
++    public Halffloat512Vector selectFrom(Vector<Float16> v) {
 +        return (Halffloat512Vector)
 +            super.selectFromTemplate((Halffloat512Vector) v);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat512Vector selectFrom(Vector<Halffloat> v,
-                                    VectorMask<Halffloat> m) {
++    public Halffloat512Vector selectFrom(Vector<Float16> v,
++                                   VectorMask<Float16> m) {
 +        return (Halffloat512Vector)
 +            super.selectFromTemplate((Halffloat512Vector) v,
-                                      (Halffloat512Mask) m);  // specialize
++                                     Halffloat512Mask.class, (Halffloat512Mask) m);  // specialize
 +    }
 +
++    @Override
++    @ForceInline
++    public Halffloat512Vector selectFrom(Vector<Float16> v1,
++                                   Vector<Float16> v2) {
++        return (Halffloat512Vector)
++            super.selectFromTemplate((Halffloat512Vector) v1, (Halffloat512Vector) v2);  // specialize
++    }
 +
 +    @ForceInline
 +    @Override
 +    public short lane(int i) {
 +        short bits;
 +        switch(i) {
 +            case 0: bits = laneHelper(0); break;
 +            case 1: bits = laneHelper(1); break;
 +            case 2: bits = laneHelper(2); break;
 +            case 3: bits = laneHelper(3); break;
 +            case 4: bits = laneHelper(4); break;
 +            case 5: bits = laneHelper(5); break;
 +            case 6: bits = laneHelper(6); break;
 +            case 7: bits = laneHelper(7); break;
 +            case 8: bits = laneHelper(8); break;
 +            case 9: bits = laneHelper(9); break;
 +            case 10: bits = laneHelper(10); break;
 +            case 11: bits = laneHelper(11); break;
 +            case 12: bits = laneHelper(12); break;
 +            case 13: bits = laneHelper(13); break;
 +            case 14: bits = laneHelper(14); break;
 +            case 15: bits = laneHelper(15); break;
 +            case 16: bits = laneHelper(16); break;
 +            case 17: bits = laneHelper(17); break;
 +            case 18: bits = laneHelper(18); break;
 +            case 19: bits = laneHelper(19); break;
 +            case 20: bits = laneHelper(20); break;
 +            case 21: bits = laneHelper(21); break;
 +            case 22: bits = laneHelper(22); break;
 +            case 23: bits = laneHelper(23); break;
 +            case 24: bits = laneHelper(24); break;
 +            case 25: bits = laneHelper(25); break;
 +            case 26: bits = laneHelper(26); break;
 +            case 27: bits = laneHelper(27); break;
 +            case 28: bits = laneHelper(28); break;
 +            case 29: bits = laneHelper(29); break;
 +            case 30: bits = laneHelper(30); break;
 +            case 31: bits = laneHelper(31); break;
 +            default: throw new IllegalArgumentException("Index " + i + " must be zero or positive, and less than " + VLENGTH);
 +        }
-         return Halffloat.shortBitsToHalffloat(bits);
++        return bits;
 +    }
 +
++    @ForceInline
 +    public short laneHelper(int i) {
 +        return (short) VectorSupport.extract(
-                      VCLASS, ETYPE, VLENGTH,
++                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
 +                     this, i,
 +                     (vec, ix) -> {
 +                     short[] vecarr = vec.vec();
-                      return (long)Halffloat.shortToShortBits(vecarr[ix]);
++                     return vecarr[ix];
 +                     });
 +    }
 +
 +    @ForceInline
 +    @Override
 +    public Halffloat512Vector withLane(int i, short e) {
 +        switch(i) {
 +            case 0: return withLaneHelper(0, e);
 +            case 1: return withLaneHelper(1, e);
 +            case 2: return withLaneHelper(2, e);
 +            case 3: return withLaneHelper(3, e);
 +            case 4: return withLaneHelper(4, e);
 +            case 5: return withLaneHelper(5, e);
 +            case 6: return withLaneHelper(6, e);
 +            case 7: return withLaneHelper(7, e);
 +            case 8: return withLaneHelper(8, e);
 +            case 9: return withLaneHelper(9, e);
 +            case 10: return withLaneHelper(10, e);
 +            case 11: return withLaneHelper(11, e);
 +            case 12: return withLaneHelper(12, e);
 +            case 13: return withLaneHelper(13, e);
 +            case 14: return withLaneHelper(14, e);
 +            case 15: return withLaneHelper(15, e);
 +            case 16: return withLaneHelper(16, e);
 +            case 17: return withLaneHelper(17, e);
 +            case 18: return withLaneHelper(18, e);
 +            case 19: return withLaneHelper(19, e);
 +            case 20: return withLaneHelper(20, e);
 +            case 21: return withLaneHelper(21, e);
 +            case 22: return withLaneHelper(22, e);
 +            case 23: return withLaneHelper(23, e);
 +            case 24: return withLaneHelper(24, e);
 +            case 25: return withLaneHelper(25, e);
 +            case 26: return withLaneHelper(26, e);
 +            case 27: return withLaneHelper(27, e);
 +            case 28: return withLaneHelper(28, e);
 +            case 29: return withLaneHelper(29, e);
 +            case 30: return withLaneHelper(30, e);
 +            case 31: return withLaneHelper(31, e);
 +            default: throw new IllegalArgumentException("Index " + i + " must be zero or positive, and less than " + VLENGTH);
 +        }
 +    }
 +
++    @ForceInline
 +    public Halffloat512Vector withLaneHelper(int i, short e) {
 +        return VectorSupport.insert(
-                                 VCLASS, ETYPE, VLENGTH,
-                                 this, i, (long)Halffloat.shortToShortBits(e),
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                this, i, (long)e,
 +                                (v, ix, bits) -> {
 +                                    short[] res = v.vec().clone();
-                                     res[ix] = Halffloat.shortBitsToHalffloat((short)bits);
++                                    res[ix] = e;
 +                                    return v.vectorFactory(res);
 +                                });
 +    }
 +
 +    // Mask
 +
-     static final class Halffloat512Mask extends AbstractMask<Halffloat> {
++    static final class Halffloat512Mask extends AbstractMask<Float16> {
 +        static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
-         static final Class<Halffloat> ETYPE = Halffloat.class; // used by the JVM
++        static final Class<Short> CTYPE = short.class; // used by the JVM
 +
 +        Halffloat512Mask(boolean[] bits) {
 +            this(bits, 0);
 +        }
 +
 +        Halffloat512Mask(boolean[] bits, int offset) {
 +            super(prepare(bits, offset));
 +        }
 +
 +        Halffloat512Mask(boolean val) {
 +            super(prepare(val));
 +        }
 +
 +        private static boolean[] prepare(boolean[] bits, int offset) {
 +            boolean[] newBits = new boolean[VSPECIES.laneCount()];
 +            for (int i = 0; i < newBits.length; i++) {
 +                newBits[i] = bits[offset + i];
 +            }
 +            return newBits;
 +        }
 +
 +        private static boolean[] prepare(boolean val) {
 +            boolean[] bits = new boolean[VSPECIES.laneCount()];
 +            Arrays.fill(bits, val);
 +            return bits;
 +        }
 +
 +        @ForceInline
 +        final @Override
 +        public HalffloatSpecies vspecies() {
 +            // ISSUE:  This should probably be a @Stable
 +            // field inside AbstractMask, rather than
 +            // a megamorphic method.
 +            return VSPECIES;
 +        }
 +
 +        @ForceInline
 +        boolean[] getBits() {
 +            return (boolean[])getPayload();
 +        }
 +
 +        @Override
 +        Halffloat512Mask uOp(MUnOp f) {
 +            boolean[] res = new boolean[vspecies().laneCount()];
 +            boolean[] bits = getBits();
 +            for (int i = 0; i < res.length; i++) {
 +                res[i] = f.apply(i, bits[i]);
 +            }
 +            return new Halffloat512Mask(res);
 +        }
 +
 +        @Override
-         Halffloat512Mask bOp(VectorMask<Halffloat> m, MBinOp f) {
++        Halffloat512Mask bOp(VectorMask<Float16> m, MBinOp f) {
 +            boolean[] res = new boolean[vspecies().laneCount()];
 +            boolean[] bits = getBits();
 +            boolean[] mbits = ((Halffloat512Mask)m).getBits();
 +            for (int i = 0; i < res.length; i++) {
 +                res[i] = f.apply(i, bits[i], mbits[i]);
 +            }
 +            return new Halffloat512Mask(res);
 +        }
 +
 +        @ForceInline
 +        @Override
 +        public final
 +        Halffloat512Vector toVector() {
 +            return (Halffloat512Vector) super.toVectorTemplate();  // specialize
 +        }
 +
 +        /**
 +         * Helper function for lane-wise mask conversions.
 +         * This function kicks in after intrinsic failure.
 +         */
 +        @ForceInline
 +        private final <E>
 +        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {
 +            if (length() != dsp.laneCount())
 +                throw new IllegalArgumentException("VectorMask length and species length differ");
 +            boolean[] maskArray = toArray();
 +            return  dsp.maskFactory(maskArray).check(dsp);
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
 +            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;
 +            if (length() != species.laneCount())
 +                throw new IllegalArgumentException("VectorMask length and species length differ");
 +
 +            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,
 +                this.getClass(), ETYPE, VLENGTH,
 +                species.maskType(), species.elementType(), VLENGTH,
 +                this, species,
 +                (m, s) -> s.maskFactory(m.toArray()).check(s));
 +        }
 +
 +        @Override
 +        @ForceInline
 +        /*package-private*/
 +        Halffloat512Mask indexPartiallyInUpperRange(long offset, long limit) {
 +            return (Halffloat512Mask) VectorSupport.indexPartiallyInUpperRange(
-                 Halffloat512Mask.class, ETYPE, VLENGTH, offset, limit,
++                Halffloat512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
 +                (o, l) -> (Halffloat512Mask) TRUE_MASK.indexPartiallyInRange(o, l));
 +        }
 +
 +        // Unary operations
 +
 +        @Override
 +        @ForceInline
 +        public Halffloat512Mask not() {
 +            return xor(maskAll(true));
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public Halffloat512Mask compress() {
 +            return (Halffloat512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                 Halffloat512Vector.class, Halffloat512Mask.class, ETYPE, VLENGTH, null, this,
-                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, Float.floatToFloat16(m1.trueCount())));
++                Halffloat512Vector.class, Halffloat512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                Float16.float16ToShortBits(Float16.valueOf(m1.trueCount()))));
 +        }
 +
 +
 +        // Binary operations
 +
 +        @Override
 +        @ForceInline
-         public Halffloat512Mask and(VectorMask<Halffloat> mask) {
++        public Halffloat512Mask and(VectorMask<Float16> mask) {
 +            Objects.requireNonNull(mask);
 +            Halffloat512Mask m = (Halffloat512Mask)mask;
-             return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat512Mask.class, null, Halffloat.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat512Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
 +                                          this, m, null,
 +                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
 +        }
 +
 +        @Override
 +        @ForceInline
-         public Halffloat512Mask or(VectorMask<Halffloat> mask) {
++        public Halffloat512Mask or(VectorMask<Float16> mask) {
 +            Objects.requireNonNull(mask);
 +            Halffloat512Mask m = (Halffloat512Mask)mask;
-             return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat512Mask.class, null, Halffloat.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat512Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
 +                                          this, m, null,
 +                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
 +        }
 +
 +        @Override
 +        @ForceInline
-         public Halffloat512Mask xor(VectorMask<Halffloat> mask) {
++        public Halffloat512Mask xor(VectorMask<Float16> mask) {
 +            Objects.requireNonNull(mask);
 +            Halffloat512Mask m = (Halffloat512Mask)mask;
-             return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat512Mask.class, null, Halffloat.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat512Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
 +                                          this, m, null,
 +                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
 +        }
 +
 +        // Mask Query operations
 +
 +        @Override
 +        @ForceInline
 +        public int trueCount() {
-             return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat512Mask.class, Halffloat.class, VLENGTH, this,
-                                                       (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat512Mask.class, short.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public int firstTrue() {
-             return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat512Mask.class, Halffloat.class, VLENGTH, this,
-                                                       (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat512Mask.class, short.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public int lastTrue() {
-             return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat512Mask.class, Halffloat.class, VLENGTH, this,
-                                                       (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat512Mask.class, short.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public long toLong() {
 +            if (length() > Long.SIZE) {
 +                throw new UnsupportedOperationException("too many lanes for one long");
 +            }
-             return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat512Mask.class, Halffloat.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat512Mask.class, short.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
 +                                                      (m) -> toLongHelper(m.getBits()));
 +        }
 +
++        // laneIsSet
++
++        @Override
++        @ForceInline
++        public boolean laneIsSet(int i) {
++            Objects.checkIndex(i, length());
++            return VectorSupport.extract(Halffloat512Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
++        }
++
 +        // Reductions
 +
 +        @Override
 +        @ForceInline
 +        public boolean anyTrue() {
-             return VectorSupport.test(BT_ne, Halffloat512Mask.class, Halffloat.class, VLENGTH,
-                                          this, vspecies().maskAll(true),
-                                          (m, __) -> anyTrueHelper(((Halffloat512Mask)m).getBits()));
++            return VectorSupport.test(BT_ne, Halffloat512Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper(((Halffloat512Mask)m).getBits()));
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public boolean allTrue() {
-             return VectorSupport.test(BT_overflow, Halffloat512Mask.class, Halffloat.class, VLENGTH,
-                                          this, vspecies().maskAll(true),
-                                          (m, __) -> allTrueHelper(((Halffloat512Mask)m).getBits()));
++            return VectorSupport.test(BT_overflow, Halffloat512Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper(((Halffloat512Mask)m).getBits()));
 +        }
 +
 +        @ForceInline
 +        /*package-private*/
 +        static Halffloat512Mask maskAll(boolean bit) {
-             return VectorSupport.fromBitsCoerced(Halffloat512Mask.class, Halffloat.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced(Halffloat512Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
 +                                                 (bit ? -1 : 0), MODE_BROADCAST, null,
 +                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
 +        }
 +        private static final Halffloat512Mask  TRUE_MASK = new Halffloat512Mask(true);
 +        private static final Halffloat512Mask FALSE_MASK = new Halffloat512Mask(false);
 +
 +    }
 +
 +    // Shuffle
 +
-     static final class Halffloat512Shuffle extends AbstractShuffle<Halffloat> {
++    static final class Halffloat512Shuffle extends AbstractShuffle<Float16> {
 +        static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
-         static final Class<Short> ETYPE = short.class; // used by the JVM
++        static final Class<Short> CTYPE = short.class; // used by the JVM
 +
 +        Halffloat512Shuffle(short[] indices) {
 +            super(indices);
 +            assert(VLENGTH == indices.length);
 +            assert(indicesInRange(indices));
 +        }
 +
 +        Halffloat512Shuffle(int[] indices, int i) {
 +            this(prepare(indices, i));
 +        }
 +
 +        Halffloat512Shuffle(IntUnaryOperator fn) {
 +            this(prepare(fn));
 +        }
 +
 +        short[] indices() {
 +            return (short[])getPayload();
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public HalffloatSpecies vspecies() {
 +            return VSPECIES;
 +        }
 +
 +        static {
 +            // There must be enough bits in the shuffle lanes to encode
 +            // VLENGTH valid indexes and VLENGTH exceptional ones.
 +            assert(VLENGTH < Short.MAX_VALUE);
 +            assert(Short.MIN_VALUE <= -VLENGTH);
 +        }
 +        static final Halffloat512Shuffle IOTA = new Halffloat512Shuffle(IDENTITY);
 +
++        @Override
++        @ForceInline
++        public Halffloat512Vector toVector() {
++            return (Halffloat512Vector) toBitsVector().castShape(vspecies(), 0);
++        }
++
 +        @Override
 +        @ForceInline
 +        Short512Vector toBitsVector() {
 +            return (Short512Vector) super.toBitsVectorTemplate();
 +        }
 +
 +        @Override
-         @ForceInline
-         ShortVector toBitsVector0() {
-             return Short512Vector.VSPECIES.dummyVector().vectorFactory(indices());
++        Short512Vector toBitsVector0() {
++            return ((Short512Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public int laneSource(int i) {
 +            return (int)toBitsVector().lane(i);
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public void intoArray(int[] a, int offset) {
 +            VectorSpecies<Integer> species = IntVector.SPECIES_512;
 +            Vector<Short> v = toBitsVector();
 +            v.convertShape(VectorOperators.S2I, species, 0)
 +                    .reinterpretAsInts()
 +                    .intoArray(a, offset);
 +            v.convertShape(VectorOperators.S2I, species, 1)
 +                    .reinterpretAsInts()
 +                    .intoArray(a, offset + species.length());
 +        }
 +
++        @Override
++        @ForceInline
++        public void intoMemorySegment(MemorySegment ms, long offset, ByteOrder bo) {
++            VectorSpecies<Integer> species = IntVector.SPECIES_512;
++            Vector<Short> v = toBitsVector();
++            v.convertShape(VectorOperators.S2I, species, 0)
++                    .reinterpretAsInts()
++                    .intoMemorySegment(ms, offset, bo);
++            v.convertShape(VectorOperators.S2I, species, 1)
++                    .reinterpretAsInts()
++                    .intoMemorySegment(ms, offset + species.vectorByteSize(), bo);
++         }
++
++        @Override
++        @ForceInline
++        public final Halffloat512Mask laneIsValid() {
++            return (Halffloat512Mask) toBitsVector().compare(VectorOperators.GE, 0)
++                    .cast(vspecies());
++        }
++
++        @ForceInline
++        @Override
++        public final Halffloat512Shuffle rearrange(VectorShuffle<Float16> shuffle) {
++            Halffloat512Shuffle concreteShuffle = (Halffloat512Shuffle) shuffle;
++            return (Halffloat512Shuffle) toBitsVector().rearrange(concreteShuffle.cast(ShortVector.SPECIES_512))
++                    .toShuffle(vspecies(), false);
++        }
++
++        @ForceInline
++        @Override
++        public final Halffloat512Shuffle wrapIndexes() {
++            Short512Vector v = toBitsVector();
++            if ((length() & (length() - 1)) == 0) {
++                v = (Short512Vector) v.lanewise(VectorOperators.AND, length() - 1);
++            } else {
++                v = (Short512Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),
++                            v.compare(VectorOperators.LT, 0));
++            }
++            return (Halffloat512Shuffle) v.toShuffle(vspecies(), false);
++        }
++
 +        private static short[] prepare(int[] indices, int offset) {
 +            short[] a = new short[VLENGTH];
 +            for (int i = 0; i < VLENGTH; i++) {
 +                int si = indices[offset + i];
 +                si = partiallyWrapIndex(si, VLENGTH);
 +                a[i] = (short)si;
 +            }
 +            return a;
 +        }
 +
 +        private static short[] prepare(IntUnaryOperator f) {
 +            short[] a = new short[VLENGTH];
 +            for (int i = 0; i < VLENGTH; i++) {
 +                int si = f.applyAsInt(i);
 +                si = partiallyWrapIndex(si, VLENGTH);
 +                a[i] = (short)si;
 +            }
 +            return a;
 +        }
 +
 +        private static boolean indicesInRange(short[] indices) {
 +            int length = indices.length;
 +            for (short si : indices) {
 +                if (si >= (short)length || si < (short)(-length)) {
-                     boolean assertsEnabled = false;
-                     assert(assertsEnabled = true);
-                     if (assertsEnabled) {
-                         String msg = ("index "+si+"out of range ["+length+"] in "+
++                    String msg = ("index "+si+"out of range ["+length+"] in "+
 +                                  java.util.Arrays.toString(indices));
-                         throw new AssertionError(msg);
-                     }
-                     return false;
++                    throw new AssertionError(msg);
 +                }
 +            }
 +            return true;
 +        }
 +    }
 +
 +    // ================================================
 +
 +    // Specialized low-level memory operations.
 +
 +    @ForceInline
 +    @Override
 +    final
 +    HalffloatVector fromArray0(short[] a, int offset) {
 +        return super.fromArray0Template(a, offset);  // specialize
 +    }
 +
 +    @ForceInline
 +    @Override
 +    final
-     HalffloatVector fromArray0(short[] a, int offset, VectorMask<Halffloat> m, int offsetInRange) {
++    HalffloatVector fromArray0(short[] a, int offset, VectorMask<Float16> m, int offsetInRange) {
 +        return super.fromArray0Template(Halffloat512Mask.class, a, offset, (Halffloat512Mask) m, offsetInRange);  // specialize
 +    }
 +
++    @ForceInline
++    @Override
++    final
++    HalffloatVector fromArray0(short[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float16> m) {
++        return super.fromArray0Template(Halffloat512Mask.class, a, offset, indexMap, mapOffset, (Halffloat512Mask) m);
++    }
 +
 +    @ForceInline
 +    @Override
 +    final
 +    HalffloatVector fromCharArray0(char[] a, int offset) {
 +        return super.fromCharArray0Template(a, offset);  // specialize
 +    }
 +
 +    @ForceInline
 +    @Override
 +    final
-     HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Halffloat> m, int offsetInRange) {
++    HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Float16> m, int offsetInRange) {
 +        return super.fromCharArray0Template(Halffloat512Mask.class, a, offset, (Halffloat512Mask) m, offsetInRange);  // specialize
 +    }
 +
 +
 +    @ForceInline
 +    @Override
 +    final
 +    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset) {
 +        return super.fromMemorySegment0Template(ms, offset);  // specialize
 +    }
 +
 +    @ForceInline
 +    @Override
 +    final
-     HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Halffloat> m, int offsetInRange) {
++    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m, int offsetInRange) {
 +        return super.fromMemorySegment0Template(Halffloat512Mask.class, ms, offset, (Halffloat512Mask) m, offsetInRange);  // specialize
 +    }
 +
 +    @ForceInline
 +    @Override
 +    final
 +    void intoArray0(short[] a, int offset) {
 +        super.intoArray0Template(a, offset);  // specialize
 +    }
 +
 +    @ForceInline
 +    @Override
 +    final
-     void intoArray0(short[] a, int offset, VectorMask<Halffloat> m) {
++    void intoArray0(short[] a, int offset, VectorMask<Float16> m) {
 +        super.intoArray0Template(Halffloat512Mask.class, a, offset, (Halffloat512Mask) m);
 +    }
 +
 +
 +
 +    @ForceInline
 +    @Override
 +    final
-     void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Halffloat> m) {
++    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m) {
 +        super.intoMemorySegment0Template(Halffloat512Mask.class, ms, offset, (Halffloat512Mask) m);
 +    }
 +
 +    @ForceInline
 +    @Override
 +    final
-     void intoCharArray0(char[] a, int offset, VectorMask<Halffloat> m) {
++    void intoCharArray0(char[] a, int offset, VectorMask<Float16> m) {
 +        super.intoCharArray0Template(Halffloat512Mask.class, a, offset, (Halffloat512Mask) m);
 +    }
 +
 +    // End of specialized low-level memory operations.
 +
 +    // ================================================
 +
 +}
 +
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Halffloat64Vector.java
index 314eca52366,00000000000..ee9a38b4d40
mode 100644,000000..100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Halffloat64Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Halffloat64Vector.java
@@@ -1,943 -1,0 +1,1034 @@@
 +/*
-  * Copyright (c) 2017, 2023, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
 + * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 + *
 + * This code is free software; you can redistribute it and/or modify it
 + * under the terms of the GNU General Public License version 2 only, as
 + * published by the Free Software Foundation.  Oracle designates this
 + * particular file as subject to the "Classpath" exception as provided
 + * by Oracle in the LICENSE file that accompanied this code.
 + *
 + * This code is distributed in the hope that it will be useful, but WITHOUT
 + * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 + * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 + * version 2 for more details (a copy is included in the LICENSE file that
 + * accompanied this code).
 + *
 + * You should have received a copy of the GNU General Public License version
 + * 2 along with this work; if not, write to the Free Software Foundation,
 + * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 + *
 + * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 + * or visit www.oracle.com if you need additional information or have any
 + * questions.
 + */
 +package jdk.incubator.vector;
 +
 +import java.lang.foreign.MemorySegment;
++import java.lang.foreign.ValueLayout;
++import java.nio.ByteOrder;
 +import java.util.Arrays;
 +import java.util.Objects;
 +import java.util.function.IntUnaryOperator;
 +
 +import jdk.internal.vm.annotation.ForceInline;
 +import jdk.internal.vm.vector.VectorSupport;
 +
 +import static jdk.internal.vm.vector.VectorSupport.*;
 +
 +import static jdk.incubator.vector.VectorOperators.*;
 +
 +// -- This file was mechanically generated: Do not edit! -- //
 +
 +@SuppressWarnings("cast")  // warning: redundant cast
 +final class Halffloat64Vector extends HalffloatVector {
 +    static final HalffloatSpecies VSPECIES =
 +        (HalffloatSpecies) HalffloatVector.SPECIES_64;
 +
 +    static final VectorShape VSHAPE =
 +        VSPECIES.vectorShape();
 +
 +    static final Class<Halffloat64Vector> VCLASS = Halffloat64Vector.class;
 +
 +    static final int VSIZE = VSPECIES.vectorBitSize();
 +
 +    static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
 +
-     static final Class<Halffloat> ETYPE = Halffloat.class; // used by the JVM
++    static final Class<Short> CTYPE = short.class; // carrier type used by the JVM
++
++    static final Class<Float16> ETYPE = Float16.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_FP16;
 +
 +    Halffloat64Vector(short[] v) {
 +        super(v);
 +    }
 +
 +    // For compatibility as Halffloat64Vector::new,
 +    // stored into species.vectorFactory.
 +    Halffloat64Vector(Object v) {
 +        this((short[]) v);
 +    }
 +
 +    static final Halffloat64Vector ZERO = new Halffloat64Vector(new short[VLENGTH]);
 +    static final Halffloat64Vector IOTA = new Halffloat64Vector(VSPECIES.iotaArray());
 +
 +    static {
 +        // Warm up a few species caches.
 +        // If we do this too much we will
 +        // get NPEs from bootstrap circularity.
 +        VSPECIES.dummyVector();
 +        VSPECIES.withLanes(LaneType.BYTE);
 +    }
 +
 +    // Specialized extractors
 +
 +    @ForceInline
 +    final @Override
 +    public HalffloatSpecies vspecies() {
 +        // ISSUE:  This should probably be a @Stable
 +        // field inside AbstractVector, rather than
 +        // a megamorphic method.
 +        return VSPECIES;
 +    }
 +
++    @ForceInline
++    final Class<Short> carrierType() { return CTYPE; }
++
 +    @ForceInline
 +    @Override
-     public final Class<Halffloat> elementType() { return Halffloat.class; }
++    public final Class<Float16> elementType() { return ETYPE; }
 +
 +    @ForceInline
 +    @Override
-     public final int elementSize() { return Halffloat.SIZE; }
++    public final int elementSize() { return Float16.SIZE; }
 +
 +    @ForceInline
 +    @Override
 +    public final VectorShape shape() { return VSHAPE; }
 +
 +    @ForceInline
 +    @Override
 +    public final int length() { return VLENGTH; }
 +
 +    @ForceInline
 +    @Override
 +    public final int bitSize() { return VSIZE; }
 +
 +    @ForceInline
 +    @Override
 +    public final int byteSize() { return VSIZE / Byte.SIZE; }
 +
 +    /*package-private*/
 +    @ForceInline
 +    final @Override
 +    short[] vec() {
 +        return (short[])getPayload();
 +    }
 +
 +    // Virtualized constructors
 +
 +    @Override
 +    @ForceInline
 +    public final Halffloat64Vector broadcast(short e) {
 +        return (Halffloat64Vector) super.broadcastTemplate(e);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final Halffloat64Vector broadcast(long e) {
 +        return (Halffloat64Vector) super.broadcastTemplate(e);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    Halffloat64Mask maskFromArray(boolean[] bits) {
 +        return new Halffloat64Mask(bits);
 +    }
 +
 +    @Override
 +    @ForceInline
 +    Halffloat64Shuffle iotaShuffle() { return Halffloat64Shuffle.IOTA; }
 +
++    @Override
++    @ForceInline
++    Halffloat64Shuffle iotaShuffle(int start, int step, boolean wrap) {
++        return (Halffloat64Shuffle) iotaShuffleTemplate((short) start, (short) step, wrap);
++    }
++
 +    @Override
 +    @ForceInline
 +    Halffloat64Shuffle shuffleFromArray(int[] indices, int i) { return new Halffloat64Shuffle(indices, i); }
 +
 +    @Override
 +    @ForceInline
 +    Halffloat64Shuffle shuffleFromOp(IntUnaryOperator fn) { return new Halffloat64Shuffle(fn); }
 +
 +    // Make a vector of the same species but the given elements:
 +    @ForceInline
 +    final @Override
 +    Halffloat64Vector vectorFactory(short[] vec) {
 +        return new Halffloat64Vector(vec);
 +    }
 +
 +    @ForceInline
 +    final @Override
 +    Byte64Vector asByteVectorRaw() {
 +        return (Byte64Vector) super.asByteVectorRawTemplate();  // specialize
 +    }
 +
 +    @ForceInline
 +    final @Override
 +    AbstractVector<?> asVectorRaw(LaneType laneType) {
 +        return super.asVectorRawTemplate(laneType);  // specialize
 +    }
 +
 +    // Unary operator
 +
 +    @ForceInline
 +    final @Override
 +    Halffloat64Vector uOp(FUnOp f) {
 +        return (Halffloat64Vector) super.uOpTemplate(f);  // specialize
 +    }
 +
 +    @ForceInline
 +    final @Override
-     Halffloat64Vector uOp(VectorMask<Halffloat> m, FUnOp f) {
++    Halffloat64Vector uOp(VectorMask<Float16> m, FUnOp f) {
 +        return (Halffloat64Vector)
 +            super.uOpTemplate((Halffloat64Mask)m, f);  // specialize
 +    }
 +
 +    // Binary operator
 +
 +    @ForceInline
 +    final @Override
-     Halffloat64Vector bOp(Vector<Halffloat> v, FBinOp f) {
++    Halffloat64Vector bOp(Vector<Float16> v, FBinOp f) {
 +        return (Halffloat64Vector) super.bOpTemplate((Halffloat64Vector)v, f);  // specialize
 +    }
 +
 +    @ForceInline
 +    final @Override
-     Halffloat64Vector bOp(Vector<Halffloat> v,
-                      VectorMask<Halffloat> m, FBinOp f) {
++    Halffloat64Vector bOp(Vector<Float16> v,
++                     VectorMask<Float16> m, FBinOp f) {
 +        return (Halffloat64Vector)
 +            super.bOpTemplate((Halffloat64Vector)v, (Halffloat64Mask)m,
 +                              f);  // specialize
 +    }
 +
 +    // Ternary operator
 +
 +    @ForceInline
 +    final @Override
-     Halffloat64Vector tOp(Vector<Halffloat> v1, Vector<Halffloat> v2, FTriOp f) {
++    Halffloat64Vector tOp(Vector<Float16> v1, Vector<Float16> v2, FTriOp f) {
 +        return (Halffloat64Vector)
 +            super.tOpTemplate((Halffloat64Vector)v1, (Halffloat64Vector)v2,
 +                              f);  // specialize
 +    }
 +
 +    @ForceInline
 +    final @Override
-     Halffloat64Vector tOp(Vector<Halffloat> v1, Vector<Halffloat> v2,
-                      VectorMask<Halffloat> m, FTriOp f) {
++    Halffloat64Vector tOp(Vector<Float16> v1, Vector<Float16> v2,
++                     VectorMask<Float16> m, FTriOp f) {
 +        return (Halffloat64Vector)
 +            super.tOpTemplate((Halffloat64Vector)v1, (Halffloat64Vector)v2,
 +                              (Halffloat64Mask)m, f);  // specialize
 +    }
 +
 +    @ForceInline
 +    final @Override
-     short rOp(short v, VectorMask<Halffloat> m, FBinOp f) {
++    short rOp(short v, VectorMask<Float16> m, FBinOp f) {
 +        return super.rOpTemplate(v, m, f);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final <F>
-     Vector<F> convertShape(VectorOperators.Conversion<Halffloat,F> conv,
++    Vector<F> convertShape(VectorOperators.Conversion<Float16,F> conv,
 +                           VectorSpecies<F> rsp, int part) {
 +        return super.convertShapeTemplate(conv, rsp, part);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final <F>
 +    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {
 +        return super.reinterpretShapeTemplate(toSpecies, part);  // specialize
 +    }
 +
 +    // Specialized algebraic operations:
 +
 +    // The following definition forces a specialized version of this
 +    // crucial method into the v-table of this class.  A call to add()
 +    // will inline to a call to lanewise(ADD,), at which point the JIT
 +    // intrinsic will have the opcode of ADD, plus all the metadata
 +    // for this particular class, enabling it to generate precise
 +    // code.
 +    //
 +    // There is probably no benefit to the JIT to specialize the
 +    // masked or broadcast versions of the lanewise method.
 +
 +    @Override
 +    @ForceInline
 +    public Halffloat64Vector lanewise(Unary op) {
 +        return (Halffloat64Vector) super.lanewiseTemplate(op);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat64Vector lanewise(Unary op, VectorMask<Halffloat> m) {
++    public Halffloat64Vector lanewise(Unary op, VectorMask<Float16> m) {
 +        return (Halffloat64Vector) super.lanewiseTemplate(op, Halffloat64Mask.class, (Halffloat64Mask) m);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat64Vector lanewise(Binary op, Vector<Halffloat> v) {
++    public Halffloat64Vector lanewise(Binary op, Vector<Float16> v) {
 +        return (Halffloat64Vector) super.lanewiseTemplate(op, v);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat64Vector lanewise(Binary op, Vector<Halffloat> v, VectorMask<Halffloat> m) {
++    public Halffloat64Vector lanewise(Binary op, Vector<Float16> v, VectorMask<Float16> m) {
 +        return (Halffloat64Vector) super.lanewiseTemplate(op, Halffloat64Mask.class, v, (Halffloat64Mask) m);  // specialize
 +    }
 +
 +
 +    /*package-private*/
 +    @Override
 +    @ForceInline
 +    public final
 +    Halffloat64Vector
-     lanewise(Ternary op, Vector<Halffloat> v1, Vector<Halffloat> v2) {
++    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2) {
 +        return (Halffloat64Vector) super.lanewiseTemplate(op, v1, v2);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final
 +    Halffloat64Vector
-     lanewise(Ternary op, Vector<Halffloat> v1, Vector<Halffloat> v2, VectorMask<Halffloat> m) {
++    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2, VectorMask<Float16> m) {
 +        return (Halffloat64Vector) super.lanewiseTemplate(op, Halffloat64Mask.class, v1, v2, (Halffloat64Mask) m);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final
 +    Halffloat64Vector addIndex(int scale) {
 +        return (Halffloat64Vector) super.addIndexTemplate(scale);  // specialize
 +    }
 +
 +    // Type specific horizontal reductions
 +
 +    @Override
 +    @ForceInline
 +    public final short reduceLanes(VectorOperators.Associative op) {
 +        return super.reduceLanesTemplate(op);  // specialized
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final short reduceLanes(VectorOperators.Associative op,
-                                     VectorMask<Halffloat> m) {
++                                    VectorMask<Float16> m) {
 +        return super.reduceLanesTemplate(op, Halffloat64Mask.class, (Halffloat64Mask) m);  // specialized
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final long reduceLanesToLong(VectorOperators.Associative op) {
 +        return (long) super.reduceLanesTemplate(op);  // specialized
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final long reduceLanesToLong(VectorOperators.Associative op,
-                                         VectorMask<Halffloat> m) {
++                                        VectorMask<Float16> m) {
 +        return (long) super.reduceLanesTemplate(op, Halffloat64Mask.class, (Halffloat64Mask) m);  // specialized
 +    }
 +
 +    @Override
 +    @ForceInline
-     public final
-     <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {
-         return super.toShuffleTemplate(dsp);
++    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {
++        throw new AssertionError();
++    }
++
++    @Override
++    @ForceInline
++    public final Halffloat64Shuffle toShuffle() {
++        return (Halffloat64Shuffle) toShuffle(vspecies(), false);
 +    }
 +
 +    // Specialized unary testing
 +
 +    @Override
 +    @ForceInline
 +    public final Halffloat64Mask test(Test op) {
 +        return super.testTemplate(Halffloat64Mask.class, op);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public final Halffloat64Mask test(Test op, VectorMask<Halffloat> m) {
++    public final Halffloat64Mask test(Test op, VectorMask<Float16> m) {
 +        return super.testTemplate(Halffloat64Mask.class, op, (Halffloat64Mask) m);  // specialize
 +    }
 +
 +    // Specialized comparisons
 +
 +    @Override
 +    @ForceInline
-     public final Halffloat64Mask compare(Comparison op, Vector<Halffloat> v) {
++    public final Halffloat64Mask compare(Comparison op, Vector<Float16> v) {
 +        return super.compareTemplate(Halffloat64Mask.class, op, v);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final Halffloat64Mask compare(Comparison op, short s) {
 +        return super.compareTemplate(Halffloat64Mask.class, op, s);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final Halffloat64Mask compare(Comparison op, long s) {
 +        return super.compareTemplate(Halffloat64Mask.class, op, s);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public final Halffloat64Mask compare(Comparison op, Vector<Halffloat> v, VectorMask<Halffloat> m) {
++    public final Halffloat64Mask compare(Comparison op, Vector<Float16> v, VectorMask<Float16> m) {
 +        return super.compareTemplate(Halffloat64Mask.class, op, v, (Halffloat64Mask) m);
 +    }
 +
 +
 +    @Override
 +    @ForceInline
-     public Halffloat64Vector blend(Vector<Halffloat> v, VectorMask<Halffloat> m) {
++    public Halffloat64Vector blend(Vector<Float16> v, VectorMask<Float16> m) {
 +        return (Halffloat64Vector)
 +            super.blendTemplate(Halffloat64Mask.class,
 +                                (Halffloat64Vector) v,
 +                                (Halffloat64Mask) m);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat64Vector slice(int origin, Vector<Halffloat> v) {
++    public Halffloat64Vector slice(int origin, Vector<Float16> v) {
 +        return (Halffloat64Vector) super.sliceTemplate(origin, v);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public Halffloat64Vector slice(int origin) {
 +        return (Halffloat64Vector) super.sliceTemplate(origin);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat64Vector unslice(int origin, Vector<Halffloat> w, int part) {
++    public Halffloat64Vector unslice(int origin, Vector<Float16> w, int part) {
 +        return (Halffloat64Vector) super.unsliceTemplate(origin, w, part);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat64Vector unslice(int origin, Vector<Halffloat> w, int part, VectorMask<Halffloat> m) {
++    public Halffloat64Vector unslice(int origin, Vector<Float16> w, int part, VectorMask<Float16> m) {
 +        return (Halffloat64Vector)
 +            super.unsliceTemplate(Halffloat64Mask.class,
 +                                  origin, w, part,
 +                                  (Halffloat64Mask) m);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public Halffloat64Vector unslice(int origin) {
 +        return (Halffloat64Vector) super.unsliceTemplate(origin);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat64Vector rearrange(VectorShuffle<Halffloat> s) {
++    public Halffloat64Vector rearrange(VectorShuffle<Float16> s) {
 +        return (Halffloat64Vector)
 +            super.rearrangeTemplate(Halffloat64Shuffle.class,
 +                                    (Halffloat64Shuffle) s);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat64Vector rearrange(VectorShuffle<Halffloat> shuffle,
-                                   VectorMask<Halffloat> m) {
++    public Halffloat64Vector rearrange(VectorShuffle<Float16> shuffle,
++                                  VectorMask<Float16> m) {
 +        return (Halffloat64Vector)
 +            super.rearrangeTemplate(Halffloat64Shuffle.class,
 +                                    Halffloat64Mask.class,
 +                                    (Halffloat64Shuffle) shuffle,
 +                                    (Halffloat64Mask) m);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat64Vector rearrange(VectorShuffle<Halffloat> s,
-                                   Vector<Halffloat> v) {
++    public Halffloat64Vector rearrange(VectorShuffle<Float16> s,
++                                  Vector<Float16> v) {
 +        return (Halffloat64Vector)
 +            super.rearrangeTemplate(Halffloat64Shuffle.class,
 +                                    (Halffloat64Shuffle) s,
 +                                    (Halffloat64Vector) v);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat64Vector compress(VectorMask<Halffloat> m) {
++    public Halffloat64Vector compress(VectorMask<Float16> m) {
 +        return (Halffloat64Vector)
 +            super.compressTemplate(Halffloat64Mask.class,
 +                                   (Halffloat64Mask) m);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat64Vector expand(VectorMask<Halffloat> m) {
++    public Halffloat64Vector expand(VectorMask<Float16> m) {
 +        return (Halffloat64Vector)
 +            super.expandTemplate(Halffloat64Mask.class,
 +                                   (Halffloat64Mask) m);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat64Vector selectFrom(Vector<Halffloat> v) {
++    public Halffloat64Vector selectFrom(Vector<Float16> v) {
 +        return (Halffloat64Vector)
 +            super.selectFromTemplate((Halffloat64Vector) v);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public Halffloat64Vector selectFrom(Vector<Halffloat> v,
-                                    VectorMask<Halffloat> m) {
++    public Halffloat64Vector selectFrom(Vector<Float16> v,
++                                   VectorMask<Float16> m) {
 +        return (Halffloat64Vector)
 +            super.selectFromTemplate((Halffloat64Vector) v,
-                                      (Halffloat64Mask) m);  // specialize
++                                     Halffloat64Mask.class, (Halffloat64Mask) m);  // specialize
 +    }
 +
++    @Override
++    @ForceInline
++    public Halffloat64Vector selectFrom(Vector<Float16> v1,
++                                   Vector<Float16> v2) {
++        return (Halffloat64Vector)
++            super.selectFromTemplate((Halffloat64Vector) v1, (Halffloat64Vector) v2);  // specialize
++    }
 +
 +    @ForceInline
 +    @Override
 +    public short lane(int i) {
 +        short bits;
 +        switch(i) {
 +            case 0: bits = laneHelper(0); break;
 +            case 1: bits = laneHelper(1); break;
 +            case 2: bits = laneHelper(2); break;
 +            case 3: bits = laneHelper(3); break;
 +            default: throw new IllegalArgumentException("Index " + i + " must be zero or positive, and less than " + VLENGTH);
 +        }
-         return Halffloat.shortBitsToHalffloat(bits);
++        return bits;
 +    }
 +
++    @ForceInline
 +    public short laneHelper(int i) {
 +        return (short) VectorSupport.extract(
-                      VCLASS, ETYPE, VLENGTH,
++                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
 +                     this, i,
 +                     (vec, ix) -> {
 +                     short[] vecarr = vec.vec();
-                      return (long)Halffloat.shortToShortBits(vecarr[ix]);
++                     return vecarr[ix];
 +                     });
 +    }
 +
 +    @ForceInline
 +    @Override
 +    public Halffloat64Vector withLane(int i, short e) {
 +        switch(i) {
 +            case 0: return withLaneHelper(0, e);
 +            case 1: return withLaneHelper(1, e);
 +            case 2: return withLaneHelper(2, e);
 +            case 3: return withLaneHelper(3, e);
 +            default: throw new IllegalArgumentException("Index " + i + " must be zero or positive, and less than " + VLENGTH);
 +        }
 +    }
 +
++    @ForceInline
 +    public Halffloat64Vector withLaneHelper(int i, short e) {
 +        return VectorSupport.insert(
-                                 VCLASS, ETYPE, VLENGTH,
-                                 this, i, (long)Halffloat.shortToShortBits(e),
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                this, i, (long)e,
 +                                (v, ix, bits) -> {
 +                                    short[] res = v.vec().clone();
-                                     res[ix] = Halffloat.shortBitsToHalffloat((short)bits);
++                                    res[ix] = e;
 +                                    return v.vectorFactory(res);
 +                                });
 +    }
 +
 +    // Mask
 +
-     static final class Halffloat64Mask extends AbstractMask<Halffloat> {
++    static final class Halffloat64Mask extends AbstractMask<Float16> {
 +        static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
-         static final Class<Halffloat> ETYPE = Halffloat.class; // used by the JVM
++        static final Class<Short> CTYPE = short.class; // used by the JVM
 +
 +        Halffloat64Mask(boolean[] bits) {
 +            this(bits, 0);
 +        }
 +
 +        Halffloat64Mask(boolean[] bits, int offset) {
 +            super(prepare(bits, offset));
 +        }
 +
 +        Halffloat64Mask(boolean val) {
 +            super(prepare(val));
 +        }
 +
 +        private static boolean[] prepare(boolean[] bits, int offset) {
 +            boolean[] newBits = new boolean[VSPECIES.laneCount()];
 +            for (int i = 0; i < newBits.length; i++) {
 +                newBits[i] = bits[offset + i];
 +            }
 +            return newBits;
 +        }
 +
 +        private static boolean[] prepare(boolean val) {
 +            boolean[] bits = new boolean[VSPECIES.laneCount()];
 +            Arrays.fill(bits, val);
 +            return bits;
 +        }
 +
 +        @ForceInline
 +        final @Override
 +        public HalffloatSpecies vspecies() {
 +            // ISSUE:  This should probably be a @Stable
 +            // field inside AbstractMask, rather than
 +            // a megamorphic method.
 +            return VSPECIES;
 +        }
 +
 +        @ForceInline
 +        boolean[] getBits() {
 +            return (boolean[])getPayload();
 +        }
 +
 +        @Override
 +        Halffloat64Mask uOp(MUnOp f) {
 +            boolean[] res = new boolean[vspecies().laneCount()];
 +            boolean[] bits = getBits();
 +            for (int i = 0; i < res.length; i++) {
 +                res[i] = f.apply(i, bits[i]);
 +            }
 +            return new Halffloat64Mask(res);
 +        }
 +
 +        @Override
-         Halffloat64Mask bOp(VectorMask<Halffloat> m, MBinOp f) {
++        Halffloat64Mask bOp(VectorMask<Float16> m, MBinOp f) {
 +            boolean[] res = new boolean[vspecies().laneCount()];
 +            boolean[] bits = getBits();
 +            boolean[] mbits = ((Halffloat64Mask)m).getBits();
 +            for (int i = 0; i < res.length; i++) {
 +                res[i] = f.apply(i, bits[i], mbits[i]);
 +            }
 +            return new Halffloat64Mask(res);
 +        }
 +
 +        @ForceInline
 +        @Override
 +        public final
 +        Halffloat64Vector toVector() {
 +            return (Halffloat64Vector) super.toVectorTemplate();  // specialize
 +        }
 +
 +        /**
 +         * Helper function for lane-wise mask conversions.
 +         * This function kicks in after intrinsic failure.
 +         */
 +        @ForceInline
 +        private final <E>
 +        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {
 +            if (length() != dsp.laneCount())
 +                throw new IllegalArgumentException("VectorMask length and species length differ");
 +            boolean[] maskArray = toArray();
 +            return  dsp.maskFactory(maskArray).check(dsp);
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
 +            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;
 +            if (length() != species.laneCount())
 +                throw new IllegalArgumentException("VectorMask length and species length differ");
 +
 +            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,
 +                this.getClass(), ETYPE, VLENGTH,
 +                species.maskType(), species.elementType(), VLENGTH,
 +                this, species,
 +                (m, s) -> s.maskFactory(m.toArray()).check(s));
 +        }
 +
 +        @Override
 +        @ForceInline
 +        /*package-private*/
 +        Halffloat64Mask indexPartiallyInUpperRange(long offset, long limit) {
 +            return (Halffloat64Mask) VectorSupport.indexPartiallyInUpperRange(
-                 Halffloat64Mask.class, ETYPE, VLENGTH, offset, limit,
++                Halffloat64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
 +                (o, l) -> (Halffloat64Mask) TRUE_MASK.indexPartiallyInRange(o, l));
 +        }
 +
 +        // Unary operations
 +
 +        @Override
 +        @ForceInline
 +        public Halffloat64Mask not() {
 +            return xor(maskAll(true));
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public Halffloat64Mask compress() {
 +            return (Halffloat64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                 Halffloat64Vector.class, Halffloat64Mask.class, ETYPE, VLENGTH, null, this,
-                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, Float.floatToFloat16(m1.trueCount())));
++                Halffloat64Vector.class, Halffloat64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                Float16.float16ToShortBits(Float16.valueOf(m1.trueCount()))));
 +        }
 +
 +
 +        // Binary operations
 +
 +        @Override
 +        @ForceInline
-         public Halffloat64Mask and(VectorMask<Halffloat> mask) {
++        public Halffloat64Mask and(VectorMask<Float16> mask) {
 +            Objects.requireNonNull(mask);
 +            Halffloat64Mask m = (Halffloat64Mask)mask;
-             return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat64Mask.class, null, Halffloat.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat64Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
 +                                          this, m, null,
 +                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
 +        }
 +
 +        @Override
 +        @ForceInline
-         public Halffloat64Mask or(VectorMask<Halffloat> mask) {
++        public Halffloat64Mask or(VectorMask<Float16> mask) {
 +            Objects.requireNonNull(mask);
 +            Halffloat64Mask m = (Halffloat64Mask)mask;
-             return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat64Mask.class, null, Halffloat.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat64Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
 +                                          this, m, null,
 +                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
 +        }
 +
 +        @Override
 +        @ForceInline
-         public Halffloat64Mask xor(VectorMask<Halffloat> mask) {
++        public Halffloat64Mask xor(VectorMask<Float16> mask) {
 +            Objects.requireNonNull(mask);
 +            Halffloat64Mask m = (Halffloat64Mask)mask;
-             return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat64Mask.class, null, Halffloat.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat64Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
 +                                          this, m, null,
 +                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
 +        }
 +
 +        // Mask Query operations
 +
 +        @Override
 +        @ForceInline
 +        public int trueCount() {
-             return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat64Mask.class, Halffloat.class, VLENGTH, this,
-                                                       (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat64Mask.class, short.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public int firstTrue() {
-             return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat64Mask.class, Halffloat.class, VLENGTH, this,
-                                                       (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat64Mask.class, short.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public int lastTrue() {
-             return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat64Mask.class, Halffloat.class, VLENGTH, this,
-                                                       (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat64Mask.class, short.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public long toLong() {
 +            if (length() > Long.SIZE) {
 +                throw new UnsupportedOperationException("too many lanes for one long");
 +            }
-             return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat64Mask.class, Halffloat.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat64Mask.class, short.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
 +                                                      (m) -> toLongHelper(m.getBits()));
 +        }
 +
++        // laneIsSet
++
++        @Override
++        @ForceInline
++        public boolean laneIsSet(int i) {
++            Objects.checkIndex(i, length());
++            return VectorSupport.extract(Halffloat64Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
++        }
++
 +        // Reductions
 +
 +        @Override
 +        @ForceInline
 +        public boolean anyTrue() {
-             return VectorSupport.test(BT_ne, Halffloat64Mask.class, Halffloat.class, VLENGTH,
-                                          this, vspecies().maskAll(true),
-                                          (m, __) -> anyTrueHelper(((Halffloat64Mask)m).getBits()));
++            return VectorSupport.test(BT_ne, Halffloat64Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper(((Halffloat64Mask)m).getBits()));
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public boolean allTrue() {
-             return VectorSupport.test(BT_overflow, Halffloat64Mask.class, Halffloat.class, VLENGTH,
-                                          this, vspecies().maskAll(true),
-                                          (m, __) -> allTrueHelper(((Halffloat64Mask)m).getBits()));
++            return VectorSupport.test(BT_overflow, Halffloat64Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper(((Halffloat64Mask)m).getBits()));
 +        }
 +
 +        @ForceInline
 +        /*package-private*/
 +        static Halffloat64Mask maskAll(boolean bit) {
-             return VectorSupport.fromBitsCoerced(Halffloat64Mask.class, Halffloat.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced(Halffloat64Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
 +                                                 (bit ? -1 : 0), MODE_BROADCAST, null,
 +                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
 +        }
 +        private static final Halffloat64Mask  TRUE_MASK = new Halffloat64Mask(true);
 +        private static final Halffloat64Mask FALSE_MASK = new Halffloat64Mask(false);
 +
 +    }
 +
 +    // Shuffle
 +
-     static final class Halffloat64Shuffle extends AbstractShuffle<Halffloat> {
++    static final class Halffloat64Shuffle extends AbstractShuffle<Float16> {
 +        static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
-         static final Class<Short> ETYPE = short.class; // used by the JVM
++        static final Class<Short> CTYPE = short.class; // used by the JVM
 +
 +        Halffloat64Shuffle(short[] indices) {
 +            super(indices);
 +            assert(VLENGTH == indices.length);
 +            assert(indicesInRange(indices));
 +        }
 +
 +        Halffloat64Shuffle(int[] indices, int i) {
 +            this(prepare(indices, i));
 +        }
 +
 +        Halffloat64Shuffle(IntUnaryOperator fn) {
 +            this(prepare(fn));
 +        }
 +
 +        short[] indices() {
 +            return (short[])getPayload();
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public HalffloatSpecies vspecies() {
 +            return VSPECIES;
 +        }
 +
 +        static {
 +            // There must be enough bits in the shuffle lanes to encode
 +            // VLENGTH valid indexes and VLENGTH exceptional ones.
 +            assert(VLENGTH < Short.MAX_VALUE);
 +            assert(Short.MIN_VALUE <= -VLENGTH);
 +        }
 +        static final Halffloat64Shuffle IOTA = new Halffloat64Shuffle(IDENTITY);
 +
++        @Override
++        @ForceInline
++        public Halffloat64Vector toVector() {
++            return (Halffloat64Vector) toBitsVector().castShape(vspecies(), 0);
++        }
++
 +        @Override
 +        @ForceInline
 +        Short64Vector toBitsVector() {
 +            return (Short64Vector) super.toBitsVectorTemplate();
 +        }
 +
 +        @Override
-         @ForceInline
-         ShortVector toBitsVector0() {
-             return Short64Vector.VSPECIES.dummyVector().vectorFactory(indices());
++        Short64Vector toBitsVector0() {
++            return ((Short64Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public int laneSource(int i) {
 +            return (int)toBitsVector().lane(i);
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public void intoArray(int[] a, int offset) {
 +            VectorSpecies<Integer> species = IntVector.SPECIES_64;
 +            Vector<Short> v = toBitsVector();
 +            v.convertShape(VectorOperators.S2I, species, 0)
 +                    .reinterpretAsInts()
 +                    .intoArray(a, offset);
 +            v.convertShape(VectorOperators.S2I, species, 1)
 +                    .reinterpretAsInts()
 +                    .intoArray(a, offset + species.length());
 +        }
 +
++        @Override
++        @ForceInline
++        public void intoMemorySegment(MemorySegment ms, long offset, ByteOrder bo) {
++            VectorSpecies<Integer> species = IntVector.SPECIES_64;
++            Vector<Short> v = toBitsVector();
++            v.convertShape(VectorOperators.S2I, species, 0)
++                    .reinterpretAsInts()
++                    .intoMemorySegment(ms, offset, bo);
++            v.convertShape(VectorOperators.S2I, species, 1)
++                    .reinterpretAsInts()
++                    .intoMemorySegment(ms, offset + species.vectorByteSize(), bo);
++         }
++
++        @Override
++        @ForceInline
++        public final Halffloat64Mask laneIsValid() {
++            return (Halffloat64Mask) toBitsVector().compare(VectorOperators.GE, 0)
++                    .cast(vspecies());
++        }
++
++        @ForceInline
++        @Override
++        public final Halffloat64Shuffle rearrange(VectorShuffle<Float16> shuffle) {
++            Halffloat64Shuffle concreteShuffle = (Halffloat64Shuffle) shuffle;
++            return (Halffloat64Shuffle) toBitsVector().rearrange(concreteShuffle.cast(ShortVector.SPECIES_64))
++                    .toShuffle(vspecies(), false);
++        }
++
++        @ForceInline
++        @Override
++        public final Halffloat64Shuffle wrapIndexes() {
++            Short64Vector v = toBitsVector();
++            if ((length() & (length() - 1)) == 0) {
++                v = (Short64Vector) v.lanewise(VectorOperators.AND, length() - 1);
++            } else {
++                v = (Short64Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),
++                            v.compare(VectorOperators.LT, 0));
++            }
++            return (Halffloat64Shuffle) v.toShuffle(vspecies(), false);
++        }
++
 +        private static short[] prepare(int[] indices, int offset) {
 +            short[] a = new short[VLENGTH];
 +            for (int i = 0; i < VLENGTH; i++) {
 +                int si = indices[offset + i];
 +                si = partiallyWrapIndex(si, VLENGTH);
 +                a[i] = (short)si;
 +            }
 +            return a;
 +        }
 +
 +        private static short[] prepare(IntUnaryOperator f) {
 +            short[] a = new short[VLENGTH];
 +            for (int i = 0; i < VLENGTH; i++) {
 +                int si = f.applyAsInt(i);
 +                si = partiallyWrapIndex(si, VLENGTH);
 +                a[i] = (short)si;
 +            }
 +            return a;
 +        }
 +
 +        private static boolean indicesInRange(short[] indices) {
 +            int length = indices.length;
 +            for (short si : indices) {
 +                if (si >= (short)length || si < (short)(-length)) {
-                     boolean assertsEnabled = false;
-                     assert(assertsEnabled = true);
-                     if (assertsEnabled) {
-                         String msg = ("index "+si+"out of range ["+length+"] in "+
++                    String msg = ("index "+si+"out of range ["+length+"] in "+
 +                                  java.util.Arrays.toString(indices));
-                         throw new AssertionError(msg);
-                     }
-                     return false;
++                    throw new AssertionError(msg);
 +                }
 +            }
 +            return true;
 +        }
 +    }
 +
 +    // ================================================
 +
 +    // Specialized low-level memory operations.
 +
 +    @ForceInline
 +    @Override
 +    final
 +    HalffloatVector fromArray0(short[] a, int offset) {
 +        return super.fromArray0Template(a, offset);  // specialize
 +    }
 +
 +    @ForceInline
 +    @Override
 +    final
-     HalffloatVector fromArray0(short[] a, int offset, VectorMask<Halffloat> m, int offsetInRange) {
++    HalffloatVector fromArray0(short[] a, int offset, VectorMask<Float16> m, int offsetInRange) {
 +        return super.fromArray0Template(Halffloat64Mask.class, a, offset, (Halffloat64Mask) m, offsetInRange);  // specialize
 +    }
 +
++    @ForceInline
++    @Override
++    final
++    HalffloatVector fromArray0(short[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float16> m) {
++        return super.fromArray0Template(Halffloat64Mask.class, a, offset, indexMap, mapOffset, (Halffloat64Mask) m);
++    }
 +
 +    @ForceInline
 +    @Override
 +    final
 +    HalffloatVector fromCharArray0(char[] a, int offset) {
 +        return super.fromCharArray0Template(a, offset);  // specialize
 +    }
 +
 +    @ForceInline
 +    @Override
 +    final
-     HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Halffloat> m, int offsetInRange) {
++    HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Float16> m, int offsetInRange) {
 +        return super.fromCharArray0Template(Halffloat64Mask.class, a, offset, (Halffloat64Mask) m, offsetInRange);  // specialize
 +    }
 +
 +
 +    @ForceInline
 +    @Override
 +    final
 +    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset) {
 +        return super.fromMemorySegment0Template(ms, offset);  // specialize
 +    }
 +
 +    @ForceInline
 +    @Override
 +    final
-     HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Halffloat> m, int offsetInRange) {
++    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m, int offsetInRange) {
 +        return super.fromMemorySegment0Template(Halffloat64Mask.class, ms, offset, (Halffloat64Mask) m, offsetInRange);  // specialize
 +    }
 +
 +    @ForceInline
 +    @Override
 +    final
 +    void intoArray0(short[] a, int offset) {
 +        super.intoArray0Template(a, offset);  // specialize
 +    }
 +
 +    @ForceInline
 +    @Override
 +    final
-     void intoArray0(short[] a, int offset, VectorMask<Halffloat> m) {
++    void intoArray0(short[] a, int offset, VectorMask<Float16> m) {
 +        super.intoArray0Template(Halffloat64Mask.class, a, offset, (Halffloat64Mask) m);
 +    }
 +
 +
 +
 +    @ForceInline
 +    @Override
 +    final
-     void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Halffloat> m) {
++    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m) {
 +        super.intoMemorySegment0Template(Halffloat64Mask.class, ms, offset, (Halffloat64Mask) m);
 +    }
 +
 +    @ForceInline
 +    @Override
 +    final
-     void intoCharArray0(char[] a, int offset, VectorMask<Halffloat> m) {
++    void intoCharArray0(char[] a, int offset, VectorMask<Float16> m) {
 +        super.intoCharArray0Template(Halffloat64Mask.class, a, offset, (Halffloat64Mask) m);
 +    }
 +
 +    // End of specialized low-level memory operations.
 +
 +    // ================================================
 +
 +}
 +
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/HalffloatMaxVector.java
index 14a8f27cde1,00000000000..8448153cd00
mode 100644,000000..100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/HalffloatMaxVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/HalffloatMaxVector.java
@@@ -1,936 -1,0 +1,1027 @@@
 +/*
-  * Copyright (c) 2017, 2023, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
 + * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 + *
 + * This code is free software; you can redistribute it and/or modify it
 + * under the terms of the GNU General Public License version 2 only, as
 + * published by the Free Software Foundation.  Oracle designates this
 + * particular file as subject to the "Classpath" exception as provided
 + * by Oracle in the LICENSE file that accompanied this code.
 + *
 + * This code is distributed in the hope that it will be useful, but WITHOUT
 + * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 + * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 + * version 2 for more details (a copy is included in the LICENSE file that
 + * accompanied this code).
 + *
 + * You should have received a copy of the GNU General Public License version
 + * 2 along with this work; if not, write to the Free Software Foundation,
 + * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 + *
 + * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 + * or visit www.oracle.com if you need additional information or have any
 + * questions.
 + */
 +package jdk.incubator.vector;
 +
 +import java.lang.foreign.MemorySegment;
++import java.lang.foreign.ValueLayout;
++import java.nio.ByteOrder;
 +import java.util.Arrays;
 +import java.util.Objects;
 +import java.util.function.IntUnaryOperator;
 +
 +import jdk.internal.vm.annotation.ForceInline;
 +import jdk.internal.vm.vector.VectorSupport;
 +
 +import static jdk.internal.vm.vector.VectorSupport.*;
 +
 +import static jdk.incubator.vector.VectorOperators.*;
 +
 +// -- This file was mechanically generated: Do not edit! -- //
 +
 +@SuppressWarnings("cast")  // warning: redundant cast
 +final class HalffloatMaxVector extends HalffloatVector {
 +    static final HalffloatSpecies VSPECIES =
 +        (HalffloatSpecies) HalffloatVector.SPECIES_MAX;
 +
 +    static final VectorShape VSHAPE =
 +        VSPECIES.vectorShape();
 +
 +    static final Class<HalffloatMaxVector> VCLASS = HalffloatMaxVector.class;
 +
 +    static final int VSIZE = VSPECIES.vectorBitSize();
 +
 +    static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
 +
-     static final Class<Halffloat> ETYPE = Halffloat.class; // used by the JVM
++    static final Class<Short> CTYPE = short.class; // carrier type used by the JVM
++
++    static final Class<Float16> ETYPE = Float16.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_FP16;
 +
 +    HalffloatMaxVector(short[] v) {
 +        super(v);
 +    }
 +
 +    // For compatibility as HalffloatMaxVector::new,
 +    // stored into species.vectorFactory.
 +    HalffloatMaxVector(Object v) {
 +        this((short[]) v);
 +    }
 +
 +    static final HalffloatMaxVector ZERO = new HalffloatMaxVector(new short[VLENGTH]);
 +    static final HalffloatMaxVector IOTA = new HalffloatMaxVector(VSPECIES.iotaArray());
 +
 +    static {
 +        // Warm up a few species caches.
 +        // If we do this too much we will
 +        // get NPEs from bootstrap circularity.
 +        VSPECIES.dummyVector();
 +        VSPECIES.withLanes(LaneType.BYTE);
 +    }
 +
 +    // Specialized extractors
 +
 +    @ForceInline
 +    final @Override
 +    public HalffloatSpecies vspecies() {
 +        // ISSUE:  This should probably be a @Stable
 +        // field inside AbstractVector, rather than
 +        // a megamorphic method.
 +        return VSPECIES;
 +    }
 +
++    @ForceInline
++    final Class<Short> carrierType() { return CTYPE; }
++
 +    @ForceInline
 +    @Override
-     public final Class<Halffloat> elementType() { return Halffloat.class; }
++    public final Class<Float16> elementType() { return ETYPE; }
 +
 +    @ForceInline
 +    @Override
-     public final int elementSize() { return Halffloat.SIZE; }
++    public final int elementSize() { return Float16.SIZE; }
 +
 +    @ForceInline
 +    @Override
 +    public final VectorShape shape() { return VSHAPE; }
 +
 +    @ForceInline
 +    @Override
 +    public final int length() { return VLENGTH; }
 +
 +    @ForceInline
 +    @Override
 +    public final int bitSize() { return VSIZE; }
 +
 +    @ForceInline
 +    @Override
 +    public final int byteSize() { return VSIZE / Byte.SIZE; }
 +
 +    /*package-private*/
 +    @ForceInline
 +    final @Override
 +    short[] vec() {
 +        return (short[])getPayload();
 +    }
 +
 +    // Virtualized constructors
 +
 +    @Override
 +    @ForceInline
 +    public final HalffloatMaxVector broadcast(short e) {
 +        return (HalffloatMaxVector) super.broadcastTemplate(e);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final HalffloatMaxVector broadcast(long e) {
 +        return (HalffloatMaxVector) super.broadcastTemplate(e);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    HalffloatMaxMask maskFromArray(boolean[] bits) {
 +        return new HalffloatMaxMask(bits);
 +    }
 +
 +    @Override
 +    @ForceInline
 +    HalffloatMaxShuffle iotaShuffle() { return HalffloatMaxShuffle.IOTA; }
 +
++    @Override
++    @ForceInline
++    HalffloatMaxShuffle iotaShuffle(int start, int step, boolean wrap) {
++        return (HalffloatMaxShuffle) iotaShuffleTemplate((short) start, (short) step, wrap);
++    }
++
 +    @Override
 +    @ForceInline
 +    HalffloatMaxShuffle shuffleFromArray(int[] indices, int i) { return new HalffloatMaxShuffle(indices, i); }
 +
 +    @Override
 +    @ForceInline
 +    HalffloatMaxShuffle shuffleFromOp(IntUnaryOperator fn) { return new HalffloatMaxShuffle(fn); }
 +
 +    // Make a vector of the same species but the given elements:
 +    @ForceInline
 +    final @Override
 +    HalffloatMaxVector vectorFactory(short[] vec) {
 +        return new HalffloatMaxVector(vec);
 +    }
 +
 +    @ForceInline
 +    final @Override
 +    ByteMaxVector asByteVectorRaw() {
 +        return (ByteMaxVector) super.asByteVectorRawTemplate();  // specialize
 +    }
 +
 +    @ForceInline
 +    final @Override
 +    AbstractVector<?> asVectorRaw(LaneType laneType) {
 +        return super.asVectorRawTemplate(laneType);  // specialize
 +    }
 +
 +    // Unary operator
 +
 +    @ForceInline
 +    final @Override
 +    HalffloatMaxVector uOp(FUnOp f) {
 +        return (HalffloatMaxVector) super.uOpTemplate(f);  // specialize
 +    }
 +
 +    @ForceInline
 +    final @Override
-     HalffloatMaxVector uOp(VectorMask<Halffloat> m, FUnOp f) {
++    HalffloatMaxVector uOp(VectorMask<Float16> m, FUnOp f) {
 +        return (HalffloatMaxVector)
 +            super.uOpTemplate((HalffloatMaxMask)m, f);  // specialize
 +    }
 +
 +    // Binary operator
 +
 +    @ForceInline
 +    final @Override
-     HalffloatMaxVector bOp(Vector<Halffloat> v, FBinOp f) {
++    HalffloatMaxVector bOp(Vector<Float16> v, FBinOp f) {
 +        return (HalffloatMaxVector) super.bOpTemplate((HalffloatMaxVector)v, f);  // specialize
 +    }
 +
 +    @ForceInline
 +    final @Override
-     HalffloatMaxVector bOp(Vector<Halffloat> v,
-                      VectorMask<Halffloat> m, FBinOp f) {
++    HalffloatMaxVector bOp(Vector<Float16> v,
++                     VectorMask<Float16> m, FBinOp f) {
 +        return (HalffloatMaxVector)
 +            super.bOpTemplate((HalffloatMaxVector)v, (HalffloatMaxMask)m,
 +                              f);  // specialize
 +    }
 +
 +    // Ternary operator
 +
 +    @ForceInline
 +    final @Override
-     HalffloatMaxVector tOp(Vector<Halffloat> v1, Vector<Halffloat> v2, FTriOp f) {
++    HalffloatMaxVector tOp(Vector<Float16> v1, Vector<Float16> v2, FTriOp f) {
 +        return (HalffloatMaxVector)
 +            super.tOpTemplate((HalffloatMaxVector)v1, (HalffloatMaxVector)v2,
 +                              f);  // specialize
 +    }
 +
 +    @ForceInline
 +    final @Override
-     HalffloatMaxVector tOp(Vector<Halffloat> v1, Vector<Halffloat> v2,
-                      VectorMask<Halffloat> m, FTriOp f) {
++    HalffloatMaxVector tOp(Vector<Float16> v1, Vector<Float16> v2,
++                     VectorMask<Float16> m, FTriOp f) {
 +        return (HalffloatMaxVector)
 +            super.tOpTemplate((HalffloatMaxVector)v1, (HalffloatMaxVector)v2,
 +                              (HalffloatMaxMask)m, f);  // specialize
 +    }
 +
 +    @ForceInline
 +    final @Override
-     short rOp(short v, VectorMask<Halffloat> m, FBinOp f) {
++    short rOp(short v, VectorMask<Float16> m, FBinOp f) {
 +        return super.rOpTemplate(v, m, f);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final <F>
-     Vector<F> convertShape(VectorOperators.Conversion<Halffloat,F> conv,
++    Vector<F> convertShape(VectorOperators.Conversion<Float16,F> conv,
 +                           VectorSpecies<F> rsp, int part) {
 +        return super.convertShapeTemplate(conv, rsp, part);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final <F>
 +    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {
 +        return super.reinterpretShapeTemplate(toSpecies, part);  // specialize
 +    }
 +
 +    // Specialized algebraic operations:
 +
 +    // The following definition forces a specialized version of this
 +    // crucial method into the v-table of this class.  A call to add()
 +    // will inline to a call to lanewise(ADD,), at which point the JIT
 +    // intrinsic will have the opcode of ADD, plus all the metadata
 +    // for this particular class, enabling it to generate precise
 +    // code.
 +    //
 +    // There is probably no benefit to the JIT to specialize the
 +    // masked or broadcast versions of the lanewise method.
 +
 +    @Override
 +    @ForceInline
 +    public HalffloatMaxVector lanewise(Unary op) {
 +        return (HalffloatMaxVector) super.lanewiseTemplate(op);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public HalffloatMaxVector lanewise(Unary op, VectorMask<Halffloat> m) {
++    public HalffloatMaxVector lanewise(Unary op, VectorMask<Float16> m) {
 +        return (HalffloatMaxVector) super.lanewiseTemplate(op, HalffloatMaxMask.class, (HalffloatMaxMask) m);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public HalffloatMaxVector lanewise(Binary op, Vector<Halffloat> v) {
++    public HalffloatMaxVector lanewise(Binary op, Vector<Float16> v) {
 +        return (HalffloatMaxVector) super.lanewiseTemplate(op, v);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public HalffloatMaxVector lanewise(Binary op, Vector<Halffloat> v, VectorMask<Halffloat> m) {
++    public HalffloatMaxVector lanewise(Binary op, Vector<Float16> v, VectorMask<Float16> m) {
 +        return (HalffloatMaxVector) super.lanewiseTemplate(op, HalffloatMaxMask.class, v, (HalffloatMaxMask) m);  // specialize
 +    }
 +
 +
 +    /*package-private*/
 +    @Override
 +    @ForceInline
 +    public final
 +    HalffloatMaxVector
-     lanewise(Ternary op, Vector<Halffloat> v1, Vector<Halffloat> v2) {
++    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2) {
 +        return (HalffloatMaxVector) super.lanewiseTemplate(op, v1, v2);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final
 +    HalffloatMaxVector
-     lanewise(Ternary op, Vector<Halffloat> v1, Vector<Halffloat> v2, VectorMask<Halffloat> m) {
++    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2, VectorMask<Float16> m) {
 +        return (HalffloatMaxVector) super.lanewiseTemplate(op, HalffloatMaxMask.class, v1, v2, (HalffloatMaxMask) m);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final
 +    HalffloatMaxVector addIndex(int scale) {
 +        return (HalffloatMaxVector) super.addIndexTemplate(scale);  // specialize
 +    }
 +
 +    // Type specific horizontal reductions
 +
 +    @Override
 +    @ForceInline
 +    public final short reduceLanes(VectorOperators.Associative op) {
 +        return super.reduceLanesTemplate(op);  // specialized
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final short reduceLanes(VectorOperators.Associative op,
-                                     VectorMask<Halffloat> m) {
++                                    VectorMask<Float16> m) {
 +        return super.reduceLanesTemplate(op, HalffloatMaxMask.class, (HalffloatMaxMask) m);  // specialized
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final long reduceLanesToLong(VectorOperators.Associative op) {
 +        return (long) super.reduceLanesTemplate(op);  // specialized
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final long reduceLanesToLong(VectorOperators.Associative op,
-                                         VectorMask<Halffloat> m) {
++                                        VectorMask<Float16> m) {
 +        return (long) super.reduceLanesTemplate(op, HalffloatMaxMask.class, (HalffloatMaxMask) m);  // specialized
 +    }
 +
 +    @Override
 +    @ForceInline
-     public final
-     <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {
-         return super.toShuffleTemplate(dsp);
++    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {
++        throw new AssertionError();
++    }
++
++    @Override
++    @ForceInline
++    public final HalffloatMaxShuffle toShuffle() {
++        return (HalffloatMaxShuffle) toShuffle(vspecies(), false);
 +    }
 +
 +    // Specialized unary testing
 +
 +    @Override
 +    @ForceInline
 +    public final HalffloatMaxMask test(Test op) {
 +        return super.testTemplate(HalffloatMaxMask.class, op);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public final HalffloatMaxMask test(Test op, VectorMask<Halffloat> m) {
++    public final HalffloatMaxMask test(Test op, VectorMask<Float16> m) {
 +        return super.testTemplate(HalffloatMaxMask.class, op, (HalffloatMaxMask) m);  // specialize
 +    }
 +
 +    // Specialized comparisons
 +
 +    @Override
 +    @ForceInline
-     public final HalffloatMaxMask compare(Comparison op, Vector<Halffloat> v) {
++    public final HalffloatMaxMask compare(Comparison op, Vector<Float16> v) {
 +        return super.compareTemplate(HalffloatMaxMask.class, op, v);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final HalffloatMaxMask compare(Comparison op, short s) {
 +        return super.compareTemplate(HalffloatMaxMask.class, op, s);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public final HalffloatMaxMask compare(Comparison op, long s) {
 +        return super.compareTemplate(HalffloatMaxMask.class, op, s);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public final HalffloatMaxMask compare(Comparison op, Vector<Halffloat> v, VectorMask<Halffloat> m) {
++    public final HalffloatMaxMask compare(Comparison op, Vector<Float16> v, VectorMask<Float16> m) {
 +        return super.compareTemplate(HalffloatMaxMask.class, op, v, (HalffloatMaxMask) m);
 +    }
 +
 +
 +    @Override
 +    @ForceInline
-     public HalffloatMaxVector blend(Vector<Halffloat> v, VectorMask<Halffloat> m) {
++    public HalffloatMaxVector blend(Vector<Float16> v, VectorMask<Float16> m) {
 +        return (HalffloatMaxVector)
 +            super.blendTemplate(HalffloatMaxMask.class,
 +                                (HalffloatMaxVector) v,
 +                                (HalffloatMaxMask) m);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public HalffloatMaxVector slice(int origin, Vector<Halffloat> v) {
++    public HalffloatMaxVector slice(int origin, Vector<Float16> v) {
 +        return (HalffloatMaxVector) super.sliceTemplate(origin, v);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public HalffloatMaxVector slice(int origin) {
 +        return (HalffloatMaxVector) super.sliceTemplate(origin);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public HalffloatMaxVector unslice(int origin, Vector<Halffloat> w, int part) {
++    public HalffloatMaxVector unslice(int origin, Vector<Float16> w, int part) {
 +        return (HalffloatMaxVector) super.unsliceTemplate(origin, w, part);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public HalffloatMaxVector unslice(int origin, Vector<Halffloat> w, int part, VectorMask<Halffloat> m) {
++    public HalffloatMaxVector unslice(int origin, Vector<Float16> w, int part, VectorMask<Float16> m) {
 +        return (HalffloatMaxVector)
 +            super.unsliceTemplate(HalffloatMaxMask.class,
 +                                  origin, w, part,
 +                                  (HalffloatMaxMask) m);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
 +    public HalffloatMaxVector unslice(int origin) {
 +        return (HalffloatMaxVector) super.unsliceTemplate(origin);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public HalffloatMaxVector rearrange(VectorShuffle<Halffloat> s) {
++    public HalffloatMaxVector rearrange(VectorShuffle<Float16> s) {
 +        return (HalffloatMaxVector)
 +            super.rearrangeTemplate(HalffloatMaxShuffle.class,
 +                                    (HalffloatMaxShuffle) s);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public HalffloatMaxVector rearrange(VectorShuffle<Halffloat> shuffle,
-                                   VectorMask<Halffloat> m) {
++    public HalffloatMaxVector rearrange(VectorShuffle<Float16> shuffle,
++                                  VectorMask<Float16> m) {
 +        return (HalffloatMaxVector)
 +            super.rearrangeTemplate(HalffloatMaxShuffle.class,
 +                                    HalffloatMaxMask.class,
 +                                    (HalffloatMaxShuffle) shuffle,
 +                                    (HalffloatMaxMask) m);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public HalffloatMaxVector rearrange(VectorShuffle<Halffloat> s,
-                                   Vector<Halffloat> v) {
++    public HalffloatMaxVector rearrange(VectorShuffle<Float16> s,
++                                  Vector<Float16> v) {
 +        return (HalffloatMaxVector)
 +            super.rearrangeTemplate(HalffloatMaxShuffle.class,
 +                                    (HalffloatMaxShuffle) s,
 +                                    (HalffloatMaxVector) v);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public HalffloatMaxVector compress(VectorMask<Halffloat> m) {
++    public HalffloatMaxVector compress(VectorMask<Float16> m) {
 +        return (HalffloatMaxVector)
 +            super.compressTemplate(HalffloatMaxMask.class,
 +                                   (HalffloatMaxMask) m);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public HalffloatMaxVector expand(VectorMask<Halffloat> m) {
++    public HalffloatMaxVector expand(VectorMask<Float16> m) {
 +        return (HalffloatMaxVector)
 +            super.expandTemplate(HalffloatMaxMask.class,
 +                                   (HalffloatMaxMask) m);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public HalffloatMaxVector selectFrom(Vector<Halffloat> v) {
++    public HalffloatMaxVector selectFrom(Vector<Float16> v) {
 +        return (HalffloatMaxVector)
 +            super.selectFromTemplate((HalffloatMaxVector) v);  // specialize
 +    }
 +
 +    @Override
 +    @ForceInline
-     public HalffloatMaxVector selectFrom(Vector<Halffloat> v,
-                                    VectorMask<Halffloat> m) {
++    public HalffloatMaxVector selectFrom(Vector<Float16> v,
++                                   VectorMask<Float16> m) {
 +        return (HalffloatMaxVector)
 +            super.selectFromTemplate((HalffloatMaxVector) v,
-                                      (HalffloatMaxMask) m);  // specialize
++                                     HalffloatMaxMask.class, (HalffloatMaxMask) m);  // specialize
 +    }
 +
++    @Override
++    @ForceInline
++    public HalffloatMaxVector selectFrom(Vector<Float16> v1,
++                                   Vector<Float16> v2) {
++        return (HalffloatMaxVector)
++            super.selectFromTemplate((HalffloatMaxVector) v1, (HalffloatMaxVector) v2);  // specialize
++    }
 +
 +    @ForceInline
 +    @Override
 +    public short lane(int i) {
 +        if (i < 0 || i >= VLENGTH) {
 +            throw new IllegalArgumentException("Index " + i + " must be zero or positive, and less than " + VLENGTH);
 +        }
 +        short bits = laneHelper(i);
-         return Halffloat.shortBitsToHalffloat(bits);
++        return bits;
 +    }
 +
++    @ForceInline
 +    public short laneHelper(int i) {
 +        return (short) VectorSupport.extract(
-                      VCLASS, ETYPE, VLENGTH,
++                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
 +                     this, i,
 +                     (vec, ix) -> {
 +                     short[] vecarr = vec.vec();
-                      return (long)Halffloat.shortToShortBits(vecarr[ix]);
++                     return vecarr[ix];
 +                     });
 +    }
 +
 +    @ForceInline
 +    @Override
 +    public HalffloatMaxVector withLane(int i, short e) {
 +        if (i < 0 || i >= VLENGTH) {
 +            throw new IllegalArgumentException("Index " + i + " must be zero or positive, and less than " + VLENGTH);
 +        }
 +        return withLaneHelper(i, e);
 +    }
 +
++    @ForceInline
 +    public HalffloatMaxVector withLaneHelper(int i, short e) {
 +        return VectorSupport.insert(
-                                 VCLASS, ETYPE, VLENGTH,
-                                 this, i, (long)Halffloat.shortToShortBits(e),
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                this, i, (long)e,
 +                                (v, ix, bits) -> {
 +                                    short[] res = v.vec().clone();
-                                     res[ix] = Halffloat.shortBitsToHalffloat((short)bits);
++                                    res[ix] = e;
 +                                    return v.vectorFactory(res);
 +                                });
 +    }
 +
 +    // Mask
 +
-     static final class HalffloatMaxMask extends AbstractMask<Halffloat> {
++    static final class HalffloatMaxMask extends AbstractMask<Float16> {
 +        static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
-         static final Class<Halffloat> ETYPE = Halffloat.class; // used by the JVM
++        static final Class<Short> CTYPE = short.class; // used by the JVM
 +
 +        HalffloatMaxMask(boolean[] bits) {
 +            this(bits, 0);
 +        }
 +
 +        HalffloatMaxMask(boolean[] bits, int offset) {
 +            super(prepare(bits, offset));
 +        }
 +
 +        HalffloatMaxMask(boolean val) {
 +            super(prepare(val));
 +        }
 +
 +        private static boolean[] prepare(boolean[] bits, int offset) {
 +            boolean[] newBits = new boolean[VSPECIES.laneCount()];
 +            for (int i = 0; i < newBits.length; i++) {
 +                newBits[i] = bits[offset + i];
 +            }
 +            return newBits;
 +        }
 +
 +        private static boolean[] prepare(boolean val) {
 +            boolean[] bits = new boolean[VSPECIES.laneCount()];
 +            Arrays.fill(bits, val);
 +            return bits;
 +        }
 +
 +        @ForceInline
 +        final @Override
 +        public HalffloatSpecies vspecies() {
 +            // ISSUE:  This should probably be a @Stable
 +            // field inside AbstractMask, rather than
 +            // a megamorphic method.
 +            return VSPECIES;
 +        }
 +
 +        @ForceInline
 +        boolean[] getBits() {
 +            return (boolean[])getPayload();
 +        }
 +
 +        @Override
 +        HalffloatMaxMask uOp(MUnOp f) {
 +            boolean[] res = new boolean[vspecies().laneCount()];
 +            boolean[] bits = getBits();
 +            for (int i = 0; i < res.length; i++) {
 +                res[i] = f.apply(i, bits[i]);
 +            }
 +            return new HalffloatMaxMask(res);
 +        }
 +
 +        @Override
-         HalffloatMaxMask bOp(VectorMask<Halffloat> m, MBinOp f) {
++        HalffloatMaxMask bOp(VectorMask<Float16> m, MBinOp f) {
 +            boolean[] res = new boolean[vspecies().laneCount()];
 +            boolean[] bits = getBits();
 +            boolean[] mbits = ((HalffloatMaxMask)m).getBits();
 +            for (int i = 0; i < res.length; i++) {
 +                res[i] = f.apply(i, bits[i], mbits[i]);
 +            }
 +            return new HalffloatMaxMask(res);
 +        }
 +
 +        @ForceInline
 +        @Override
 +        public final
 +        HalffloatMaxVector toVector() {
 +            return (HalffloatMaxVector) super.toVectorTemplate();  // specialize
 +        }
 +
 +        /**
 +         * Helper function for lane-wise mask conversions.
 +         * This function kicks in after intrinsic failure.
 +         */
 +        @ForceInline
 +        private final <E>
 +        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {
 +            if (length() != dsp.laneCount())
 +                throw new IllegalArgumentException("VectorMask length and species length differ");
 +            boolean[] maskArray = toArray();
 +            return  dsp.maskFactory(maskArray).check(dsp);
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
 +            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;
 +            if (length() != species.laneCount())
 +                throw new IllegalArgumentException("VectorMask length and species length differ");
 +
 +            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,
 +                this.getClass(), ETYPE, VLENGTH,
 +                species.maskType(), species.elementType(), VLENGTH,
 +                this, species,
 +                (m, s) -> s.maskFactory(m.toArray()).check(s));
 +        }
 +
 +        @Override
 +        @ForceInline
 +        /*package-private*/
 +        HalffloatMaxMask indexPartiallyInUpperRange(long offset, long limit) {
 +            return (HalffloatMaxMask) VectorSupport.indexPartiallyInUpperRange(
-                 HalffloatMaxMask.class, ETYPE, VLENGTH, offset, limit,
++                HalffloatMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
 +                (o, l) -> (HalffloatMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));
 +        }
 +
 +        // Unary operations
 +
 +        @Override
 +        @ForceInline
 +        public HalffloatMaxMask not() {
 +            return xor(maskAll(true));
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public HalffloatMaxMask compress() {
 +            return (HalffloatMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                 HalffloatMaxVector.class, HalffloatMaxMask.class, ETYPE, VLENGTH, null, this,
-                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, Float.floatToFloat16(m1.trueCount())));
++                HalffloatMaxVector.class, HalffloatMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                Float16.float16ToShortBits(Float16.valueOf(m1.trueCount()))));
 +        }
 +
 +
 +        // Binary operations
 +
 +        @Override
 +        @ForceInline
-         public HalffloatMaxMask and(VectorMask<Halffloat> mask) {
++        public HalffloatMaxMask and(VectorMask<Float16> mask) {
 +            Objects.requireNonNull(mask);
 +            HalffloatMaxMask m = (HalffloatMaxMask)mask;
-             return VectorSupport.binaryOp(VECTOR_OP_AND, HalffloatMaxMask.class, null, Halffloat.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, HalffloatMaxMask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
 +                                          this, m, null,
 +                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
 +        }
 +
 +        @Override
 +        @ForceInline
-         public HalffloatMaxMask or(VectorMask<Halffloat> mask) {
++        public HalffloatMaxMask or(VectorMask<Float16> mask) {
 +            Objects.requireNonNull(mask);
 +            HalffloatMaxMask m = (HalffloatMaxMask)mask;
-             return VectorSupport.binaryOp(VECTOR_OP_OR, HalffloatMaxMask.class, null, Halffloat.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, HalffloatMaxMask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
 +                                          this, m, null,
 +                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
 +        }
 +
 +        @Override
 +        @ForceInline
-         public HalffloatMaxMask xor(VectorMask<Halffloat> mask) {
++        public HalffloatMaxMask xor(VectorMask<Float16> mask) {
 +            Objects.requireNonNull(mask);
 +            HalffloatMaxMask m = (HalffloatMaxMask)mask;
-             return VectorSupport.binaryOp(VECTOR_OP_XOR, HalffloatMaxMask.class, null, Halffloat.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, HalffloatMaxMask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
 +                                          this, m, null,
 +                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
 +        }
 +
 +        // Mask Query operations
 +
 +        @Override
 +        @ForceInline
 +        public int trueCount() {
-             return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, HalffloatMaxMask.class, Halffloat.class, VLENGTH, this,
-                                                       (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, HalffloatMaxMask.class, short.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public int firstTrue() {
-             return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, HalffloatMaxMask.class, Halffloat.class, VLENGTH, this,
-                                                       (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, HalffloatMaxMask.class, short.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public int lastTrue() {
-             return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, HalffloatMaxMask.class, Halffloat.class, VLENGTH, this,
-                                                       (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, HalffloatMaxMask.class, short.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public long toLong() {
 +            if (length() > Long.SIZE) {
 +                throw new UnsupportedOperationException("too many lanes for one long");
 +            }
-             return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, HalffloatMaxMask.class, Halffloat.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, HalffloatMaxMask.class, short.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
 +                                                      (m) -> toLongHelper(m.getBits()));
 +        }
 +
++        // laneIsSet
++
++        @Override
++        @ForceInline
++        public boolean laneIsSet(int i) {
++            Objects.checkIndex(i, length());
++            return VectorSupport.extract(HalffloatMaxMask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
++        }
++
 +        // Reductions
 +
 +        @Override
 +        @ForceInline
 +        public boolean anyTrue() {
-             return VectorSupport.test(BT_ne, HalffloatMaxMask.class, Halffloat.class, VLENGTH,
-                                          this, vspecies().maskAll(true),
-                                          (m, __) -> anyTrueHelper(((HalffloatMaxMask)m).getBits()));
++            return VectorSupport.test(BT_ne, HalffloatMaxMask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper(((HalffloatMaxMask)m).getBits()));
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public boolean allTrue() {
-             return VectorSupport.test(BT_overflow, HalffloatMaxMask.class, Halffloat.class, VLENGTH,
-                                          this, vspecies().maskAll(true),
-                                          (m, __) -> allTrueHelper(((HalffloatMaxMask)m).getBits()));
++            return VectorSupport.test(BT_overflow, HalffloatMaxMask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper(((HalffloatMaxMask)m).getBits()));
 +        }
 +
 +        @ForceInline
 +        /*package-private*/
 +        static HalffloatMaxMask maskAll(boolean bit) {
-             return VectorSupport.fromBitsCoerced(HalffloatMaxMask.class, Halffloat.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced(HalffloatMaxMask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
 +                                                 (bit ? -1 : 0), MODE_BROADCAST, null,
 +                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
 +        }
 +        private static final HalffloatMaxMask  TRUE_MASK = new HalffloatMaxMask(true);
 +        private static final HalffloatMaxMask FALSE_MASK = new HalffloatMaxMask(false);
 +
 +    }
 +
 +    // Shuffle
 +
-     static final class HalffloatMaxShuffle extends AbstractShuffle<Halffloat> {
++    static final class HalffloatMaxShuffle extends AbstractShuffle<Float16> {
 +        static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
-         static final Class<Short> ETYPE = short.class; // used by the JVM
++        static final Class<Short> CTYPE = short.class; // used by the JVM
 +
 +        HalffloatMaxShuffle(short[] indices) {
 +            super(indices);
 +            assert(VLENGTH == indices.length);
 +            assert(indicesInRange(indices));
 +        }
 +
 +        HalffloatMaxShuffle(int[] indices, int i) {
 +            this(prepare(indices, i));
 +        }
 +
 +        HalffloatMaxShuffle(IntUnaryOperator fn) {
 +            this(prepare(fn));
 +        }
 +
 +        short[] indices() {
 +            return (short[])getPayload();
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public HalffloatSpecies vspecies() {
 +            return VSPECIES;
 +        }
 +
 +        static {
 +            // There must be enough bits in the shuffle lanes to encode
 +            // VLENGTH valid indexes and VLENGTH exceptional ones.
 +            assert(VLENGTH < Short.MAX_VALUE);
 +            assert(Short.MIN_VALUE <= -VLENGTH);
 +        }
 +        static final HalffloatMaxShuffle IOTA = new HalffloatMaxShuffle(IDENTITY);
 +
++        @Override
++        @ForceInline
++        public HalffloatMaxVector toVector() {
++            return (HalffloatMaxVector) toBitsVector().castShape(vspecies(), 0);
++        }
++
 +        @Override
 +        @ForceInline
 +        ShortMaxVector toBitsVector() {
 +            return (ShortMaxVector) super.toBitsVectorTemplate();
 +        }
 +
 +        @Override
-         @ForceInline
-         ShortVector toBitsVector0() {
-             return ShortMaxVector.VSPECIES.dummyVector().vectorFactory(indices());
++        ShortMaxVector toBitsVector0() {
++            return ((ShortMaxVector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public int laneSource(int i) {
 +            return (int)toBitsVector().lane(i);
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public void intoArray(int[] a, int offset) {
 +            VectorSpecies<Integer> species = IntVector.SPECIES_MAX;
 +            Vector<Short> v = toBitsVector();
 +            v.convertShape(VectorOperators.S2I, species, 0)
 +                    .reinterpretAsInts()
 +                    .intoArray(a, offset);
 +            v.convertShape(VectorOperators.S2I, species, 1)
 +                    .reinterpretAsInts()
 +                    .intoArray(a, offset + species.length());
 +        }
 +
++        @Override
++        @ForceInline
++        public void intoMemorySegment(MemorySegment ms, long offset, ByteOrder bo) {
++            VectorSpecies<Integer> species = IntVector.SPECIES_MAX;
++            Vector<Short> v = toBitsVector();
++            v.convertShape(VectorOperators.S2I, species, 0)
++                    .reinterpretAsInts()
++                    .intoMemorySegment(ms, offset, bo);
++            v.convertShape(VectorOperators.S2I, species, 1)
++                    .reinterpretAsInts()
++                    .intoMemorySegment(ms, offset + species.vectorByteSize(), bo);
++         }
++
++        @Override
++        @ForceInline
++        public final HalffloatMaxMask laneIsValid() {
++            return (HalffloatMaxMask) toBitsVector().compare(VectorOperators.GE, 0)
++                    .cast(vspecies());
++        }
++
++        @ForceInline
++        @Override
++        public final HalffloatMaxShuffle rearrange(VectorShuffle<Float16> shuffle) {
++            HalffloatMaxShuffle concreteShuffle = (HalffloatMaxShuffle) shuffle;
++            return (HalffloatMaxShuffle) toBitsVector().rearrange(concreteShuffle.cast(ShortVector.SPECIES_MAX))
++                    .toShuffle(vspecies(), false);
++        }
++
++        @ForceInline
++        @Override
++        public final HalffloatMaxShuffle wrapIndexes() {
++            ShortMaxVector v = toBitsVector();
++            if ((length() & (length() - 1)) == 0) {
++                v = (ShortMaxVector) v.lanewise(VectorOperators.AND, length() - 1);
++            } else {
++                v = (ShortMaxVector) v.blend(v.lanewise(VectorOperators.ADD, length()),
++                            v.compare(VectorOperators.LT, 0));
++            }
++            return (HalffloatMaxShuffle) v.toShuffle(vspecies(), false);
++        }
++
 +        private static short[] prepare(int[] indices, int offset) {
 +            short[] a = new short[VLENGTH];
 +            for (int i = 0; i < VLENGTH; i++) {
 +                int si = indices[offset + i];
 +                si = partiallyWrapIndex(si, VLENGTH);
 +                a[i] = (short)si;
 +            }
 +            return a;
 +        }
 +
 +        private static short[] prepare(IntUnaryOperator f) {
 +            short[] a = new short[VLENGTH];
 +            for (int i = 0; i < VLENGTH; i++) {
 +                int si = f.applyAsInt(i);
 +                si = partiallyWrapIndex(si, VLENGTH);
 +                a[i] = (short)si;
 +            }
 +            return a;
 +        }
 +
 +        private static boolean indicesInRange(short[] indices) {
 +            int length = indices.length;
 +            for (short si : indices) {
 +                if (si >= (short)length || si < (short)(-length)) {
-                     boolean assertsEnabled = false;
-                     assert(assertsEnabled = true);
-                     if (assertsEnabled) {
-                         String msg = ("index "+si+"out of range ["+length+"] in "+
++                    String msg = ("index "+si+"out of range ["+length+"] in "+
 +                                  java.util.Arrays.toString(indices));
-                         throw new AssertionError(msg);
-                     }
-                     return false;
++                    throw new AssertionError(msg);
 +                }
 +            }
 +            return true;
 +        }
 +    }
 +
 +    // ================================================
 +
 +    // Specialized low-level memory operations.
 +
 +    @ForceInline
 +    @Override
 +    final
 +    HalffloatVector fromArray0(short[] a, int offset) {
 +        return super.fromArray0Template(a, offset);  // specialize
 +    }
 +
 +    @ForceInline
 +    @Override
 +    final
-     HalffloatVector fromArray0(short[] a, int offset, VectorMask<Halffloat> m, int offsetInRange) {
++    HalffloatVector fromArray0(short[] a, int offset, VectorMask<Float16> m, int offsetInRange) {
 +        return super.fromArray0Template(HalffloatMaxMask.class, a, offset, (HalffloatMaxMask) m, offsetInRange);  // specialize
 +    }
 +
++    @ForceInline
++    @Override
++    final
++    HalffloatVector fromArray0(short[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float16> m) {
++        return super.fromArray0Template(HalffloatMaxMask.class, a, offset, indexMap, mapOffset, (HalffloatMaxMask) m);
++    }
 +
 +    @ForceInline
 +    @Override
 +    final
 +    HalffloatVector fromCharArray0(char[] a, int offset) {
 +        return super.fromCharArray0Template(a, offset);  // specialize
 +    }
 +
 +    @ForceInline
 +    @Override
 +    final
-     HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Halffloat> m, int offsetInRange) {
++    HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Float16> m, int offsetInRange) {
 +        return super.fromCharArray0Template(HalffloatMaxMask.class, a, offset, (HalffloatMaxMask) m, offsetInRange);  // specialize
 +    }
 +
 +
 +    @ForceInline
 +    @Override
 +    final
 +    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset) {
 +        return super.fromMemorySegment0Template(ms, offset);  // specialize
 +    }
 +
 +    @ForceInline
 +    @Override
 +    final
-     HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Halffloat> m, int offsetInRange) {
++    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m, int offsetInRange) {
 +        return super.fromMemorySegment0Template(HalffloatMaxMask.class, ms, offset, (HalffloatMaxMask) m, offsetInRange);  // specialize
 +    }
 +
 +    @ForceInline
 +    @Override
 +    final
 +    void intoArray0(short[] a, int offset) {
 +        super.intoArray0Template(a, offset);  // specialize
 +    }
 +
 +    @ForceInline
 +    @Override
 +    final
-     void intoArray0(short[] a, int offset, VectorMask<Halffloat> m) {
++    void intoArray0(short[] a, int offset, VectorMask<Float16> m) {
 +        super.intoArray0Template(HalffloatMaxMask.class, a, offset, (HalffloatMaxMask) m);
 +    }
 +
 +
 +
 +    @ForceInline
 +    @Override
 +    final
-     void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Halffloat> m) {
++    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m) {
 +        super.intoMemorySegment0Template(HalffloatMaxMask.class, ms, offset, (HalffloatMaxMask) m);
 +    }
 +
 +    @ForceInline
 +    @Override
 +    final
-     void intoCharArray0(char[] a, int offset, VectorMask<Halffloat> m) {
++    void intoCharArray0(char[] a, int offset, VectorMask<Float16> m) {
 +        super.intoCharArray0Template(HalffloatMaxMask.class, a, offset, (HalffloatMaxMask) m);
 +    }
 +
 +    // End of specialized low-level memory operations.
 +
 +    // ================================================
 +
 +}
 +
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/HalffloatVector.java
index f39231b3805,00000000000..84983792ff5
mode 100644,000000..100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/HalffloatVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/HalffloatVector.java
@@@ -1,4200 -1,0 +1,4361 @@@
 +/*
-  * Copyright (c) 2017, 2023, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
 + * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 + *
 + * This code is free software; you can redistribute it and/or modify it
 + * under the terms of the GNU General Public License version 2 only, as
 + * published by the Free Software Foundation.  Oracle designates this
 + * particular file as subject to the "Classpath" exception as provided
 + * by Oracle in the LICENSE file that accompanied this code.
 + *
 + * This code is distributed in the hope that it will be useful, but WITHOUT
 + * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 + * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 + * version 2 for more details (a copy is included in the LICENSE file that
 + * accompanied this code).
 + *
 + * You should have received a copy of the GNU General Public License version
 + * 2 along with this work; if not, write to the Free Software Foundation,
 + * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 + *
 + * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 + * or visit www.oracle.com if you need additional information or have any
 + * questions.
 + */
 +package jdk.incubator.vector;
 +
 +import java.lang.foreign.MemorySegment;
 +import java.lang.foreign.ValueLayout;
 +import java.nio.ByteOrder;
 +import java.util.Arrays;
 +import java.util.Objects;
 +import java.util.function.Function;
 +
 +import jdk.internal.foreign.AbstractMemorySegmentImpl;
 +import jdk.internal.misc.ScopedMemoryAccess;
 +import jdk.internal.misc.Unsafe;
 +import jdk.internal.vm.annotation.ForceInline;
 +import jdk.internal.vm.vector.VectorSupport;
 +
 +import static jdk.internal.vm.vector.VectorSupport.*;
 +import static jdk.incubator.vector.VectorIntrinsics.*;
 +
 +import static jdk.incubator.vector.VectorOperators.*;
++import jdk.incubator.vector.Float16;
 +
 +// -- This file was mechanically generated: Do not edit! -- //
 +
 +/**
 + * A specialized {@link Vector} representing an ordered immutable sequence of
 + * {@code short} values.
 + */
 +@SuppressWarnings("cast")  // warning: redundant cast
- public abstract class HalffloatVector extends AbstractVector<Halffloat> {
++public abstract class HalffloatVector extends AbstractVector<Float16> {
 +
 +    HalffloatVector(short[] vec) {
 +        super(vec);
 +    }
 +
 +    static final int FORBID_OPCODE_KIND = VO_NOFP;
 +
-     static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withBitAlignment(8);
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_FP16;
++
++    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withByteAlignment(1);
 +
 +    @ForceInline
 +    static int opCode(Operator op) {
 +        return VectorOperators.opCode(op, VO_OPCODE_VALID, FORBID_OPCODE_KIND);
 +    }
 +    @ForceInline
 +    static int opCode(Operator op, int requireKind) {
 +        requireKind |= VO_OPCODE_VALID;
 +        return VectorOperators.opCode(op, requireKind, FORBID_OPCODE_KIND);
 +    }
 +    @ForceInline
 +    static boolean opKind(Operator op, int bit) {
 +        return VectorOperators.opKind(op, bit);
 +    }
 +
 +    // Virtualized factories and operators,
 +    // coded with portable definitions.
 +    // These are all @ForceInline in case
 +    // they need to be used performantly.
 +    // The various shape-specific subclasses
 +    // also specialize them by wrapping
 +    // them in a call like this:
 +    //    return (Byte128Vector)
 +    //       super.bOp((Byte128Vector) o);
 +    // The purpose of that is to forcibly inline
 +    // the generic definition from this file
-     // into a sharply type- and size-specific
++    // into a sharply-typed and size-specific
 +    // wrapper in the subclass file, so that
 +    // the JIT can specialize the code.
 +    // The code is only inlined and expanded
 +    // if it gets hot.  Think of it as a cheap
 +    // and lazy version of C++ templates.
 +
 +    // Virtualized getter
 +
 +    /*package-private*/
 +    abstract short[] vec();
 +
 +    // Virtualized constructors
 +
 +    /**
 +     * Build a vector directly using my own constructor.
 +     * It is an error if the array is aliased elsewhere.
 +     */
 +    /*package-private*/
 +    abstract HalffloatVector vectorFactory(short[] vec);
 +
 +    /**
 +     * Build a mask directly using my species.
 +     * It is an error if the array is aliased elsewhere.
 +     */
 +    /*package-private*/
 +    @ForceInline
 +    final
-     AbstractMask<Halffloat> maskFactory(boolean[] bits) {
++    AbstractMask<Float16> maskFactory(boolean[] bits) {
 +        return vspecies().maskFactory(bits);
 +    }
 +
 +    // Constant loader (takes dummy as vector arg)
 +    interface FVOp {
 +        short apply(int i);
 +    }
 +
 +    /*package-private*/
 +    @ForceInline
 +    final
 +    HalffloatVector vOp(FVOp f) {
 +        short[] res = new short[length()];
 +        for (int i = 0; i < res.length; i++) {
 +            res[i] = f.apply(i);
 +        }
 +        return vectorFactory(res);
 +    }
 +
 +    @ForceInline
 +    final
-     HalffloatVector vOp(VectorMask<Halffloat> m, FVOp f) {
++    HalffloatVector vOp(VectorMask<Float16> m, FVOp f) {
 +        short[] res = new short[length()];
-         boolean[] mbits = ((AbstractMask<Halffloat>)m).getBits();
++        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();
 +        for (int i = 0; i < res.length; i++) {
 +            if (mbits[i]) {
 +                res[i] = f.apply(i);
 +            }
 +        }
 +        return vectorFactory(res);
 +    }
 +
 +    // Unary operator
 +
 +    /*package-private*/
 +    interface FUnOp {
 +        short apply(int i, short a);
 +    }
 +
 +    /*package-private*/
 +    abstract
 +    HalffloatVector uOp(FUnOp f);
 +    @ForceInline
 +    final
 +    HalffloatVector uOpTemplate(FUnOp f) {
 +        short[] vec = vec();
 +        short[] res = new short[length()];
 +        for (int i = 0; i < res.length; i++) {
 +            res[i] = f.apply(i, vec[i]);
 +        }
 +        return vectorFactory(res);
 +    }
 +
 +    /*package-private*/
 +    abstract
-     HalffloatVector uOp(VectorMask<Halffloat> m,
++    HalffloatVector uOp(VectorMask<Float16> m,
 +                             FUnOp f);
 +    @ForceInline
 +    final
-     HalffloatVector uOpTemplate(VectorMask<Halffloat> m,
++    HalffloatVector uOpTemplate(VectorMask<Float16> m,
 +                                     FUnOp f) {
 +        if (m == null) {
 +            return uOpTemplate(f);
 +        }
 +        short[] vec = vec();
 +        short[] res = new short[length()];
-         boolean[] mbits = ((AbstractMask<Halffloat>)m).getBits();
++        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();
 +        for (int i = 0; i < res.length; i++) {
 +            res[i] = mbits[i] ? f.apply(i, vec[i]) : vec[i];
 +        }
 +        return vectorFactory(res);
 +    }
 +
 +    // Binary operator
 +
 +    /*package-private*/
 +    interface FBinOp {
 +        short apply(int i, short a, short b);
 +    }
 +
 +    /*package-private*/
 +    abstract
-     HalffloatVector bOp(Vector<Halffloat> o,
++    HalffloatVector bOp(Vector<Float16> o,
 +                             FBinOp f);
 +    @ForceInline
 +    final
-     HalffloatVector bOpTemplate(Vector<Halffloat> o,
++    HalffloatVector bOpTemplate(Vector<Float16> o,
 +                                     FBinOp f) {
 +        short[] res = new short[length()];
 +        short[] vec1 = this.vec();
 +        short[] vec2 = ((HalffloatVector)o).vec();
 +        for (int i = 0; i < res.length; i++) {
 +            res[i] = f.apply(i, vec1[i], vec2[i]);
 +        }
 +        return vectorFactory(res);
 +    }
 +
 +    /*package-private*/
 +    abstract
-     HalffloatVector bOp(Vector<Halffloat> o,
-                              VectorMask<Halffloat> m,
++    HalffloatVector bOp(Vector<Float16> o,
++                             VectorMask<Float16> m,
 +                             FBinOp f);
 +    @ForceInline
 +    final
-     HalffloatVector bOpTemplate(Vector<Halffloat> o,
-                                      VectorMask<Halffloat> m,
++    HalffloatVector bOpTemplate(Vector<Float16> o,
++                                     VectorMask<Float16> m,
 +                                     FBinOp f) {
 +        if (m == null) {
 +            return bOpTemplate(o, f);
 +        }
 +        short[] res = new short[length()];
 +        short[] vec1 = this.vec();
 +        short[] vec2 = ((HalffloatVector)o).vec();
-         boolean[] mbits = ((AbstractMask<Halffloat>)m).getBits();
++        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();
 +        for (int i = 0; i < res.length; i++) {
 +            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i]) : vec1[i];
 +        }
 +        return vectorFactory(res);
 +    }
 +
 +    // Ternary operator
 +
 +    /*package-private*/
 +    interface FTriOp {
 +        short apply(int i, short a, short b, short c);
 +    }
 +
 +    /*package-private*/
 +    abstract
-     HalffloatVector tOp(Vector<Halffloat> o1,
-                              Vector<Halffloat> o2,
++    HalffloatVector tOp(Vector<Float16> o1,
++                             Vector<Float16> o2,
 +                             FTriOp f);
 +    @ForceInline
 +    final
-     HalffloatVector tOpTemplate(Vector<Halffloat> o1,
-                                      Vector<Halffloat> o2,
++    HalffloatVector tOpTemplate(Vector<Float16> o1,
++                                     Vector<Float16> o2,
 +                                     FTriOp f) {
 +        short[] res = new short[length()];
 +        short[] vec1 = this.vec();
 +        short[] vec2 = ((HalffloatVector)o1).vec();
 +        short[] vec3 = ((HalffloatVector)o2).vec();
 +        for (int i = 0; i < res.length; i++) {
 +            res[i] = f.apply(i, vec1[i], vec2[i], vec3[i]);
 +        }
 +        return vectorFactory(res);
 +    }
 +
 +    /*package-private*/
 +    abstract
-     HalffloatVector tOp(Vector<Halffloat> o1,
-                              Vector<Halffloat> o2,
-                              VectorMask<Halffloat> m,
++    HalffloatVector tOp(Vector<Float16> o1,
++                             Vector<Float16> o2,
++                             VectorMask<Float16> m,
 +                             FTriOp f);
 +    @ForceInline
 +    final
-     HalffloatVector tOpTemplate(Vector<Halffloat> o1,
-                                      Vector<Halffloat> o2,
-                                      VectorMask<Halffloat> m,
++    HalffloatVector tOpTemplate(Vector<Float16> o1,
++                                     Vector<Float16> o2,
++                                     VectorMask<Float16> m,
 +                                     FTriOp f) {
 +        if (m == null) {
 +            return tOpTemplate(o1, o2, f);
 +        }
 +        short[] res = new short[length()];
 +        short[] vec1 = this.vec();
 +        short[] vec2 = ((HalffloatVector)o1).vec();
 +        short[] vec3 = ((HalffloatVector)o2).vec();
-         boolean[] mbits = ((AbstractMask<Halffloat>)m).getBits();
++        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();
 +        for (int i = 0; i < res.length; i++) {
 +            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i], vec3[i]) : vec1[i];
 +        }
 +        return vectorFactory(res);
 +    }
 +
 +    // Reduction operator
 +
 +    /*package-private*/
 +    abstract
-     short rOp(short v, VectorMask<Halffloat> m, FBinOp f);
++    short rOp(short v, VectorMask<Float16> m, FBinOp f);
 +
 +    @ForceInline
 +    final
-     short rOpTemplate(short v, VectorMask<Halffloat> m, FBinOp f) {
++    short rOpTemplate(short v, VectorMask<Float16> m, FBinOp f) {
 +        if (m == null) {
 +            return rOpTemplate(v, f);
 +        }
 +        short[] vec = vec();
-         boolean[] mbits = ((AbstractMask<Halffloat>)m).getBits();
++        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();
 +        for (int i = 0; i < vec.length; i++) {
 +            v = mbits[i] ? f.apply(i, v, vec[i]) : v;
 +        }
 +        return v;
 +    }
 +
 +    @ForceInline
 +    final
 +    short rOpTemplate(short v, FBinOp f) {
 +        short[] vec = vec();
 +        for (int i = 0; i < vec.length; i++) {
 +            v = f.apply(i, v, vec[i]);
 +        }
 +        return v;
 +    }
 +
 +    // Memory reference
 +
 +    /*package-private*/
 +    interface FLdOp<M> {
 +        short apply(M memory, int offset, int i);
 +    }
 +
 +    /*package-private*/
 +    @ForceInline
 +    final
 +    <M> HalffloatVector ldOp(M memory, int offset,
 +                                  FLdOp<M> f) {
 +        //dummy; no vec = vec();
 +        short[] res = new short[length()];
 +        for (int i = 0; i < res.length; i++) {
 +            res[i] = f.apply(memory, offset, i);
 +        }
 +        return vectorFactory(res);
 +    }
 +
 +    /*package-private*/
 +    @ForceInline
 +    final
 +    <M> HalffloatVector ldOp(M memory, int offset,
-                                   VectorMask<Halffloat> m,
++                                  VectorMask<Float16> m,
 +                                  FLdOp<M> f) {
 +        //short[] vec = vec();
 +        short[] res = new short[length()];
-         boolean[] mbits = ((AbstractMask<Halffloat>)m).getBits();
++        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();
 +        for (int i = 0; i < res.length; i++) {
 +            if (mbits[i]) {
 +                res[i] = f.apply(memory, offset, i);
 +            }
 +        }
 +        return vectorFactory(res);
 +    }
 +
 +    /*package-private*/
 +    interface FLdLongOp {
 +        short apply(MemorySegment memory, long offset, int i);
 +    }
 +
 +    /*package-private*/
 +    @ForceInline
 +    final
 +    HalffloatVector ldLongOp(MemorySegment memory, long offset,
 +                                  FLdLongOp f) {
 +        //dummy; no vec = vec();
 +        short[] res = new short[length()];
 +        for (int i = 0; i < res.length; i++) {
 +            res[i] = f.apply(memory, offset, i);
 +        }
 +        return vectorFactory(res);
 +    }
 +
 +    /*package-private*/
 +    @ForceInline
 +    final
 +    HalffloatVector ldLongOp(MemorySegment memory, long offset,
-                                   VectorMask<Halffloat> m,
++                                  VectorMask<Float16> m,
 +                                  FLdLongOp f) {
 +        //short[] vec = vec();
 +        short[] res = new short[length()];
-         boolean[] mbits = ((AbstractMask<Halffloat>)m).getBits();
++        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();
 +        for (int i = 0; i < res.length; i++) {
 +            if (mbits[i]) {
 +                res[i] = f.apply(memory, offset, i);
 +            }
 +        }
 +        return vectorFactory(res);
 +    }
 +
 +    static short memorySegmentGet(MemorySegment ms, long o, int i) {
 +        return ms.get(ELEMENT_LAYOUT, o + i * 2L);
 +    }
 +
 +    interface FStOp<M> {
 +        void apply(M memory, int offset, int i, short a);
 +    }
 +
 +    /*package-private*/
 +    @ForceInline
 +    final
 +    <M> void stOp(M memory, int offset,
 +                  FStOp<M> f) {
 +        short[] vec = vec();
 +        for (int i = 0; i < vec.length; i++) {
 +            f.apply(memory, offset, i, vec[i]);
 +        }
 +    }
 +
 +    /*package-private*/
 +    @ForceInline
 +    final
 +    <M> void stOp(M memory, int offset,
-                   VectorMask<Halffloat> m,
++                  VectorMask<Float16> m,
 +                  FStOp<M> f) {
 +        short[] vec = vec();
-         boolean[] mbits = ((AbstractMask<Halffloat>)m).getBits();
++        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();
 +        for (int i = 0; i < vec.length; i++) {
 +            if (mbits[i]) {
 +                f.apply(memory, offset, i, vec[i]);
 +            }
 +        }
 +    }
 +
 +    interface FStLongOp {
 +        void apply(MemorySegment memory, long offset, int i, short a);
 +    }
 +
 +    /*package-private*/
 +    @ForceInline
 +    final
 +    void stLongOp(MemorySegment memory, long offset,
 +                  FStLongOp f) {
 +        short[] vec = vec();
 +        for (int i = 0; i < vec.length; i++) {
 +            f.apply(memory, offset, i, vec[i]);
 +        }
 +    }
 +
 +    /*package-private*/
 +    @ForceInline
 +    final
 +    void stLongOp(MemorySegment memory, long offset,
-                   VectorMask<Halffloat> m,
++                  VectorMask<Float16> m,
 +                  FStLongOp f) {
 +        short[] vec = vec();
-         boolean[] mbits = ((AbstractMask<Halffloat>)m).getBits();
++        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();
 +        for (int i = 0; i < vec.length; i++) {
 +            if (mbits[i]) {
 +                f.apply(memory, offset, i, vec[i]);
 +            }
 +        }
 +    }
 +
 +    static void memorySegmentSet(MemorySegment ms, long o, int i, short e) {
 +        ms.set(ELEMENT_LAYOUT, o + i * 2L, e);
 +    }
 +
 +    // Binary test
 +
 +    /*package-private*/
 +    interface FBinTest {
 +        boolean apply(int cond, int i, short a, short b);
 +    }
 +
 +    /*package-private*/
 +    @ForceInline
 +    final
-     AbstractMask<Halffloat> bTest(int cond,
-                                   Vector<Halffloat> o,
++    AbstractMask<Float16> bTest(int cond,
++                                  Vector<Float16> o,
 +                                  FBinTest f) {
 +        short[] vec1 = vec();
 +        short[] vec2 = ((HalffloatVector)o).vec();
 +        boolean[] bits = new boolean[length()];
 +        for (int i = 0; i < length(); i++){
 +            bits[i] = f.apply(cond, i, vec1[i], vec2[i]);
 +        }
 +        return maskFactory(bits);
 +    }
 +
 +
 +    /*package-private*/
 +    @Override
 +    abstract HalffloatSpecies vspecies();
 +
 +    /*package-private*/
 +    @ForceInline
 +    static long toBits(short e) {
-         return  Halffloat.shortToRawShortBits(e);
++        return e;
 +    }
 +
 +    /*package-private*/
 +    @ForceInline
 +    static short fromBits(long bits) {
-         return Halffloat.shortBitsToHalffloat((short)bits);
++        return Float16.float16ToRawShortBits(Float16.valueOf(bits));
 +    }
 +
-     static HalffloatVector expandHelper(Vector<Halffloat> v, VectorMask<Halffloat> m) {
-         VectorSpecies<Halffloat> vsp = m.vectorSpecies();
++    static HalffloatVector expandHelper(Vector<Float16> v, VectorMask<Float16> m) {
++        VectorSpecies<Float16> vsp = m.vectorSpecies();
 +        HalffloatVector r  = (HalffloatVector) vsp.zero();
 +        HalffloatVector vi = (HalffloatVector) v;
 +        if (m.allTrue()) {
 +            return vi;
 +        }
 +        for (int i = 0, j = 0; i < vsp.length(); i++) {
 +            if (m.laneIsSet(i)) {
 +                r = r.withLane(i, vi.lane(j++));
 +            }
 +        }
 +        return r;
 +    }
 +
-     static HalffloatVector compressHelper(Vector<Halffloat> v, VectorMask<Halffloat> m) {
-         VectorSpecies<Halffloat> vsp = m.vectorSpecies();
++    static HalffloatVector compressHelper(Vector<Float16> v, VectorMask<Float16> m) {
++        VectorSpecies<Float16> vsp = m.vectorSpecies();
 +        HalffloatVector r  = (HalffloatVector) vsp.zero();
 +        HalffloatVector vi = (HalffloatVector) v;
 +        if (m.allTrue()) {
 +            return vi;
 +        }
 +        for (int i = 0, j = 0; i < vsp.length(); i++) {
 +            if (m.laneIsSet(i)) {
 +                r = r.withLane(j++, vi.lane(i));
 +            }
 +        }
 +        return r;
 +    }
 +
++    static HalffloatVector selectFromTwoVectorHelper(Vector<Float16> indexes, Vector<Float16> src1, Vector<Float16> src2) {
++        int vlen = indexes.length();
++        short[] res = new short[vlen];
++        short[] vecPayload1 = ((HalffloatVector)indexes).vec();
++        short[] vecPayload2 = ((HalffloatVector)src1).vec();
++        short[] vecPayload3 = ((HalffloatVector)src2).vec();
++        for (int i = 0; i < vlen; i++) {
++            int wrapped_index = VectorIntrinsics.wrapToRange((int)vecPayload1[i], 2 * vlen);
++            res[i] = wrapped_index >= vlen ? vecPayload3[wrapped_index - vlen] : vecPayload2[wrapped_index];
++        }
++        return ((HalffloatVector)src1).vectorFactory(res);
++    }
++
 +    // Static factories (other than memory operations)
 +
 +    // Note: A surprising behavior in javadoc
 +    // sometimes makes a lone /** {@inheritDoc} */
 +    // comment drop the method altogether,
-     // apparently if the method mentions an
-     // parameter or return type of Vector<Halffloat>
++    // apparently if the method mentions a
++    // parameter or return type of Vector<Float16>
 +    // instead of Vector<E> as originally specified.
 +    // Adding an empty HTML fragment appears to
 +    // nudge javadoc into providing the desired
 +    // inherited documentation.  We use the HTML
 +    // comment <!--workaround--> for this.
 +
 +    /**
 +     * Returns a vector of the given species
 +     * where all lane elements are set to
 +     * zero, the default primitive value.
 +     *
 +     * @param species species of the desired zero vector
 +     * @return a zero vector
 +     */
 +    @ForceInline
-     public static HalffloatVector zero(VectorSpecies<Halffloat> species) {
++    public static HalffloatVector zero(VectorSpecies<Float16> species) {
 +        HalffloatSpecies vsp = (HalffloatSpecies) species;
-         return VectorSupport.fromBitsCoerced(vsp.vectorType(), Halffloat.class, species.length(),
-                         toBits((short)0), MODE_BROADCAST, vsp,
++        return VectorSupport.fromBitsCoerced(vsp.vectorType(), short.class, Float16.class, VECTOR_OPER_TYPE, species.length(),
++                        toBits((short) 0), MODE_BROADCAST, vsp,
 +                        ((bits_, s_) -> s_.rvOp(i -> bits_)));
 +    }
 +
 +    /**
 +     * Returns a vector of the same species as this one
 +     * where all lane elements are set to
 +     * the primitive value {@code e}.
 +     *
 +     * The contents of the current vector are discarded;
 +     * only the species is relevant to this operation.
 +     *
 +     * <p> This method returns the value of this expression:
 +     * {@code HalffloatVector.broadcast(this.species(), e)}.
 +     *
 +     * @apiNote
 +     * Unlike the similar method named {@code broadcast()}
 +     * in the supertype {@code Vector}, this method does not
 +     * need to validate its argument, and cannot throw
 +     * {@code IllegalArgumentException}.  This method is
 +     * therefore preferable to the supertype method.
 +     *
 +     * @param e the value to broadcast
 +     * @return a vector where all lane elements are set to
 +     *         the primitive value {@code e}
 +     * @see #broadcast(VectorSpecies,long)
 +     * @see Vector#broadcast(long)
 +     * @see VectorSpecies#broadcast(long)
 +     */
 +    public abstract HalffloatVector broadcast(short e);
 +
 +    /**
 +     * Returns a vector of the given species
 +     * where all lane elements are set to
 +     * the primitive value {@code e}.
 +     *
 +     * @param species species of the desired vector
 +     * @param e the value to broadcast
 +     * @return a vector where all lane elements are set to
 +     *         the primitive value {@code e}
 +     * @see #broadcast(long)
 +     * @see Vector#broadcast(long)
 +     * @see VectorSpecies#broadcast(long)
 +     */
 +    @ForceInline
-     public static HalffloatVector broadcast(VectorSpecies<Halffloat> species, short e) {
++    public static HalffloatVector broadcast(VectorSpecies<Float16> species, short e) {
 +        HalffloatSpecies vsp = (HalffloatSpecies) species;
 +        return vsp.broadcast(e);
 +    }
 +
 +    /*package-private*/
 +    @ForceInline
 +    final HalffloatVector broadcastTemplate(short e) {
 +        HalffloatSpecies vsp = vspecies();
 +        return vsp.broadcast(e);
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     * @apiNote
 +     * When working with vector subtypes like {@code HalffloatVector},
 +     * {@linkplain #broadcast(short) the more strongly typed method}
 +     * is typically selected.  It can be explicitly selected
 +     * using a cast: {@code v.broadcast((short)e)}.
 +     * The two expressions will produce numerically identical results.
 +     */
 +    @Override
 +    public abstract HalffloatVector broadcast(long e);
 +
 +    /**
 +     * Returns a vector of the given species
 +     * where all lane elements are set to
 +     * the primitive value {@code e}.
 +     *
 +     * The {@code long} value must be accurately representable
 +     * by the {@code ETYPE} of the vector species, so that
 +     * {@code e==(long)(ETYPE)e}.
 +     *
 +     * @param species species of the desired vector
 +     * @param e the value to broadcast
 +     * @return a vector where all lane elements are set to
 +     *         the primitive value {@code e}
 +     * @throws IllegalArgumentException
 +     *         if the given {@code long} value cannot
 +     *         be represented by the vector's {@code ETYPE}
 +     * @see #broadcast(VectorSpecies,short)
 +     * @see VectorSpecies#checkValue(long)
 +     */
 +    @ForceInline
-     public static HalffloatVector broadcast(VectorSpecies<Halffloat> species, long e) {
++    public static HalffloatVector broadcast(VectorSpecies<Float16> species, long e) {
 +        HalffloatSpecies vsp = (HalffloatSpecies) species;
 +        return vsp.broadcast(e);
 +    }
 +
 +    /*package-private*/
 +    @ForceInline
 +    final HalffloatVector broadcastTemplate(long e) {
 +        return vspecies().broadcast(e);
 +    }
 +
 +    // Unary lanewise support
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     */
 +    public abstract
 +    HalffloatVector lanewise(VectorOperators.Unary op);
 +
 +    @ForceInline
 +    final
 +    HalffloatVector lanewiseTemplate(VectorOperators.Unary op) {
 +        if (opKind(op, VO_SPECIAL)) {
 +            if (op == ZOMO) {
 +                return blend(broadcast(-1), compare(NE, 0));
 +            }
++            else if (opKind(op, VO_MATHLIB)) {
++                return unaryMathOp(op);
++            }
 +        }
 +        int opc = opCode(op);
 +        return VectorSupport.unaryOp(
-             opc, getClass(), null, Halffloat.class, length(),
++            opc, getClass(), null, short.class, Float16.class, VECTOR_OPER_TYPE, length(),
 +            this, null,
 +            UN_IMPL.find(op, opc, HalffloatVector::unaryOperations));
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     */
 +    @Override
 +    public abstract
 +    HalffloatVector lanewise(VectorOperators.Unary op,
-                                   VectorMask<Halffloat> m);
++                                  VectorMask<Float16> m);
 +    @ForceInline
 +    final
 +    HalffloatVector lanewiseTemplate(VectorOperators.Unary op,
-                                           Class<? extends VectorMask<Halffloat>> maskClass,
-                                           VectorMask<Halffloat> m) {
++                                          Class<? extends VectorMask<Float16>> maskClass,
++                                          VectorMask<Float16> m) {
 +        m.check(maskClass, this);
 +        if (opKind(op, VO_SPECIAL)) {
 +            if (op == ZOMO) {
 +                return blend(broadcast(-1), compare(NE, 0, m));
 +            }
++            else if (opKind(op, VO_MATHLIB)) {
++                return blend(unaryMathOp(op), m);
++            }
 +        }
 +        int opc = opCode(op);
 +        return VectorSupport.unaryOp(
-             opc, getClass(), maskClass, Halffloat.class, length(),
++            opc, getClass(), maskClass, short.class, Float16.class, VECTOR_OPER_TYPE, length(),
 +            this, m,
 +            UN_IMPL.find(op, opc, HalffloatVector::unaryOperations));
 +    }
 +
++    @ForceInline
++    final
++    HalffloatVector unaryMathOp(VectorOperators.Unary op) {
++        return VectorMathLibrary.unaryMathOp(op, opCode(op), species(), HalffloatVector::unaryOperations,
++                                             this);
++    }
++
 +    private static final
-     ImplCache<Unary, UnaryOperation<HalffloatVector, VectorMask<Halffloat>>>
++    ImplCache<Unary, UnaryOperation<HalffloatVector, VectorMask<Float16>>>
 +        UN_IMPL = new ImplCache<>(Unary.class, HalffloatVector.class);
 +
-     private static UnaryOperation<HalffloatVector, VectorMask<Halffloat>> unaryOperations(int opc_) {
++    private static UnaryOperation<HalffloatVector, VectorMask<Float16>> unaryOperations(int opc_) {
 +        switch (opc_) {
 +            case VECTOR_OP_NEG: return (v0, m) ->
 +                    v0.uOp(m, (i, a) -> (short) -a);
 +            case VECTOR_OP_ABS: return (v0, m) ->
 +                    v0.uOp(m, (i, a) -> (short) Math.abs(a));
 +            case VECTOR_OP_SIN: return (v0, m) ->
-                     v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.sin(Float.float16ToFloat(a))));
++                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.sin(Float16.shortBitsToFloat16(a).doubleValue()))));
 +            case VECTOR_OP_COS: return (v0, m) ->
-                     v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.cos(Float.float16ToFloat(a))));
++                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.cos(Float16.shortBitsToFloat16(a).doubleValue()))));
 +            case VECTOR_OP_TAN: return (v0, m) ->
-                     v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.tan(Float.float16ToFloat(a))));
++                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.tan(Float16.shortBitsToFloat16(a).doubleValue()))));
 +            case VECTOR_OP_ASIN: return (v0, m) ->
-                     v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.asin(Float.float16ToFloat(a))));
++                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.asin(Float16.shortBitsToFloat16(a).doubleValue()))));
 +            case VECTOR_OP_ACOS: return (v0, m) ->
-                     v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.acos(Float.float16ToFloat(a))));
++                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.acos(Float16.shortBitsToFloat16(a).doubleValue()))));
 +            case VECTOR_OP_ATAN: return (v0, m) ->
-                     v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.atan(Float.float16ToFloat(a))));
++                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.atan(Float16.shortBitsToFloat16(a).doubleValue()))));
 +            case VECTOR_OP_EXP: return (v0, m) ->
-                     v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.exp(Float.float16ToFloat(a))));
++                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.exp(Float16.shortBitsToFloat16(a).doubleValue()))));
 +            case VECTOR_OP_LOG: return (v0, m) ->
-                     v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.log(Float.float16ToFloat(a))));
++                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.log(Float16.shortBitsToFloat16(a).doubleValue()))));
 +            case VECTOR_OP_LOG10: return (v0, m) ->
-                     v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.log10(Float.float16ToFloat(a))));
++                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.log10(Float16.shortBitsToFloat16(a).doubleValue()))));
 +            case VECTOR_OP_SQRT: return (v0, m) ->
-                     v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));
++                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.sqrt(Float16.shortBitsToFloat16(a).doubleValue()))));
 +            case VECTOR_OP_CBRT: return (v0, m) ->
-                     v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.cbrt(Float.float16ToFloat(a))));
++                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.cbrt(Float16.shortBitsToFloat16(a).doubleValue()))));
 +            case VECTOR_OP_SINH: return (v0, m) ->
-                     v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.sinh(Float.float16ToFloat(a))));
++                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.sinh(Float16.shortBitsToFloat16(a).doubleValue()))));
 +            case VECTOR_OP_COSH: return (v0, m) ->
-                     v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.cosh(Float.float16ToFloat(a))));
++                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.cosh(Float16.shortBitsToFloat16(a).doubleValue()))));
 +            case VECTOR_OP_TANH: return (v0, m) ->
-                     v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.tanh(Float.float16ToFloat(a))));
++                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.tanh(Float16.shortBitsToFloat16(a).doubleValue()))));
 +            case VECTOR_OP_EXPM1: return (v0, m) ->
-                     v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.expm1(Float.float16ToFloat(a))));
++                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.expm1(Float16.shortBitsToFloat16(a).doubleValue()))));
 +            case VECTOR_OP_LOG1P: return (v0, m) ->
-                     v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.log1p(Float.float16ToFloat(a))));
++                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.log1p(Float16.shortBitsToFloat16(a).doubleValue()))));
 +            default: return null;
 +        }
 +    }
 +
 +    // Binary lanewise support
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     * @see #lanewise(VectorOperators.Binary,short)
 +     * @see #lanewise(VectorOperators.Binary,short,VectorMask)
 +     */
 +    @Override
 +    public abstract
 +    HalffloatVector lanewise(VectorOperators.Binary op,
-                                   Vector<Halffloat> v);
++                                  Vector<Float16> v);
 +    @ForceInline
 +    final
 +    HalffloatVector lanewiseTemplate(VectorOperators.Binary op,
-                                           Vector<Halffloat> v) {
++                                          Vector<Float16> v) {
 +        HalffloatVector that = (HalffloatVector) v;
 +        that.check(this);
 +
 +        if (opKind(op, VO_SPECIAL )) {
 +            if (op == FIRST_NONZERO) {
 +                VectorMask<Short> mask
 +                    = this.viewAsIntegralLanes().compare(EQ, (short) 0);
 +                return this.blend(that, mask.cast(vspecies()));
 +            }
++            else if (opKind(op, VO_MATHLIB)) {
++                return binaryMathOp(op, that);
++            }
 +        }
 +
 +        int opc = opCode(op);
 +        return VectorSupport.binaryOp(
-             opc, getClass(), null, Halffloat.class, length(),
++            opc, getClass(), null, short.class, Float16.class, VECTOR_OPER_TYPE, length(),
 +            this, that, null,
 +            BIN_IMPL.find(op, opc, HalffloatVector::binaryOperations));
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     * @see #lanewise(VectorOperators.Binary,short,VectorMask)
 +     */
 +    @Override
 +    public abstract
 +    HalffloatVector lanewise(VectorOperators.Binary op,
-                                   Vector<Halffloat> v,
-                                   VectorMask<Halffloat> m);
++                                  Vector<Float16> v,
++                                  VectorMask<Float16> m);
 +    @ForceInline
 +    final
 +    HalffloatVector lanewiseTemplate(VectorOperators.Binary op,
-                                           Class<? extends VectorMask<Halffloat>> maskClass,
-                                           Vector<Halffloat> v, VectorMask<Halffloat> m) {
++                                          Class<? extends VectorMask<Float16>> maskClass,
++                                          Vector<Float16> v, VectorMask<Float16> m) {
 +        HalffloatVector that = (HalffloatVector) v;
 +        that.check(this);
 +        m.check(maskClass, this);
 +
 +        if (opKind(op, VO_SPECIAL )) {
 +            if (op == FIRST_NONZERO) {
 +                ShortVector bits = this.viewAsIntegralLanes();
 +                VectorMask<Short> mask
 +                    = bits.compare(EQ, (short) 0, m.cast(bits.vspecies()));
 +                return this.blend(that, mask.cast(vspecies()));
 +            }
++            else if (opKind(op, VO_MATHLIB)) {
++                return this.blend(binaryMathOp(op, that), m);
++            }
++
 +        }
 +
 +        int opc = opCode(op);
 +        return VectorSupport.binaryOp(
-             opc, getClass(), maskClass, Halffloat.class, length(),
++            opc, getClass(), maskClass, short.class, Float16.class, VECTOR_OPER_TYPE, length(),
 +            this, that, m,
 +            BIN_IMPL.find(op, opc, HalffloatVector::binaryOperations));
 +    }
 +
++    @ForceInline
++    final
++    HalffloatVector binaryMathOp(VectorOperators.Binary op, HalffloatVector that) {
++        return VectorMathLibrary.binaryMathOp(op, opCode(op), species(), HalffloatVector::binaryOperations,
++                                              this, that);
++    }
++
 +    private static final
-     ImplCache<Binary, BinaryOperation<HalffloatVector, VectorMask<Halffloat>>>
++    ImplCache<Binary, BinaryOperation<HalffloatVector, VectorMask<Float16>>>
 +        BIN_IMPL = new ImplCache<>(Binary.class, HalffloatVector.class);
 +
-     private static BinaryOperation<HalffloatVector, VectorMask<Halffloat>> binaryOperations(int opc_) {
++    private static BinaryOperation<HalffloatVector, VectorMask<Float16>> binaryOperations(int opc_) {
 +        switch (opc_) {
 +            case VECTOR_OP_ADD: return (v0, v1, vm) ->
-                     v0.bOp(v1, vm, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b)));
++                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.add(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b))));
 +            case VECTOR_OP_SUB: return (v0, v1, vm) ->
-                     v0.bOp(v1, vm, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b)));
++                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.subtract(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b))));
 +            case VECTOR_OP_MUL: return (v0, v1, vm) ->
-                     v0.bOp(v1, vm, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(a) * Float.float16ToFloat(b)));
++                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.multiply(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b))));
 +            case VECTOR_OP_DIV: return (v0, v1, vm) ->
-                     v0.bOp(v1, vm, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(a) / Float.float16ToFloat(b)));
++                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.divide(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b))));
 +            case VECTOR_OP_MAX: return (v0, v1, vm) ->
-                     v0.bOp(v1, vm, (i, a, b) -> Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b))));
++                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.max(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b))));
 +            case VECTOR_OP_MIN: return (v0, v1, vm) ->
-                     v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));
++                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.min(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b))));
 +            case VECTOR_OP_ATAN2: return (v0, v1, vm) ->
-                     v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf((float) Math.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b))));
++                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.atan2(Float16.shortBitsToFloat16(a).floatValue(), Float16.shortBitsToFloat16(b).floatValue()))));
 +            case VECTOR_OP_POW: return (v0, v1, vm) ->
-                     v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b))));
++                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.pow(Float16.shortBitsToFloat16(a).floatValue(), Float16.shortBitsToFloat16(b).floatValue()))));
 +            case VECTOR_OP_HYPOT: return (v0, v1, vm) ->
-                     v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf((float) Math.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b))));
++                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.hypot(Float16.shortBitsToFloat16(a).floatValue(), Float16.shortBitsToFloat16(b).floatValue()))));
 +            default: return null;
 +        }
 +    }
 +
 +    // FIXME: Maybe all of the public final methods in this file (the
 +    // simple ones that just call lanewise) should be pushed down to
 +    // the X-VectorBits template.  They can't optimize properly at
 +    // this level, and must rely on inlining.  Does it work?
 +    // (If it works, of course keep the code here.)
 +
 +    /**
 +     * Combines the lane values of this vector
 +     * with the value of a broadcast scalar.
 +     *
 +     * This is a lane-wise binary operation which applies
 +     * the selected operation to each lane.
 +     * The return value will be equal to this expression:
 +     * {@code this.lanewise(op, this.broadcast(e))}.
 +     *
 +     * @param op the operation used to process lane values
 +     * @param e the input scalar
 +     * @return the result of applying the operation lane-wise
 +     *         to the two input vectors
 +     * @throws UnsupportedOperationException if this vector does
 +     *         not support the requested operation
 +     * @see #lanewise(VectorOperators.Binary,Vector)
 +     * @see #lanewise(VectorOperators.Binary,short,VectorMask)
 +     */
 +    @ForceInline
 +    public final
 +    HalffloatVector lanewise(VectorOperators.Binary op,
 +                                  short e) {
 +        return lanewise(op, broadcast(e));
 +    }
 +
 +    /**
 +     * Combines the lane values of this vector
 +     * with the value of a broadcast scalar,
 +     * with selection of lane elements controlled by a mask.
 +     *
 +     * This is a masked lane-wise binary operation which applies
 +     * the selected operation to each lane.
 +     * The return value will be equal to this expression:
 +     * {@code this.lanewise(op, this.broadcast(e), m)}.
 +     *
 +     * @param op the operation used to process lane values
 +     * @param e the input scalar
 +     * @param m the mask controlling lane selection
 +     * @return the result of applying the operation lane-wise
 +     *         to the input vector and the scalar
 +     * @throws UnsupportedOperationException if this vector does
 +     *         not support the requested operation
 +     * @see #lanewise(VectorOperators.Binary,Vector,VectorMask)
 +     * @see #lanewise(VectorOperators.Binary,short)
 +     */
 +    @ForceInline
 +    public final
 +    HalffloatVector lanewise(VectorOperators.Binary op,
 +                                  short e,
-                                   VectorMask<Halffloat> m) {
++                                  VectorMask<Float16> m) {
 +        return lanewise(op, broadcast(e), m);
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     * @apiNote
 +     * When working with vector subtypes like {@code HalffloatVector},
 +     * {@linkplain #lanewise(VectorOperators.Binary,short)
 +     * the more strongly typed method}
 +     * is typically selected.  It can be explicitly selected
 +     * using a cast: {@code v.lanewise(op,(short)e)}.
 +     * The two expressions will produce numerically identical results.
 +     */
 +    @ForceInline
 +    public final
 +    HalffloatVector lanewise(VectorOperators.Binary op,
 +                                  long e) {
 +        short e1 = (short) e;
 +        if ((long)e1 != e) {
 +            vspecies().checkValue(e);  // for exception
 +        }
 +        return lanewise(op, e1);
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     * @apiNote
 +     * When working with vector subtypes like {@code HalffloatVector},
 +     * {@linkplain #lanewise(VectorOperators.Binary,short,VectorMask)
 +     * the more strongly typed method}
 +     * is typically selected.  It can be explicitly selected
 +     * using a cast: {@code v.lanewise(op,(short)e,m)}.
 +     * The two expressions will produce numerically identical results.
 +     */
 +    @ForceInline
 +    public final
 +    HalffloatVector lanewise(VectorOperators.Binary op,
-                                   long e, VectorMask<Halffloat> m) {
++                                  long e, VectorMask<Float16> m) {
 +        short e1 = (short) e;
 +        if ((long)e1 != e) {
 +            vspecies().checkValue(e);  // for exception
 +        }
 +        return lanewise(op, e1, m);
 +    }
 +
 +
 +    // Ternary lanewise support
 +
 +    // Ternary operators come in eight variations:
 +    //   lanewise(op, [broadcast(e1)|v1], [broadcast(e2)|v2])
 +    //   lanewise(op, [broadcast(e1)|v1], [broadcast(e2)|v2], mask)
 +
 +    // It is annoying to support all of these variations of masking
 +    // and broadcast, but it would be more surprising not to continue
 +    // the obvious pattern started by unary and binary.
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     * @see #lanewise(VectorOperators.Ternary,short,short,VectorMask)
 +     * @see #lanewise(VectorOperators.Ternary,Vector,short,VectorMask)
 +     * @see #lanewise(VectorOperators.Ternary,short,Vector,VectorMask)
 +     * @see #lanewise(VectorOperators.Ternary,short,short)
 +     * @see #lanewise(VectorOperators.Ternary,Vector,short)
 +     * @see #lanewise(VectorOperators.Ternary,short,Vector)
 +     */
 +    @Override
 +    public abstract
 +    HalffloatVector lanewise(VectorOperators.Ternary op,
-                                                   Vector<Halffloat> v1,
-                                                   Vector<Halffloat> v2);
++                                                  Vector<Float16> v1,
++                                                  Vector<Float16> v2);
 +    @ForceInline
 +    final
 +    HalffloatVector lanewiseTemplate(VectorOperators.Ternary op,
-                                           Vector<Halffloat> v1,
-                                           Vector<Halffloat> v2) {
++                                          Vector<Float16> v1,
++                                          Vector<Float16> v2) {
 +        HalffloatVector that = (HalffloatVector) v1;
 +        HalffloatVector tother = (HalffloatVector) v2;
 +        // It's a word: https://www.dictionary.com/browse/tother
 +        // See also Chapter 11 of Dickens, Our Mutual Friend:
 +        // "Totherest Governor," replied Mr Riderhood...
 +        that.check(this);
 +        tother.check(this);
 +        int opc = opCode(op);
 +        return VectorSupport.ternaryOp(
-             opc, getClass(), null, Halffloat.class, length(),
++            opc, getClass(), null, short.class, Float16.class, VECTOR_OPER_TYPE, length(),
 +            this, that, tother, null,
 +            TERN_IMPL.find(op, opc, HalffloatVector::ternaryOperations));
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     * @see #lanewise(VectorOperators.Ternary,short,short,VectorMask)
 +     * @see #lanewise(VectorOperators.Ternary,Vector,short,VectorMask)
 +     * @see #lanewise(VectorOperators.Ternary,short,Vector,VectorMask)
 +     */
 +    @Override
 +    public abstract
 +    HalffloatVector lanewise(VectorOperators.Ternary op,
-                                   Vector<Halffloat> v1,
-                                   Vector<Halffloat> v2,
-                                   VectorMask<Halffloat> m);
++                                  Vector<Float16> v1,
++                                  Vector<Float16> v2,
++                                  VectorMask<Float16> m);
 +    @ForceInline
 +    final
 +    HalffloatVector lanewiseTemplate(VectorOperators.Ternary op,
-                                           Class<? extends VectorMask<Halffloat>> maskClass,
-                                           Vector<Halffloat> v1,
-                                           Vector<Halffloat> v2,
-                                           VectorMask<Halffloat> m) {
++                                          Class<? extends VectorMask<Float16>> maskClass,
++                                          Vector<Float16> v1,
++                                          Vector<Float16> v2,
++                                          VectorMask<Float16> m) {
 +        HalffloatVector that = (HalffloatVector) v1;
 +        HalffloatVector tother = (HalffloatVector) v2;
 +        // It's a word: https://www.dictionary.com/browse/tother
 +        // See also Chapter 11 of Dickens, Our Mutual Friend:
 +        // "Totherest Governor," replied Mr Riderhood...
 +        that.check(this);
 +        tother.check(this);
 +        m.check(maskClass, this);
 +
 +        int opc = opCode(op);
 +        return VectorSupport.ternaryOp(
-             opc, getClass(), maskClass, Halffloat.class, length(),
++            opc, getClass(), maskClass, short.class, Float16.class, VECTOR_OPER_TYPE, length(),
 +            this, that, tother, m,
 +            TERN_IMPL.find(op, opc, HalffloatVector::ternaryOperations));
 +    }
 +
 +    private static final
-     ImplCache<Ternary, TernaryOperation<HalffloatVector, VectorMask<Halffloat>>>
++    ImplCache<Ternary, TernaryOperation<HalffloatVector, VectorMask<Float16>>>
 +        TERN_IMPL = new ImplCache<>(Ternary.class, HalffloatVector.class);
 +
-     private static TernaryOperation<HalffloatVector, VectorMask<Halffloat>> ternaryOperations(int opc_) {
++    private static TernaryOperation<HalffloatVector, VectorMask<Float16>> ternaryOperations(int opc_) {
 +        switch (opc_) {
 +            case VECTOR_OP_FMA: return (v0, v1_, v2_, m) -> v0.tOp(v1_, v2_, m, (i, a, b, c) ->
-                     Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));
++                                        Float16.float16ToRawShortBits(Float16.fma(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b), Float16.shortBitsToFloat16(c))));
 +            default: return null;
 +        }
 +    }
 +
 +    /**
 +     * Combines the lane values of this vector
 +     * with the values of two broadcast scalars.
 +     *
 +     * This is a lane-wise ternary operation which applies
 +     * the selected operation to each lane.
 +     * The return value will be equal to this expression:
 +     * {@code this.lanewise(op, this.broadcast(e1), this.broadcast(e2))}.
 +     *
 +     * @param op the operation used to combine lane values
 +     * @param e1 the first input scalar
 +     * @param e2 the second input scalar
 +     * @return the result of applying the operation lane-wise
 +     *         to the input vector and the scalars
 +     * @throws UnsupportedOperationException if this vector does
 +     *         not support the requested operation
 +     * @see #lanewise(VectorOperators.Ternary,Vector,Vector)
 +     * @see #lanewise(VectorOperators.Ternary,short,short,VectorMask)
 +     */
 +    @ForceInline
 +    public final
 +    HalffloatVector lanewise(VectorOperators.Ternary op, //(op,e1,e2)
 +                                  short e1,
 +                                  short e2) {
 +        return lanewise(op, broadcast(e1), broadcast(e2));
 +    }
 +
 +    /**
 +     * Combines the lane values of this vector
 +     * with the values of two broadcast scalars,
 +     * with selection of lane elements controlled by a mask.
 +     *
 +     * This is a masked lane-wise ternary operation which applies
 +     * the selected operation to each lane.
 +     * The return value will be equal to this expression:
 +     * {@code this.lanewise(op, this.broadcast(e1), this.broadcast(e2), m)}.
 +     *
 +     * @param op the operation used to combine lane values
 +     * @param e1 the first input scalar
 +     * @param e2 the second input scalar
 +     * @param m the mask controlling lane selection
 +     * @return the result of applying the operation lane-wise
 +     *         to the input vector and the scalars
 +     * @throws UnsupportedOperationException if this vector does
 +     *         not support the requested operation
 +     * @see #lanewise(VectorOperators.Ternary,Vector,Vector,VectorMask)
 +     * @see #lanewise(VectorOperators.Ternary,short,short)
 +     */
 +    @ForceInline
 +    public final
 +    HalffloatVector lanewise(VectorOperators.Ternary op, //(op,e1,e2,m)
 +                                  short e1,
 +                                  short e2,
-                                   VectorMask<Halffloat> m) {
++                                  VectorMask<Float16> m) {
 +        return lanewise(op, broadcast(e1), broadcast(e2), m);
 +    }
 +
 +    /**
 +     * Combines the lane values of this vector
 +     * with the values of another vector and a broadcast scalar.
 +     *
 +     * This is a lane-wise ternary operation which applies
 +     * the selected operation to each lane.
 +     * The return value will be equal to this expression:
 +     * {@code this.lanewise(op, v1, this.broadcast(e2))}.
 +     *
 +     * @param op the operation used to combine lane values
 +     * @param v1 the other input vector
 +     * @param e2 the input scalar
 +     * @return the result of applying the operation lane-wise
 +     *         to the input vectors and the scalar
 +     * @throws UnsupportedOperationException if this vector does
 +     *         not support the requested operation
 +     * @see #lanewise(VectorOperators.Ternary,short,short)
 +     * @see #lanewise(VectorOperators.Ternary,Vector,short,VectorMask)
 +     */
 +    @ForceInline
 +    public final
 +    HalffloatVector lanewise(VectorOperators.Ternary op, //(op,v1,e2)
-                                   Vector<Halffloat> v1,
++                                  Vector<Float16> v1,
 +                                  short e2) {
 +        return lanewise(op, v1, broadcast(e2));
 +    }
 +
 +    /**
 +     * Combines the lane values of this vector
 +     * with the values of another vector and a broadcast scalar,
 +     * with selection of lane elements controlled by a mask.
 +     *
 +     * This is a masked lane-wise ternary operation which applies
 +     * the selected operation to each lane.
 +     * The return value will be equal to this expression:
 +     * {@code this.lanewise(op, v1, this.broadcast(e2), m)}.
 +     *
 +     * @param op the operation used to combine lane values
 +     * @param v1 the other input vector
 +     * @param e2 the input scalar
 +     * @param m the mask controlling lane selection
 +     * @return the result of applying the operation lane-wise
 +     *         to the input vectors and the scalar
 +     * @throws UnsupportedOperationException if this vector does
 +     *         not support the requested operation
 +     * @see #lanewise(VectorOperators.Ternary,Vector,Vector)
 +     * @see #lanewise(VectorOperators.Ternary,short,short,VectorMask)
 +     * @see #lanewise(VectorOperators.Ternary,Vector,short)
 +     */
 +    @ForceInline
 +    public final
 +    HalffloatVector lanewise(VectorOperators.Ternary op, //(op,v1,e2,m)
-                                   Vector<Halffloat> v1,
++                                  Vector<Float16> v1,
 +                                  short e2,
-                                   VectorMask<Halffloat> m) {
++                                  VectorMask<Float16> m) {
 +        return lanewise(op, v1, broadcast(e2), m);
 +    }
 +
 +    /**
 +     * Combines the lane values of this vector
 +     * with the values of another vector and a broadcast scalar.
 +     *
 +     * This is a lane-wise ternary operation which applies
 +     * the selected operation to each lane.
 +     * The return value will be equal to this expression:
 +     * {@code this.lanewise(op, this.broadcast(e1), v2)}.
 +     *
 +     * @param op the operation used to combine lane values
 +     * @param e1 the input scalar
 +     * @param v2 the other input vector
 +     * @return the result of applying the operation lane-wise
 +     *         to the input vectors and the scalar
 +     * @throws UnsupportedOperationException if this vector does
 +     *         not support the requested operation
 +     * @see #lanewise(VectorOperators.Ternary,Vector,Vector)
 +     * @see #lanewise(VectorOperators.Ternary,short,Vector,VectorMask)
 +     */
 +    @ForceInline
 +    public final
 +    HalffloatVector lanewise(VectorOperators.Ternary op, //(op,e1,v2)
 +                                  short e1,
-                                   Vector<Halffloat> v2) {
++                                  Vector<Float16> v2) {
 +        return lanewise(op, broadcast(e1), v2);
 +    }
 +
 +    /**
 +     * Combines the lane values of this vector
 +     * with the values of another vector and a broadcast scalar,
 +     * with selection of lane elements controlled by a mask.
 +     *
 +     * This is a masked lane-wise ternary operation which applies
 +     * the selected operation to each lane.
 +     * The return value will be equal to this expression:
 +     * {@code this.lanewise(op, this.broadcast(e1), v2, m)}.
 +     *
 +     * @param op the operation used to combine lane values
 +     * @param e1 the input scalar
 +     * @param v2 the other input vector
 +     * @param m the mask controlling lane selection
 +     * @return the result of applying the operation lane-wise
 +     *         to the input vectors and the scalar
 +     * @throws UnsupportedOperationException if this vector does
 +     *         not support the requested operation
 +     * @see #lanewise(VectorOperators.Ternary,Vector,Vector,VectorMask)
 +     * @see #lanewise(VectorOperators.Ternary,short,Vector)
 +     */
 +    @ForceInline
 +    public final
 +    HalffloatVector lanewise(VectorOperators.Ternary op, //(op,e1,v2,m)
 +                                  short e1,
-                                   Vector<Halffloat> v2,
-                                   VectorMask<Halffloat> m) {
++                                  Vector<Float16> v2,
++                                  VectorMask<Float16> m) {
 +        return lanewise(op, broadcast(e1), v2, m);
 +    }
 +
 +    // (Thus endeth the Great and Mighty Ternary Ogdoad.)
 +    // https://en.wikipedia.org/wiki/Ogdoad
 +
 +    /// FULL-SERVICE BINARY METHODS: ADD, SUB, MUL, DIV
 +    //
 +    // These include masked and non-masked versions.
 +    // This subclass adds broadcast (masked or not).
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     * @see #add(short)
 +     */
 +    @Override
 +    @ForceInline
-     public final HalffloatVector add(Vector<Halffloat> v) {
++    public final HalffloatVector add(Vector<Float16> v) {
 +        return lanewise(ADD, v);
 +    }
 +
 +    /**
 +     * Adds this vector to the broadcast of an input scalar.
 +     *
 +     * This is a lane-wise binary operation which applies
 +     * the primitive addition operation ({@code +}) to each lane.
 +     *
 +     * This method is also equivalent to the expression
 +     * {@link #lanewise(VectorOperators.Binary,short)
 +     *    lanewise}{@code (}{@link VectorOperators#ADD
 +     *    ADD}{@code , e)}.
 +     *
 +     * @param e the input scalar
 +     * @return the result of adding each lane of this vector to the scalar
 +     * @see #add(Vector)
 +     * @see #broadcast(short)
 +     * @see #add(short,VectorMask)
 +     * @see VectorOperators#ADD
 +     * @see #lanewise(VectorOperators.Binary,Vector)
 +     * @see #lanewise(VectorOperators.Binary,short)
 +     */
 +    @ForceInline
 +    public final
 +    HalffloatVector add(short e) {
 +        return lanewise(ADD, e);
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     * @see #add(short,VectorMask)
 +     */
 +    @Override
 +    @ForceInline
-     public final HalffloatVector add(Vector<Halffloat> v,
-                                           VectorMask<Halffloat> m) {
++    public final HalffloatVector add(Vector<Float16> v,
++                                          VectorMask<Float16> m) {
 +        return lanewise(ADD, v, m);
 +    }
 +
 +    /**
 +     * Adds this vector to the broadcast of an input scalar,
 +     * selecting lane elements controlled by a mask.
 +     *
 +     * This is a masked lane-wise binary operation which applies
 +     * the primitive addition operation ({@code +}) to each lane.
 +     *
 +     * This method is also equivalent to the expression
 +     * {@link #lanewise(VectorOperators.Binary,short,VectorMask)
 +     *    lanewise}{@code (}{@link VectorOperators#ADD
 +     *    ADD}{@code , s, m)}.
 +     *
 +     * @param e the input scalar
 +     * @param m the mask controlling lane selection
 +     * @return the result of adding each lane of this vector to the scalar
 +     * @see #add(Vector,VectorMask)
 +     * @see #broadcast(short)
 +     * @see #add(short)
 +     * @see VectorOperators#ADD
 +     * @see #lanewise(VectorOperators.Binary,Vector)
 +     * @see #lanewise(VectorOperators.Binary,short)
 +     */
 +    @ForceInline
 +    public final HalffloatVector add(short e,
-                                           VectorMask<Halffloat> m) {
++                                          VectorMask<Float16> m) {
 +        return lanewise(ADD, e, m);
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     * @see #sub(short)
 +     */
 +    @Override
 +    @ForceInline
-     public final HalffloatVector sub(Vector<Halffloat> v) {
++    public final HalffloatVector sub(Vector<Float16> v) {
 +        return lanewise(SUB, v);
 +    }
 +
 +    /**
 +     * Subtracts an input scalar from this vector.
 +     *
 +     * This is a masked lane-wise binary operation which applies
 +     * the primitive subtraction operation ({@code -}) to each lane.
 +     *
 +     * This method is also equivalent to the expression
 +     * {@link #lanewise(VectorOperators.Binary,short)
 +     *    lanewise}{@code (}{@link VectorOperators#SUB
 +     *    SUB}{@code , e)}.
 +     *
 +     * @param e the input scalar
 +     * @return the result of subtracting the scalar from each lane of this vector
 +     * @see #sub(Vector)
 +     * @see #broadcast(short)
 +     * @see #sub(short,VectorMask)
 +     * @see VectorOperators#SUB
 +     * @see #lanewise(VectorOperators.Binary,Vector)
 +     * @see #lanewise(VectorOperators.Binary,short)
 +     */
 +    @ForceInline
 +    public final HalffloatVector sub(short e) {
 +        return lanewise(SUB, e);
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     * @see #sub(short,VectorMask)
 +     */
 +    @Override
 +    @ForceInline
-     public final HalffloatVector sub(Vector<Halffloat> v,
-                                           VectorMask<Halffloat> m) {
++    public final HalffloatVector sub(Vector<Float16> v,
++                                          VectorMask<Float16> m) {
 +        return lanewise(SUB, v, m);
 +    }
 +
 +    /**
 +     * Subtracts an input scalar from this vector
 +     * under the control of a mask.
 +     *
 +     * This is a masked lane-wise binary operation which applies
 +     * the primitive subtraction operation ({@code -}) to each lane.
 +     *
 +     * This method is also equivalent to the expression
 +     * {@link #lanewise(VectorOperators.Binary,short,VectorMask)
 +     *    lanewise}{@code (}{@link VectorOperators#SUB
 +     *    SUB}{@code , s, m)}.
 +     *
 +     * @param e the input scalar
 +     * @param m the mask controlling lane selection
 +     * @return the result of subtracting the scalar from each lane of this vector
 +     * @see #sub(Vector,VectorMask)
 +     * @see #broadcast(short)
 +     * @see #sub(short)
 +     * @see VectorOperators#SUB
 +     * @see #lanewise(VectorOperators.Binary,Vector)
 +     * @see #lanewise(VectorOperators.Binary,short)
 +     */
 +    @ForceInline
 +    public final HalffloatVector sub(short e,
-                                           VectorMask<Halffloat> m) {
++                                          VectorMask<Float16> m) {
 +        return lanewise(SUB, e, m);
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     * @see #mul(short)
 +     */
 +    @Override
 +    @ForceInline
-     public final HalffloatVector mul(Vector<Halffloat> v) {
++    public final HalffloatVector mul(Vector<Float16> v) {
 +        return lanewise(MUL, v);
 +    }
 +
 +    /**
 +     * Multiplies this vector by the broadcast of an input scalar.
 +     *
 +     * This is a lane-wise binary operation which applies
 +     * the primitive multiplication operation ({@code *}) to each lane.
 +     *
 +     * This method is also equivalent to the expression
 +     * {@link #lanewise(VectorOperators.Binary,short)
 +     *    lanewise}{@code (}{@link VectorOperators#MUL
 +     *    MUL}{@code , e)}.
 +     *
 +     * @param e the input scalar
 +     * @return the result of multiplying this vector by the given scalar
 +     * @see #mul(Vector)
 +     * @see #broadcast(short)
 +     * @see #mul(short,VectorMask)
 +     * @see VectorOperators#MUL
 +     * @see #lanewise(VectorOperators.Binary,Vector)
 +     * @see #lanewise(VectorOperators.Binary,short)
 +     */
 +    @ForceInline
 +    public final HalffloatVector mul(short e) {
 +        return lanewise(MUL, e);
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     * @see #mul(short,VectorMask)
 +     */
 +    @Override
 +    @ForceInline
-     public final HalffloatVector mul(Vector<Halffloat> v,
-                                           VectorMask<Halffloat> m) {
++    public final HalffloatVector mul(Vector<Float16> v,
++                                          VectorMask<Float16> m) {
 +        return lanewise(MUL, v, m);
 +    }
 +
 +    /**
 +     * Multiplies this vector by the broadcast of an input scalar,
 +     * selecting lane elements controlled by a mask.
 +     *
 +     * This is a masked lane-wise binary operation which applies
 +     * the primitive multiplication operation ({@code *}) to each lane.
 +     *
 +     * This method is also equivalent to the expression
 +     * {@link #lanewise(VectorOperators.Binary,short,VectorMask)
 +     *    lanewise}{@code (}{@link VectorOperators#MUL
 +     *    MUL}{@code , s, m)}.
 +     *
 +     * @param e the input scalar
 +     * @param m the mask controlling lane selection
 +     * @return the result of muling each lane of this vector to the scalar
 +     * @see #mul(Vector,VectorMask)
 +     * @see #broadcast(short)
 +     * @see #mul(short)
 +     * @see VectorOperators#MUL
 +     * @see #lanewise(VectorOperators.Binary,Vector)
 +     * @see #lanewise(VectorOperators.Binary,short)
 +     */
 +    @ForceInline
 +    public final HalffloatVector mul(short e,
-                                           VectorMask<Halffloat> m) {
++                                          VectorMask<Float16> m) {
 +        return lanewise(MUL, e, m);
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     * @apiNote Because the underlying scalar operator is an IEEE
 +     * floating point number, division by zero in fact will
 +     * not throw an exception, but will yield a signed
 +     * infinity or NaN.
 +     */
 +    @Override
 +    @ForceInline
-     public final HalffloatVector div(Vector<Halffloat> v) {
++    public final HalffloatVector div(Vector<Float16> v) {
 +        return lanewise(DIV, v);
 +    }
 +
 +    /**
 +     * Divides this vector by the broadcast of an input scalar.
 +     *
 +     * This is a lane-wise binary operation which applies
 +     * the primitive division operation ({@code /}) to each lane.
 +     *
 +     * This method is also equivalent to the expression
 +     * {@link #lanewise(VectorOperators.Binary,short)
 +     *    lanewise}{@code (}{@link VectorOperators#DIV
 +     *    DIV}{@code , e)}.
 +     *
 +     * @apiNote Because the underlying scalar operator is an IEEE
 +     * floating point number, division by zero in fact will
 +     * not throw an exception, but will yield a signed
 +     * infinity or NaN.
 +     *
 +     * @param e the input scalar
 +     * @return the result of dividing each lane of this vector by the scalar
 +     * @see #div(Vector)
 +     * @see #broadcast(short)
 +     * @see #div(short,VectorMask)
 +     * @see VectorOperators#DIV
 +     * @see #lanewise(VectorOperators.Binary,Vector)
 +     * @see #lanewise(VectorOperators.Binary,short)
 +     */
 +    @ForceInline
 +    public final HalffloatVector div(short e) {
 +        return lanewise(DIV, e);
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     * @see #div(short,VectorMask)
 +     * @apiNote Because the underlying scalar operator is an IEEE
 +     * floating point number, division by zero in fact will
 +     * not throw an exception, but will yield a signed
 +     * infinity or NaN.
 +     */
 +    @Override
 +    @ForceInline
-     public final HalffloatVector div(Vector<Halffloat> v,
-                                           VectorMask<Halffloat> m) {
++    public final HalffloatVector div(Vector<Float16> v,
++                                          VectorMask<Float16> m) {
 +        return lanewise(DIV, v, m);
 +    }
 +
 +    /**
 +     * Divides this vector by the broadcast of an input scalar,
 +     * selecting lane elements controlled by a mask.
 +     *
 +     * This is a masked lane-wise binary operation which applies
 +     * the primitive division operation ({@code /}) to each lane.
 +     *
 +     * This method is also equivalent to the expression
 +     * {@link #lanewise(VectorOperators.Binary,short,VectorMask)
 +     *    lanewise}{@code (}{@link VectorOperators#DIV
 +     *    DIV}{@code , s, m)}.
 +     *
 +     * @apiNote Because the underlying scalar operator is an IEEE
 +     * floating point number, division by zero in fact will
 +     * not throw an exception, but will yield a signed
 +     * infinity or NaN.
 +     *
 +     * @param e the input scalar
 +     * @param m the mask controlling lane selection
 +     * @return the result of dividing each lane of this vector by the scalar
 +     * @see #div(Vector,VectorMask)
 +     * @see #broadcast(short)
 +     * @see #div(short)
 +     * @see VectorOperators#DIV
 +     * @see #lanewise(VectorOperators.Binary,Vector)
 +     * @see #lanewise(VectorOperators.Binary,short)
 +     */
 +    @ForceInline
 +    public final HalffloatVector div(short e,
-                                           VectorMask<Halffloat> m) {
++                                          VectorMask<Float16> m) {
 +        return lanewise(DIV, e, m);
 +    }
 +
 +    /// END OF FULL-SERVICE BINARY METHODS
 +
 +    /// SECOND-TIER BINARY METHODS
 +    //
 +    // There are no masked versions.
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     * @apiNote
 +     * For this method, floating point negative
 +     * zero {@code -0.0} is treated as a value distinct from, and less
 +     * than the default value (positive zero).
 +     */
 +    @Override
 +    @ForceInline
-     public final HalffloatVector min(Vector<Halffloat> v) {
++    public final HalffloatVector min(Vector<Float16> v) {
 +        return lanewise(MIN, v);
 +    }
 +
 +    // FIXME:  "broadcast of an input scalar" is really wordy.  Reduce?
 +    /**
 +     * Computes the smaller of this vector and the broadcast of an input scalar.
 +     *
 +     * This is a lane-wise binary operation which applies the
 +     * operation {@code Math.min()} to each pair of
 +     * corresponding lane values.
 +     *
 +     * This method is also equivalent to the expression
 +     * {@link #lanewise(VectorOperators.Binary,short)
 +     *    lanewise}{@code (}{@link VectorOperators#MIN
 +     *    MIN}{@code , e)}.
 +     *
 +     * @param e the input scalar
 +     * @return the result of multiplying this vector by the given scalar
 +     * @see #min(Vector)
 +     * @see #broadcast(short)
 +     * @see VectorOperators#MIN
 +     * @see #lanewise(VectorOperators.Binary,short,VectorMask)
 +     * @apiNote
 +     * For this method, floating point negative
 +     * zero {@code -0.0} is treated as a value distinct from, and less
 +     * than the default value (positive zero).
 +     */
 +    @ForceInline
 +    public final HalffloatVector min(short e) {
 +        return lanewise(MIN, e);
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     * @apiNote
 +     * For this method, floating point negative
 +     * zero {@code -0.0} is treated as a value distinct from, and less
 +     * than the default value (positive zero).
 +     */
 +    @Override
 +    @ForceInline
-     public final HalffloatVector max(Vector<Halffloat> v) {
++    public final HalffloatVector max(Vector<Float16> v) {
 +        return lanewise(MAX, v);
 +    }
 +
 +    /**
 +     * Computes the larger of this vector and the broadcast of an input scalar.
 +     *
 +     * This is a lane-wise binary operation which applies the
 +     * operation {@code Math.max()} to each pair of
 +     * corresponding lane values.
 +     *
 +     * This method is also equivalent to the expression
 +     * {@link #lanewise(VectorOperators.Binary,short)
 +     *    lanewise}{@code (}{@link VectorOperators#MAX
 +     *    MAX}{@code , e)}.
 +     *
 +     * @param e the input scalar
 +     * @return the result of multiplying this vector by the given scalar
 +     * @see #max(Vector)
 +     * @see #broadcast(short)
 +     * @see VectorOperators#MAX
 +     * @see #lanewise(VectorOperators.Binary,short,VectorMask)
 +     * @apiNote
 +     * For this method, floating point negative
 +     * zero {@code -0.0} is treated as a value distinct from, and less
 +     * than the default value (positive zero).
 +     */
 +    @ForceInline
 +    public final HalffloatVector max(short e) {
 +        return lanewise(MAX, e);
 +    }
 +
 +
 +    // common FP operator: pow
 +    /**
 +     * Raises this vector to the power of a second input vector.
 +     *
 +     * This is a lane-wise binary operation which applies an operation
 +     * conforming to the specification of
 +     * {@link Math#pow Math.pow(a,b)}
 +     * to each pair of corresponding lane values.
 +     *
 +     * This method is also equivalent to the expression
 +     * {@link #lanewise(VectorOperators.Binary,Vector)
 +     *    lanewise}{@code (}{@link VectorOperators#POW
 +     *    POW}{@code , b)}.
 +     *
 +     * <p>
 +     * This is not a full-service named operation like
 +     * {@link #add(Vector) add}.  A masked version of
 +     * this operation is not directly available
 +     * but may be obtained via the masked version of
 +     * {@code lanewise}.
 +     *
 +     * @param b a vector exponent by which to raise this vector
 +     * @return the {@code b}-th power of this vector
 +     * @see #pow(short)
 +     * @see VectorOperators#POW
 +     * @see #lanewise(VectorOperators.Binary,Vector,VectorMask)
 +     */
 +    @ForceInline
-     public final HalffloatVector pow(Vector<Halffloat> b) {
++    public final HalffloatVector pow(Vector<Float16> b) {
 +        return lanewise(POW, b);
 +    }
 +
 +    /**
 +     * Raises this vector to a scalar power.
 +     *
 +     * This is a lane-wise binary operation which applies an operation
 +     * conforming to the specification of
 +     * {@link Math#pow Math.pow(a,b)}
 +     * to each pair of corresponding lane values.
 +     *
 +     * This method is also equivalent to the expression
 +     * {@link #lanewise(VectorOperators.Binary,Vector)
 +     *    lanewise}{@code (}{@link VectorOperators#POW
 +     *    POW}{@code , b)}.
 +     *
 +     * @param b a scalar exponent by which to raise this vector
 +     * @return the {@code b}-th power of this vector
 +     * @see #pow(Vector)
 +     * @see VectorOperators#POW
 +     * @see #lanewise(VectorOperators.Binary,short,VectorMask)
 +     */
 +    @ForceInline
 +    public final HalffloatVector pow(short b) {
 +        return lanewise(POW, b);
 +    }
 +
 +    /// UNARY METHODS
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     */
 +    @Override
 +    @ForceInline
 +    public final
 +    HalffloatVector neg() {
 +        return lanewise(NEG);
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     */
 +    @Override
 +    @ForceInline
 +    public final
 +    HalffloatVector abs() {
 +        return lanewise(ABS);
 +    }
 +
 +
 +
 +    // sqrt
 +    /**
 +     * Computes the square root of this vector.
 +     *
 +     * This is a lane-wise unary operation which applies an operation
 +     * conforming to the specification of
 +     * {@link Math#sqrt Math.sqrt(a)}
 +     * to each lane value.
 +     *
 +     * This method is also equivalent to the expression
 +     * {@link #lanewise(VectorOperators.Unary)
 +     *    lanewise}{@code (}{@link VectorOperators#SQRT
 +     *    SQRT}{@code )}.
 +     *
 +     * @return the square root of this vector
 +     * @see VectorOperators#SQRT
 +     * @see #lanewise(VectorOperators.Unary,VectorMask)
 +     */
 +    @ForceInline
 +    public final HalffloatVector sqrt() {
 +        return lanewise(SQRT);
 +    }
 +
 +    /// COMPARISONS
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     */
 +    @Override
 +    @ForceInline
 +    public final
-     VectorMask<Halffloat> eq(Vector<Halffloat> v) {
++    VectorMask<Float16> eq(Vector<Float16> v) {
 +        return compare(EQ, v);
 +    }
 +
 +    /**
 +     * Tests if this vector is equal to an input scalar.
 +     *
 +     * This is a lane-wise binary test operation which applies
 +     * the primitive equals operation ({@code ==}) to each lane.
 +     * The result is the same as {@code compare(VectorOperators.Comparison.EQ, e)}.
 +     *
 +     * @param e the input scalar
 +     * @return the result mask of testing if this vector
 +     *         is equal to {@code e}
 +     * @see #compare(VectorOperators.Comparison,short)
 +     */
 +    @ForceInline
 +    public final
-     VectorMask<Halffloat> eq(short e) {
++    VectorMask<Float16> eq(short e) {
 +        return compare(EQ, e);
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     */
 +    @Override
 +    @ForceInline
 +    public final
-     VectorMask<Halffloat> lt(Vector<Halffloat> v) {
++    VectorMask<Float16> lt(Vector<Float16> v) {
 +        return compare(LT, v);
 +    }
 +
 +    /**
 +     * Tests if this vector is less than an input scalar.
 +     *
 +     * This is a lane-wise binary test operation which applies
 +     * the primitive less than operation ({@code <}) to each lane.
 +     * The result is the same as {@code compare(VectorOperators.LT, e)}.
 +     *
 +     * @param e the input scalar
 +     * @return the mask result of testing if this vector
 +     *         is less than the input scalar
 +     * @see #compare(VectorOperators.Comparison,short)
 +     */
 +    @ForceInline
 +    public final
-     VectorMask<Halffloat> lt(short e) {
++    VectorMask<Float16> lt(short e) {
 +        return compare(LT, e);
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     */
 +    @Override
 +    public abstract
-     VectorMask<Halffloat> test(VectorOperators.Test op);
++    VectorMask<Float16> test(VectorOperators.Test op);
 +
 +    /*package-private*/
 +    @ForceInline
 +    final
-     <M extends VectorMask<Halffloat>>
++    <M extends VectorMask<Float16>>
 +    M testTemplate(Class<M> maskType, Test op) {
 +        HalffloatSpecies vsp = vspecies();
 +        if (opKind(op, VO_SPECIAL)) {
 +            ShortVector bits = this.viewAsIntegralLanes();
 +            VectorMask<Short> m;
 +            if (op == IS_DEFAULT) {
 +                m = bits.compare(EQ, (short) 0);
 +            } else if (op == IS_NEGATIVE) {
 +                m = bits.compare(LT, (short) 0);
 +            }
 +            else if (op == IS_FINITE ||
 +                     op == IS_NAN ||
 +                     op == IS_INFINITE) {
 +                // first kill the sign:
 +                bits = bits.and(Short.MAX_VALUE);
 +                // next find the bit pattern for infinity:
-                 short infbits = (short) toBits(Halffloat.POSITIVE_INFINITY);
++                short infbits = (short) toBits(Float16.float16ToRawShortBits(Float16.POSITIVE_INFINITY));
 +                // now compare:
 +                if (op == IS_FINITE) {
 +                    m = bits.compare(LT, infbits);
 +                } else if (op == IS_NAN) {
 +                    m = bits.compare(GT, infbits);
 +                } else {
 +                    m = bits.compare(EQ, infbits);
 +                }
 +            }
 +            else {
 +                throw new AssertionError(op);
 +            }
 +            return maskType.cast(m.cast(vsp));
 +        }
 +        int opc = opCode(op);
 +        throw new AssertionError(op);
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     */
 +    @Override
 +    public abstract
-     VectorMask<Halffloat> test(VectorOperators.Test op,
-                                   VectorMask<Halffloat> m);
++    VectorMask<Float16> test(VectorOperators.Test op,
++                                  VectorMask<Float16> m);
 +
 +    /*package-private*/
 +    @ForceInline
 +    final
-     <M extends VectorMask<Halffloat>>
++    <M extends VectorMask<Float16>>
 +    M testTemplate(Class<M> maskType, Test op, M mask) {
 +        HalffloatSpecies vsp = vspecies();
 +        mask.check(maskType, this);
 +        if (opKind(op, VO_SPECIAL)) {
 +            ShortVector bits = this.viewAsIntegralLanes();
 +            VectorMask<Short> m = mask.cast(ShortVector.species(shape()));
 +            if (op == IS_DEFAULT) {
 +                m = bits.compare(EQ, (short) 0, m);
 +            } else if (op == IS_NEGATIVE) {
 +                m = bits.compare(LT, (short) 0, m);
 +            }
 +            else if (op == IS_FINITE ||
 +                     op == IS_NAN ||
 +                     op == IS_INFINITE) {
 +                // first kill the sign:
 +                bits = bits.and(Short.MAX_VALUE);
 +                // next find the bit pattern for infinity:
-                 short infbits = (short) toBits(Halffloat.POSITIVE_INFINITY);
++                short infbits = (short) toBits(Float16.float16ToRawShortBits(Float16.POSITIVE_INFINITY));
 +                // now compare:
 +                if (op == IS_FINITE) {
 +                    m = bits.compare(LT, infbits, m);
 +                } else if (op == IS_NAN) {
 +                    m = bits.compare(GT, infbits, m);
 +                } else {
 +                    m = bits.compare(EQ, infbits, m);
 +                }
 +            }
 +            else {
 +                throw new AssertionError(op);
 +            }
 +            return maskType.cast(m.cast(vsp));
 +        }
 +        int opc = opCode(op);
 +        throw new AssertionError(op);
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     */
 +    @Override
 +    public abstract
-     VectorMask<Halffloat> compare(VectorOperators.Comparison op, Vector<Halffloat> v);
++    VectorMask<Float16> compare(VectorOperators.Comparison op, Vector<Float16> v);
 +
 +    /*package-private*/
 +    @ForceInline
 +    final
-     <M extends VectorMask<Halffloat>>
-     M compareTemplate(Class<M> maskType, Comparison op, Vector<Halffloat> v) {
++    <M extends VectorMask<Float16>>
++    M compareTemplate(Class<M> maskType, Comparison op, Vector<Float16> v) {
 +        HalffloatVector that = (HalffloatVector) v;
 +        that.check(this);
 +        int opc = opCode(op);
 +        return VectorSupport.compare(
-             opc, getClass(), maskType, Halffloat.class, length(),
++            opc, getClass(), maskType, short.class, Float16.class, VECTOR_OPER_TYPE, length(),
 +            this, that, null,
 +            (cond, v0, v1, m1) -> {
-                 AbstractMask<Halffloat> m
++                AbstractMask<Float16> m
 +                    = v0.bTest(cond, v1, (cond_, i, a, b)
 +                               -> compareWithOp(cond, a, b));
 +                @SuppressWarnings("unchecked")
 +                M m2 = (M) m;
 +                return m2;
 +            });
 +    }
 +
 +    /*package-private*/
 +    @ForceInline
 +    final
-     <M extends VectorMask<Halffloat>>
-     M compareTemplate(Class<M> maskType, Comparison op, Vector<Halffloat> v, M m) {
++    <M extends VectorMask<Float16>>
++    M compareTemplate(Class<M> maskType, Comparison op, Vector<Float16> v, M m) {
 +        HalffloatVector that = (HalffloatVector) v;
 +        that.check(this);
 +        m.check(maskType, this);
 +        int opc = opCode(op);
 +        return VectorSupport.compare(
-             opc, getClass(), maskType, Halffloat.class, length(),
++            opc, getClass(), maskType, short.class, Float16.class, VECTOR_OPER_TYPE, length(),
 +            this, that, m,
 +            (cond, v0, v1, m1) -> {
-                 AbstractMask<Halffloat> cmpM
++                AbstractMask<Float16> cmpM
 +                    = v0.bTest(cond, v1, (cond_, i, a, b)
 +                               -> compareWithOp(cond, a, b));
 +                @SuppressWarnings("unchecked")
 +                M m2 = (M) cmpM.and(m1);
 +                return m2;
 +            });
 +    }
 +
 +    @ForceInline
 +    private static boolean compareWithOp(int cond, short a, short b) {
 +        return switch (cond) {
 +            case BT_eq -> Float.float16ToFloat(a) == Float.float16ToFloat(b);
 +            case BT_ne -> Float.float16ToFloat(a) != Float.float16ToFloat(b);
 +            case BT_lt -> Float.float16ToFloat(a) < Float.float16ToFloat(b);
 +            case BT_le -> Float.float16ToFloat(a) <= Float.float16ToFloat(b);
 +            case BT_gt -> Float.float16ToFloat(a) > Float.float16ToFloat(b);
 +            case BT_ge -> Float.float16ToFloat(a) >= Float.float16ToFloat(b);
 +            default -> throw new AssertionError();
 +        };
 +    }
 +
 +    /**
 +     * Tests this vector by comparing it with an input scalar,
 +     * according to the given comparison operation.
 +     *
 +     * This is a lane-wise binary test operation which applies
 +     * the comparison operation to each lane.
 +     * <p>
 +     * The result is the same as
 +     * {@code compare(op, broadcast(species(), e))}.
 +     * That is, the scalar may be regarded as broadcast to
 +     * a vector of the same species, and then compared
 +     * against the original vector, using the selected
 +     * comparison operation.
 +     *
 +     * @param op the operation used to compare lane values
 +     * @param e the input scalar
 +     * @return the mask result of testing lane-wise if this vector
 +     *         compares to the input, according to the selected
 +     *         comparison operator
 +     * @see HalffloatVector#compare(VectorOperators.Comparison,Vector)
 +     * @see #eq(short)
 +     * @see #lt(short)
 +     */
 +    public abstract
-     VectorMask<Halffloat> compare(Comparison op, short e);
++    VectorMask<Float16> compare(Comparison op, short e);
 +
 +    /*package-private*/
 +    @ForceInline
 +    final
-     <M extends VectorMask<Halffloat>>
++    <M extends VectorMask<Float16>>
 +    M compareTemplate(Class<M> maskType, Comparison op, short e) {
 +        return compareTemplate(maskType, op, broadcast(e));
 +    }
 +
 +    /**
 +     * Tests this vector by comparing it with an input scalar,
 +     * according to the given comparison operation,
 +     * in lanes selected by a mask.
 +     *
 +     * This is a masked lane-wise binary test operation which applies
 +     * to each pair of corresponding lane values.
 +     *
 +     * The returned result is equal to the expression
 +     * {@code compare(op,s).and(m)}.
 +     *
 +     * @param op the operation used to compare lane values
 +     * @param e the input scalar
 +     * @param m the mask controlling lane selection
 +     * @return the mask result of testing lane-wise if this vector
 +     *         compares to the input, according to the selected
 +     *         comparison operator,
 +     *         and only in the lanes selected by the mask
 +     * @see HalffloatVector#compare(VectorOperators.Comparison,Vector,VectorMask)
 +     */
 +    @ForceInline
-     public final VectorMask<Halffloat> compare(VectorOperators.Comparison op,
++    public final VectorMask<Float16> compare(VectorOperators.Comparison op,
 +                                               short e,
-                                                VectorMask<Halffloat> m) {
++                                               VectorMask<Float16> m) {
 +        return compare(op, broadcast(e), m);
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     */
 +    @Override
 +    public abstract
-     VectorMask<Halffloat> compare(Comparison op, long e);
++    VectorMask<Float16> compare(Comparison op, long e);
 +
 +    /*package-private*/
 +    @ForceInline
 +    final
-     <M extends VectorMask<Halffloat>>
++    <M extends VectorMask<Float16>>
 +    M compareTemplate(Class<M> maskType, Comparison op, long e) {
 +        return compareTemplate(maskType, op, broadcast(e));
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     */
 +    @Override
 +    @ForceInline
 +    public final
-     VectorMask<Halffloat> compare(Comparison op, long e, VectorMask<Halffloat> m) {
++    VectorMask<Float16> compare(Comparison op, long e, VectorMask<Float16> m) {
 +        return compare(op, broadcast(e), m);
 +    }
 +
 +
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     */
 +    @Override public abstract
-     HalffloatVector blend(Vector<Halffloat> v, VectorMask<Halffloat> m);
++    HalffloatVector blend(Vector<Float16> v, VectorMask<Float16> m);
 +
 +    /*package-private*/
 +    @ForceInline
 +    final
-     <M extends VectorMask<Halffloat>>
++    <M extends VectorMask<Float16>>
 +    HalffloatVector
 +    blendTemplate(Class<M> maskType, HalffloatVector v, M m) {
 +        v.check(this);
 +        return VectorSupport.blend(
-             getClass(), maskType, Halffloat.class, length(),
++            getClass(), maskType, short.class, Float16.class, VECTOR_OPER_TYPE, length(),
 +            this, v, m,
 +            (v0, v1, m_) -> v0.bOp(v1, m_, (i, a, b) -> b));
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     */
 +    @Override public abstract HalffloatVector addIndex(int scale);
 +
 +    /*package-private*/
 +    @ForceInline
 +    final HalffloatVector addIndexTemplate(int scale) {
 +        HalffloatSpecies vsp = vspecies();
 +        // make sure VLENGTH*scale doesn't overflow:
 +        vsp.checkScale(scale);
 +        return VectorSupport.indexVector(
-             getClass(), Halffloat.class, length(),
++            getClass(), short.class, Float16.class, VECTOR_OPER_TYPE, length(),
 +            this, scale, vsp,
 +            (v, scale_, s)
 +            -> {
 +                // If the platform doesn't support an INDEX
 +                // instruction directly, load IOTA from memory
 +                // and multiply.
 +                HalffloatVector iota = s.iota();
 +                short sc = (short) scale_;
-                 return v.add(sc == 1 ? iota : iota.mul(Float.floatToFloat16((float) sc)));
++                return v.add(sc == 1 ? iota : iota.mul(Float16.float16ToRawShortBits(Float16.valueOf(sc))));
 +            });
 +    }
 +
 +    /**
 +     * Replaces selected lanes of this vector with
 +     * a scalar value
 +     * under the control of a mask.
 +     *
 +     * This is a masked lane-wise binary operation which
 +     * selects each lane value from one or the other input.
 +     *
 +     * The returned result is equal to the expression
 +     * {@code blend(broadcast(e),m)}.
 +     *
 +     * @param e the input scalar, containing the replacement lane value
 +     * @param m the mask controlling lane selection of the scalar
 +     * @return the result of blending the lane elements of this vector with
 +     *         the scalar value
 +     */
 +    @ForceInline
 +    public final HalffloatVector blend(short e,
-                                             VectorMask<Halffloat> m) {
++                                            VectorMask<Float16> m) {
 +        return blend(broadcast(e), m);
 +    }
 +
 +    /**
 +     * Replaces selected lanes of this vector with
 +     * a scalar value
 +     * under the control of a mask.
 +     *
 +     * This is a masked lane-wise binary operation which
 +     * selects each lane value from one or the other input.
 +     *
 +     * The returned result is equal to the expression
 +     * {@code blend(broadcast(e),m)}.
 +     *
 +     * @param e the input scalar, containing the replacement lane value
 +     * @param m the mask controlling lane selection of the scalar
 +     * @return the result of blending the lane elements of this vector with
 +     *         the scalar value
 +     */
 +    @ForceInline
 +    public final HalffloatVector blend(long e,
-                                             VectorMask<Halffloat> m) {
++                                            VectorMask<Float16> m) {
 +        return blend(broadcast(e), m);
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     */
 +    @Override
 +    public abstract
-     HalffloatVector slice(int origin, Vector<Halffloat> v1);
++    HalffloatVector slice(int origin, Vector<Float16> v1);
 +
 +    /*package-private*/
 +    final
 +    @ForceInline
-     HalffloatVector sliceTemplate(int origin, Vector<Halffloat> v1) {
++    HalffloatVector sliceTemplate(int origin, Vector<Float16> v1) {
 +        HalffloatVector that = (HalffloatVector) v1;
 +        that.check(this);
 +        Objects.checkIndex(origin, length() + 1);
-         VectorShuffle<Halffloat> iota = iotaShuffle();
-         VectorMask<Halffloat> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((short)(length() - origin))));
-         iota = iotaShuffle(origin, 1, true);
++        ShortVector iotaVector = (ShortVector) iotaShuffle().toBitsVector();
++        ShortVector filter = ShortVector.broadcast((ShortVector.ShortSpecies) vspecies().asIntegral(), (short)(length() - origin));
++        VectorMask<Float16> blendMask = iotaVector.compare(VectorOperators.LT, filter).cast(vspecies());
++        AbstractShuffle<Float16> iota = iotaShuffle(origin, 1, true);
 +        return that.rearrange(iota).blend(this.rearrange(iota), blendMask);
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     */
 +    @Override
 +    @ForceInline
 +    public final
 +    HalffloatVector slice(int origin,
-                                Vector<Halffloat> w,
-                                VectorMask<Halffloat> m) {
++                               Vector<Float16> w,
++                               VectorMask<Float16> m) {
 +        return broadcast(0).blend(slice(origin, w), m);
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     */
 +    @Override
 +    public abstract
 +    HalffloatVector slice(int origin);
 +
 +    /*package-private*/
 +    final
 +    @ForceInline
 +    HalffloatVector sliceTemplate(int origin) {
 +        Objects.checkIndex(origin, length() + 1);
-         VectorShuffle<Halffloat> iota = iotaShuffle();
-         VectorMask<Halffloat> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((short)(length() - origin))));
-         iota = iotaShuffle(origin, 1, true);
++        ShortVector iotaVector = (ShortVector) iotaShuffle().toBitsVector();
++        ShortVector filter = ShortVector.broadcast((ShortVector.ShortSpecies) vspecies().asIntegral(), (short)(length() - origin));
++        VectorMask<Float16> blendMask = iotaVector.compare(VectorOperators.LT, filter).cast(vspecies());
++        AbstractShuffle<Float16> iota = iotaShuffle(origin, 1, true);
 +        return vspecies().zero().blend(this.rearrange(iota), blendMask);
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     */
 +    @Override
 +    public abstract
-     HalffloatVector unslice(int origin, Vector<Halffloat> w, int part);
++    HalffloatVector unslice(int origin, Vector<Float16> w, int part);
 +
 +    /*package-private*/
 +    final
 +    @ForceInline
 +    HalffloatVector
-     unsliceTemplate(int origin, Vector<Halffloat> w, int part) {
++    unsliceTemplate(int origin, Vector<Float16> w, int part) {
 +        HalffloatVector that = (HalffloatVector) w;
 +        that.check(this);
 +        Objects.checkIndex(origin, length() + 1);
-         VectorShuffle<Halffloat> iota = iotaShuffle();
-         VectorMask<Halffloat> blendMask = iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,
-                                                                   (broadcast((short)(origin))));
-         iota = iotaShuffle(-origin, 1, true);
++        ShortVector iotaVector = (ShortVector) iotaShuffle().toBitsVector();
++        ShortVector filter = ShortVector.broadcast((ShortVector.ShortSpecies) vspecies().asIntegral(), (short)origin);
++        VectorMask<Float16> blendMask = iotaVector.compare((part == 0) ? VectorOperators.GE : VectorOperators.LT, filter).cast(vspecies());
++        AbstractShuffle<Float16> iota = iotaShuffle(-origin, 1, true);
 +        return that.blend(this.rearrange(iota), blendMask);
 +    }
 +
 +    /*package-private*/
 +    final
 +    @ForceInline
-     <M extends VectorMask<Halffloat>>
++    <M extends VectorMask<Float16>>
 +    HalffloatVector
-     unsliceTemplate(Class<M> maskType, int origin, Vector<Halffloat> w, int part, M m) {
++    unsliceTemplate(Class<M> maskType, int origin, Vector<Float16> w, int part, M m) {
 +        HalffloatVector that = (HalffloatVector) w;
 +        that.check(this);
 +        HalffloatVector slice = that.sliceTemplate(origin, that);
 +        slice = slice.blendTemplate(maskType, this, m);
 +        return slice.unsliceTemplate(origin, w, part);
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     */
 +    @Override
 +    public abstract
-     HalffloatVector unslice(int origin, Vector<Halffloat> w, int part, VectorMask<Halffloat> m);
++    HalffloatVector unslice(int origin, Vector<Float16> w, int part, VectorMask<Float16> m);
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     */
 +    @Override
 +    public abstract
 +    HalffloatVector unslice(int origin);
 +
 +    /*package-private*/
 +    final
 +    @ForceInline
 +    HalffloatVector
 +    unsliceTemplate(int origin) {
 +        Objects.checkIndex(origin, length() + 1);
-         VectorShuffle<Halffloat> iota = iotaShuffle();
-         VectorMask<Halffloat> blendMask = iota.toVector().compare(VectorOperators.GE,
-                                                                   (broadcast((short)(origin))));
-         iota = iotaShuffle(-origin, 1, true);
++        ShortVector iotaVector = (ShortVector) iotaShuffle().toBitsVector();
++        ShortVector filter = ShortVector.broadcast((ShortVector.ShortSpecies) vspecies().asIntegral(), (short)origin);
++        VectorMask<Float16> blendMask = iotaVector.compare(VectorOperators.GE, filter).cast(vspecies());
++        AbstractShuffle<Float16> iota = iotaShuffle(-origin, 1, true);
 +        return vspecies().zero().blend(this.rearrange(iota), blendMask);
 +    }
 +
 +    private ArrayIndexOutOfBoundsException
 +    wrongPartForSlice(int part) {
 +        String msg = String.format("bad part number %d for slice operation",
 +                                   part);
 +        return new ArrayIndexOutOfBoundsException(msg);
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     */
 +    @Override
 +    public abstract
-     HalffloatVector rearrange(VectorShuffle<Halffloat> m);
++    HalffloatVector rearrange(VectorShuffle<Float16> shuffle);
 +
 +    /*package-private*/
 +    @ForceInline
 +    final
-     <S extends VectorShuffle<Halffloat>>
++    <S extends VectorShuffle<Float16>>
 +    HalffloatVector rearrangeTemplate(Class<S> shuffletype, S shuffle) {
-         shuffle.checkIndexes();
++        Objects.requireNonNull(shuffle);
 +        return VectorSupport.rearrangeOp(
-             getClass(), shuffletype, null, Halffloat.class, length(),
++            getClass(), shuffletype, null, short.class, Float16.class, VECTOR_OPER_TYPE, length(),
 +            this, shuffle, null,
 +            (v1, s_, m_) -> v1.uOp((i, a) -> {
-                 int ei = s_.laneSource(i);
++                int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
 +                return v1.lane(ei);
 +            }));
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     */
 +    @Override
 +    public abstract
-     HalffloatVector rearrange(VectorShuffle<Halffloat> s,
-                                    VectorMask<Halffloat> m);
++    HalffloatVector rearrange(VectorShuffle<Float16> s,
++                                   VectorMask<Float16> m);
 +
 +    /*package-private*/
 +    @ForceInline
 +    final
-     <S extends VectorShuffle<Halffloat>, M extends VectorMask<Halffloat>>
++    <S extends VectorShuffle<Float16>, M extends VectorMask<Float16>>
 +    HalffloatVector rearrangeTemplate(Class<S> shuffletype,
 +                                           Class<M> masktype,
 +                                           S shuffle,
 +                                           M m) {
- 
++        Objects.requireNonNull(shuffle);
 +        m.check(masktype, this);
-         VectorMask<Halffloat> valid = shuffle.laneIsValid();
-         if (m.andNot(valid).anyTrue()) {
-             shuffle.checkIndexes();
-             throw new AssertionError();
-         }
 +        return VectorSupport.rearrangeOp(
-                    getClass(), shuffletype, masktype, Halffloat.class, length(),
++                   getClass(), shuffletype, masktype, short.class, Float16.class, VECTOR_OPER_TYPE, length(),
 +                   this, shuffle, m,
 +                   (v1, s_, m_) -> v1.uOp((i, a) -> {
-                         int ei = s_.laneSource(i);
-                         return ei < 0  || !m_.laneIsSet(i) ? 0 : v1.lane(ei);
++                        int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
++                        return !m_.laneIsSet(i) ? 0 : v1.lane(ei);
 +                   }));
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     */
 +    @Override
 +    public abstract
-     HalffloatVector rearrange(VectorShuffle<Halffloat> s,
-                                    Vector<Halffloat> v);
++    HalffloatVector rearrange(VectorShuffle<Float16> s,
++                                   Vector<Float16> v);
 +
 +    /*package-private*/
 +    @ForceInline
 +    final
-     <S extends VectorShuffle<Halffloat>>
++    <S extends VectorShuffle<Float16>>
 +    HalffloatVector rearrangeTemplate(Class<S> shuffletype,
 +                                           S shuffle,
 +                                           HalffloatVector v) {
-         VectorMask<Halffloat> valid = shuffle.laneIsValid();
-         @SuppressWarnings("unchecked")
-         S ws = (S) shuffle.wrapIndexes();
++        VectorMask<Float16> valid = shuffle.laneIsValid();
 +        HalffloatVector r0 =
 +            VectorSupport.rearrangeOp(
-                 getClass(), shuffletype, null, Halffloat.class, length(),
-                 this, ws, null,
++                getClass(), shuffletype, null, short.class, Float16.class, VECTOR_OPER_TYPE, length(),
++                this, shuffle, null,
 +                (v0, s_, m_) -> v0.uOp((i, a) -> {
-                     int ei = s_.laneSource(i);
++                    int ei = Integer.remainderUnsigned(s_.laneSource(i), v0.length());
 +                    return v0.lane(ei);
 +                }));
 +        HalffloatVector r1 =
 +            VectorSupport.rearrangeOp(
-                 getClass(), shuffletype, null, Halffloat.class, length(),
-                 v, ws, null,
++                getClass(), shuffletype, null, short.class, Float16.class, VECTOR_OPER_TYPE, length(),
++                v, shuffle, null,
 +                (v1, s_, m_) -> v1.uOp((i, a) -> {
-                     int ei = s_.laneSource(i);
++                    int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
 +                    return v1.lane(ei);
 +                }));
 +        return r1.blend(r0, valid);
 +    }
 +
++    @Override
++    @ForceInline
++    final <F> VectorShuffle<F> bitsToShuffle0(AbstractSpecies<F> dsp) {
++        throw new AssertionError();
++    }
++
 +    @ForceInline
 +    final <F>
-     VectorShuffle<F> toShuffle0(AbstractSpecies<F> dsp) {
-         short[] a = toArray();
-         int[] sa = new int[a.length];
-         for (int i = 0; i < a.length; i++) {
-             sa[i] = (int) a[i];
++    VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp, boolean wrap) {
++        assert(dsp.elementSize() == vspecies().elementSize());
++        ShortVector idx = convert(VectorOperators.H2S, 0).reinterpretAsShorts();
++        ShortVector wrapped = idx.lanewise(VectorOperators.AND, length() - 1);
++        if (!wrap) {
++            ShortVector wrappedEx = wrapped.lanewise(VectorOperators.SUB, length());
++            VectorMask<Short> inBound = wrapped.compare(VectorOperators.EQ, idx);
++            wrapped = wrappedEx.blend(wrapped, inBound);
 +        }
-         return VectorShuffle.fromArray(dsp, sa, 0);
++        return wrapped.bitsToShuffle(dsp);
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     * @since 19
 +     */
 +    @Override
 +    public abstract
-     HalffloatVector compress(VectorMask<Halffloat> m);
++    HalffloatVector compress(VectorMask<Float16> m);
 +
 +    /*package-private*/
 +    @ForceInline
 +    final
-     <M extends AbstractMask<Halffloat>>
++    <M extends AbstractMask<Float16>>
 +    HalffloatVector compressTemplate(Class<M> masktype, M m) {
 +      m.check(masktype, this);
 +      return (HalffloatVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,
-                                                         Halffloat.class, length(), this, m,
++                                                        short.class, Float16.class, VECTOR_OPER_TYPE, length(), this, m,
 +                                                        (v1, m1) -> compressHelper(v1, m1));
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     * @since 19
 +     */
 +    @Override
 +    public abstract
-     HalffloatVector expand(VectorMask<Halffloat> m);
++    HalffloatVector expand(VectorMask<Float16> m);
 +
 +    /*package-private*/
 +    @ForceInline
 +    final
-     <M extends AbstractMask<Halffloat>>
++    <M extends AbstractMask<Float16>>
 +    HalffloatVector expandTemplate(Class<M> masktype, M m) {
 +      m.check(masktype, this);
 +      return (HalffloatVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,
-                                                         Halffloat.class, length(), this, m,
++                                                        short.class, Float16.class, VECTOR_OPER_TYPE, length(), this, m,
 +                                                        (v1, m1) -> expandHelper(v1, m1));
 +    }
 +
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     */
 +    @Override
 +    public abstract
-     HalffloatVector selectFrom(Vector<Halffloat> v);
++    HalffloatVector selectFrom(Vector<Float16> v);
 +
 +    /*package-private*/
 +    @ForceInline
 +    final HalffloatVector selectFromTemplate(HalffloatVector v) {
-         return v.rearrange(this.toShuffle());
++        return (HalffloatVector)VectorSupport.selectFromOp(getClass(), null, short.class, Float16.class, VECTOR_OPER_TYPE,
++                                                        length(), this, v, null,
++                                                        (v1, v2, _m) ->
++                                                         v2.rearrange(v1.toShuffle()));
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     */
 +    @Override
 +    public abstract
-     HalffloatVector selectFrom(Vector<Halffloat> s, VectorMask<Halffloat> m);
++    HalffloatVector selectFrom(Vector<Float16> s, VectorMask<Float16> m);
 +
 +    /*package-private*/
 +    @ForceInline
-     final HalffloatVector selectFromTemplate(HalffloatVector v,
-                                                   AbstractMask<Halffloat> m) {
-         return v.rearrange(this.toShuffle(), m);
++    final
++    <M extends VectorMask<Float16>>
++    HalffloatVector selectFromTemplate(HalffloatVector v,
++                                            Class<M> masktype, M m) {
++        m.check(masktype, this);
++        return (HalffloatVector)VectorSupport.selectFromOp(getClass(), masktype, short.class, Float16.class, VECTOR_OPER_TYPE,
++                                                        length(), this, v, m,
++                                                        (v1, v2, _m) ->
++                                                         v2.rearrange(v1.toShuffle(), _m));
++    }
++
++
++    /**
++     * {@inheritDoc} <!--workaround-->
++     */
++    @Override
++    public abstract
++    HalffloatVector selectFrom(Vector<Float16> v1, Vector<Float16> v2);
++
++
++    /*package-private*/
++    @ForceInline
++    final HalffloatVector selectFromTemplate(HalffloatVector v1, HalffloatVector v2) {
++        return VectorSupport.selectFromTwoVectorOp(getClass(), short.class, Float16.class, VECTOR_OPER_TYPE, length(), this, v1, v2,
++                                                   (vec1, vec2, vec3) -> selectFromTwoVectorHelper(vec1, vec2, vec3));
 +    }
 +
 +    /// Ternary operations
 +
 +
 +    /**
 +     * Multiplies this vector by a second input vector, and sums
 +     * the result with a third.
 +     *
 +     * Extended precision is used for the intermediate result,
 +     * avoiding possible loss of precision from rounding once
 +     * for each of the two operations.
 +     * The result is numerically close to {@code this.mul(b).add(c)},
 +     * and is typically closer to the true mathematical result.
 +     *
 +     * This is a lane-wise ternary operation which applies an operation
 +     * conforming to the specification of
 +     * {@link Math#fma(short,short,short) Math.fma(a,b,c)}
 +     * to each lane.
 +     *
 +     * This method is also equivalent to the expression
 +     * {@link #lanewise(VectorOperators.Ternary,Vector,Vector)
 +     *    lanewise}{@code (}{@link VectorOperators#FMA
 +     *    FMA}{@code , b, c)}.
 +     *
 +     * @param b the second input vector, supplying multiplier values
 +     * @param c the third input vector, supplying addend values
 +     * @return the product of this vector and the second input vector
 +     *         summed with the third input vector, using extended precision
 +     *         for the intermediate result
 +     * @see #fma(short,short)
 +     * @see VectorOperators#FMA
 +     * @see #lanewise(VectorOperators.Ternary,Vector,Vector,VectorMask)
 +     */
 +    @ForceInline
 +    public final
-     HalffloatVector fma(Vector<Halffloat> b, Vector<Halffloat> c) {
++    HalffloatVector fma(Vector<Float16> b, Vector<Float16> c) {
 +        return lanewise(FMA, b, c);
 +    }
 +
 +    /**
 +     * Multiplies this vector by a scalar multiplier, and sums
 +     * the result with a scalar addend.
 +     *
 +     * Extended precision is used for the intermediate result,
 +     * avoiding possible loss of precision from rounding once
 +     * for each of the two operations.
 +     * The result is numerically close to {@code this.mul(b).add(c)},
 +     * and is typically closer to the true mathematical result.
 +     *
 +     * This is a lane-wise ternary operation which applies an operation
 +     * conforming to the specification of
 +     * {@link Math#fma(short,short,short) Math.fma(a,b,c)}
 +     * to each lane.
 +     *
 +     * This method is also equivalent to the expression
 +     * {@link #lanewise(VectorOperators.Ternary,Vector,Vector)
 +     *    lanewise}{@code (}{@link VectorOperators#FMA
 +     *    FMA}{@code , b, c)}.
 +     *
 +     * @param b the scalar multiplier
 +     * @param c the scalar addend
 +     * @return the product of this vector and the scalar multiplier
 +     *         summed with scalar addend, using extended precision
 +     *         for the intermediate result
 +     * @see #fma(Vector,Vector)
 +     * @see VectorOperators#FMA
 +     * @see #lanewise(VectorOperators.Ternary,short,short,VectorMask)
 +     */
 +    @ForceInline
 +    public final
 +    HalffloatVector fma(short b, short c) {
 +        return lanewise(FMA, b, c);
 +    }
 +
 +    // Don't bother with (Vector,short) and (short,Vector) overloadings.
 +
 +    // Type specific horizontal reductions
 +
 +    /**
 +     * Returns a value accumulated from all the lanes of this vector.
 +     *
 +     * This is an associative cross-lane reduction operation which
 +     * applies the specified operation to all the lane elements.
 +     * <p>
 +     * A few reduction operations do not support arbitrary reordering
 +     * of their operands, yet are included here because of their
 +     * usefulness.
 +     * <ul>
 +     * <li>
 +     * In the case of {@code FIRST_NONZERO}, the reduction returns
 +     * the value from the lowest-numbered non-zero lane.
 +     * (As with {@code MAX} and {@code MIN}, floating point negative
 +     * zero {@code -0.0} is treated as a value distinct from
 +     * the default value, positive zero. So a first-nonzero lane reduction
 +     * might return {@code -0.0} even in the presence of non-zero
 +     * lane values.)
 +     * <li>
 +     * In the case of {@code ADD} and {@code MUL}, the
 +     * precise result will reflect the choice of an arbitrary order
 +     * of operations, which may even vary over time.
 +     * For further details see the section
 +     * <a href="VectorOperators.html#fp_assoc">Operations on floating point vectors</a>.
 +     * <li>
 +     * All other reduction operations are fully commutative and
 +     * associative.  The implementation can choose any order of
 +     * processing, yet it will always produce the same result.
 +     * </ul>
 +     *
 +     * @param op the operation used to combine lane values
 +     * @return the accumulated result
 +     * @throws UnsupportedOperationException if this vector does
 +     *         not support the requested operation
 +     * @see #reduceLanes(VectorOperators.Associative,VectorMask)
 +     * @see #add(Vector)
 +     * @see #mul(Vector)
 +     * @see #min(Vector)
 +     * @see #max(Vector)
 +     * @see VectorOperators#FIRST_NONZERO
 +     */
 +    public abstract short reduceLanes(VectorOperators.Associative op);
 +
 +    /**
 +     * Returns a value accumulated from selected lanes of this vector,
 +     * controlled by a mask.
 +     *
 +     * This is an associative cross-lane reduction operation which
 +     * applies the specified operation to the selected lane elements.
 +     * <p>
 +     * If no elements are selected, an operation-specific identity
 +     * value is returned.
 +     * <ul>
 +     * <li>
 +     * If the operation is
 +     *  {@code ADD}
 +     * or {@code FIRST_NONZERO},
 +     * then the identity value is positive zero, the default {@code short} value.
 +     * <li>
 +     * If the operation is {@code MUL},
 +     * then the identity value is one.
 +     * <li>
 +     * If the operation is {@code MAX},
-      * then the identity value is {@code Halffloat.NEGATIVE_INFINITY}.
++     * then the identity value is {@code Float16.NEGATIVE_INFINITY}.
 +     * <li>
 +     * If the operation is {@code MIN},
-      * then the identity value is {@code Halffloat.POSITIVE_INFINITY}.
++     * then the identity value is {@code Float16.POSITIVE_INFINITY}.
 +     * </ul>
 +     * <p>
 +     * A few reduction operations do not support arbitrary reordering
 +     * of their operands, yet are included here because of their
 +     * usefulness.
 +     * <ul>
 +     * <li>
 +     * In the case of {@code FIRST_NONZERO}, the reduction returns
 +     * the value from the lowest-numbered non-zero lane.
 +     * (As with {@code MAX} and {@code MIN}, floating point negative
 +     * zero {@code -0.0} is treated as a value distinct from
 +     * the default value, positive zero. So a first-nonzero lane reduction
 +     * might return {@code -0.0} even in the presence of non-zero
 +     * lane values.)
 +     * <li>
 +     * In the case of {@code ADD} and {@code MUL}, the
 +     * precise result will reflect the choice of an arbitrary order
 +     * of operations, which may even vary over time.
 +     * For further details see the section
 +     * <a href="VectorOperators.html#fp_assoc">Operations on floating point vectors</a>.
 +     * <li>
 +     * All other reduction operations are fully commutative and
 +     * associative.  The implementation can choose any order of
 +     * processing, yet it will always produce the same result.
 +     * </ul>
 +     *
 +     * @param op the operation used to combine lane values
 +     * @param m the mask controlling lane selection
 +     * @return the reduced result accumulated from the selected lane values
 +     * @throws UnsupportedOperationException if this vector does
 +     *         not support the requested operation
 +     * @see #reduceLanes(VectorOperators.Associative)
 +     */
 +    public abstract short reduceLanes(VectorOperators.Associative op,
-                                        VectorMask<Halffloat> m);
++                                       VectorMask<Float16> m);
 +
 +    /*package-private*/
 +    @ForceInline
 +    final
 +    short reduceLanesTemplate(VectorOperators.Associative op,
-                                Class<? extends VectorMask<Halffloat>> maskClass,
-                                VectorMask<Halffloat> m) {
++                               Class<? extends VectorMask<Float16>> maskClass,
++                               VectorMask<Float16> m) {
 +        m.check(maskClass, this);
 +        if (op == FIRST_NONZERO) {
 +            // FIXME:  The JIT should handle this.
 +            HalffloatVector v = broadcast((short) 0).blend(this, m);
 +            return v.reduceLanesTemplate(op);
 +        }
 +        int opc = opCode(op);
 +        return fromBits(VectorSupport.reductionCoerced(
-             opc, getClass(), maskClass, Halffloat.class, length(),
++            opc, getClass(), maskClass, short.class, Float16.class, VECTOR_OPER_TYPE, length(),
 +            this, m,
 +            REDUCE_IMPL.find(op, opc, HalffloatVector::reductionOperations)));
 +    }
 +
 +    /*package-private*/
 +    @ForceInline
 +    final
 +    short reduceLanesTemplate(VectorOperators.Associative op) {
 +        if (op == FIRST_NONZERO) {
 +            // FIXME:  The JIT should handle this.
 +            VectorMask<Short> thisNZ
 +                = this.viewAsIntegralLanes().compare(NE, (short) 0);
 +            int ft = thisNZ.firstTrue();
 +            return ft < length() ? this.lane(ft) : (short) 0;
 +        }
 +        int opc = opCode(op);
 +        return fromBits(VectorSupport.reductionCoerced(
-             opc, getClass(), null, Halffloat.class, length(),
++            opc, getClass(), null, short.class, Float16.class, VECTOR_OPER_TYPE, length(),
 +            this, null,
 +            REDUCE_IMPL.find(op, opc, HalffloatVector::reductionOperations)));
 +    }
 +
 +    private static final
-     ImplCache<Associative, ReductionOperation<HalffloatVector, VectorMask<Halffloat>>>
++    ImplCache<Associative, ReductionOperation<HalffloatVector, VectorMask<Float16>>>
 +        REDUCE_IMPL = new ImplCache<>(Associative.class, HalffloatVector.class);
 +
-     private static ReductionOperation<HalffloatVector, VectorMask<Halffloat>> reductionOperations(int opc_) {
++    private static ReductionOperation<HalffloatVector, VectorMask<Float16>> reductionOperations(int opc_) {
 +        switch (opc_) {
 +            case VECTOR_OP_ADD: return (v, m) ->
-                     toBits(v.rOp((short)0, m, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b))));
++                    toBits(v.rOp((short)0, m, (i, a, b) -> Float16.float16ToRawShortBits(Float16.add(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b)))));
 +            case VECTOR_OP_MUL: return (v, m) ->
-                     toBits(v.rOp((short)1, m, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(b) * Float.float16ToFloat(b))));
++                    toBits(v.rOp((short)0, m, (i, a, b) -> Float16.float16ToRawShortBits(Float16.multiply(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b)))));
 +            case VECTOR_OP_MIN: return (v, m) ->
-                     toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> Float.floatToFloat16(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b)))));
++                    toBits(v.rOp((short)0, m, (i, a, b) -> Float16.float16ToRawShortBits(Float16.min(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b)))));
 +            case VECTOR_OP_MAX: return (v, m) ->
-                     toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b)))));
++                    toBits(v.rOp((short)0, m, (i, a, b) -> Float16.float16ToRawShortBits(Float16.max(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b)))));
 +            default: return null;
 +        }
 +    }
 +
-     private static final short MIN_OR_INF = Halffloat.NEGATIVE_INFINITY;
-     private static final short MAX_OR_INF = Halffloat.POSITIVE_INFINITY;
++    private static final short MIN_OR_INF = Float16.float16ToRawShortBits(Float16.NEGATIVE_INFINITY);
++    private static final short MAX_OR_INF = Float16.float16ToRawShortBits(Float16.POSITIVE_INFINITY);
 +
 +    public @Override abstract long reduceLanesToLong(VectorOperators.Associative op);
 +    public @Override abstract long reduceLanesToLong(VectorOperators.Associative op,
-                                                      VectorMask<Halffloat> m);
++                                                     VectorMask<Float16> m);
 +
 +    // Type specific accessors
 +
 +    /**
 +     * Gets the lane element at lane index {@code i}
 +     *
 +     * @param i the lane index
 +     * @return the lane element at lane index {@code i}
-      * @throws IllegalArgumentException if the index is is out of range
++     * @throws IllegalArgumentException if the index is out of range
 +     * ({@code < 0 || >= length()})
 +     */
 +    public abstract short lane(int i);
 +
 +    /**
 +     * Replaces the lane element of this vector at lane index {@code i} with
 +     * value {@code e}.
 +     *
 +     * This is a cross-lane operation and behaves as if it returns the result
 +     * of blending this vector with an input vector that is the result of
 +     * broadcasting {@code e} and a mask that has only one lane set at lane
 +     * index {@code i}.
 +     *
 +     * @param i the lane index of the lane element to be replaced
 +     * @param e the value to be placed
 +     * @return the result of replacing the lane element of this vector at lane
 +     * index {@code i} with value {@code e}.
-      * @throws IllegalArgumentException if the index is is out of range
++     * @throws IllegalArgumentException if the index is out of range
 +     * ({@code < 0 || >= length()})
 +     */
 +    public abstract HalffloatVector withLane(int i, short e);
 +
 +    // Memory load operations
 +
 +    /**
 +     * Returns an array of type {@code short[]}
 +     * containing all the lane values.
 +     * The array length is the same as the vector length.
 +     * The array elements are stored in lane order.
 +     * <p>
 +     * This method behaves as if it stores
 +     * this vector into an allocated array
 +     * (using {@link #intoArray(short[], int) intoArray})
 +     * and returns the array as follows:
 +     * <pre>{@code
 +     *   short[] a = new short[this.length()];
 +     *   this.intoArray(a, 0);
 +     *   return a;
 +     * }</pre>
 +     *
 +     * @return an array containing the lane values of this vector
 +     */
 +    @ForceInline
 +    @Override
 +    public final short[] toArray() {
 +        short[] a = new short[vspecies().laneCount()];
 +        intoArray(a, 0);
 +        return a;
 +    }
 +
 +    /** {@inheritDoc} <!--workaround-->
 +     */
 +    @ForceInline
 +    @Override
 +    public final int[] toIntArray() {
 +        short[] a = toArray();
 +        int[] res = new int[a.length];
 +        for (int i = 0; i < a.length; i++) {
 +            short e = a[i];
 +            res[i] = (int) HalffloatSpecies.toIntegralChecked(e, true);
 +        }
 +        return res;
 +    }
 +
 +    /** {@inheritDoc} <!--workaround-->
 +     */
 +    @ForceInline
 +    @Override
 +    public final long[] toLongArray() {
 +        short[] a = toArray();
 +        long[] res = new long[a.length];
 +        for (int i = 0; i < a.length; i++) {
-             short e = (short) Halffloat.valueOf(a[i]).floatValue();
++            short e = Float16.shortBitsToFloat16(a[i]).shortValue();
 +            res[i] = HalffloatSpecies.toIntegralChecked(e, false);
 +        }
 +        return res;
 +    }
 +
 +    /** {@inheritDoc} <!--workaround-->
 +     * @implNote
-      * When this method is used on used on vectors
++     * When this method is used on vectors
 +     * of type {@code HalffloatVector},
 +     * there will be no loss of precision.
 +     */
 +    @ForceInline
 +    @Override
 +    public final double[] toDoubleArray() {
 +        short[] a = toArray();
 +        double[] res = new double[a.length];
 +        for (int i = 0; i < a.length; i++) {
-             res[i] = (double) Halffloat.valueOf(a[i]).floatValue();
++            res[i] = (double) Float16.shortBitsToFloat16(a[i]).doubleValue();
 +        }
 +        return res;
 +    }
 +
 +    /**
 +     * Loads a vector from an array of type {@code short[]}
 +     * starting at an offset.
 +     * For each vector lane, where {@code N} is the vector lane index, the
 +     * array element at index {@code offset + N} is placed into the
 +     * resulting vector at lane index {@code N}.
 +     *
 +     * @param species species of desired vector
 +     * @param a the array
 +     * @param offset the offset into the array
 +     * @return the vector loaded from an array
 +     * @throws IndexOutOfBoundsException
 +     *         if {@code offset+N < 0} or {@code offset+N >= a.length}
 +     *         for any lane {@code N} in the vector
 +     */
 +    @ForceInline
 +    public static
-     HalffloatVector fromArray(VectorSpecies<Halffloat> species,
++    HalffloatVector fromArray(VectorSpecies<Float16> species,
 +                                   short[] a, int offset) {
 +        offset = checkFromIndexSize(offset, species.length(), a.length);
 +        HalffloatSpecies vsp = (HalffloatSpecies) species;
 +        return vsp.dummyVector().fromArray0(a, offset);
 +    }
 +
 +    /**
 +     * Loads a vector from an array of type {@code short[]}
 +     * starting at an offset and using a mask.
 +     * Lanes where the mask is unset are filled with the default
 +     * value of {@code short} (positive zero).
 +     * For each vector lane, where {@code N} is the vector lane index,
 +     * if the mask lane at index {@code N} is set then the array element at
 +     * index {@code offset + N} is placed into the resulting vector at lane index
 +     * {@code N}, otherwise the default element value is placed into the
 +     * resulting vector at lane index {@code N}.
 +     *
 +     * @param species species of desired vector
 +     * @param a the array
 +     * @param offset the offset into the array
 +     * @param m the mask controlling lane selection
 +     * @return the vector loaded from an array
 +     * @throws IndexOutOfBoundsException
 +     *         if {@code offset+N < 0} or {@code offset+N >= a.length}
 +     *         for any lane {@code N} in the vector
 +     *         where the mask is set
 +     */
 +    @ForceInline
 +    public static
-     HalffloatVector fromArray(VectorSpecies<Halffloat> species,
++    HalffloatVector fromArray(VectorSpecies<Float16> species,
 +                                   short[] a, int offset,
-                                    VectorMask<Halffloat> m) {
++                                   VectorMask<Float16> m) {
 +        HalffloatSpecies vsp = (HalffloatSpecies) species;
 +        if (VectorIntrinsics.indexInRange(offset, vsp.length(), a.length)) {
 +            return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_IN_RANGE);
 +        }
 +
-         checkMaskFromIndexSize(offset, vsp, m, 1, a.length);
++        ((AbstractMask<Float16>)m)
++            .checkIndexByLane(offset, a.length, vsp.iota(), 1);
 +        return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_OUT_OF_RANGE);
 +    }
 +
 +    /**
 +     * Gathers a new vector composed of elements from an array of type
 +     * {@code short[]},
 +     * using indexes obtained by adding a fixed {@code offset} to a
 +     * series of secondary offsets from an <em>index map</em>.
 +     * The index map is a contiguous sequence of {@code VLENGTH}
 +     * elements in a second array of {@code int}s, starting at a given
 +     * {@code mapOffset}.
 +     * <p>
 +     * For each vector lane, where {@code N} is the vector lane index,
 +     * the lane is loaded from the array
 +     * element {@code a[f(N)]}, where {@code f(N)} is the
 +     * index mapping expression
 +     * {@code offset + indexMap[mapOffset + N]]}.
 +     *
 +     * @param species species of desired vector
 +     * @param a the array
 +     * @param offset the offset into the array, may be negative if relative
 +     * indexes in the index map compensate to produce a value within the
 +     * array bounds
 +     * @param indexMap the index map
 +     * @param mapOffset the offset into the index map
 +     * @return the vector loaded from the indexed elements of the array
 +     * @throws IndexOutOfBoundsException
 +     *         if {@code mapOffset+N < 0}
 +     *         or if {@code mapOffset+N >= indexMap.length},
 +     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}
 +     *         is an invalid index into {@code a},
 +     *         for any lane {@code N} in the vector
 +     * @see HalffloatVector#toIntArray()
 +     */
 +    @ForceInline
 +    public static
-     HalffloatVector fromArray(VectorSpecies<Halffloat> species,
++    HalffloatVector fromArray(VectorSpecies<Float16> species,
 +                                   short[] a, int offset,
 +                                   int[] indexMap, int mapOffset) {
 +        HalffloatSpecies vsp = (HalffloatSpecies) species;
-         return vsp.vOp(n -> a[offset + indexMap[mapOffset + n]]);
++        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());
++        Objects.requireNonNull(a);
++        Objects.requireNonNull(indexMap);
++        Class<? extends HalffloatVector> vectorType = vsp.vectorType();
++
++
++        // Constant folding should sweep out following conditonal logic.
++        VectorSpecies<Integer> lsp;
++        if (isp.length() > IntVector.SPECIES_PREFERRED.length()) {
++            lsp = IntVector.SPECIES_PREFERRED;
++        } else {
++            lsp = isp;
++        }
++
++        // Check indices are within array bounds.
++        IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);
++        VectorIntrinsics.checkIndex(vix0, a.length);
++
++        int vlen = vsp.length();
++        int idx_vlen = lsp.length();
++        IntVector vix1 = null;
++        if (vlen >= idx_vlen * 2) {
++            vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);
++            VectorIntrinsics.checkIndex(vix1, a.length);
++        }
++
++        return VectorSupport.loadWithMap(
++            vectorType, null, short.class, Float16.class, VECTOR_OPER_TYPE, vsp.laneCount(),
++            lsp.vectorType(), lsp.length(),
++            a, ARRAY_BASE, vix0, vix1, null, null, null,
++            a, offset, indexMap, mapOffset, vsp,
++            (c, idx, iMap, idy, s, vm) ->
++            s.vOp(n -> c[idx + iMap[idy+n]]));
 +    }
 +
 +    /**
 +     * Gathers a new vector composed of elements from an array of type
 +     * {@code short[]},
 +     * under the control of a mask, and
 +     * using indexes obtained by adding a fixed {@code offset} to a
 +     * series of secondary offsets from an <em>index map</em>.
 +     * The index map is a contiguous sequence of {@code VLENGTH}
 +     * elements in a second array of {@code int}s, starting at a given
 +     * {@code mapOffset}.
 +     * <p>
 +     * For each vector lane, where {@code N} is the vector lane index,
 +     * if the lane is set in the mask,
 +     * the lane is loaded from the array
 +     * element {@code a[f(N)]}, where {@code f(N)} is the
 +     * index mapping expression
 +     * {@code offset + indexMap[mapOffset + N]]}.
 +     * Unset lanes in the resulting vector are set to zero.
 +     *
 +     * @param species species of desired vector
 +     * @param a the array
 +     * @param offset the offset into the array, may be negative if relative
 +     * indexes in the index map compensate to produce a value within the
 +     * array bounds
 +     * @param indexMap the index map
 +     * @param mapOffset the offset into the index map
 +     * @param m the mask controlling lane selection
 +     * @return the vector loaded from the indexed elements of the array
 +     * @throws IndexOutOfBoundsException
 +     *         if {@code mapOffset+N < 0}
 +     *         or if {@code mapOffset+N >= indexMap.length},
 +     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}
 +     *         is an invalid index into {@code a},
 +     *         for any lane {@code N} in the vector
 +     *         where the mask is set
 +     * @see HalffloatVector#toIntArray()
 +     */
 +    @ForceInline
 +    public static
-     HalffloatVector fromArray(VectorSpecies<Halffloat> species,
++    HalffloatVector fromArray(VectorSpecies<Float16> species,
 +                                   short[] a, int offset,
 +                                   int[] indexMap, int mapOffset,
-                                    VectorMask<Halffloat> m) {
-         HalffloatSpecies vsp = (HalffloatSpecies) species;
-         return vsp.vOp(m, n -> a[offset + indexMap[mapOffset + n]]);
++                                   VectorMask<Float16> m) {
++        if (m.allTrue()) {
++            return fromArray(species, a, offset, indexMap, mapOffset);
++        }
++        else {
++            HalffloatSpecies vsp = (HalffloatSpecies) species;
++            return vsp.dummyVector().fromArray0(a, offset, indexMap, mapOffset, m);
++        }
 +    }
 +
 +    /**
 +     * Loads a vector from an array of type {@code char[]}
 +     * starting at an offset.
 +     * For each vector lane, where {@code N} is the vector lane index, the
 +     * array element at index {@code offset + N}
 +     * is first cast to a {@code short} value and then
 +     * placed into the resulting vector at lane index {@code N}.
 +     *
 +     * @param species species of desired vector
 +     * @param a the array
 +     * @param offset the offset into the array
 +     * @return the vector loaded from an array
 +     * @throws IndexOutOfBoundsException
 +     *         if {@code offset+N < 0} or {@code offset+N >= a.length}
 +     *         for any lane {@code N} in the vector
 +     */
 +    @ForceInline
 +    public static
-     HalffloatVector fromCharArray(VectorSpecies<Halffloat> species,
++    HalffloatVector fromCharArray(VectorSpecies<Float16> species,
 +                                       char[] a, int offset) {
 +        offset = checkFromIndexSize(offset, species.length(), a.length);
 +        HalffloatSpecies vsp = (HalffloatSpecies) species;
 +        return vsp.dummyVector().fromCharArray0(a, offset);
 +    }
 +
 +    /**
 +     * Loads a vector from an array of type {@code char[]}
 +     * starting at an offset and using a mask.
 +     * Lanes where the mask is unset are filled with the default
 +     * value of {@code short} (positive zero).
 +     * For each vector lane, where {@code N} is the vector lane index,
 +     * if the mask lane at index {@code N} is set then the array element at
 +     * index {@code offset + N}
 +     * is first cast to a {@code short} value and then
 +     * placed into the resulting vector at lane index
 +     * {@code N}, otherwise the default element value is placed into the
 +     * resulting vector at lane index {@code N}.
 +     *
 +     * @param species species of desired vector
 +     * @param a the array
 +     * @param offset the offset into the array
 +     * @param m the mask controlling lane selection
 +     * @return the vector loaded from an array
 +     * @throws IndexOutOfBoundsException
 +     *         if {@code offset+N < 0} or {@code offset+N >= a.length}
 +     *         for any lane {@code N} in the vector
 +     *         where the mask is set
 +     */
 +    @ForceInline
 +    public static
-     HalffloatVector fromCharArray(VectorSpecies<Halffloat> species,
++    HalffloatVector fromCharArray(VectorSpecies<Float16> species,
 +                                       char[] a, int offset,
-                                        VectorMask<Halffloat> m) {
++                                       VectorMask<Float16> m) {
 +        HalffloatSpecies vsp = (HalffloatSpecies) species;
 +        if (VectorIntrinsics.indexInRange(offset, vsp.length(), a.length)) {
 +            return vsp.dummyVector().fromCharArray0(a, offset, m, OFFSET_IN_RANGE);
 +        }
 +
-         checkMaskFromIndexSize(offset, vsp, m, 1, a.length);
++        ((AbstractMask<Float16>)m)
++            .checkIndexByLane(offset, a.length, vsp.iota(), 1);
 +        return vsp.dummyVector().fromCharArray0(a, offset, m, OFFSET_OUT_OF_RANGE);
 +    }
 +
 +    /**
 +     * Gathers a new vector composed of elements from an array of type
 +     * {@code char[]},
 +     * using indexes obtained by adding a fixed {@code offset} to a
 +     * series of secondary offsets from an <em>index map</em>.
 +     * The index map is a contiguous sequence of {@code VLENGTH}
 +     * elements in a second array of {@code int}s, starting at a given
 +     * {@code mapOffset}.
 +     * <p>
 +     * For each vector lane, where {@code N} is the vector lane index,
 +     * the lane is loaded from the expression
 +     * {@code (short) a[f(N)]}, where {@code f(N)} is the
 +     * index mapping expression
 +     * {@code offset + indexMap[mapOffset + N]]}.
 +     *
 +     * @param species species of desired vector
 +     * @param a the array
 +     * @param offset the offset into the array, may be negative if relative
 +     * indexes in the index map compensate to produce a value within the
 +     * array bounds
 +     * @param indexMap the index map
 +     * @param mapOffset the offset into the index map
 +     * @return the vector loaded from the indexed elements of the array
 +     * @throws IndexOutOfBoundsException
 +     *         if {@code mapOffset+N < 0}
 +     *         or if {@code mapOffset+N >= indexMap.length},
 +     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}
 +     *         is an invalid index into {@code a},
 +     *         for any lane {@code N} in the vector
 +     * @see HalffloatVector#toIntArray()
 +     */
 +    @ForceInline
 +    public static
-     HalffloatVector fromCharArray(VectorSpecies<Halffloat> species,
++    HalffloatVector fromCharArray(VectorSpecies<Float16> species,
 +                                       char[] a, int offset,
 +                                       int[] indexMap, int mapOffset) {
 +        // FIXME: optimize
 +        HalffloatSpecies vsp = (HalffloatSpecies) species;
 +        return vsp.vOp(n -> (short) a[offset + indexMap[mapOffset + n]]);
 +    }
 +
 +    /**
 +     * Gathers a new vector composed of elements from an array of type
 +     * {@code char[]},
 +     * under the control of a mask, and
 +     * using indexes obtained by adding a fixed {@code offset} to a
 +     * series of secondary offsets from an <em>index map</em>.
 +     * The index map is a contiguous sequence of {@code VLENGTH}
 +     * elements in a second array of {@code int}s, starting at a given
 +     * {@code mapOffset}.
 +     * <p>
 +     * For each vector lane, where {@code N} is the vector lane index,
 +     * if the lane is set in the mask,
 +     * the lane is loaded from the expression
 +     * {@code (short) a[f(N)]}, where {@code f(N)} is the
 +     * index mapping expression
 +     * {@code offset + indexMap[mapOffset + N]]}.
 +     * Unset lanes in the resulting vector are set to zero.
 +     *
 +     * @param species species of desired vector
 +     * @param a the array
 +     * @param offset the offset into the array, may be negative if relative
 +     * indexes in the index map compensate to produce a value within the
 +     * array bounds
 +     * @param indexMap the index map
 +     * @param mapOffset the offset into the index map
 +     * @param m the mask controlling lane selection
 +     * @return the vector loaded from the indexed elements of the array
 +     * @throws IndexOutOfBoundsException
 +     *         if {@code mapOffset+N < 0}
 +     *         or if {@code mapOffset+N >= indexMap.length},
 +     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}
 +     *         is an invalid index into {@code a},
 +     *         for any lane {@code N} in the vector
 +     *         where the mask is set
 +     * @see HalffloatVector#toIntArray()
 +     */
 +    @ForceInline
 +    public static
-     HalffloatVector fromCharArray(VectorSpecies<Halffloat> species,
++    HalffloatVector fromCharArray(VectorSpecies<Float16> species,
 +                                       char[] a, int offset,
 +                                       int[] indexMap, int mapOffset,
-                                        VectorMask<Halffloat> m) {
++                                       VectorMask<Float16> m) {
 +        // FIXME: optimize
 +        HalffloatSpecies vsp = (HalffloatSpecies) species;
 +        return vsp.vOp(m, n -> (short) a[offset + indexMap[mapOffset + n]]);
 +    }
 +
 +
 +    /**
 +     * Loads a vector from a {@linkplain MemorySegment memory segment}
 +     * starting at an offset into the memory segment.
 +     * Bytes are composed into primitive lane elements according
 +     * to the specified byte order.
 +     * The vector is arranged into lanes according to
 +     * <a href="Vector.html#lane-order">memory ordering</a>.
 +     * <p>
 +     * This method behaves as if it returns the result of calling
 +     * {@link #fromMemorySegment(VectorSpecies,MemorySegment,long,ByteOrder,VectorMask)
 +     * fromMemorySegment()} as follows:
 +     * <pre>{@code
 +     * var m = species.maskAll(true);
 +     * return fromMemorySegment(species, ms, offset, bo, m);
 +     * }</pre>
 +     *
 +     * @param species species of desired vector
 +     * @param ms the memory segment
 +     * @param offset the offset into the memory segment
 +     * @param bo the intended byte order
 +     * @return a vector loaded from the memory segment
 +     * @throws IndexOutOfBoundsException
 +     *         if {@code offset+N*2 < 0}
 +     *         or {@code offset+N*2 >= ms.byteSize()}
 +     *         for any lane {@code N} in the vector
-      * @throws IllegalArgumentException if the memory segment is a heap segment that is
-      *         not backed by a {@code byte[]} array.
 +     * @throws IllegalStateException if the memory segment's session is not alive,
 +     *         or if access occurs from a thread other than the thread owning the session.
 +     * @since 19
 +     */
 +    @ForceInline
 +    public static
-     HalffloatVector fromMemorySegment(VectorSpecies<Halffloat> species,
++    HalffloatVector fromMemorySegment(VectorSpecies<Float16> species,
 +                                           MemorySegment ms, long offset,
 +                                           ByteOrder bo) {
 +        offset = checkFromIndexSize(offset, species.vectorByteSize(), ms.byteSize());
 +        HalffloatSpecies vsp = (HalffloatSpecies) species;
 +        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);
 +    }
 +
 +    /**
 +     * Loads a vector from a {@linkplain MemorySegment memory segment}
 +     * starting at an offset into the memory segment
 +     * and using a mask.
 +     * Lanes where the mask is unset are filled with the default
 +     * value of {@code short} (positive zero).
 +     * Bytes are composed into primitive lane elements according
 +     * to the specified byte order.
 +     * The vector is arranged into lanes according to
 +     * <a href="Vector.html#lane-order">memory ordering</a>.
 +     * <p>
 +     * The following pseudocode illustrates the behavior:
 +     * <pre>{@code
 +     * var slice = ms.asSlice(offset);
 +     * short[] ar = new short[species.length()];
 +     * for (int n = 0; n < ar.length; n++) {
 +     *     if (m.laneIsSet(n)) {
-      *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_SHORT.withBitAlignment(8), n);
++     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_SHORT.withByteAlignment(1), n);
 +     *     }
 +     * }
 +     * HalffloatVector r = HalffloatVector.fromArray(species, ar, 0);
 +     * }</pre>
 +     * @implNote
 +     * This operation is likely to be more efficient if
 +     * the specified byte order is the same as
 +     * {@linkplain ByteOrder#nativeOrder()
 +     * the platform native order},
 +     * since this method will not need to reorder
 +     * the bytes of lane values.
 +     *
 +     * @param species species of desired vector
 +     * @param ms the memory segment
 +     * @param offset the offset into the memory segment
 +     * @param bo the intended byte order
 +     * @param m the mask controlling lane selection
 +     * @return a vector loaded from the memory segment
 +     * @throws IndexOutOfBoundsException
 +     *         if {@code offset+N*2 < 0}
 +     *         or {@code offset+N*2 >= ms.byteSize()}
 +     *         for any lane {@code N} in the vector
 +     *         where the mask is set
-      * @throws IllegalArgumentException if the memory segment is a heap segment that is
-      *         not backed by a {@code byte[]} array.
 +     * @throws IllegalStateException if the memory segment's session is not alive,
 +     *         or if access occurs from a thread other than the thread owning the session.
 +     * @since 19
 +     */
 +    @ForceInline
 +    public static
-     HalffloatVector fromMemorySegment(VectorSpecies<Halffloat> species,
++    HalffloatVector fromMemorySegment(VectorSpecies<Float16> species,
 +                                           MemorySegment ms, long offset,
 +                                           ByteOrder bo,
-                                            VectorMask<Halffloat> m) {
++                                           VectorMask<Float16> m) {
 +        HalffloatSpecies vsp = (HalffloatSpecies) species;
 +        if (VectorIntrinsics.indexInRange(offset, vsp.vectorByteSize(), ms.byteSize())) {
 +            return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_IN_RANGE).maybeSwap(bo);
 +        }
 +
-         checkMaskFromIndexSize(offset, vsp, m, 2, ms.byteSize());
++        ((AbstractMask<Float16>)m)
++            .checkIndexByLane(offset, ms.byteSize(), vsp.iota(), 2);
 +        return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_OUT_OF_RANGE).maybeSwap(bo);
 +    }
 +
 +    // Memory store operations
 +
 +    /**
 +     * Stores this vector into an array of type {@code short[]}
 +     * starting at an offset.
 +     * <p>
 +     * For each vector lane, where {@code N} is the vector lane index,
 +     * the lane element at index {@code N} is stored into the array
 +     * element {@code a[offset+N]}.
 +     *
 +     * @param a the array, of type {@code short[]}
 +     * @param offset the offset into the array
 +     * @throws IndexOutOfBoundsException
 +     *         if {@code offset+N < 0} or {@code offset+N >= a.length}
 +     *         for any lane {@code N} in the vector
 +     */
 +    @ForceInline
 +    public final
 +    void intoArray(short[] a, int offset) {
 +        offset = checkFromIndexSize(offset, length(), a.length);
 +        HalffloatSpecies vsp = vspecies();
 +        VectorSupport.store(
-             vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset),
++            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
++            a, arrayAddress(a, offset), false,
 +            this,
 +            a, offset,
 +            (arr, off, v)
 +            -> v.stOp(arr, (int) off,
 +                      (arr_, off_, i, e) -> arr_[off_ + i] = e));
 +    }
 +
 +    /**
 +     * Stores this vector into an array of type {@code short[]}
 +     * starting at offset and using a mask.
 +     * <p>
 +     * For each vector lane, where {@code N} is the vector lane index,
 +     * the lane element at index {@code N} is stored into the array
 +     * element {@code a[offset+N]}.
 +     * If the mask lane at {@code N} is unset then the corresponding
 +     * array element {@code a[offset+N]} is left unchanged.
 +     * <p>
 +     * Array range checking is done for lanes where the mask is set.
 +     * Lanes where the mask is unset are not stored and do not need
 +     * to correspond to legitimate elements of {@code a}.
 +     * That is, unset lanes may correspond to array indexes less than
 +     * zero or beyond the end of the array.
 +     *
 +     * @param a the array, of type {@code short[]}
 +     * @param offset the offset into the array
 +     * @param m the mask controlling lane storage
 +     * @throws IndexOutOfBoundsException
 +     *         if {@code offset+N < 0} or {@code offset+N >= a.length}
 +     *         for any lane {@code N} in the vector
 +     *         where the mask is set
 +     */
 +    @ForceInline
 +    public final
 +    void intoArray(short[] a, int offset,
-                    VectorMask<Halffloat> m) {
++                   VectorMask<Float16> m) {
 +        if (m.allTrue()) {
 +            intoArray(a, offset);
 +        } else {
 +            HalffloatSpecies vsp = vspecies();
 +            if (!VectorIntrinsics.indexInRange(offset, vsp.length(), a.length)) {
-                 checkMaskFromIndexSize(offset, vsp, m, 1, a.length);
++                ((AbstractMask<Float16>)m)
++                    .checkIndexByLane(offset, a.length, vsp.iota(), 1);
 +            }
 +            intoArray0(a, offset, m);
 +        }
 +    }
 +
 +    /**
 +     * Scatters this vector into an array of type {@code short[]}
 +     * using indexes obtained by adding a fixed {@code offset} to a
 +     * series of secondary offsets from an <em>index map</em>.
 +     * The index map is a contiguous sequence of {@code VLENGTH}
 +     * elements in a second array of {@code int}s, starting at a given
 +     * {@code mapOffset}.
 +     * <p>
 +     * For each vector lane, where {@code N} is the vector lane index,
 +     * the lane element at index {@code N} is stored into the array
 +     * element {@code a[f(N)]}, where {@code f(N)} is the
 +     * index mapping expression
 +     * {@code offset + indexMap[mapOffset + N]]}.
 +     *
 +     * @param a the array
 +     * @param offset an offset to combine with the index map offsets
 +     * @param indexMap the index map
 +     * @param mapOffset the offset into the index map
 +     * @throws IndexOutOfBoundsException
 +     *         if {@code mapOffset+N < 0}
 +     *         or if {@code mapOffset+N >= indexMap.length},
 +     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}
 +     *         is an invalid index into {@code a},
 +     *         for any lane {@code N} in the vector
 +     * @see HalffloatVector#toIntArray()
 +     */
 +    @ForceInline
 +    public final
 +    void intoArray(short[] a, int offset,
 +                   int[] indexMap, int mapOffset) {
 +        stOp(a, offset,
 +             (arr, off, i, e) -> {
 +                 int j = indexMap[mapOffset + i];
 +                 arr[off + j] = e;
 +             });
 +    }
 +
 +    /**
 +     * Scatters this vector into an array of type {@code short[]},
 +     * under the control of a mask, and
 +     * using indexes obtained by adding a fixed {@code offset} to a
 +     * series of secondary offsets from an <em>index map</em>.
 +     * The index map is a contiguous sequence of {@code VLENGTH}
 +     * elements in a second array of {@code int}s, starting at a given
 +     * {@code mapOffset}.
 +     * <p>
 +     * For each vector lane, where {@code N} is the vector lane index,
 +     * if the mask lane at index {@code N} is set then
 +     * the lane element at index {@code N} is stored into the array
 +     * element {@code a[f(N)]}, where {@code f(N)} is the
 +     * index mapping expression
 +     * {@code offset + indexMap[mapOffset + N]]}.
 +     *
 +     * @param a the array
 +     * @param offset an offset to combine with the index map offsets
 +     * @param indexMap the index map
 +     * @param mapOffset the offset into the index map
 +     * @param m the mask
 +     * @throws IndexOutOfBoundsException
 +     *         if {@code mapOffset+N < 0}
 +     *         or if {@code mapOffset+N >= indexMap.length},
 +     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}
 +     *         is an invalid index into {@code a},
 +     *         for any lane {@code N} in the vector
 +     *         where the mask is set
 +     * @see HalffloatVector#toIntArray()
 +     */
 +    @ForceInline
 +    public final
 +    void intoArray(short[] a, int offset,
 +                   int[] indexMap, int mapOffset,
-                    VectorMask<Halffloat> m) {
++                   VectorMask<Float16> m) {
 +        stOp(a, offset, m,
 +             (arr, off, i, e) -> {
 +                 int j = indexMap[mapOffset + i];
 +                 arr[off + j] = e;
 +             });
 +    }
 +
 +    /**
 +     * Stores this vector into an array of type {@code char[]}
 +     * starting at an offset.
 +     * <p>
 +     * For each vector lane, where {@code N} is the vector lane index,
 +     * the lane element at index {@code N}
 +     * is first cast to a {@code char} value and then
 +     * stored into the array element {@code a[offset+N]}.
 +     *
 +     * @param a the array, of type {@code char[]}
 +     * @param offset the offset into the array
 +     * @throws IndexOutOfBoundsException
 +     *         if {@code offset+N < 0} or {@code offset+N >= a.length}
 +     *         for any lane {@code N} in the vector
 +     */
 +    @ForceInline
 +    public final
 +    void intoCharArray(char[] a, int offset) {
 +        offset = checkFromIndexSize(offset, length(), a.length);
 +        HalffloatSpecies vsp = vspecies();
 +        VectorSupport.store(
-             vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
-             a, charArrayAddress(a, offset),
++            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
++            a, charArrayAddress(a, offset), false,
 +            this,
 +            a, offset,
 +            (arr, off, v)
 +            -> v.stOp(arr, (int) off,
 +                      (arr_, off_, i, e) -> arr_[off_ + i] = (char) e));
 +    }
 +
 +    /**
 +     * Stores this vector into an array of type {@code char[]}
 +     * starting at offset and using a mask.
 +     * <p>
 +     * For each vector lane, where {@code N} is the vector lane index,
 +     * the lane element at index {@code N}
 +     * is first cast to a {@code char} value and then
 +     * stored into the array element {@code a[offset+N]}.
 +     * If the mask lane at {@code N} is unset then the corresponding
 +     * array element {@code a[offset+N]} is left unchanged.
 +     * <p>
 +     * Array range checking is done for lanes where the mask is set.
 +     * Lanes where the mask is unset are not stored and do not need
 +     * to correspond to legitimate elements of {@code a}.
 +     * That is, unset lanes may correspond to array indexes less than
 +     * zero or beyond the end of the array.
 +     *
 +     * @param a the array, of type {@code char[]}
 +     * @param offset the offset into the array
 +     * @param m the mask controlling lane storage
 +     * @throws IndexOutOfBoundsException
 +     *         if {@code offset+N < 0} or {@code offset+N >= a.length}
 +     *         for any lane {@code N} in the vector
 +     *         where the mask is set
 +     */
 +    @ForceInline
 +    public final
 +    void intoCharArray(char[] a, int offset,
-                        VectorMask<Halffloat> m) {
++                       VectorMask<Float16> m) {
 +        if (m.allTrue()) {
 +            intoCharArray(a, offset);
 +        } else {
 +            HalffloatSpecies vsp = vspecies();
 +            if (!VectorIntrinsics.indexInRange(offset, vsp.length(), a.length)) {
-                 checkMaskFromIndexSize(offset, vsp, m, 1, a.length);
++                ((AbstractMask<Float16>)m)
++                    .checkIndexByLane(offset, a.length, vsp.iota(), 1);
 +            }
 +            intoCharArray0(a, offset, m);
 +        }
 +    }
 +
 +    /**
 +     * Scatters this vector into an array of type {@code char[]}
 +     * using indexes obtained by adding a fixed {@code offset} to a
 +     * series of secondary offsets from an <em>index map</em>.
 +     * The index map is a contiguous sequence of {@code VLENGTH}
 +     * elements in a second array of {@code int}s, starting at a given
 +     * {@code mapOffset}.
 +     * <p>
 +     * For each vector lane, where {@code N} is the vector lane index,
 +     * the lane element at index {@code N}
 +     * is first cast to a {@code char} value and then
 +     * stored into the array
 +     * element {@code a[f(N)]}, where {@code f(N)} is the
 +     * index mapping expression
 +     * {@code offset + indexMap[mapOffset + N]]}.
 +     *
 +     * @param a the array
 +     * @param offset an offset to combine with the index map offsets
 +     * @param indexMap the index map
 +     * @param mapOffset the offset into the index map
 +     * @throws IndexOutOfBoundsException
 +     *         if {@code mapOffset+N < 0}
 +     *         or if {@code mapOffset+N >= indexMap.length},
 +     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}
 +     *         is an invalid index into {@code a},
 +     *         for any lane {@code N} in the vector
 +     * @see HalffloatVector#toIntArray()
 +     */
 +    @ForceInline
 +    public final
 +    void intoCharArray(char[] a, int offset,
 +                       int[] indexMap, int mapOffset) {
 +        // FIXME: optimize
 +        stOp(a, offset,
 +             (arr, off, i, e) -> {
 +                 int j = indexMap[mapOffset + i];
 +                 arr[off + j] = (char) e;
 +             });
 +    }
 +
 +    /**
 +     * Scatters this vector into an array of type {@code char[]},
 +     * under the control of a mask, and
 +     * using indexes obtained by adding a fixed {@code offset} to a
 +     * series of secondary offsets from an <em>index map</em>.
 +     * The index map is a contiguous sequence of {@code VLENGTH}
 +     * elements in a second array of {@code int}s, starting at a given
 +     * {@code mapOffset}.
 +     * <p>
 +     * For each vector lane, where {@code N} is the vector lane index,
 +     * if the mask lane at index {@code N} is set then
 +     * the lane element at index {@code N}
 +     * is first cast to a {@code char} value and then
 +     * stored into the array
 +     * element {@code a[f(N)]}, where {@code f(N)} is the
 +     * index mapping expression
 +     * {@code offset + indexMap[mapOffset + N]]}.
 +     *
 +     * @param a the array
 +     * @param offset an offset to combine with the index map offsets
 +     * @param indexMap the index map
 +     * @param mapOffset the offset into the index map
 +     * @param m the mask
 +     * @throws IndexOutOfBoundsException
 +     *         if {@code mapOffset+N < 0}
 +     *         or if {@code mapOffset+N >= indexMap.length},
 +     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}
 +     *         is an invalid index into {@code a},
 +     *         for any lane {@code N} in the vector
 +     *         where the mask is set
 +     * @see HalffloatVector#toIntArray()
 +     */
 +    @ForceInline
 +    public final
 +    void intoCharArray(char[] a, int offset,
 +                       int[] indexMap, int mapOffset,
-                        VectorMask<Halffloat> m) {
++                       VectorMask<Float16> m) {
 +        // FIXME: optimize
 +        stOp(a, offset, m,
 +             (arr, off, i, e) -> {
 +                 int j = indexMap[mapOffset + i];
 +                 arr[off + j] = (char) e;
 +             });
 +    }
 +
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     * @since 19
 +     */
 +    @Override
 +    @ForceInline
 +    public final
 +    void intoMemorySegment(MemorySegment ms, long offset,
 +                           ByteOrder bo) {
 +        if (ms.isReadOnly()) {
 +            throw new UnsupportedOperationException("Attempt to write a read-only segment");
 +        }
 +
 +        offset = checkFromIndexSize(offset, byteSize(), ms.byteSize());
 +        maybeSwap(bo).intoMemorySegment0(ms, offset);
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     * @since 19
 +     */
 +    @Override
 +    @ForceInline
 +    public final
 +    void intoMemorySegment(MemorySegment ms, long offset,
 +                           ByteOrder bo,
-                            VectorMask<Halffloat> m) {
++                           VectorMask<Float16> m) {
 +        if (m.allTrue()) {
 +            intoMemorySegment(ms, offset, bo);
 +        } else {
 +            if (ms.isReadOnly()) {
 +                throw new UnsupportedOperationException("Attempt to write a read-only segment");
 +            }
 +            HalffloatSpecies vsp = vspecies();
 +            if (!VectorIntrinsics.indexInRange(offset, vsp.vectorByteSize(), ms.byteSize())) {
-                 checkMaskFromIndexSize(offset, vsp, m, 2, ms.byteSize());
++                ((AbstractMask<Float16>)m)
++                    .checkIndexByLane(offset, ms.byteSize(), vsp.iota(), 2);
 +            }
 +            maybeSwap(bo).intoMemorySegment0(ms, offset, m);
 +        }
 +    }
 +
 +    // ================================================
 +
 +    // Low-level memory operations.
 +    //
 +    // Note that all of these operations *must* inline into a context
 +    // where the exact species of the involved vector is a
 +    // compile-time constant.  Otherwise, the intrinsic generation
 +    // will fail and performance will suffer.
 +    //
 +    // In many cases this is achieved by re-deriving a version of the
 +    // method in each concrete subclass (per species).  The re-derived
 +    // method simply calls one of these generic methods, with exact
 +    // parameters for the controlling metadata, which is either a
 +    // typed vector or constant species instance.
 +
 +    // Unchecked loading operations in native byte order.
 +    // Caller is responsible for applying index checks, masking, and
 +    // byte swapping.
 +
 +    /*package-private*/
 +    abstract
 +    HalffloatVector fromArray0(short[] a, int offset);
 +    @ForceInline
 +    final
 +    HalffloatVector fromArray0Template(short[] a, int offset) {
 +        HalffloatSpecies vsp = vspecies();
 +        return VectorSupport.load(
-             vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset),
++            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
++            a, arrayAddress(a, offset), false,
 +            a, offset, vsp,
 +            (arr, off, s) -> s.ldOp(arr, (int) off,
 +                                    (arr_, off_, i) -> arr_[off_ + i]));
 +    }
 +
 +    /*package-private*/
 +    abstract
-     HalffloatVector fromArray0(short[] a, int offset, VectorMask<Halffloat> m, int offsetInRange);
++    HalffloatVector fromArray0(short[] a, int offset, VectorMask<Float16> m, int offsetInRange);
 +    @ForceInline
 +    final
-     <M extends VectorMask<Halffloat>>
++    <M extends VectorMask<Float16>>
 +    HalffloatVector fromArray0Template(Class<M> maskClass, short[] a, int offset, M m, int offsetInRange) {
 +        m.check(species());
 +        HalffloatSpecies vsp = vspecies();
 +        return VectorSupport.loadMasked(
-             vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset), m, offsetInRange,
++            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
++            a, arrayAddress(a, offset), false, m, offsetInRange,
 +            a, offset, vsp,
 +            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,
 +                                        (arr_, off_, i) -> arr_[off_ + i]));
 +    }
 +
++    /*package-private*/
++    abstract
++    HalffloatVector fromArray0(short[] a, int offset,
++                                    int[] indexMap, int mapOffset,
++                                    VectorMask<Float16> m);
++    @ForceInline
++    final
++    <M extends VectorMask<Float16>>
++    HalffloatVector fromArray0Template(Class<M> maskClass, short[] a, int offset,
++                                            int[] indexMap, int mapOffset, M m) {
++        HalffloatSpecies vsp = vspecies();
++        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());
++        Objects.requireNonNull(a);
++        Objects.requireNonNull(indexMap);
++        m.check(vsp);
++        Class<? extends HalffloatVector> vectorType = vsp.vectorType();
++
++
++        // Constant folding should sweep out following conditonal logic.
++        VectorSpecies<Integer> lsp;
++        if (isp.length() > IntVector.SPECIES_PREFERRED.length()) {
++            lsp = IntVector.SPECIES_PREFERRED;
++        } else {
++            lsp = isp;
++        }
++
++        // Check indices are within array bounds.
++        // FIXME: Check index under mask controlling.
++        IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);
++        VectorIntrinsics.checkIndex(vix0, a.length);
++
++        int vlen = vsp.length();
++        int idx_vlen = lsp.length();
++        IntVector vix1 = null;
++        if (vlen >= idx_vlen * 2) {
++            vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);
++            VectorIntrinsics.checkIndex(vix1, a.length);
++        }
++
++        return VectorSupport.loadWithMap(
++            vectorType, maskClass, short.class, Float16.class, VECTOR_OPER_TYPE, vsp.laneCount(),
++            lsp.vectorType(), lsp.length(),
++            a, ARRAY_BASE, vix0, vix1, null, null, m,
++            a, offset, indexMap, mapOffset, vsp,
++            (c, idx, iMap, idy, s, vm) ->
++            s.vOp(vm, n -> c[idx + iMap[idy+n]]));
++    }
 +
 +    /*package-private*/
 +    abstract
 +    HalffloatVector fromCharArray0(char[] a, int offset);
 +    @ForceInline
 +    final
 +    HalffloatVector fromCharArray0Template(char[] a, int offset) {
 +        HalffloatSpecies vsp = vspecies();
 +        return VectorSupport.load(
-             vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
-             a, charArrayAddress(a, offset),
++            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
++            a, charArrayAddress(a, offset), false,
 +            a, offset, vsp,
 +            (arr, off, s) -> s.ldOp(arr, (int) off,
 +                                    (arr_, off_, i) -> (short) arr_[off_ + i]));
 +    }
 +
 +    /*package-private*/
 +    abstract
-     HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Halffloat> m, int offsetInRange);
++    HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Float16> m, int offsetInRange);
 +    @ForceInline
 +    final
-     <M extends VectorMask<Halffloat>>
++    <M extends VectorMask<Float16>>
 +    HalffloatVector fromCharArray0Template(Class<M> maskClass, char[] a, int offset, M m, int offsetInRange) {
 +        m.check(species());
 +        HalffloatSpecies vsp = vspecies();
 +        return VectorSupport.loadMasked(
-                 vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
-                 a, charArrayAddress(a, offset), m, offsetInRange,
++                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
++                a, charArrayAddress(a, offset), false, m, offsetInRange,
 +                a, offset, vsp,
 +                (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,
 +                                            (arr_, off_, i) -> (short) arr_[off_ + i]));
 +    }
 +
 +
 +    abstract
 +    HalffloatVector fromMemorySegment0(MemorySegment bb, long offset);
 +    @ForceInline
 +    final
 +    HalffloatVector fromMemorySegment0Template(MemorySegment ms, long offset) {
 +        HalffloatSpecies vsp = vspecies();
 +        return ScopedMemoryAccess.loadFromMemorySegment(
-                 vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
++                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
 +                (AbstractMemorySegmentImpl) ms, offset, vsp,
 +                (msp, off, s) -> {
 +                    return s.ldLongOp((MemorySegment) msp, off, HalffloatVector::memorySegmentGet);
 +                });
 +    }
 +
 +    abstract
-     HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Halffloat> m, int offsetInRange);
++    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m, int offsetInRange);
 +    @ForceInline
 +    final
-     <M extends VectorMask<Halffloat>>
++    <M extends VectorMask<Float16>>
 +    HalffloatVector fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m, int offsetInRange) {
 +        HalffloatSpecies vsp = vspecies();
 +        m.check(vsp);
 +        return ScopedMemoryAccess.loadFromMemorySegmentMasked(
-                 vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
++                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
 +                (AbstractMemorySegmentImpl) ms, offset, m, vsp, offsetInRange,
 +                (msp, off, s, vm) -> {
 +                    return s.ldLongOp((MemorySegment) msp, off, vm, HalffloatVector::memorySegmentGet);
 +                });
 +    }
 +
 +    // Unchecked storing operations in native byte order.
 +    // Caller is responsible for applying index checks, masking, and
 +    // byte swapping.
 +
 +    abstract
 +    void intoArray0(short[] a, int offset);
 +    @ForceInline
 +    final
 +    void intoArray0Template(short[] a, int offset) {
 +        HalffloatSpecies vsp = vspecies();
 +        VectorSupport.store(
-             vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset),
++            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
++            a, arrayAddress(a, offset), false,
 +            this, a, offset,
 +            (arr, off, v)
 +            -> v.stOp(arr, (int) off,
 +                      (arr_, off_, i, e) -> arr_[off_+i] = e));
 +    }
 +
 +    abstract
-     void intoArray0(short[] a, int offset, VectorMask<Halffloat> m);
++    void intoArray0(short[] a, int offset, VectorMask<Float16> m);
 +    @ForceInline
 +    final
-     <M extends VectorMask<Halffloat>>
++    <M extends VectorMask<Float16>>
 +    void intoArray0Template(Class<M> maskClass, short[] a, int offset, M m) {
 +        m.check(species());
 +        HalffloatSpecies vsp = vspecies();
 +        VectorSupport.storeMasked(
-             vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset),
++            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
++            a, arrayAddress(a, offset), false,
 +            this, m, a, offset,
 +            (arr, off, v, vm)
 +            -> v.stOp(arr, (int) off, vm,
 +                      (arr_, off_, i, e) -> arr_[off_ + i] = e));
 +    }
 +
 +
 +
 +    @ForceInline
 +    final
 +    void intoMemorySegment0(MemorySegment ms, long offset) {
 +        HalffloatSpecies vsp = vspecies();
 +        ScopedMemoryAccess.storeIntoMemorySegment(
-                 vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
++                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
 +                this,
 +                (AbstractMemorySegmentImpl) ms, offset,
 +                (msp, off, v) -> {
 +                    v.stLongOp((MemorySegment) msp, off, HalffloatVector::memorySegmentSet);
 +                });
 +    }
 +
 +    abstract
-     void intoMemorySegment0(MemorySegment bb, long offset, VectorMask<Halffloat> m);
++    void intoMemorySegment0(MemorySegment bb, long offset, VectorMask<Float16> m);
 +    @ForceInline
 +    final
-     <M extends VectorMask<Halffloat>>
++    <M extends VectorMask<Float16>>
 +    void intoMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {
 +        HalffloatSpecies vsp = vspecies();
 +        m.check(vsp);
 +        ScopedMemoryAccess.storeIntoMemorySegmentMasked(
-                 vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
++                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
 +                this, m,
 +                (AbstractMemorySegmentImpl) ms, offset,
 +                (msp, off, v, vm) -> {
 +                    v.stLongOp((MemorySegment) msp, off, vm, HalffloatVector::memorySegmentSet);
 +                });
 +    }
 +
 +    /*package-private*/
 +    abstract
-     void intoCharArray0(char[] a, int offset, VectorMask<Halffloat> m);
++    void intoCharArray0(char[] a, int offset, VectorMask<Float16> m);
 +    @ForceInline
 +    final
-     <M extends VectorMask<Halffloat>>
++    <M extends VectorMask<Float16>>
 +    void intoCharArray0Template(Class<M> maskClass, char[] a, int offset, M m) {
 +        m.check(species());
 +        HalffloatSpecies vsp = vspecies();
 +        VectorSupport.storeMasked(
-             vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
-             a, charArrayAddress(a, offset),
++            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
++            a, charArrayAddress(a, offset), false,
 +            this, m, a, offset,
 +            (arr, off, v, vm)
 +            -> v.stOp(arr, (int) off, vm,
 +                      (arr_, off_, i, e) -> arr_[off_ + i] = (char) e));
 +    }
 +
 +    // End of low-level memory operations.
 +
-     private static
-     void checkMaskFromIndexSize(int offset,
-                                 HalffloatSpecies vsp,
-                                 VectorMask<Halffloat> m,
-                                 int scale,
-                                 int limit) {
-         ((AbstractMask<Halffloat>)m)
-             .checkIndexByLane(offset, limit, vsp.iota(), scale);
-     }
- 
-     private static
-     void checkMaskFromIndexSize(long offset,
-                                 HalffloatSpecies vsp,
-                                 VectorMask<Halffloat> m,
-                                 int scale,
-                                 long limit) {
-         ((AbstractMask<Halffloat>)m)
-             .checkIndexByLane(offset, limit, vsp.iota(), scale);
-     }
- 
 +    @ForceInline
 +    private void conditionalStoreNYI(int offset,
 +                                     HalffloatSpecies vsp,
-                                      VectorMask<Halffloat> m,
++                                     VectorMask<Float16> m,
 +                                     int scale,
 +                                     int limit) {
 +        if (offset < 0 || offset + vsp.laneCount() * scale > limit) {
 +            String msg =
 +                String.format("unimplemented: store @%d in [0..%d), %s in %s",
 +                              offset, limit, m, vsp);
 +            throw new AssertionError(msg);
 +        }
 +    }
 +
 +    /*package-private*/
 +    @Override
 +    @ForceInline
 +    final
 +    HalffloatVector maybeSwap(ByteOrder bo) {
 +        if (bo != NATIVE_ENDIAN) {
 +            return this.reinterpretAsBytes()
 +                .rearrange(swapBytesShuffle())
 +                .reinterpretAsHalffloats();
 +        }
 +        return this;
 +    }
 +
 +    static final int ARRAY_SHIFT =
 +        31 - Integer.numberOfLeadingZeros(Unsafe.ARRAY_SHORT_INDEX_SCALE);
 +    static final long ARRAY_BASE =
 +        Unsafe.ARRAY_SHORT_BASE_OFFSET;
 +
 +    @ForceInline
 +    static long arrayAddress(short[] a, int index) {
 +        return ARRAY_BASE + (((long)index) << ARRAY_SHIFT);
 +    }
 +
 +    static final int ARRAY_CHAR_SHIFT =
 +            31 - Integer.numberOfLeadingZeros(Unsafe.ARRAY_CHAR_INDEX_SCALE);
 +    static final long ARRAY_CHAR_BASE =
 +            Unsafe.ARRAY_CHAR_BASE_OFFSET;
 +
 +    @ForceInline
 +    static long charArrayAddress(char[] a, int index) {
 +        return ARRAY_CHAR_BASE + (((long)index) << ARRAY_CHAR_SHIFT);
 +    }
 +
 +
 +    @ForceInline
 +    static long byteArrayAddress(byte[] a, int index) {
 +        return Unsafe.ARRAY_BYTE_BASE_OFFSET + index;
 +    }
 +
 +    // ================================================
 +
 +    /// Reinterpreting view methods:
 +    //   lanewise reinterpret: viewAsXVector()
 +    //   keep shape, redraw lanes: reinterpretAsEs()
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     */
 +    @ForceInline
 +    @Override
 +    public final ByteVector reinterpretAsBytes() {
 +         // Going to ByteVector, pay close attention to byte order.
 +         assert(REGISTER_ENDIAN == ByteOrder.LITTLE_ENDIAN);
 +         return asByteVectorRaw();
 +         //return asByteVectorRaw().rearrange(swapBytesShuffle());
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     */
 +    @ForceInline
 +    @Override
 +    public final ShortVector viewAsIntegralLanes() {
 +        LaneType ilt = LaneType.SHORT.asIntegral();
 +        return (ShortVector) asVectorRaw(ilt);
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     *
 +     * @implNote This method always throws
 +     * {@code UnsupportedOperationException}, because there is no floating
 +     * point type of the same size as {@code short}.  The return type
 +     * of this method is arbitrarily designated as
 +     * {@code Vector<?>}.  Future versions of this API may change the return
 +     * type if additional floating point types become available.
 +     */
 +    @ForceInline
 +    @Override
 +    public final
 +    HalffloatVector
 +    viewAsFloatingLanes() {
 +        return this;
 +    }
 +
 +    // ================================================
 +
 +    /// Object methods: toString, equals, hashCode
 +    //
 +    // Object methods are defined as if via Arrays.toString, etc.,
 +    // is applied to the array of elements.  Two equal vectors
 +    // are required to have equal species and equal lane values.
 +
 +    /**
 +     * Returns a string representation of this vector, of the form
 +     * {@code "[0,1,2...]"}, reporting the lane values of this vector,
 +     * in lane order.
 +     *
 +     * The string is produced as if by a call to {@link
 +     * java.util.Arrays#toString(short[]) Arrays.toString()},
 +     * as appropriate to the {@code short} array returned by
 +     * {@link #toArray this.toArray()}.
 +     *
 +     * @return a string of the form {@code "[0,1,2...]"}
 +     * reporting the lane values of this vector
 +     */
 +    @Override
 +    @ForceInline
 +    public final
 +    String toString() {
 +        // now that toArray is strongly typed, we can define this
 +        return Arrays.toString(toArray());
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     */
 +    @Override
 +    @ForceInline
 +    public final
 +    boolean equals(Object obj) {
 +        if (obj instanceof Vector) {
 +            Vector<?> that = (Vector<?>) obj;
 +            if (this.species().equals(that.species())) {
 +                return this.eq(that.check(this.species())).allTrue();
 +            }
 +        }
 +        return false;
 +    }
 +
 +    /**
 +     * {@inheritDoc} <!--workaround-->
 +     */
 +    @Override
 +    @ForceInline
 +    public final
 +    int hashCode() {
 +        // now that toArray is strongly typed, we can define this
 +        return Objects.hash(species(), Arrays.hashCode(toArray()));
 +    }
 +
 +    // ================================================
 +
 +    // Species
 +
 +    /**
 +     * Class representing {@link HalffloatVector}'s of the same {@link VectorShape VectorShape}.
 +     */
 +    /*package-private*/
-     static final class HalffloatSpecies extends AbstractSpecies<Halffloat> {
++    static final class HalffloatSpecies extends AbstractSpecies<Float16> {
 +        private HalffloatSpecies(VectorShape shape,
 +                Class<? extends HalffloatVector> vectorType,
-                 Class<? extends AbstractMask<Halffloat>> maskType,
-                 Class<? extends AbstractShuffle<Halffloat>> shuffleType,
++                Class<? extends AbstractMask<Float16>> maskType,
++                Class<? extends AbstractShuffle<Float16>> shuffleType,
 +                Function<Object, HalffloatVector> vectorFactory) {
-             super(shape, LaneType.of(Halffloat.class),
++            super(shape, LaneType.of(short.class),
 +                  vectorType, maskType, shuffleType,
 +                  vectorFactory);
-             assert(this.elementSize() == Halffloat.SIZE);
++            assert(this.elementSize() == Float16.SIZE);
 +        }
 +
 +        // Specializing overrides:
 +
++        @ForceInline
++        final Class<?> carrierType() {
++            return short.class;
++        }
++
++        @ForceInline
++        final int operType() {
++            if (Float16.class.equals(Float16.class)) {
++                return VECTOR_TYPE_FP16;
++            }
++            return VECTOR_TYPE_PRIM;
++        }
++
 +        @Override
 +        @ForceInline
-         public final Class<Halffloat> elementType() {
-             return Halffloat.class;
++        public final Class<Float16> elementType() {
++            return Float16.class;
 +        }
 +
 +        @Override
 +        @ForceInline
-         final Class<Halffloat> genericElementType() {
-             return Halffloat.class;
++        final Class<Float16> genericElementType() {
++            return Float16.class;
 +        }
 +
 +        @SuppressWarnings("unchecked")
 +        @Override
 +        @ForceInline
 +        public final Class<? extends HalffloatVector> vectorType() {
 +            return (Class<? extends HalffloatVector>) vectorType;
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public final long checkValue(long e) {
 +            longToElementBits(e);  // only for exception
 +            return e;
 +        }
 +
 +        /*package-private*/
 +        @Override
 +        @ForceInline
 +        final HalffloatVector broadcastBits(long bits) {
 +            return (HalffloatVector)
 +                VectorSupport.fromBitsCoerced(
-                     vectorType, Halffloat.class, laneCount,
++                    vectorType, short.class, Float16.class, VECTOR_OPER_TYPE, laneCount,
 +                    bits, MODE_BROADCAST, this,
 +                    (bits_, s_) -> s_.rvOp(i -> bits_));
 +        }
 +
 +        /*package-private*/
 +        @ForceInline
 +        final HalffloatVector broadcast(short e) {
 +            return broadcastBits(toBits(e));
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public final HalffloatVector broadcast(long e) {
 +            return broadcastBits(longToElementBits(e));
 +        }
 +
 +        /*package-private*/
 +        final @Override
 +        @ForceInline
 +        long longToElementBits(long value) {
 +            // Do the conversion, and then test it for failure.
 +            short e = (short) value;
 +            if ((long) e != value) {
 +                throw badElementBits(value, e);
 +            }
 +            return toBits(e);
 +        }
 +
 +        /*package-private*/
 +        @ForceInline
 +        static long toIntegralChecked(short e, boolean convertToInt) {
 +            long value = convertToInt ? (int) e : (long) e;
 +            if ((short) value != e) {
 +                throw badArrayBits(e, convertToInt, value);
 +            }
 +            return value;
 +        }
 +
 +        /* this non-public one is for internal conversions */
 +        @Override
 +        @ForceInline
 +        final HalffloatVector fromIntValues(int[] values) {
 +            VectorIntrinsics.requireLength(values.length, laneCount);
 +            short[] va = new short[laneCount()];
 +            for (int i = 0; i < va.length; i++) {
 +                int lv = values[i];
-                 short v = Float.floatToFloat16((float) lv);
++                short v = Float16.float16ToRawShortBits(Float16.valueOf(lv));
 +                va[i] = v;
-                 if ((int) Float.float16ToFloat(v) != lv) {
++                if (Float16.valueOf(lv).intValue() != lv) {
 +                    throw badElementBits(lv, v);
 +                }
 +            }
 +            return dummyVector().fromArray0(va, 0);
 +        }
 +
 +        // Virtual constructors
 +
 +        @ForceInline
 +        @Override final
 +        public HalffloatVector fromArray(Object a, int offset) {
-             // User entry point:  Be careful with inputs.
++            // User entry point
++            // Defer only to the equivalent method on the vector class, using the same inputs
 +            return HalffloatVector
 +                .fromArray(this, (short[]) a, offset);
 +        }
 +
++        @ForceInline
++        @Override final
++        public HalffloatVector fromMemorySegment(MemorySegment ms, long offset, ByteOrder bo) {
++            // User entry point
++            // Defer only to the equivalent method on the vector class, using the same inputs
++            return HalffloatVector
++                .fromMemorySegment(this, ms, offset, bo);
++        }
++
 +        @ForceInline
 +        @Override final
 +        HalffloatVector dummyVector() {
 +            return (HalffloatVector) super.dummyVector();
 +        }
 +
 +        /*package-private*/
 +        final @Override
 +        @ForceInline
 +        HalffloatVector rvOp(RVOp f) {
 +            short[] res = new short[laneCount()];
 +            for (int i = 0; i < res.length; i++) {
 +                short bits = (short) f.apply(i);
 +                res[i] = fromBits(bits);
 +            }
 +            return dummyVector().vectorFactory(res);
 +        }
 +
 +        HalffloatVector vOp(FVOp f) {
 +            short[] res = new short[laneCount()];
 +            for (int i = 0; i < res.length; i++) {
 +                res[i] = f.apply(i);
 +            }
 +            return dummyVector().vectorFactory(res);
 +        }
 +
-         HalffloatVector vOp(VectorMask<Halffloat> m, FVOp f) {
++        HalffloatVector vOp(VectorMask<Float16> m, FVOp f) {
 +            short[] res = new short[laneCount()];
-             boolean[] mbits = ((AbstractMask<Halffloat>)m).getBits();
++            boolean[] mbits = ((AbstractMask<Float16>)m).getBits();
 +            for (int i = 0; i < res.length; i++) {
 +                if (mbits[i]) {
 +                    res[i] = f.apply(i);
 +                }
 +            }
 +            return dummyVector().vectorFactory(res);
 +        }
 +
 +        /*package-private*/
 +        @ForceInline
 +        <M> HalffloatVector ldOp(M memory, int offset,
 +                                      FLdOp<M> f) {
 +            return dummyVector().ldOp(memory, offset, f);
 +        }
 +
 +        /*package-private*/
 +        @ForceInline
 +        <M> HalffloatVector ldOp(M memory, int offset,
-                                       VectorMask<Halffloat> m,
++                                      VectorMask<Float16> m,
 +                                      FLdOp<M> f) {
 +            return dummyVector().ldOp(memory, offset, m, f);
 +        }
 +
 +        /*package-private*/
 +        @ForceInline
 +        HalffloatVector ldLongOp(MemorySegment memory, long offset,
 +                                      FLdLongOp f) {
 +            return dummyVector().ldLongOp(memory, offset, f);
 +        }
 +
 +        /*package-private*/
 +        @ForceInline
 +        HalffloatVector ldLongOp(MemorySegment memory, long offset,
-                                       VectorMask<Halffloat> m,
++                                      VectorMask<Float16> m,
 +                                      FLdLongOp f) {
 +            return dummyVector().ldLongOp(memory, offset, m, f);
 +        }
 +
 +        /*package-private*/
 +        @ForceInline
 +        <M> void stOp(M memory, int offset, FStOp<M> f) {
 +            dummyVector().stOp(memory, offset, f);
 +        }
 +
 +        /*package-private*/
 +        @ForceInline
 +        <M> void stOp(M memory, int offset,
-                       AbstractMask<Halffloat> m,
++                      AbstractMask<Float16> m,
 +                      FStOp<M> f) {
 +            dummyVector().stOp(memory, offset, m, f);
 +        }
 +
 +        /*package-private*/
 +        @ForceInline
 +        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {
 +            dummyVector().stLongOp(memory, offset, f);
 +        }
 +
 +        /*package-private*/
 +        @ForceInline
 +        void stLongOp(MemorySegment memory, long offset,
-                       AbstractMask<Halffloat> m,
++                      AbstractMask<Float16> m,
 +                      FStLongOp f) {
 +            dummyVector().stLongOp(memory, offset, m, f);
 +        }
 +
 +        // N.B. Make sure these constant vectors and
 +        // masks load up correctly into registers.
 +        //
 +        // Also, see if we can avoid all that switching.
 +        // Could we cache both vectors and both masks in
 +        // this species object?
 +
 +        // Zero and iota vector access
 +        @Override
 +        @ForceInline
 +        public final HalffloatVector zero() {
 +            if ((Class<?>) vectorType() == HalffloatMaxVector.class)
 +                return HalffloatMaxVector.ZERO;
 +            switch (vectorBitSize()) {
 +                case 64: return Halffloat64Vector.ZERO;
 +                case 128: return Halffloat128Vector.ZERO;
 +                case 256: return Halffloat256Vector.ZERO;
 +                case 512: return Halffloat512Vector.ZERO;
 +            }
 +            throw new AssertionError();
 +        }
 +
 +        @Override
 +        @ForceInline
 +        public final HalffloatVector iota() {
 +            if ((Class<?>) vectorType() == HalffloatMaxVector.class)
 +                return HalffloatMaxVector.IOTA;
 +            switch (vectorBitSize()) {
 +                case 64: return Halffloat64Vector.IOTA;
 +                case 128: return Halffloat128Vector.IOTA;
 +                case 256: return Halffloat256Vector.IOTA;
 +                case 512: return Halffloat512Vector.IOTA;
 +            }
 +            throw new AssertionError();
 +        }
 +
 +        // Mask access
 +        @Override
 +        @ForceInline
-         public final VectorMask<Halffloat> maskAll(boolean bit) {
++        public final VectorMask<Float16> maskAll(boolean bit) {
 +            if ((Class<?>) vectorType() == HalffloatMaxVector.class)
 +                return HalffloatMaxVector.HalffloatMaxMask.maskAll(bit);
 +            switch (vectorBitSize()) {
 +                case 64: return Halffloat64Vector.Halffloat64Mask.maskAll(bit);
 +                case 128: return Halffloat128Vector.Halffloat128Mask.maskAll(bit);
 +                case 256: return Halffloat256Vector.Halffloat256Mask.maskAll(bit);
 +                case 512: return Halffloat512Vector.Halffloat512Mask.maskAll(bit);
 +            }
 +            throw new AssertionError();
 +        }
 +    }
 +
 +    /**
 +     * Finds a species for an element type of {@code short} and shape.
 +     *
 +     * @param s the shape
 +     * @return a species for an element type of {@code short} and shape
 +     * @throws IllegalArgumentException if no such species exists for the shape
 +     */
 +    static HalffloatSpecies species(VectorShape s) {
 +        Objects.requireNonNull(s);
 +        switch (s.switchKey) {
 +            case VectorShape.SK_64_BIT: return (HalffloatSpecies) SPECIES_64;
 +            case VectorShape.SK_128_BIT: return (HalffloatSpecies) SPECIES_128;
 +            case VectorShape.SK_256_BIT: return (HalffloatSpecies) SPECIES_256;
 +            case VectorShape.SK_512_BIT: return (HalffloatSpecies) SPECIES_512;
 +            case VectorShape.SK_Max_BIT: return (HalffloatSpecies) SPECIES_MAX;
 +            default: throw new IllegalArgumentException("Bad shape: " + s);
 +        }
 +    }
 +
 +    /** Species representing {@link HalffloatVector}s of {@link VectorShape#S_64_BIT VectorShape.S_64_BIT}. */
-     public static final VectorSpecies<Halffloat> SPECIES_64
++    public static final VectorSpecies<Float16> SPECIES_64
 +        = new HalffloatSpecies(VectorShape.S_64_BIT,
 +                            Halffloat64Vector.class,
 +                            Halffloat64Vector.Halffloat64Mask.class,
 +                            Halffloat64Vector.Halffloat64Shuffle.class,
 +                            Halffloat64Vector::new);
 +
 +    /** Species representing {@link HalffloatVector}s of {@link VectorShape#S_128_BIT VectorShape.S_128_BIT}. */
-     public static final VectorSpecies<Halffloat> SPECIES_128
++    public static final VectorSpecies<Float16> SPECIES_128
 +        = new HalffloatSpecies(VectorShape.S_128_BIT,
 +                            Halffloat128Vector.class,
 +                            Halffloat128Vector.Halffloat128Mask.class,
 +                            Halffloat128Vector.Halffloat128Shuffle.class,
 +                            Halffloat128Vector::new);
 +
 +    /** Species representing {@link HalffloatVector}s of {@link VectorShape#S_256_BIT VectorShape.S_256_BIT}. */
-     public static final VectorSpecies<Halffloat> SPECIES_256
++    public static final VectorSpecies<Float16> SPECIES_256
 +        = new HalffloatSpecies(VectorShape.S_256_BIT,
 +                            Halffloat256Vector.class,
 +                            Halffloat256Vector.Halffloat256Mask.class,
 +                            Halffloat256Vector.Halffloat256Shuffle.class,
 +                            Halffloat256Vector::new);
 +
 +    /** Species representing {@link HalffloatVector}s of {@link VectorShape#S_512_BIT VectorShape.S_512_BIT}. */
-     public static final VectorSpecies<Halffloat> SPECIES_512
++    public static final VectorSpecies<Float16> SPECIES_512
 +        = new HalffloatSpecies(VectorShape.S_512_BIT,
 +                            Halffloat512Vector.class,
 +                            Halffloat512Vector.Halffloat512Mask.class,
 +                            Halffloat512Vector.Halffloat512Shuffle.class,
 +                            Halffloat512Vector::new);
 +
 +    /** Species representing {@link HalffloatVector}s of {@link VectorShape#S_Max_BIT VectorShape.S_Max_BIT}. */
-     public static final VectorSpecies<Halffloat> SPECIES_MAX
++    public static final VectorSpecies<Float16> SPECIES_MAX
 +        = new HalffloatSpecies(VectorShape.S_Max_BIT,
 +                            HalffloatMaxVector.class,
 +                            HalffloatMaxVector.HalffloatMaxMask.class,
 +                            HalffloatMaxVector.HalffloatMaxShuffle.class,
 +                            HalffloatMaxVector::new);
 +
 +    /**
 +     * Preferred species for {@link HalffloatVector}s.
 +     * A preferred species is a species of maximal bit-size for the platform.
 +     */
-     public static final VectorSpecies<Halffloat> SPECIES_PREFERRED
-         = (HalffloatSpecies) VectorSpecies.ofPreferred(Halffloat.class);
++    public static final VectorSpecies<Float16> SPECIES_PREFERRED
++        = (HalffloatSpecies) VectorSpecies.ofPreferred(Float16.class);
 +}
 +
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int128Vector.java
index 8e2e10e077d,edf45b8772a..69b50f30684
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int128Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int128Vector.java
@@@ -52,7 -54,7 +54,11 @@@ final class Int128Vector extends IntVec
  
      static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
  
--    static final Class<Integer> ETYPE = int.class; // used by the JVM
++    static final Class<Integer> CTYPE = int.class; // carrier type used by the JVM
++
++    static final Class<Integer> ETYPE = int.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
  
      Int128Vector(int[] v) {
          super(v);
@@@ -86,9 -88,9 +92,12 @@@
          return VSPECIES;
      }
  
++    @ForceInline
++    final Class<Integer> carrierType() { return CTYPE; }
++
      @ForceInline
      @Override
--    public final Class<Integer> elementType() { return int.class; }
++    public final Class<Integer> elementType() { return ETYPE; }
  
      @ForceInline
      @Override
@@@ -506,9 -526,10 +533,10 @@@
          }
      }
  
+     @ForceInline
      public int laneHelper(int i) {
          return (int) VectorSupport.extract(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i,
                                  (vec, ix) -> {
                                      int[] vecarr = vec.vec();
@@@ -528,9 -549,10 +556,10 @@@
          }
      }
  
+     @ForceInline
      public Int128Vector withLaneHelper(int i, int e) {
          return VectorSupport.insert(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i, (long)e,
                                  (v, ix, bits) -> {
                                      int[] res = v.vec().clone();
@@@ -543,7 -565,7 +572,7 @@@
  
      static final class Int128Mask extends AbstractMask<Integer> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Integer> ETYPE = int.class; // used by the JVM
++        static final Class<Integer> CTYPE = int.class; // used by the JVM
  
          Int128Mask(boolean[] bits) {
              this(bits, 0);
@@@ -645,7 -667,7 +674,7 @@@
          /*package-private*/
          Int128Mask indexPartiallyInUpperRange(long offset, long limit) {
              return (Int128Mask) VectorSupport.indexPartiallyInUpperRange(
-                 Int128Mask.class, ETYPE, VLENGTH, offset, limit,
 -                Int128Mask.class, int.class, VLENGTH, offset, limit,
++                Int128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                  (o, l) -> (Int128Mask) TRUE_MASK.indexPartiallyInRange(o, l));
          }
  
@@@ -661,8 -683,8 +690,9 @@@
          @ForceInline
          public Int128Mask compress() {
              return (Int128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
--                Int128Vector.class, Int128Mask.class, ETYPE, VLENGTH, null, this,
--                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
++                Int128Vector.class, Int128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                m1.trueCount()));
          }
  
  
@@@ -673,7 -695,7 +703,7 @@@
          public Int128Mask and(VectorMask<Integer> mask) {
              Objects.requireNonNull(mask);
              Int128Mask m = (Int128Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_AND, Int128Mask.class, null, int.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, Int128Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
          }
@@@ -683,7 -705,7 +713,7 @@@
          public Int128Mask or(VectorMask<Integer> mask) {
              Objects.requireNonNull(mask);
              Int128Mask m = (Int128Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_OR, Int128Mask.class, null, int.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, Int128Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
          }
@@@ -693,7 -715,7 +723,7 @@@
          public Int128Mask xor(VectorMask<Integer> mask) {
              Objects.requireNonNull(mask);
              Int128Mask m = (Int128Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int128Mask.class, null, int.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int128Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
          }
@@@ -703,22 -725,22 +733,25 @@@
          @Override
          @ForceInline
          public int trueCount() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int128Mask.class, int.class, VLENGTH, this,
--                                                      (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int128Mask.class, int.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int firstTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int128Mask.class, int.class, VLENGTH, this,
--                                                      (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int128Mask.class, int.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int lastTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int128Mask.class, int.class, VLENGTH, this,
--                                                      (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int128Mask.class, int.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
          }
  
          @Override
@@@ -727,32 -749,42 +760,43 @@@
              if (length() > Long.SIZE) {
                  throw new UnsupportedOperationException("too many lanes for one long");
              }
--            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Int128Mask.class, int.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Int128Mask.class, int.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
                                                        (m) -> toLongHelper(m.getBits()));
          }
  
+         // laneIsSet
+ 
+         @Override
+         @ForceInline
+         public boolean laneIsSet(int i) {
+             Objects.checkIndex(i, length());
 -            return VectorSupport.extract(Int128Mask.class, int.class, VLENGTH,
++            return VectorSupport.extract(Int128Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
+         }
+ 
          // Reductions
  
          @Override
          @ForceInline
          public boolean anyTrue() {
--            return VectorSupport.test(BT_ne, Int128Mask.class, int.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> anyTrueHelper(((Int128Mask)m).getBits()));
++            return VectorSupport.test(BT_ne, Int128Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper(((Int128Mask)m).getBits()));
          }
  
          @Override
          @ForceInline
          public boolean allTrue() {
--            return VectorSupport.test(BT_overflow, Int128Mask.class, int.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> allTrueHelper(((Int128Mask)m).getBits()));
++            return VectorSupport.test(BT_overflow, Int128Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper(((Int128Mask)m).getBits()));
          }
  
          @ForceInline
          /*package-private*/
          static Int128Mask maskAll(boolean bit) {
--            return VectorSupport.fromBitsCoerced(Int128Mask.class, int.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced(Int128Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                                   (bit ? -1 : 0), MODE_BROADCAST, null,
                                                   (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
          }
@@@ -765,7 -797,7 +809,7 @@@
  
      static final class Int128Shuffle extends AbstractShuffle<Integer> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Integer> ETYPE = int.class; // used by the JVM
++        static final Class<Integer> CTYPE = int.class; // used by the JVM
  
          Int128Shuffle(int[] indices) {
              super(indices);
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int256Vector.java
index a0448218491,bb86ede05e1..f7e1cb8dbcf
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int256Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int256Vector.java
@@@ -52,7 -54,7 +54,11 @@@ final class Int256Vector extends IntVec
  
      static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
  
--    static final Class<Integer> ETYPE = int.class; // used by the JVM
++    static final Class<Integer> CTYPE = int.class; // carrier type used by the JVM
++
++    static final Class<Integer> ETYPE = int.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
  
      Int256Vector(int[] v) {
          super(v);
@@@ -86,9 -88,9 +92,12 @@@
          return VSPECIES;
      }
  
++    @ForceInline
++    final Class<Integer> carrierType() { return CTYPE; }
++
      @ForceInline
      @Override
--    public final Class<Integer> elementType() { return int.class; }
++    public final Class<Integer> elementType() { return ETYPE; }
  
      @ForceInline
      @Override
@@@ -510,9 -530,10 +537,10 @@@
          }
      }
  
+     @ForceInline
      public int laneHelper(int i) {
          return (int) VectorSupport.extract(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i,
                                  (vec, ix) -> {
                                      int[] vecarr = vec.vec();
@@@ -536,9 -557,10 +564,10 @@@
          }
      }
  
+     @ForceInline
      public Int256Vector withLaneHelper(int i, int e) {
          return VectorSupport.insert(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i, (long)e,
                                  (v, ix, bits) -> {
                                      int[] res = v.vec().clone();
@@@ -551,7 -573,7 +580,7 @@@
  
      static final class Int256Mask extends AbstractMask<Integer> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Integer> ETYPE = int.class; // used by the JVM
++        static final Class<Integer> CTYPE = int.class; // used by the JVM
  
          Int256Mask(boolean[] bits) {
              this(bits, 0);
@@@ -653,7 -675,7 +682,7 @@@
          /*package-private*/
          Int256Mask indexPartiallyInUpperRange(long offset, long limit) {
              return (Int256Mask) VectorSupport.indexPartiallyInUpperRange(
-                 Int256Mask.class, ETYPE, VLENGTH, offset, limit,
 -                Int256Mask.class, int.class, VLENGTH, offset, limit,
++                Int256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                  (o, l) -> (Int256Mask) TRUE_MASK.indexPartiallyInRange(o, l));
          }
  
@@@ -669,8 -691,8 +698,9 @@@
          @ForceInline
          public Int256Mask compress() {
              return (Int256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
--                Int256Vector.class, Int256Mask.class, ETYPE, VLENGTH, null, this,
--                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
++                Int256Vector.class, Int256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                m1.trueCount()));
          }
  
  
@@@ -681,7 -703,7 +711,7 @@@
          public Int256Mask and(VectorMask<Integer> mask) {
              Objects.requireNonNull(mask);
              Int256Mask m = (Int256Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_AND, Int256Mask.class, null, int.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, Int256Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
          }
@@@ -691,7 -713,7 +721,7 @@@
          public Int256Mask or(VectorMask<Integer> mask) {
              Objects.requireNonNull(mask);
              Int256Mask m = (Int256Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_OR, Int256Mask.class, null, int.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, Int256Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
          }
@@@ -701,7 -723,7 +731,7 @@@
          public Int256Mask xor(VectorMask<Integer> mask) {
              Objects.requireNonNull(mask);
              Int256Mask m = (Int256Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int256Mask.class, null, int.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int256Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
          }
@@@ -711,22 -733,22 +741,25 @@@
          @Override
          @ForceInline
          public int trueCount() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int256Mask.class, int.class, VLENGTH, this,
--                                                      (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int256Mask.class, int.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int firstTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int256Mask.class, int.class, VLENGTH, this,
--                                                      (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int256Mask.class, int.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int lastTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int256Mask.class, int.class, VLENGTH, this,
--                                                      (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int256Mask.class, int.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
          }
  
          @Override
@@@ -735,32 -757,42 +768,43 @@@
              if (length() > Long.SIZE) {
                  throw new UnsupportedOperationException("too many lanes for one long");
              }
--            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Int256Mask.class, int.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Int256Mask.class, int.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
                                                        (m) -> toLongHelper(m.getBits()));
          }
  
+         // laneIsSet
+ 
+         @Override
+         @ForceInline
+         public boolean laneIsSet(int i) {
+             Objects.checkIndex(i, length());
 -            return VectorSupport.extract(Int256Mask.class, int.class, VLENGTH,
++            return VectorSupport.extract(Int256Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
+         }
+ 
          // Reductions
  
          @Override
          @ForceInline
          public boolean anyTrue() {
--            return VectorSupport.test(BT_ne, Int256Mask.class, int.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> anyTrueHelper(((Int256Mask)m).getBits()));
++            return VectorSupport.test(BT_ne, Int256Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper(((Int256Mask)m).getBits()));
          }
  
          @Override
          @ForceInline
          public boolean allTrue() {
--            return VectorSupport.test(BT_overflow, Int256Mask.class, int.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> allTrueHelper(((Int256Mask)m).getBits()));
++            return VectorSupport.test(BT_overflow, Int256Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper(((Int256Mask)m).getBits()));
          }
  
          @ForceInline
          /*package-private*/
          static Int256Mask maskAll(boolean bit) {
--            return VectorSupport.fromBitsCoerced(Int256Mask.class, int.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced(Int256Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                                   (bit ? -1 : 0), MODE_BROADCAST, null,
                                                   (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
          }
@@@ -773,7 -805,7 +817,7 @@@
  
      static final class Int256Shuffle extends AbstractShuffle<Integer> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Integer> ETYPE = int.class; // used by the JVM
++        static final Class<Integer> CTYPE = int.class; // used by the JVM
  
          Int256Shuffle(int[] indices) {
              super(indices);
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int512Vector.java
index b8b4f015275,16d3b673da0..e321f2a3d65
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int512Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int512Vector.java
@@@ -52,7 -54,7 +54,11 @@@ final class Int512Vector extends IntVec
  
      static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
  
--    static final Class<Integer> ETYPE = int.class; // used by the JVM
++    static final Class<Integer> CTYPE = int.class; // carrier type used by the JVM
++
++    static final Class<Integer> ETYPE = int.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
  
      Int512Vector(int[] v) {
          super(v);
@@@ -86,9 -88,9 +92,12 @@@
          return VSPECIES;
      }
  
++    @ForceInline
++    final Class<Integer> carrierType() { return CTYPE; }
++
      @ForceInline
      @Override
--    public final Class<Integer> elementType() { return int.class; }
++    public final Class<Integer> elementType() { return ETYPE; }
  
      @ForceInline
      @Override
@@@ -518,9 -538,10 +545,10 @@@
          }
      }
  
+     @ForceInline
      public int laneHelper(int i) {
          return (int) VectorSupport.extract(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i,
                                  (vec, ix) -> {
                                      int[] vecarr = vec.vec();
@@@ -552,9 -573,10 +580,10 @@@
          }
      }
  
+     @ForceInline
      public Int512Vector withLaneHelper(int i, int e) {
          return VectorSupport.insert(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i, (long)e,
                                  (v, ix, bits) -> {
                                      int[] res = v.vec().clone();
@@@ -567,7 -589,7 +596,7 @@@
  
      static final class Int512Mask extends AbstractMask<Integer> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Integer> ETYPE = int.class; // used by the JVM
++        static final Class<Integer> CTYPE = int.class; // used by the JVM
  
          Int512Mask(boolean[] bits) {
              this(bits, 0);
@@@ -669,7 -691,7 +698,7 @@@
          /*package-private*/
          Int512Mask indexPartiallyInUpperRange(long offset, long limit) {
              return (Int512Mask) VectorSupport.indexPartiallyInUpperRange(
-                 Int512Mask.class, ETYPE, VLENGTH, offset, limit,
 -                Int512Mask.class, int.class, VLENGTH, offset, limit,
++                Int512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                  (o, l) -> (Int512Mask) TRUE_MASK.indexPartiallyInRange(o, l));
          }
  
@@@ -685,8 -707,8 +714,9 @@@
          @ForceInline
          public Int512Mask compress() {
              return (Int512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
--                Int512Vector.class, Int512Mask.class, ETYPE, VLENGTH, null, this,
--                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
++                Int512Vector.class, Int512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                m1.trueCount()));
          }
  
  
@@@ -697,7 -719,7 +727,7 @@@
          public Int512Mask and(VectorMask<Integer> mask) {
              Objects.requireNonNull(mask);
              Int512Mask m = (Int512Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_AND, Int512Mask.class, null, int.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, Int512Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
          }
@@@ -707,7 -729,7 +737,7 @@@
          public Int512Mask or(VectorMask<Integer> mask) {
              Objects.requireNonNull(mask);
              Int512Mask m = (Int512Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_OR, Int512Mask.class, null, int.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, Int512Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
          }
@@@ -717,7 -739,7 +747,7 @@@
          public Int512Mask xor(VectorMask<Integer> mask) {
              Objects.requireNonNull(mask);
              Int512Mask m = (Int512Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int512Mask.class, null, int.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int512Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
          }
@@@ -727,22 -749,22 +757,25 @@@
          @Override
          @ForceInline
          public int trueCount() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int512Mask.class, int.class, VLENGTH, this,
--                                                      (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int512Mask.class, int.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int firstTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int512Mask.class, int.class, VLENGTH, this,
--                                                      (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int512Mask.class, int.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int lastTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int512Mask.class, int.class, VLENGTH, this,
--                                                      (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int512Mask.class, int.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
          }
  
          @Override
@@@ -751,32 -773,42 +784,43 @@@
              if (length() > Long.SIZE) {
                  throw new UnsupportedOperationException("too many lanes for one long");
              }
--            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Int512Mask.class, int.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Int512Mask.class, int.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
                                                        (m) -> toLongHelper(m.getBits()));
          }
  
+         // laneIsSet
+ 
+         @Override
+         @ForceInline
+         public boolean laneIsSet(int i) {
+             Objects.checkIndex(i, length());
 -            return VectorSupport.extract(Int512Mask.class, int.class, VLENGTH,
++            return VectorSupport.extract(Int512Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
+         }
+ 
          // Reductions
  
          @Override
          @ForceInline
          public boolean anyTrue() {
--            return VectorSupport.test(BT_ne, Int512Mask.class, int.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> anyTrueHelper(((Int512Mask)m).getBits()));
++            return VectorSupport.test(BT_ne, Int512Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper(((Int512Mask)m).getBits()));
          }
  
          @Override
          @ForceInline
          public boolean allTrue() {
--            return VectorSupport.test(BT_overflow, Int512Mask.class, int.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> allTrueHelper(((Int512Mask)m).getBits()));
++            return VectorSupport.test(BT_overflow, Int512Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper(((Int512Mask)m).getBits()));
          }
  
          @ForceInline
          /*package-private*/
          static Int512Mask maskAll(boolean bit) {
--            return VectorSupport.fromBitsCoerced(Int512Mask.class, int.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced(Int512Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                                   (bit ? -1 : 0), MODE_BROADCAST, null,
                                                   (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
          }
@@@ -789,7 -821,7 +833,7 @@@
  
      static final class Int512Shuffle extends AbstractShuffle<Integer> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Integer> ETYPE = int.class; // used by the JVM
++        static final Class<Integer> CTYPE = int.class; // used by the JVM
  
          Int512Shuffle(int[] indices) {
              super(indices);
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int64Vector.java
index 4dc8141017e,d55364a8d67..3d1da443fc8
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int64Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int64Vector.java
@@@ -52,7 -54,7 +54,11 @@@ final class Int64Vector extends IntVect
  
      static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
  
--    static final Class<Integer> ETYPE = int.class; // used by the JVM
++    static final Class<Integer> CTYPE = int.class; // carrier type used by the JVM
++
++    static final Class<Integer> ETYPE = int.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
  
      Int64Vector(int[] v) {
          super(v);
@@@ -86,9 -88,9 +92,12 @@@
          return VSPECIES;
      }
  
++    @ForceInline
++    final Class<Integer> carrierType() { return CTYPE; }
++
      @ForceInline
      @Override
--    public final Class<Integer> elementType() { return int.class; }
++    public final Class<Integer> elementType() { return ETYPE; }
  
      @ForceInline
      @Override
@@@ -504,9 -524,10 +531,10 @@@
          }
      }
  
+     @ForceInline
      public int laneHelper(int i) {
          return (int) VectorSupport.extract(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i,
                                  (vec, ix) -> {
                                      int[] vecarr = vec.vec();
@@@ -524,9 -545,10 +552,10 @@@
          }
      }
  
+     @ForceInline
      public Int64Vector withLaneHelper(int i, int e) {
          return VectorSupport.insert(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i, (long)e,
                                  (v, ix, bits) -> {
                                      int[] res = v.vec().clone();
@@@ -539,7 -561,7 +568,7 @@@
  
      static final class Int64Mask extends AbstractMask<Integer> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Integer> ETYPE = int.class; // used by the JVM
++        static final Class<Integer> CTYPE = int.class; // used by the JVM
  
          Int64Mask(boolean[] bits) {
              this(bits, 0);
@@@ -641,7 -663,7 +670,7 @@@
          /*package-private*/
          Int64Mask indexPartiallyInUpperRange(long offset, long limit) {
              return (Int64Mask) VectorSupport.indexPartiallyInUpperRange(
-                 Int64Mask.class, ETYPE, VLENGTH, offset, limit,
 -                Int64Mask.class, int.class, VLENGTH, offset, limit,
++                Int64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                  (o, l) -> (Int64Mask) TRUE_MASK.indexPartiallyInRange(o, l));
          }
  
@@@ -657,8 -679,8 +686,9 @@@
          @ForceInline
          public Int64Mask compress() {
              return (Int64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
--                Int64Vector.class, Int64Mask.class, ETYPE, VLENGTH, null, this,
--                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
++                Int64Vector.class, Int64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                m1.trueCount()));
          }
  
  
@@@ -669,7 -691,7 +699,7 @@@
          public Int64Mask and(VectorMask<Integer> mask) {
              Objects.requireNonNull(mask);
              Int64Mask m = (Int64Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_AND, Int64Mask.class, null, int.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, Int64Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
          }
@@@ -679,7 -701,7 +709,7 @@@
          public Int64Mask or(VectorMask<Integer> mask) {
              Objects.requireNonNull(mask);
              Int64Mask m = (Int64Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_OR, Int64Mask.class, null, int.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, Int64Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
          }
@@@ -689,7 -711,7 +719,7 @@@
          public Int64Mask xor(VectorMask<Integer> mask) {
              Objects.requireNonNull(mask);
              Int64Mask m = (Int64Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int64Mask.class, null, int.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int64Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
          }
@@@ -699,22 -721,22 +729,25 @@@
          @Override
          @ForceInline
          public int trueCount() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int64Mask.class, int.class, VLENGTH, this,
--                                                      (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int64Mask.class, int.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int firstTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int64Mask.class, int.class, VLENGTH, this,
--                                                      (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int64Mask.class, int.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int lastTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int64Mask.class, int.class, VLENGTH, this,
--                                                      (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int64Mask.class, int.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
          }
  
          @Override
@@@ -723,32 -745,42 +756,43 @@@
              if (length() > Long.SIZE) {
                  throw new UnsupportedOperationException("too many lanes for one long");
              }
--            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Int64Mask.class, int.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Int64Mask.class, int.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
                                                        (m) -> toLongHelper(m.getBits()));
          }
  
+         // laneIsSet
+ 
+         @Override
+         @ForceInline
+         public boolean laneIsSet(int i) {
+             Objects.checkIndex(i, length());
 -            return VectorSupport.extract(Int64Mask.class, int.class, VLENGTH,
++            return VectorSupport.extract(Int64Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
+         }
+ 
          // Reductions
  
          @Override
          @ForceInline
          public boolean anyTrue() {
--            return VectorSupport.test(BT_ne, Int64Mask.class, int.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> anyTrueHelper(((Int64Mask)m).getBits()));
++            return VectorSupport.test(BT_ne, Int64Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper(((Int64Mask)m).getBits()));
          }
  
          @Override
          @ForceInline
          public boolean allTrue() {
--            return VectorSupport.test(BT_overflow, Int64Mask.class, int.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> allTrueHelper(((Int64Mask)m).getBits()));
++            return VectorSupport.test(BT_overflow, Int64Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper(((Int64Mask)m).getBits()));
          }
  
          @ForceInline
          /*package-private*/
          static Int64Mask maskAll(boolean bit) {
--            return VectorSupport.fromBitsCoerced(Int64Mask.class, int.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced(Int64Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                                   (bit ? -1 : 0), MODE_BROADCAST, null,
                                                   (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
          }
@@@ -761,7 -793,7 +805,7 @@@
  
      static final class Int64Shuffle extends AbstractShuffle<Integer> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Integer> ETYPE = int.class; // used by the JVM
++        static final Class<Integer> CTYPE = int.class; // used by the JVM
  
          Int64Shuffle(int[] indices) {
              super(indices);
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/IntMaxVector.java
index 5754b16c41b,0a1cd45eb93..6cb2387f082
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/IntMaxVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/IntMaxVector.java
@@@ -52,7 -54,7 +54,11 @@@ final class IntMaxVector extends IntVec
  
      static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
  
--    static final Class<Integer> ETYPE = int.class; // used by the JVM
++    static final Class<Integer> CTYPE = int.class; // carrier type used by the JVM
++
++    static final Class<Integer> ETYPE = int.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
  
      IntMaxVector(int[] v) {
          super(v);
@@@ -86,9 -88,9 +92,12 @@@
          return VSPECIES;
      }
  
++    @ForceInline
++    final Class<Integer> carrierType() { return CTYPE; }
++
      @ForceInline
      @Override
--    public final Class<Integer> elementType() { return int.class; }
++    public final Class<Integer> elementType() { return ETYPE; }
  
      @ForceInline
      @Override
@@@ -503,9 -523,10 +530,10 @@@
          return laneHelper(i);
      }
  
+     @ForceInline
      public int laneHelper(int i) {
          return (int) VectorSupport.extract(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i,
                                  (vec, ix) -> {
                                      int[] vecarr = vec.vec();
@@@ -522,9 -543,10 +550,10 @@@
          return withLaneHelper(i, e);
      }
  
+     @ForceInline
      public IntMaxVector withLaneHelper(int i, int e) {
          return VectorSupport.insert(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i, (long)e,
                                  (v, ix, bits) -> {
                                      int[] res = v.vec().clone();
@@@ -537,7 -559,7 +566,7 @@@
  
      static final class IntMaxMask extends AbstractMask<Integer> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Integer> ETYPE = int.class; // used by the JVM
++        static final Class<Integer> CTYPE = int.class; // used by the JVM
  
          IntMaxMask(boolean[] bits) {
              this(bits, 0);
@@@ -639,7 -661,7 +668,7 @@@
          /*package-private*/
          IntMaxMask indexPartiallyInUpperRange(long offset, long limit) {
              return (IntMaxMask) VectorSupport.indexPartiallyInUpperRange(
-                 IntMaxMask.class, ETYPE, VLENGTH, offset, limit,
 -                IntMaxMask.class, int.class, VLENGTH, offset, limit,
++                IntMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                  (o, l) -> (IntMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));
          }
  
@@@ -655,8 -677,8 +684,9 @@@
          @ForceInline
          public IntMaxMask compress() {
              return (IntMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
--                IntMaxVector.class, IntMaxMask.class, ETYPE, VLENGTH, null, this,
--                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
++                IntMaxVector.class, IntMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                m1.trueCount()));
          }
  
  
@@@ -667,7 -689,7 +697,7 @@@
          public IntMaxMask and(VectorMask<Integer> mask) {
              Objects.requireNonNull(mask);
              IntMaxMask m = (IntMaxMask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_AND, IntMaxMask.class, null, int.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, IntMaxMask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
          }
@@@ -677,7 -699,7 +707,7 @@@
          public IntMaxMask or(VectorMask<Integer> mask) {
              Objects.requireNonNull(mask);
              IntMaxMask m = (IntMaxMask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_OR, IntMaxMask.class, null, int.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, IntMaxMask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
          }
@@@ -687,7 -709,7 +717,7 @@@
          public IntMaxMask xor(VectorMask<Integer> mask) {
              Objects.requireNonNull(mask);
              IntMaxMask m = (IntMaxMask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_XOR, IntMaxMask.class, null, int.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, IntMaxMask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
          }
@@@ -697,22 -719,22 +727,25 @@@
          @Override
          @ForceInline
          public int trueCount() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, IntMaxMask.class, int.class, VLENGTH, this,
--                                                      (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, IntMaxMask.class, int.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int firstTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, IntMaxMask.class, int.class, VLENGTH, this,
--                                                      (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, IntMaxMask.class, int.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int lastTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, IntMaxMask.class, int.class, VLENGTH, this,
--                                                      (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, IntMaxMask.class, int.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
          }
  
          @Override
@@@ -721,32 -743,42 +754,43 @@@
              if (length() > Long.SIZE) {
                  throw new UnsupportedOperationException("too many lanes for one long");
              }
--            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, IntMaxMask.class, int.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, IntMaxMask.class, int.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
                                                        (m) -> toLongHelper(m.getBits()));
          }
  
+         // laneIsSet
+ 
+         @Override
+         @ForceInline
+         public boolean laneIsSet(int i) {
+             Objects.checkIndex(i, length());
 -            return VectorSupport.extract(IntMaxMask.class, int.class, VLENGTH,
++            return VectorSupport.extract(IntMaxMask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
+         }
+ 
          // Reductions
  
          @Override
          @ForceInline
          public boolean anyTrue() {
--            return VectorSupport.test(BT_ne, IntMaxMask.class, int.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> anyTrueHelper(((IntMaxMask)m).getBits()));
++            return VectorSupport.test(BT_ne, IntMaxMask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper(((IntMaxMask)m).getBits()));
          }
  
          @Override
          @ForceInline
          public boolean allTrue() {
--            return VectorSupport.test(BT_overflow, IntMaxMask.class, int.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> allTrueHelper(((IntMaxMask)m).getBits()));
++            return VectorSupport.test(BT_overflow, IntMaxMask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper(((IntMaxMask)m).getBits()));
          }
  
          @ForceInline
          /*package-private*/
          static IntMaxMask maskAll(boolean bit) {
--            return VectorSupport.fromBitsCoerced(IntMaxMask.class, int.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced(IntMaxMask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                                   (bit ? -1 : 0), MODE_BROADCAST, null,
                                                   (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
          }
@@@ -770,7 -802,7 +814,7 @@@
  
      static final class IntMaxShuffle extends AbstractShuffle<Integer> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Integer> ETYPE = int.class; // used by the JVM
++        static final Class<Integer> CTYPE = int.class; // used by the JVM
  
          IntMaxShuffle(int[] indices) {
              super(indices);
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/IntVector.java
index a6faa907387,43356b9ea6c..f16608e5f41
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/IntVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/IntVector.java
@@@ -57,7 -57,7 +57,9 @@@ public abstract class IntVector extend
  
      static final int FORBID_OPCODE_KIND = VO_ONLYFP;
  
-     static final ValueLayout.OfInt ELEMENT_LAYOUT = ValueLayout.JAVA_INT.withBitAlignment(8);
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
++
+     static final ValueLayout.OfInt ELEMENT_LAYOUT = ValueLayout.JAVA_INT.withByteAlignment(1);
  
      @ForceInline
      static int opCode(Operator op) {
@@@ -560,7 -573,7 +575,7 @@@
      @ForceInline
      public static IntVector zero(VectorSpecies<Integer> species) {
          IntSpecies vsp = (IntSpecies) species;
--        return VectorSupport.fromBitsCoerced(vsp.vectorType(), int.class, species.length(),
++        return VectorSupport.fromBitsCoerced(vsp.vectorType(), int.class, int.class, VECTOR_OPER_TYPE, species.length(),
                                  0, MODE_BROADCAST, vsp,
                                  ((bits_, s_) -> s_.rvOp(i -> bits_)));
      }
@@@ -682,7 -695,7 +697,7 @@@
          }
          int opc = opCode(op);
          return VectorSupport.unaryOp(
--            opc, getClass(), null, int.class, length(),
++            opc, getClass(), null, int.class, int.class, VECTOR_OPER_TYPE, length(),
              this, null,
              UN_IMPL.find(op, opc, IntVector::unaryOperations));
      }
@@@ -710,7 -723,7 +725,7 @@@
          }
          int opc = opCode(op);
          return VectorSupport.unaryOp(
--            opc, getClass(), maskClass, int.class, length(),
++            opc, getClass(), maskClass, int.class, int.class, VECTOR_OPER_TYPE, length(),
              this, m,
              UN_IMPL.find(op, opc, IntVector::unaryOperations));
      }
@@@ -782,7 -796,7 +798,7 @@@
  
          int opc = opCode(op);
          return VectorSupport.binaryOp(
--            opc, getClass(), null, int.class, length(),
++            opc, getClass(), null, int.class, int.class, VECTOR_OPER_TYPE, length(),
              this, that, null,
              BIN_IMPL.find(op, opc, IntVector::binaryOperations));
      }
@@@ -832,7 -847,7 +849,7 @@@
  
          int opc = opCode(op);
          return VectorSupport.binaryOp(
--            opc, getClass(), maskClass, int.class, length(),
++            opc, getClass(), maskClass, int.class, int.class, VECTOR_OPER_TYPE, length(),
              this, that, m,
              BIN_IMPL.find(op, opc, IntVector::binaryOperations));
      }
@@@ -1010,7 -1038,7 +1040,7 @@@
          e &= SHIFT_MASK;
          int opc = opCode(op);
          return VectorSupport.broadcastInt(
--            opc, getClass(), null, int.class, length(),
++            opc, getClass(), null, int.class, int.class, VECTOR_OPER_TYPE, length(),
              this, e, null,
              BIN_INT_IMPL.find(op, opc, IntVector::broadcastIntOperations));
      }
@@@ -1031,7 -1059,7 +1061,7 @@@
          e &= SHIFT_MASK;
          int opc = opCode(op);
          return VectorSupport.broadcastInt(
--            opc, getClass(), maskClass, int.class, length(),
++            opc, getClass(), maskClass, int.class, int.class, VECTOR_OPER_TYPE, length(),
              this, e, m,
              BIN_INT_IMPL.find(op, opc, IntVector::broadcastIntOperations));
      }
@@@ -1107,7 -1135,7 +1137,7 @@@
          }
          int opc = opCode(op);
          return VectorSupport.ternaryOp(
--            opc, getClass(), null, int.class, length(),
++            opc, getClass(), null, int.class, int.class, VECTOR_OPER_TYPE, length(),
              this, that, tother, null,
              TERN_IMPL.find(op, opc, IntVector::ternaryOperations));
      }
@@@ -1147,7 -1175,7 +1177,7 @@@
          }
          int opc = opCode(op);
          return VectorSupport.ternaryOp(
--            opc, getClass(), maskClass, int.class, length(),
++            opc, getClass(), maskClass, int.class, int.class, VECTOR_OPER_TYPE, length(),
              this, that, tother, m,
              TERN_IMPL.find(op, opc, IntVector::ternaryOperations));
      }
@@@ -2027,7 -2055,7 +2057,7 @@@
          that.check(this);
          int opc = opCode(op);
          return VectorSupport.compare(
--            opc, getClass(), maskType, int.class, length(),
++            opc, getClass(), maskType, int.class, int.class, VECTOR_OPER_TYPE, length(),
              this, that, null,
              (cond, v0, v1, m1) -> {
                  AbstractMask<Integer> m
@@@ -2049,7 -2077,7 +2079,7 @@@
          m.check(maskType, this);
          int opc = opCode(op);
          return VectorSupport.compare(
--            opc, getClass(), maskType, int.class, length(),
++            opc, getClass(), maskType, int.class, int.class, VECTOR_OPER_TYPE, length(),
              this, that, m,
              (cond, v0, v1, m1) -> {
                  AbstractMask<Integer> cmpM
@@@ -2180,7 -2208,7 +2210,7 @@@
      blendTemplate(Class<M> maskType, IntVector v, M m) {
          v.check(this);
          return VectorSupport.blend(
--            getClass(), maskType, int.class, length(),
++            getClass(), maskType, int.class, int.class, VECTOR_OPER_TYPE, length(),
              this, v, m,
              (v0, v1, m_) -> v0.bOp(v1, m_, (i, a, b) -> b));
      }
@@@ -2197,7 -2225,7 +2227,7 @@@
          // make sure VLENGTH*scale doesn't overflow:
          vsp.checkScale(scale);
          return VectorSupport.indexVector(
--            getClass(), int.class, length(),
++            getClass(), int.class, int.class, VECTOR_OPER_TYPE, length(),
              this, scale, vsp,
              (v, scale_, s)
              -> {
@@@ -2385,12 -2415,12 +2417,12 @@@
      final
      <S extends VectorShuffle<Integer>>
      IntVector rearrangeTemplate(Class<S> shuffletype, S shuffle) {
-         shuffle.checkIndexes();
+         Objects.requireNonNull(shuffle);
          return VectorSupport.rearrangeOp(
--            getClass(), shuffletype, null, int.class, length(),
++            getClass(), shuffletype, null, int.class, int.class, VECTOR_OPER_TYPE, length(),
              this, shuffle, null,
              (v1, s_, m_) -> v1.uOp((i, a) -> {
-                 int ei = s_.laneSource(i);
+                 int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
                  return v1.lane(ei);
              }));
      }
@@@ -2411,19 -2441,14 +2443,14 @@@
                                             Class<M> masktype,
                                             S shuffle,
                                             M m) {
- 
+         Objects.requireNonNull(shuffle);
          m.check(masktype, this);
-         VectorMask<Integer> valid = shuffle.laneIsValid();
-         if (m.andNot(valid).anyTrue()) {
-             shuffle.checkIndexes();
-             throw new AssertionError();
-         }
          return VectorSupport.rearrangeOp(
--                   getClass(), shuffletype, masktype, int.class, length(),
++                   getClass(), shuffletype, masktype, int.class, int.class, VECTOR_OPER_TYPE, length(),
                     this, shuffle, m,
                     (v1, s_, m_) -> v1.uOp((i, a) -> {
-                         int ei = s_.laneSource(i);
-                         return ei < 0  || !m_.laneIsSet(i) ? 0 : v1.lane(ei);
+                         int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
+                         return !m_.laneIsSet(i) ? 0 : v1.lane(ei);
                     }));
      }
  
@@@ -2443,22 -2468,20 +2470,20 @@@
                                             S shuffle,
                                             IntVector v) {
          VectorMask<Integer> valid = shuffle.laneIsValid();
-         @SuppressWarnings("unchecked")
-         S ws = (S) shuffle.wrapIndexes();
          IntVector r0 =
              VectorSupport.rearrangeOp(
--                getClass(), shuffletype, null, int.class, length(),
-                 this, ws, null,
++                getClass(), shuffletype, null, int.class, int.class, VECTOR_OPER_TYPE, length(),
+                 this, shuffle, null,
                  (v0, s_, m_) -> v0.uOp((i, a) -> {
-                     int ei = s_.laneSource(i);
+                     int ei = Integer.remainderUnsigned(s_.laneSource(i), v0.length());
                      return v0.lane(ei);
                  }));
          IntVector r1 =
              VectorSupport.rearrangeOp(
--                getClass(), shuffletype, null, int.class, length(),
-                 v, ws, null,
++                getClass(), shuffletype, null, int.class, int.class, VECTOR_OPER_TYPE, length(),
+                 v, shuffle, null,
                  (v1, s_, m_) -> v1.uOp((i, a) -> {
-                     int ei = s_.laneSource(i);
+                     int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
                      return v1.lane(ei);
                  }));
          return r1.blend(r0, valid);
@@@ -2490,7 -2528,7 +2530,7 @@@
      IntVector compressTemplate(Class<M> masktype, M m) {
        m.check(masktype, this);
        return (IntVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,
--                                                        int.class, length(), this, m,
++                                                        int.class, int.class, VECTOR_OPER_TYPE, length(), this, m,
                                                          (v1, m1) -> compressHelper(v1, m1));
      }
  
@@@ -2509,7 -2547,7 +2549,7 @@@
      IntVector expandTemplate(Class<M> masktype, M m) {
        m.check(masktype, this);
        return (IntVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,
--                                                        int.class, length(), this, m,
++                                                        int.class, int.class, VECTOR_OPER_TYPE, length(), this, m,
                                                          (v1, m1) -> expandHelper(v1, m1));
      }
  
@@@ -2524,7 -2562,10 +2564,10 @@@
      /*package-private*/
      @ForceInline
      final IntVector selectFromTemplate(IntVector v) {
-         return v.rearrange(this.toShuffle());
 -        return (IntVector)VectorSupport.selectFromOp(getClass(), null, int.class,
++        return (IntVector)VectorSupport.selectFromOp(getClass(), null, int.class, int.class, VECTOR_OPER_TYPE,
+                                                         length(), this, v, null,
+                                                         (v1, v2, _m) ->
+                                                          v2.rearrange(v1.toShuffle()));
      }
  
      /**
@@@ -2536,9 -2577,31 +2579,31 @@@
  
      /*package-private*/
      @ForceInline
-     final IntVector selectFromTemplate(IntVector v,
-                                                   AbstractMask<Integer> m) {
-         return v.rearrange(this.toShuffle(), m);
+     final
+     <M extends VectorMask<Integer>>
+     IntVector selectFromTemplate(IntVector v,
+                                             Class<M> masktype, M m) {
+         m.check(masktype, this);
 -        return (IntVector)VectorSupport.selectFromOp(getClass(), masktype, int.class,
++        return (IntVector)VectorSupport.selectFromOp(getClass(), masktype, int.class, int.class, VECTOR_OPER_TYPE,
+                                                         length(), this, v, m,
+                                                         (v1, v2, _m) ->
+                                                          v2.rearrange(v1.toShuffle(), _m));
+     }
+ 
+ 
+     /**
+      * {@inheritDoc} <!--workaround-->
+      */
+     @Override
+     public abstract
+     IntVector selectFrom(Vector<Integer> v1, Vector<Integer> v2);
+ 
+ 
+     /*package-private*/
+     @ForceInline
+     final IntVector selectFromTemplate(IntVector v1, IntVector v2) {
 -        return VectorSupport.selectFromTwoVectorOp(getClass(), int.class, length(), this, v1, v2,
++        return VectorSupport.selectFromTwoVectorOp(getClass(), int.class, int.class, VECTOR_OPER_TYPE, length(), this, v1, v2,
+                                                    (vec1, vec2, vec3) -> selectFromTwoVectorHelper(vec1, vec2, vec3));
      }
  
      /// Ternary operations
@@@ -2757,7 -2820,7 +2822,7 @@@
          }
          int opc = opCode(op);
          return fromBits(VectorSupport.reductionCoerced(
--            opc, getClass(), maskClass, int.class, length(),
++            opc, getClass(), maskClass, int.class, int.class, VECTOR_OPER_TYPE, length(),
              this, m,
              REDUCE_IMPL.find(op, opc, IntVector::reductionOperations)));
      }
@@@ -2775,7 -2838,7 +2840,7 @@@
          }
          int opc = opCode(op);
          return fromBits(VectorSupport.reductionCoerced(
--            opc, getClass(), null, int.class, length(),
++            opc, getClass(), null, int.class, int.class, VECTOR_OPER_TYPE, length(),
              this, null,
              REDUCE_IMPL.find(op, opc, IntVector::reductionOperations)));
      }
@@@ -3028,9 -3098,9 +3100,9 @@@
          vix = VectorIntrinsics.checkIndex(vix, a.length);
  
          return VectorSupport.loadWithMap(
--            vectorType, null, int.class, vsp.laneCount(),
-             isp.vectorType(),
-             a, ARRAY_BASE, vix, null,
++            vectorType, null, int.class, int.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+             isp.vectorType(), isp.length(),
+             a, ARRAY_BASE, vix, null, null, null, null,
              a, offset, indexMap, mapOffset, vsp,
              (c, idx, iMap, idy, s, vm) ->
              s.vOp(n -> c[idx + iMap[idy+n]]));
@@@ -3214,8 -3281,8 +3283,8 @@@
          offset = checkFromIndexSize(offset, length(), a.length);
          IntSpecies vsp = vspecies();
          VectorSupport.store(
--            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset),
++            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, arrayAddress(a, offset), false,
              this,
              a, offset,
              (arr, off, v)
@@@ -3302,8 -3370,8 +3372,8 @@@
          vix = VectorIntrinsics.checkIndex(vix, a.length);
  
          VectorSupport.storeWithMap(
--            vsp.vectorType(), null, vsp.elementType(), vsp.laneCount(),
-             isp.vectorType(),
++            vsp.vectorType(), null, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             isp.vectorType(), isp.length(),
              a, arrayAddress(a, 0), vix,
              this, null,
              a, offset, indexMap, mapOffset,
@@@ -3428,8 -3497,8 +3499,8 @@@
      IntVector fromArray0Template(int[] a, int offset) {
          IntSpecies vsp = vspecies();
          return VectorSupport.load(
--            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset),
++            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, arrayAddress(a, offset), false,
              a, offset, vsp,
              (arr, off, s) -> s.ldOp(arr, (int) off,
                                      (arr_, off_, i) -> arr_[off_ + i]));
@@@ -3445,8 -3514,8 +3516,8 @@@
          m.check(species());
          IntSpecies vsp = vspecies();
          return VectorSupport.loadMasked(
--            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset), m, offsetInRange,
++            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, arrayAddress(a, offset), false, m, offsetInRange,
              a, offset, vsp,
              (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,
                                          (arr_, off_, i) -> arr_[off_ + i]));
@@@ -3478,9 -3547,9 +3549,9 @@@
          vix = VectorIntrinsics.checkIndex(vix, a.length);
  
          return VectorSupport.loadWithMap(
--            vectorType, maskClass, int.class, vsp.laneCount(),
-             isp.vectorType(),
-             a, ARRAY_BASE, vix, m,
++            vectorType, maskClass, int.class, int.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+             isp.vectorType(), isp.length(),
+             a, ARRAY_BASE, vix, null, null, null, m,
              a, offset, indexMap, mapOffset, vsp,
              (c, idx, iMap, idy, s, vm) ->
              s.vOp(vm, n -> c[idx + iMap[idy+n]]));
@@@ -3495,7 -3564,7 +3566,7 @@@
      IntVector fromMemorySegment0Template(MemorySegment ms, long offset) {
          IntSpecies vsp = vspecies();
          return ScopedMemoryAccess.loadFromMemorySegment(
--                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
++                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                  (AbstractMemorySegmentImpl) ms, offset, vsp,
                  (msp, off, s) -> {
                      return s.ldLongOp((MemorySegment) msp, off, IntVector::memorySegmentGet);
@@@ -3511,7 -3580,7 +3582,7 @@@
          IntSpecies vsp = vspecies();
          m.check(vsp);
          return ScopedMemoryAccess.loadFromMemorySegmentMasked(
--                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
++                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                  (AbstractMemorySegmentImpl) ms, offset, m, vsp, offsetInRange,
                  (msp, off, s, vm) -> {
                      return s.ldLongOp((MemorySegment) msp, off, vm, IntVector::memorySegmentGet);
@@@ -3529,8 -3598,8 +3600,8 @@@
      void intoArray0Template(int[] a, int offset) {
          IntSpecies vsp = vspecies();
          VectorSupport.store(
--            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset),
++            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, arrayAddress(a, offset), false,
              this, a, offset,
              (arr, off, v)
              -> v.stOp(arr, (int) off,
@@@ -3546,8 -3615,8 +3617,8 @@@
          m.check(species());
          IntSpecies vsp = vspecies();
          VectorSupport.storeMasked(
--            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset),
++            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, arrayAddress(a, offset), false,
              this, m, a, offset,
              (arr, off, v, vm)
              -> v.stOp(arr, (int) off, vm,
@@@ -3575,8 -3644,8 +3646,8 @@@
          vix = VectorIntrinsics.checkIndex(vix, a.length);
  
          VectorSupport.storeWithMap(
--            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
-             isp.vectorType(),
++            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             isp.vectorType(), isp.length(),
              a, arrayAddress(a, 0), vix,
              this, m,
              a, offset, indexMap, mapOffset,
@@@ -3594,7 -3663,7 +3665,7 @@@
      void intoMemorySegment0(MemorySegment ms, long offset) {
          IntSpecies vsp = vspecies();
          ScopedMemoryAccess.storeIntoMemorySegment(
--                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
++                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                  this,
                  (AbstractMemorySegmentImpl) ms, offset,
                  (msp, off, v) -> {
@@@ -3611,7 -3680,7 +3682,7 @@@
          IntSpecies vsp = vspecies();
          m.check(vsp);
          ScopedMemoryAccess.storeIntoMemorySegmentMasked(
--                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
++                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                  this, m,
                  (AbstractMemorySegmentImpl) ms, offset,
                  (msp, off, v, vm) -> {
@@@ -3803,6 -3852,6 +3854,19 @@@
  
          // Specializing overrides:
  
++        @ForceInline
++        final Class<?> carrierType() {
++            return int.class;
++        }
++
++        @ForceInline
++        final int operType() {
++            if (int.class.equals(Float16.class)) {
++                return VECTOR_TYPE_FP16;
++            }
++            return VECTOR_TYPE_PRIM;
++        }
++
          @Override
          @ForceInline
          public final Class<Integer> elementType() {
@@@ -3835,7 -3884,7 +3899,7 @@@
          final IntVector broadcastBits(long bits) {
              return (IntVector)
                  VectorSupport.fromBitsCoerced(
--                    vectorType, int.class, laneCount,
++                    vectorType, int.class, int.class, VECTOR_OPER_TYPE, laneCount,
                      bits, MODE_BROADCAST, this,
                      (bits_, s_) -> s_.rvOp(i -> bits_));
          }
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/LaneType.java
index 1d141d344c8,53fa773555f..752f734d923
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/LaneType.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/LaneType.java
@@@ -40,8 -40,7 +40,8 @@@ enum LaneType 
      BYTE(byte.class, Byte.class, byte[].class, 'I', -1, Byte.SIZE, T_BYTE),
      SHORT(short.class, Short.class, short[].class, 'I', -1, Short.SIZE, T_SHORT),
      INT(int.class, Integer.class, int[].class, 'I', -1, Integer.SIZE, T_INT),
 -    LONG(long.class, Long.class, long[].class, 'I', -1, Long.SIZE, T_LONG);
 +    LONG(long.class, Long.class, long[].class, 'I', -1, Long.SIZE, T_LONG),
-     HALFFLOAT(Halffloat.class, Short.class, short[].class, 'F', 11, Halffloat.SIZE, T_HALFFLOAT);
++    HALFFLOAT(Float16.class, Short.class, short[].class, 'F', 11, Float16.SIZE, T_HALFFLOAT);
  
      LaneType(Class<?> elementType,
               Class<?> genericElementType,
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long128Vector.java
index 4e4a10d042b,5a47153837a..549d06d40c4
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long128Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long128Vector.java
@@@ -52,7 -54,7 +54,11 @@@ final class Long128Vector extends LongV
  
      static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
  
--    static final Class<Long> ETYPE = long.class; // used by the JVM
++    static final Class<Long> CTYPE = long.class; // carrier type used by the JVM
++
++    static final Class<Long> ETYPE = long.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
  
      Long128Vector(long[] v) {
          super(v);
@@@ -86,9 -88,9 +92,12 @@@
          return VSPECIES;
      }
  
++    @ForceInline
++    final Class<Long> carrierType() { return CTYPE; }
++
      @ForceInline
      @Override
--    public final Class<Long> elementType() { return long.class; }
++    public final Class<Long> elementType() { return ETYPE; }
  
      @ForceInline
      @Override
@@@ -494,9 -514,10 +521,10 @@@
          }
      }
  
+     @ForceInline
      public long laneHelper(int i) {
          return (long) VectorSupport.extract(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i,
                                  (vec, ix) -> {
                                      long[] vecarr = vec.vec();
@@@ -514,9 -535,10 +542,10 @@@
          }
      }
  
+     @ForceInline
      public Long128Vector withLaneHelper(int i, long e) {
          return VectorSupport.insert(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i, (long)e,
                                  (v, ix, bits) -> {
                                      long[] res = v.vec().clone();
@@@ -529,7 -551,7 +558,7 @@@
  
      static final class Long128Mask extends AbstractMask<Long> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Long> ETYPE = long.class; // used by the JVM
++        static final Class<Long> CTYPE = long.class; // used by the JVM
  
          Long128Mask(boolean[] bits) {
              this(bits, 0);
@@@ -631,7 -653,7 +660,7 @@@
          /*package-private*/
          Long128Mask indexPartiallyInUpperRange(long offset, long limit) {
              return (Long128Mask) VectorSupport.indexPartiallyInUpperRange(
-                 Long128Mask.class, ETYPE, VLENGTH, offset, limit,
 -                Long128Mask.class, long.class, VLENGTH, offset, limit,
++                Long128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                  (o, l) -> (Long128Mask) TRUE_MASK.indexPartiallyInRange(o, l));
          }
  
@@@ -647,8 -669,8 +676,9 @@@
          @ForceInline
          public Long128Mask compress() {
              return (Long128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
--                Long128Vector.class, Long128Mask.class, ETYPE, VLENGTH, null, this,
--                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
++                Long128Vector.class, Long128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                m1.trueCount()));
          }
  
  
@@@ -659,7 -681,7 +689,7 @@@
          public Long128Mask and(VectorMask<Long> mask) {
              Objects.requireNonNull(mask);
              Long128Mask m = (Long128Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_AND, Long128Mask.class, null, long.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, Long128Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
          }
@@@ -669,7 -691,7 +699,7 @@@
          public Long128Mask or(VectorMask<Long> mask) {
              Objects.requireNonNull(mask);
              Long128Mask m = (Long128Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_OR, Long128Mask.class, null, long.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, Long128Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
          }
@@@ -679,7 -701,7 +709,7 @@@
          public Long128Mask xor(VectorMask<Long> mask) {
              Objects.requireNonNull(mask);
              Long128Mask m = (Long128Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long128Mask.class, null, long.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long128Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
          }
@@@ -689,22 -711,22 +719,25 @@@
          @Override
          @ForceInline
          public int trueCount() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long128Mask.class, long.class, VLENGTH, this,
--                                                      (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long128Mask.class, long.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int firstTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long128Mask.class, long.class, VLENGTH, this,
--                                                      (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long128Mask.class, long.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int lastTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long128Mask.class, long.class, VLENGTH, this,
--                                                      (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long128Mask.class, long.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
          }
  
          @Override
@@@ -713,32 -735,42 +746,43 @@@
              if (length() > Long.SIZE) {
                  throw new UnsupportedOperationException("too many lanes for one long");
              }
--            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Long128Mask.class, long.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Long128Mask.class, long.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
                                                        (m) -> toLongHelper(m.getBits()));
          }
  
+         // laneIsSet
+ 
+         @Override
+         @ForceInline
+         public boolean laneIsSet(int i) {
+             Objects.checkIndex(i, length());
 -            return VectorSupport.extract(Long128Mask.class, long.class, VLENGTH,
++            return VectorSupport.extract(Long128Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
+         }
+ 
          // Reductions
  
          @Override
          @ForceInline
          public boolean anyTrue() {
--            return VectorSupport.test(BT_ne, Long128Mask.class, long.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> anyTrueHelper(((Long128Mask)m).getBits()));
++            return VectorSupport.test(BT_ne, Long128Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper(((Long128Mask)m).getBits()));
          }
  
          @Override
          @ForceInline
          public boolean allTrue() {
--            return VectorSupport.test(BT_overflow, Long128Mask.class, long.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> allTrueHelper(((Long128Mask)m).getBits()));
++            return VectorSupport.test(BT_overflow, Long128Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper(((Long128Mask)m).getBits()));
          }
  
          @ForceInline
          /*package-private*/
          static Long128Mask maskAll(boolean bit) {
--            return VectorSupport.fromBitsCoerced(Long128Mask.class, long.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced(Long128Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                                   (bit ? -1 : 0), MODE_BROADCAST, null,
                                                   (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
          }
@@@ -751,7 -783,7 +795,7 @@@
  
      static final class Long128Shuffle extends AbstractShuffle<Long> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Long> ETYPE = long.class; // used by the JVM
++        static final Class<Long> CTYPE = long.class; // used by the JVM
  
          Long128Shuffle(long[] indices) {
              super(indices);
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long256Vector.java
index 644566cb523,9c3ff7627cc..c71b65396d0
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long256Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long256Vector.java
@@@ -52,7 -54,7 +54,11 @@@ final class Long256Vector extends LongV
  
      static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
  
--    static final Class<Long> ETYPE = long.class; // used by the JVM
++    static final Class<Long> CTYPE = long.class; // carrier type used by the JVM
++
++    static final Class<Long> ETYPE = long.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
  
      Long256Vector(long[] v) {
          super(v);
@@@ -86,9 -88,9 +92,12 @@@
          return VSPECIES;
      }
  
++    @ForceInline
++    final Class<Long> carrierType() { return CTYPE; }
++
      @ForceInline
      @Override
--    public final Class<Long> elementType() { return long.class; }
++    public final Class<Long> elementType() { return ETYPE; }
  
      @ForceInline
      @Override
@@@ -496,9 -516,10 +523,10 @@@
          }
      }
  
+     @ForceInline
      public long laneHelper(int i) {
          return (long) VectorSupport.extract(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i,
                                  (vec, ix) -> {
                                      long[] vecarr = vec.vec();
@@@ -518,9 -539,10 +546,10 @@@
          }
      }
  
+     @ForceInline
      public Long256Vector withLaneHelper(int i, long e) {
          return VectorSupport.insert(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i, (long)e,
                                  (v, ix, bits) -> {
                                      long[] res = v.vec().clone();
@@@ -533,7 -555,7 +562,7 @@@
  
      static final class Long256Mask extends AbstractMask<Long> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Long> ETYPE = long.class; // used by the JVM
++        static final Class<Long> CTYPE = long.class; // used by the JVM
  
          Long256Mask(boolean[] bits) {
              this(bits, 0);
@@@ -635,7 -657,7 +664,7 @@@
          /*package-private*/
          Long256Mask indexPartiallyInUpperRange(long offset, long limit) {
              return (Long256Mask) VectorSupport.indexPartiallyInUpperRange(
-                 Long256Mask.class, ETYPE, VLENGTH, offset, limit,
 -                Long256Mask.class, long.class, VLENGTH, offset, limit,
++                Long256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                  (o, l) -> (Long256Mask) TRUE_MASK.indexPartiallyInRange(o, l));
          }
  
@@@ -651,8 -673,8 +680,9 @@@
          @ForceInline
          public Long256Mask compress() {
              return (Long256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
--                Long256Vector.class, Long256Mask.class, ETYPE, VLENGTH, null, this,
--                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
++                Long256Vector.class, Long256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                m1.trueCount()));
          }
  
  
@@@ -663,7 -685,7 +693,7 @@@
          public Long256Mask and(VectorMask<Long> mask) {
              Objects.requireNonNull(mask);
              Long256Mask m = (Long256Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_AND, Long256Mask.class, null, long.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, Long256Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
          }
@@@ -673,7 -695,7 +703,7 @@@
          public Long256Mask or(VectorMask<Long> mask) {
              Objects.requireNonNull(mask);
              Long256Mask m = (Long256Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_OR, Long256Mask.class, null, long.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, Long256Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
          }
@@@ -683,7 -705,7 +713,7 @@@
          public Long256Mask xor(VectorMask<Long> mask) {
              Objects.requireNonNull(mask);
              Long256Mask m = (Long256Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long256Mask.class, null, long.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long256Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
          }
@@@ -693,22 -715,22 +723,25 @@@
          @Override
          @ForceInline
          public int trueCount() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long256Mask.class, long.class, VLENGTH, this,
--                                                      (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long256Mask.class, long.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int firstTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long256Mask.class, long.class, VLENGTH, this,
--                                                      (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long256Mask.class, long.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int lastTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long256Mask.class, long.class, VLENGTH, this,
--                                                      (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long256Mask.class, long.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
          }
  
          @Override
@@@ -717,32 -739,42 +750,43 @@@
              if (length() > Long.SIZE) {
                  throw new UnsupportedOperationException("too many lanes for one long");
              }
--            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Long256Mask.class, long.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Long256Mask.class, long.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
                                                        (m) -> toLongHelper(m.getBits()));
          }
  
+         // laneIsSet
+ 
+         @Override
+         @ForceInline
+         public boolean laneIsSet(int i) {
+             Objects.checkIndex(i, length());
 -            return VectorSupport.extract(Long256Mask.class, long.class, VLENGTH,
++            return VectorSupport.extract(Long256Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
+         }
+ 
          // Reductions
  
          @Override
          @ForceInline
          public boolean anyTrue() {
--            return VectorSupport.test(BT_ne, Long256Mask.class, long.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> anyTrueHelper(((Long256Mask)m).getBits()));
++            return VectorSupport.test(BT_ne, Long256Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper(((Long256Mask)m).getBits()));
          }
  
          @Override
          @ForceInline
          public boolean allTrue() {
--            return VectorSupport.test(BT_overflow, Long256Mask.class, long.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> allTrueHelper(((Long256Mask)m).getBits()));
++            return VectorSupport.test(BT_overflow, Long256Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper(((Long256Mask)m).getBits()));
          }
  
          @ForceInline
          /*package-private*/
          static Long256Mask maskAll(boolean bit) {
--            return VectorSupport.fromBitsCoerced(Long256Mask.class, long.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced(Long256Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                                   (bit ? -1 : 0), MODE_BROADCAST, null,
                                                   (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
          }
@@@ -755,7 -787,7 +799,7 @@@
  
      static final class Long256Shuffle extends AbstractShuffle<Long> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Long> ETYPE = long.class; // used by the JVM
++        static final Class<Long> CTYPE = long.class; // used by the JVM
  
          Long256Shuffle(long[] indices) {
              super(indices);
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long512Vector.java
index 6b317a75e13,30d29c3cd03..513e07a3ee3
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long512Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long512Vector.java
@@@ -52,7 -54,7 +54,11 @@@ final class Long512Vector extends LongV
  
      static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
  
--    static final Class<Long> ETYPE = long.class; // used by the JVM
++    static final Class<Long> CTYPE = long.class; // carrier type used by the JVM
++
++    static final Class<Long> ETYPE = long.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
  
      Long512Vector(long[] v) {
          super(v);
@@@ -86,9 -88,9 +92,12 @@@
          return VSPECIES;
      }
  
++    @ForceInline
++    final Class<Long> carrierType() { return CTYPE; }
++
      @ForceInline
      @Override
--    public final Class<Long> elementType() { return long.class; }
++    public final Class<Long> elementType() { return ETYPE; }
  
      @ForceInline
      @Override
@@@ -500,9 -520,10 +527,10 @@@
          }
      }
  
+     @ForceInline
      public long laneHelper(int i) {
          return (long) VectorSupport.extract(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i,
                                  (vec, ix) -> {
                                      long[] vecarr = vec.vec();
@@@ -526,9 -547,10 +554,10 @@@
          }
      }
  
+     @ForceInline
      public Long512Vector withLaneHelper(int i, long e) {
          return VectorSupport.insert(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i, (long)e,
                                  (v, ix, bits) -> {
                                      long[] res = v.vec().clone();
@@@ -541,7 -563,7 +570,7 @@@
  
      static final class Long512Mask extends AbstractMask<Long> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Long> ETYPE = long.class; // used by the JVM
++        static final Class<Long> CTYPE = long.class; // used by the JVM
  
          Long512Mask(boolean[] bits) {
              this(bits, 0);
@@@ -643,7 -665,7 +672,7 @@@
          /*package-private*/
          Long512Mask indexPartiallyInUpperRange(long offset, long limit) {
              return (Long512Mask) VectorSupport.indexPartiallyInUpperRange(
-                 Long512Mask.class, ETYPE, VLENGTH, offset, limit,
 -                Long512Mask.class, long.class, VLENGTH, offset, limit,
++                Long512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                  (o, l) -> (Long512Mask) TRUE_MASK.indexPartiallyInRange(o, l));
          }
  
@@@ -659,8 -681,8 +688,9 @@@
          @ForceInline
          public Long512Mask compress() {
              return (Long512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
--                Long512Vector.class, Long512Mask.class, ETYPE, VLENGTH, null, this,
--                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
++                Long512Vector.class, Long512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                m1.trueCount()));
          }
  
  
@@@ -671,7 -693,7 +701,7 @@@
          public Long512Mask and(VectorMask<Long> mask) {
              Objects.requireNonNull(mask);
              Long512Mask m = (Long512Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_AND, Long512Mask.class, null, long.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, Long512Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
          }
@@@ -681,7 -703,7 +711,7 @@@
          public Long512Mask or(VectorMask<Long> mask) {
              Objects.requireNonNull(mask);
              Long512Mask m = (Long512Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_OR, Long512Mask.class, null, long.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, Long512Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
          }
@@@ -691,7 -713,7 +721,7 @@@
          public Long512Mask xor(VectorMask<Long> mask) {
              Objects.requireNonNull(mask);
              Long512Mask m = (Long512Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long512Mask.class, null, long.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long512Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
          }
@@@ -701,22 -723,22 +731,25 @@@
          @Override
          @ForceInline
          public int trueCount() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long512Mask.class, long.class, VLENGTH, this,
--                                                      (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long512Mask.class, long.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int firstTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long512Mask.class, long.class, VLENGTH, this,
--                                                      (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long512Mask.class, long.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int lastTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long512Mask.class, long.class, VLENGTH, this,
--                                                      (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long512Mask.class, long.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
          }
  
          @Override
@@@ -725,32 -747,42 +758,43 @@@
              if (length() > Long.SIZE) {
                  throw new UnsupportedOperationException("too many lanes for one long");
              }
--            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Long512Mask.class, long.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Long512Mask.class, long.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
                                                        (m) -> toLongHelper(m.getBits()));
          }
  
+         // laneIsSet
+ 
+         @Override
+         @ForceInline
+         public boolean laneIsSet(int i) {
+             Objects.checkIndex(i, length());
 -            return VectorSupport.extract(Long512Mask.class, long.class, VLENGTH,
++            return VectorSupport.extract(Long512Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
+         }
+ 
          // Reductions
  
          @Override
          @ForceInline
          public boolean anyTrue() {
--            return VectorSupport.test(BT_ne, Long512Mask.class, long.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> anyTrueHelper(((Long512Mask)m).getBits()));
++            return VectorSupport.test(BT_ne, Long512Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper(((Long512Mask)m).getBits()));
          }
  
          @Override
          @ForceInline
          public boolean allTrue() {
--            return VectorSupport.test(BT_overflow, Long512Mask.class, long.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> allTrueHelper(((Long512Mask)m).getBits()));
++            return VectorSupport.test(BT_overflow, Long512Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper(((Long512Mask)m).getBits()));
          }
  
          @ForceInline
          /*package-private*/
          static Long512Mask maskAll(boolean bit) {
--            return VectorSupport.fromBitsCoerced(Long512Mask.class, long.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced(Long512Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                                   (bit ? -1 : 0), MODE_BROADCAST, null,
                                                   (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
          }
@@@ -763,7 -795,7 +807,7 @@@
  
      static final class Long512Shuffle extends AbstractShuffle<Long> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Long> ETYPE = long.class; // used by the JVM
++        static final Class<Long> CTYPE = long.class; // used by the JVM
  
          Long512Shuffle(long[] indices) {
              super(indices);
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long64Vector.java
index ffc15ced84b,518baa168ec..a26ec8b4002
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long64Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long64Vector.java
@@@ -52,7 -54,7 +54,11 @@@ final class Long64Vector extends LongVe
  
      static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
  
--    static final Class<Long> ETYPE = long.class; // used by the JVM
++    static final Class<Long> CTYPE = long.class; // carrier type used by the JVM
++
++    static final Class<Long> ETYPE = long.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
  
      Long64Vector(long[] v) {
          super(v);
@@@ -86,9 -88,9 +92,12 @@@
          return VSPECIES;
      }
  
++    @ForceInline
++    final Class<Long> carrierType() { return CTYPE; }
++
      @ForceInline
      @Override
--    public final Class<Long> elementType() { return long.class; }
++    public final Class<Long> elementType() { return ETYPE; }
  
      @ForceInline
      @Override
@@@ -493,9 -513,10 +520,10 @@@
          }
      }
  
+     @ForceInline
      public long laneHelper(int i) {
          return (long) VectorSupport.extract(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i,
                                  (vec, ix) -> {
                                      long[] vecarr = vec.vec();
@@@ -512,9 -533,10 +540,10 @@@
          }
      }
  
+     @ForceInline
      public Long64Vector withLaneHelper(int i, long e) {
          return VectorSupport.insert(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i, (long)e,
                                  (v, ix, bits) -> {
                                      long[] res = v.vec().clone();
@@@ -527,7 -549,7 +556,7 @@@
  
      static final class Long64Mask extends AbstractMask<Long> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Long> ETYPE = long.class; // used by the JVM
++        static final Class<Long> CTYPE = long.class; // used by the JVM
  
          Long64Mask(boolean[] bits) {
              this(bits, 0);
@@@ -629,7 -651,7 +658,7 @@@
          /*package-private*/
          Long64Mask indexPartiallyInUpperRange(long offset, long limit) {
              return (Long64Mask) VectorSupport.indexPartiallyInUpperRange(
-                 Long64Mask.class, ETYPE, VLENGTH, offset, limit,
 -                Long64Mask.class, long.class, VLENGTH, offset, limit,
++                Long64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                  (o, l) -> (Long64Mask) TRUE_MASK.indexPartiallyInRange(o, l));
          }
  
@@@ -645,8 -667,8 +674,9 @@@
          @ForceInline
          public Long64Mask compress() {
              return (Long64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
--                Long64Vector.class, Long64Mask.class, ETYPE, VLENGTH, null, this,
--                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
++                Long64Vector.class, Long64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                m1.trueCount()));
          }
  
  
@@@ -657,7 -679,7 +687,7 @@@
          public Long64Mask and(VectorMask<Long> mask) {
              Objects.requireNonNull(mask);
              Long64Mask m = (Long64Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_AND, Long64Mask.class, null, long.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, Long64Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
          }
@@@ -667,7 -689,7 +697,7 @@@
          public Long64Mask or(VectorMask<Long> mask) {
              Objects.requireNonNull(mask);
              Long64Mask m = (Long64Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_OR, Long64Mask.class, null, long.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, Long64Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
          }
@@@ -677,7 -699,7 +707,7 @@@
          public Long64Mask xor(VectorMask<Long> mask) {
              Objects.requireNonNull(mask);
              Long64Mask m = (Long64Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long64Mask.class, null, long.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long64Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
          }
@@@ -687,22 -709,22 +717,25 @@@
          @Override
          @ForceInline
          public int trueCount() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long64Mask.class, long.class, VLENGTH, this,
--                                                      (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long64Mask.class, long.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int firstTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long64Mask.class, long.class, VLENGTH, this,
--                                                      (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long64Mask.class, long.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int lastTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long64Mask.class, long.class, VLENGTH, this,
--                                                      (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long64Mask.class, long.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
          }
  
          @Override
@@@ -711,32 -733,42 +744,43 @@@
              if (length() > Long.SIZE) {
                  throw new UnsupportedOperationException("too many lanes for one long");
              }
--            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Long64Mask.class, long.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Long64Mask.class, long.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
                                                        (m) -> toLongHelper(m.getBits()));
          }
  
+         // laneIsSet
+ 
+         @Override
+         @ForceInline
+         public boolean laneIsSet(int i) {
+             Objects.checkIndex(i, length());
 -            return VectorSupport.extract(Long64Mask.class, long.class, VLENGTH,
++            return VectorSupport.extract(Long64Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
+         }
+ 
          // Reductions
  
          @Override
          @ForceInline
          public boolean anyTrue() {
--            return VectorSupport.test(BT_ne, Long64Mask.class, long.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> anyTrueHelper(((Long64Mask)m).getBits()));
++            return VectorSupport.test(BT_ne, Long64Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper(((Long64Mask)m).getBits()));
          }
  
          @Override
          @ForceInline
          public boolean allTrue() {
--            return VectorSupport.test(BT_overflow, Long64Mask.class, long.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> allTrueHelper(((Long64Mask)m).getBits()));
++            return VectorSupport.test(BT_overflow, Long64Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper(((Long64Mask)m).getBits()));
          }
  
          @ForceInline
          /*package-private*/
          static Long64Mask maskAll(boolean bit) {
--            return VectorSupport.fromBitsCoerced(Long64Mask.class, long.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced(Long64Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                                   (bit ? -1 : 0), MODE_BROADCAST, null,
                                                   (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
          }
@@@ -749,7 -781,7 +793,7 @@@
  
      static final class Long64Shuffle extends AbstractShuffle<Long> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Long> ETYPE = long.class; // used by the JVM
++        static final Class<Long> CTYPE = long.class; // used by the JVM
  
          Long64Shuffle(long[] indices) {
              super(indices);
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/LongMaxVector.java
index 81b81774be9,3d981c37ae2..ae5b5fd3b68
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/LongMaxVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/LongMaxVector.java
@@@ -52,7 -54,7 +54,11 @@@ final class LongMaxVector extends LongV
  
      static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
  
--    static final Class<Long> ETYPE = long.class; // used by the JVM
++    static final Class<Long> CTYPE = long.class; // carrier type used by the JVM
++
++    static final Class<Long> ETYPE = long.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
  
      LongMaxVector(long[] v) {
          super(v);
@@@ -86,9 -88,9 +92,12 @@@
          return VSPECIES;
      }
  
++    @ForceInline
++    final Class<Long> carrierType() { return CTYPE; }
++
      @ForceInline
      @Override
--    public final Class<Long> elementType() { return long.class; }
++    public final Class<Long> elementType() { return ETYPE; }
  
      @ForceInline
      @Override
@@@ -493,9 -513,10 +520,10 @@@
          return laneHelper(i);
      }
  
+     @ForceInline
      public long laneHelper(int i) {
          return (long) VectorSupport.extract(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i,
                                  (vec, ix) -> {
                                      long[] vecarr = vec.vec();
@@@ -512,9 -533,10 +540,10 @@@
          return withLaneHelper(i, e);
      }
  
+     @ForceInline
      public LongMaxVector withLaneHelper(int i, long e) {
          return VectorSupport.insert(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i, (long)e,
                                  (v, ix, bits) -> {
                                      long[] res = v.vec().clone();
@@@ -527,7 -549,7 +556,7 @@@
  
      static final class LongMaxMask extends AbstractMask<Long> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Long> ETYPE = long.class; // used by the JVM
++        static final Class<Long> CTYPE = long.class; // used by the JVM
  
          LongMaxMask(boolean[] bits) {
              this(bits, 0);
@@@ -629,7 -651,7 +658,7 @@@
          /*package-private*/
          LongMaxMask indexPartiallyInUpperRange(long offset, long limit) {
              return (LongMaxMask) VectorSupport.indexPartiallyInUpperRange(
-                 LongMaxMask.class, ETYPE, VLENGTH, offset, limit,
 -                LongMaxMask.class, long.class, VLENGTH, offset, limit,
++                LongMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                  (o, l) -> (LongMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));
          }
  
@@@ -645,8 -667,8 +674,9 @@@
          @ForceInline
          public LongMaxMask compress() {
              return (LongMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
--                LongMaxVector.class, LongMaxMask.class, ETYPE, VLENGTH, null, this,
--                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
++                LongMaxVector.class, LongMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                m1.trueCount()));
          }
  
  
@@@ -657,7 -679,7 +687,7 @@@
          public LongMaxMask and(VectorMask<Long> mask) {
              Objects.requireNonNull(mask);
              LongMaxMask m = (LongMaxMask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_AND, LongMaxMask.class, null, long.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, LongMaxMask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
          }
@@@ -667,7 -689,7 +697,7 @@@
          public LongMaxMask or(VectorMask<Long> mask) {
              Objects.requireNonNull(mask);
              LongMaxMask m = (LongMaxMask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_OR, LongMaxMask.class, null, long.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, LongMaxMask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
          }
@@@ -677,7 -699,7 +707,7 @@@
          public LongMaxMask xor(VectorMask<Long> mask) {
              Objects.requireNonNull(mask);
              LongMaxMask m = (LongMaxMask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_XOR, LongMaxMask.class, null, long.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, LongMaxMask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
          }
@@@ -687,22 -709,22 +717,25 @@@
          @Override
          @ForceInline
          public int trueCount() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, LongMaxMask.class, long.class, VLENGTH, this,
--                                                      (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, LongMaxMask.class, long.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int firstTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, LongMaxMask.class, long.class, VLENGTH, this,
--                                                      (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, LongMaxMask.class, long.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int lastTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, LongMaxMask.class, long.class, VLENGTH, this,
--                                                      (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, LongMaxMask.class, long.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
          }
  
          @Override
@@@ -711,32 -733,42 +744,43 @@@
              if (length() > Long.SIZE) {
                  throw new UnsupportedOperationException("too many lanes for one long");
              }
--            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, LongMaxMask.class, long.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, LongMaxMask.class, long.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
                                                        (m) -> toLongHelper(m.getBits()));
          }
  
+         // laneIsSet
+ 
+         @Override
+         @ForceInline
+         public boolean laneIsSet(int i) {
+             Objects.checkIndex(i, length());
 -            return VectorSupport.extract(LongMaxMask.class, long.class, VLENGTH,
++            return VectorSupport.extract(LongMaxMask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
+         }
+ 
          // Reductions
  
          @Override
          @ForceInline
          public boolean anyTrue() {
--            return VectorSupport.test(BT_ne, LongMaxMask.class, long.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> anyTrueHelper(((LongMaxMask)m).getBits()));
++            return VectorSupport.test(BT_ne, LongMaxMask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper(((LongMaxMask)m).getBits()));
          }
  
          @Override
          @ForceInline
          public boolean allTrue() {
--            return VectorSupport.test(BT_overflow, LongMaxMask.class, long.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> allTrueHelper(((LongMaxMask)m).getBits()));
++            return VectorSupport.test(BT_overflow, LongMaxMask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper(((LongMaxMask)m).getBits()));
          }
  
          @ForceInline
          /*package-private*/
          static LongMaxMask maskAll(boolean bit) {
--            return VectorSupport.fromBitsCoerced(LongMaxMask.class, long.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced(LongMaxMask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                                   (bit ? -1 : 0), MODE_BROADCAST, null,
                                                   (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
          }
@@@ -749,7 -781,7 +793,7 @@@
  
      static final class LongMaxShuffle extends AbstractShuffle<Long> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Long> ETYPE = long.class; // used by the JVM
++        static final Class<Long> CTYPE = long.class; // used by the JVM
  
          LongMaxShuffle(long[] indices) {
              super(indices);
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/LongVector.java
index bbaa8fdb799,8947343ff30..cc394f24a76
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/LongVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/LongVector.java
@@@ -57,7 -57,7 +57,9 @@@ public abstract class LongVector extend
  
      static final int FORBID_OPCODE_KIND = VO_ONLYFP;
  
-     static final ValueLayout.OfLong ELEMENT_LAYOUT = ValueLayout.JAVA_LONG.withBitAlignment(8);
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
++
+     static final ValueLayout.OfLong ELEMENT_LAYOUT = ValueLayout.JAVA_LONG.withByteAlignment(1);
  
      @ForceInline
      static int opCode(Operator op) {
@@@ -560,7 -573,7 +575,7 @@@
      @ForceInline
      public static LongVector zero(VectorSpecies<Long> species) {
          LongSpecies vsp = (LongSpecies) species;
--        return VectorSupport.fromBitsCoerced(vsp.vectorType(), long.class, species.length(),
++        return VectorSupport.fromBitsCoerced(vsp.vectorType(), long.class, long.class, VECTOR_OPER_TYPE, species.length(),
                                  0, MODE_BROADCAST, vsp,
                                  ((bits_, s_) -> s_.rvOp(i -> bits_)));
      }
@@@ -640,7 -653,7 +655,7 @@@
          }
          int opc = opCode(op);
          return VectorSupport.unaryOp(
--            opc, getClass(), null, long.class, length(),
++            opc, getClass(), null, long.class, long.class, VECTOR_OPER_TYPE, length(),
              this, null,
              UN_IMPL.find(op, opc, LongVector::unaryOperations));
      }
@@@ -668,7 -681,7 +683,7 @@@
          }
          int opc = opCode(op);
          return VectorSupport.unaryOp(
--            opc, getClass(), maskClass, long.class, length(),
++            opc, getClass(), maskClass, long.class, long.class, VECTOR_OPER_TYPE, length(),
              this, m,
              UN_IMPL.find(op, opc, LongVector::unaryOperations));
      }
@@@ -740,7 -754,7 +756,7 @@@
  
          int opc = opCode(op);
          return VectorSupport.binaryOp(
--            opc, getClass(), null, long.class, length(),
++            opc, getClass(), null, long.class, long.class, VECTOR_OPER_TYPE, length(),
              this, that, null,
              BIN_IMPL.find(op, opc, LongVector::binaryOperations));
      }
@@@ -790,7 -805,7 +807,7 @@@
  
          int opc = opCode(op);
          return VectorSupport.binaryOp(
--            opc, getClass(), maskClass, long.class, length(),
++            opc, getClass(), maskClass, long.class, long.class, VECTOR_OPER_TYPE, length(),
              this, that, m,
              BIN_IMPL.find(op, opc, LongVector::binaryOperations));
      }
@@@ -923,7 -951,7 +953,7 @@@
          e &= SHIFT_MASK;
          int opc = opCode(op);
          return VectorSupport.broadcastInt(
--            opc, getClass(), null, long.class, length(),
++            opc, getClass(), null, long.class, long.class, VECTOR_OPER_TYPE, length(),
              this, e, null,
              BIN_INT_IMPL.find(op, opc, LongVector::broadcastIntOperations));
      }
@@@ -944,7 -972,7 +974,7 @@@
          e &= SHIFT_MASK;
          int opc = opCode(op);
          return VectorSupport.broadcastInt(
--            opc, getClass(), maskClass, long.class, length(),
++            opc, getClass(), maskClass, long.class, long.class, VECTOR_OPER_TYPE, length(),
              this, e, m,
              BIN_INT_IMPL.find(op, opc, LongVector::broadcastIntOperations));
      }
@@@ -1020,7 -1048,7 +1050,7 @@@
          }
          int opc = opCode(op);
          return VectorSupport.ternaryOp(
--            opc, getClass(), null, long.class, length(),
++            opc, getClass(), null, long.class, long.class, VECTOR_OPER_TYPE, length(),
              this, that, tother, null,
              TERN_IMPL.find(op, opc, LongVector::ternaryOperations));
      }
@@@ -1060,7 -1088,7 +1090,7 @@@
          }
          int opc = opCode(op);
          return VectorSupport.ternaryOp(
--            opc, getClass(), maskClass, long.class, length(),
++            opc, getClass(), maskClass, long.class, long.class, VECTOR_OPER_TYPE, length(),
              this, that, tother, m,
              TERN_IMPL.find(op, opc, LongVector::ternaryOperations));
      }
@@@ -1940,7 -1968,7 +1970,7 @@@
          that.check(this);
          int opc = opCode(op);
          return VectorSupport.compare(
--            opc, getClass(), maskType, long.class, length(),
++            opc, getClass(), maskType, long.class, long.class, VECTOR_OPER_TYPE, length(),
              this, that, null,
              (cond, v0, v1, m1) -> {
                  AbstractMask<Long> m
@@@ -1962,7 -1990,7 +1992,7 @@@
          m.check(maskType, this);
          int opc = opCode(op);
          return VectorSupport.compare(
--            opc, getClass(), maskType, long.class, length(),
++            opc, getClass(), maskType, long.class, long.class, VECTOR_OPER_TYPE, length(),
              this, that, m,
              (cond, v0, v1, m1) -> {
                  AbstractMask<Long> cmpM
@@@ -2067,7 -2095,7 +2097,7 @@@
      blendTemplate(Class<M> maskType, LongVector v, M m) {
          v.check(this);
          return VectorSupport.blend(
--            getClass(), maskType, long.class, length(),
++            getClass(), maskType, long.class, long.class, VECTOR_OPER_TYPE, length(),
              this, v, m,
              (v0, v1, m_) -> v0.bOp(v1, m_, (i, a, b) -> b));
      }
@@@ -2084,7 -2112,7 +2114,7 @@@
          // make sure VLENGTH*scale doesn't overflow:
          vsp.checkScale(scale);
          return VectorSupport.indexVector(
--            getClass(), long.class, length(),
++            getClass(), long.class, long.class, VECTOR_OPER_TYPE, length(),
              this, scale, vsp,
              (v, scale_, s)
              -> {
@@@ -2251,12 -2281,12 +2283,12 @@@
      final
      <S extends VectorShuffle<Long>>
      LongVector rearrangeTemplate(Class<S> shuffletype, S shuffle) {
-         shuffle.checkIndexes();
+         Objects.requireNonNull(shuffle);
          return VectorSupport.rearrangeOp(
--            getClass(), shuffletype, null, long.class, length(),
++            getClass(), shuffletype, null, long.class, long.class, VECTOR_OPER_TYPE, length(),
              this, shuffle, null,
              (v1, s_, m_) -> v1.uOp((i, a) -> {
-                 int ei = s_.laneSource(i);
+                 int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
                  return v1.lane(ei);
              }));
      }
@@@ -2277,19 -2307,14 +2309,14 @@@
                                             Class<M> masktype,
                                             S shuffle,
                                             M m) {
- 
+         Objects.requireNonNull(shuffle);
          m.check(masktype, this);
-         VectorMask<Long> valid = shuffle.laneIsValid();
-         if (m.andNot(valid).anyTrue()) {
-             shuffle.checkIndexes();
-             throw new AssertionError();
-         }
          return VectorSupport.rearrangeOp(
--                   getClass(), shuffletype, masktype, long.class, length(),
++                   getClass(), shuffletype, masktype, long.class, long.class, VECTOR_OPER_TYPE, length(),
                     this, shuffle, m,
                     (v1, s_, m_) -> v1.uOp((i, a) -> {
-                         int ei = s_.laneSource(i);
-                         return ei < 0  || !m_.laneIsSet(i) ? 0 : v1.lane(ei);
+                         int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
+                         return !m_.laneIsSet(i) ? 0 : v1.lane(ei);
                     }));
      }
  
@@@ -2309,22 -2334,20 +2336,20 @@@
                                             S shuffle,
                                             LongVector v) {
          VectorMask<Long> valid = shuffle.laneIsValid();
-         @SuppressWarnings("unchecked")
-         S ws = (S) shuffle.wrapIndexes();
          LongVector r0 =
              VectorSupport.rearrangeOp(
--                getClass(), shuffletype, null, long.class, length(),
-                 this, ws, null,
++                getClass(), shuffletype, null, long.class, long.class, VECTOR_OPER_TYPE, length(),
+                 this, shuffle, null,
                  (v0, s_, m_) -> v0.uOp((i, a) -> {
-                     int ei = s_.laneSource(i);
+                     int ei = Integer.remainderUnsigned(s_.laneSource(i), v0.length());
                      return v0.lane(ei);
                  }));
          LongVector r1 =
              VectorSupport.rearrangeOp(
--                getClass(), shuffletype, null, long.class, length(),
-                 v, ws, null,
++                getClass(), shuffletype, null, long.class, long.class, VECTOR_OPER_TYPE, length(),
+                 v, shuffle, null,
                  (v1, s_, m_) -> v1.uOp((i, a) -> {
-                     int ei = s_.laneSource(i);
+                     int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
                      return v1.lane(ei);
                  }));
          return r1.blend(r0, valid);
@@@ -2356,7 -2394,7 +2396,7 @@@
      LongVector compressTemplate(Class<M> masktype, M m) {
        m.check(masktype, this);
        return (LongVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,
--                                                        long.class, length(), this, m,
++                                                        long.class, long.class, VECTOR_OPER_TYPE, length(), this, m,
                                                          (v1, m1) -> compressHelper(v1, m1));
      }
  
@@@ -2375,7 -2413,7 +2415,7 @@@
      LongVector expandTemplate(Class<M> masktype, M m) {
        m.check(masktype, this);
        return (LongVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,
--                                                        long.class, length(), this, m,
++                                                        long.class, long.class, VECTOR_OPER_TYPE, length(), this, m,
                                                          (v1, m1) -> expandHelper(v1, m1));
      }
  
@@@ -2390,7 -2428,10 +2430,10 @@@
      /*package-private*/
      @ForceInline
      final LongVector selectFromTemplate(LongVector v) {
-         return v.rearrange(this.toShuffle());
 -        return (LongVector)VectorSupport.selectFromOp(getClass(), null, long.class,
++        return (LongVector)VectorSupport.selectFromOp(getClass(), null, long.class, long.class, VECTOR_OPER_TYPE,
+                                                         length(), this, v, null,
+                                                         (v1, v2, _m) ->
+                                                          v2.rearrange(v1.toShuffle()));
      }
  
      /**
@@@ -2402,9 -2443,31 +2445,31 @@@
  
      /*package-private*/
      @ForceInline
-     final LongVector selectFromTemplate(LongVector v,
-                                                   AbstractMask<Long> m) {
-         return v.rearrange(this.toShuffle(), m);
+     final
+     <M extends VectorMask<Long>>
+     LongVector selectFromTemplate(LongVector v,
+                                             Class<M> masktype, M m) {
+         m.check(masktype, this);
 -        return (LongVector)VectorSupport.selectFromOp(getClass(), masktype, long.class,
++        return (LongVector)VectorSupport.selectFromOp(getClass(), masktype, long.class, long.class, VECTOR_OPER_TYPE,
+                                                         length(), this, v, m,
+                                                         (v1, v2, _m) ->
+                                                          v2.rearrange(v1.toShuffle(), _m));
+     }
+ 
+ 
+     /**
+      * {@inheritDoc} <!--workaround-->
+      */
+     @Override
+     public abstract
+     LongVector selectFrom(Vector<Long> v1, Vector<Long> v2);
+ 
+ 
+     /*package-private*/
+     @ForceInline
+     final LongVector selectFromTemplate(LongVector v1, LongVector v2) {
 -        return VectorSupport.selectFromTwoVectorOp(getClass(), long.class, length(), this, v1, v2,
++        return VectorSupport.selectFromTwoVectorOp(getClass(), long.class, long.class, VECTOR_OPER_TYPE, length(), this, v1, v2,
+                                                    (vec1, vec2, vec3) -> selectFromTwoVectorHelper(vec1, vec2, vec3));
      }
  
      /// Ternary operations
@@@ -2623,7 -2686,7 +2688,7 @@@
          }
          int opc = opCode(op);
          return fromBits(VectorSupport.reductionCoerced(
--            opc, getClass(), maskClass, long.class, length(),
++            opc, getClass(), maskClass, long.class, long.class, VECTOR_OPER_TYPE, length(),
              this, m,
              REDUCE_IMPL.find(op, opc, LongVector::reductionOperations)));
      }
@@@ -2641,7 -2704,7 +2706,7 @@@
          }
          int opc = opCode(op);
          return fromBits(VectorSupport.reductionCoerced(
--            opc, getClass(), null, long.class, length(),
++            opc, getClass(), null, long.class, long.class, VECTOR_OPER_TYPE, length(),
              this, null,
              REDUCE_IMPL.find(op, opc, LongVector::reductionOperations)));
      }
@@@ -2907,9 -2977,9 +2979,9 @@@
          vix = VectorIntrinsics.checkIndex(vix, a.length);
  
          return VectorSupport.loadWithMap(
--            vectorType, null, long.class, vsp.laneCount(),
-             isp.vectorType(),
-             a, ARRAY_BASE, vix, null,
++            vectorType, null, long.class, long.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+             isp.vectorType(), isp.length(),
+             a, ARRAY_BASE, vix, null, null, null, null,
              a, offset, indexMap, mapOffset, vsp,
              (c, idx, iMap, idy, s, vm) ->
              s.vOp(n -> c[idx + iMap[idy+n]]));
@@@ -3093,8 -3160,8 +3162,8 @@@
          offset = checkFromIndexSize(offset, length(), a.length);
          LongSpecies vsp = vspecies();
          VectorSupport.store(
--            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset),
++            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, arrayAddress(a, offset), false,
              this,
              a, offset,
              (arr, off, v)
@@@ -3200,8 -3268,8 +3270,8 @@@
          vix = VectorIntrinsics.checkIndex(vix, a.length);
  
          VectorSupport.storeWithMap(
--            vsp.vectorType(), null, vsp.elementType(), vsp.laneCount(),
-             isp.vectorType(),
++            vsp.vectorType(), null, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             isp.vectorType(), isp.length(),
              a, arrayAddress(a, 0), vix,
              this, null,
              a, offset, indexMap, mapOffset,
@@@ -3326,8 -3395,8 +3397,8 @@@
      LongVector fromArray0Template(long[] a, int offset) {
          LongSpecies vsp = vspecies();
          return VectorSupport.load(
--            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset),
++            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, arrayAddress(a, offset), false,
              a, offset, vsp,
              (arr, off, s) -> s.ldOp(arr, (int) off,
                                      (arr_, off_, i) -> arr_[off_ + i]));
@@@ -3343,8 -3412,8 +3414,8 @@@
          m.check(species());
          LongSpecies vsp = vspecies();
          return VectorSupport.loadMasked(
--            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset), m, offsetInRange,
++            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, arrayAddress(a, offset), false, m, offsetInRange,
              a, offset, vsp,
              (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,
                                          (arr_, off_, i) -> arr_[off_ + i]));
@@@ -3394,9 -3463,9 +3465,9 @@@
          vix = VectorIntrinsics.checkIndex(vix, a.length);
  
          return VectorSupport.loadWithMap(
--            vectorType, maskClass, long.class, vsp.laneCount(),
-             isp.vectorType(),
-             a, ARRAY_BASE, vix, m,
++            vectorType, maskClass, long.class, long.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+             isp.vectorType(), isp.length(),
+             a, ARRAY_BASE, vix, null, null, null, m,
              a, offset, indexMap, mapOffset, vsp,
              (c, idx, iMap, idy, s, vm) ->
              s.vOp(vm, n -> c[idx + iMap[idy+n]]));
@@@ -3411,7 -3480,7 +3482,7 @@@
      LongVector fromMemorySegment0Template(MemorySegment ms, long offset) {
          LongSpecies vsp = vspecies();
          return ScopedMemoryAccess.loadFromMemorySegment(
--                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
++                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                  (AbstractMemorySegmentImpl) ms, offset, vsp,
                  (msp, off, s) -> {
                      return s.ldLongOp((MemorySegment) msp, off, LongVector::memorySegmentGet);
@@@ -3427,7 -3496,7 +3498,7 @@@
          LongSpecies vsp = vspecies();
          m.check(vsp);
          return ScopedMemoryAccess.loadFromMemorySegmentMasked(
--                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
++                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                  (AbstractMemorySegmentImpl) ms, offset, m, vsp, offsetInRange,
                  (msp, off, s, vm) -> {
                      return s.ldLongOp((MemorySegment) msp, off, vm, LongVector::memorySegmentGet);
@@@ -3445,8 -3514,8 +3516,8 @@@
      void intoArray0Template(long[] a, int offset) {
          LongSpecies vsp = vspecies();
          VectorSupport.store(
--            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset),
++            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, arrayAddress(a, offset), false,
              this, a, offset,
              (arr, off, v)
              -> v.stOp(arr, (int) off,
@@@ -3462,8 -3531,8 +3533,8 @@@
          m.check(species());
          LongSpecies vsp = vspecies();
          VectorSupport.storeMasked(
--            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset),
++            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, arrayAddress(a, offset), false,
              this, m, a, offset,
              (arr, off, v, vm)
              -> v.stOp(arr, (int) off, vm,
@@@ -3510,8 -3579,8 +3581,8 @@@
          vix = VectorIntrinsics.checkIndex(vix, a.length);
  
          VectorSupport.storeWithMap(
--            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
-             isp.vectorType(),
++            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             isp.vectorType(), isp.length(),
              a, arrayAddress(a, 0), vix,
              this, m,
              a, offset, indexMap, mapOffset,
@@@ -3529,7 -3598,7 +3600,7 @@@
      void intoMemorySegment0(MemorySegment ms, long offset) {
          LongSpecies vsp = vspecies();
          ScopedMemoryAccess.storeIntoMemorySegment(
--                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
++                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                  this,
                  (AbstractMemorySegmentImpl) ms, offset,
                  (msp, off, v) -> {
@@@ -3546,7 -3615,7 +3617,7 @@@
          LongSpecies vsp = vspecies();
          m.check(vsp);
          ScopedMemoryAccess.storeIntoMemorySegmentMasked(
--                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
++                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                  this, m,
                  (AbstractMemorySegmentImpl) ms, offset,
                  (msp, off, v, vm) -> {
@@@ -3738,6 -3787,6 +3789,19 @@@
  
          // Specializing overrides:
  
++        @ForceInline
++        final Class<?> carrierType() {
++            return long.class;
++        }
++
++        @ForceInline
++        final int operType() {
++            if (long.class.equals(Float16.class)) {
++                return VECTOR_TYPE_FP16;
++            }
++            return VECTOR_TYPE_PRIM;
++        }
++
          @Override
          @ForceInline
          public final Class<Long> elementType() {
@@@ -3770,7 -3819,7 +3834,7 @@@
          final LongVector broadcastBits(long bits) {
              return (LongVector)
                  VectorSupport.fromBitsCoerced(
--                    vectorType, long.class, laneCount,
++                    vectorType, long.class, long.class, VECTOR_OPER_TYPE, laneCount,
                      bits, MODE_BROADCAST, this,
                      (bits_, s_) -> s_.rvOp(i -> bits_));
          }
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short128Vector.java
index 5d000abc511,60f22eb5fb9..52cb78a79a6
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short128Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short128Vector.java
@@@ -52,7 -54,7 +54,11 @@@ final class Short128Vector extends Shor
  
      static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
  
--    static final Class<Short> ETYPE = short.class; // used by the JVM
++    static final Class<Short> CTYPE = short.class; // carrier type used by the JVM
++
++    static final Class<Short> ETYPE = short.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
  
      Short128Vector(short[] v) {
          super(v);
@@@ -86,9 -88,9 +92,12 @@@
          return VSPECIES;
      }
  
++    @ForceInline
++    final Class<Short> carrierType() { return CTYPE; }
++
      @ForceInline
      @Override
--    public final Class<Short> elementType() { return short.class; }
++    public final Class<Short> elementType() { return ETYPE; }
  
      @ForceInline
      @Override
@@@ -510,9 -530,10 +537,10 @@@
          }
      }
  
+     @ForceInline
      public short laneHelper(int i) {
          return (short) VectorSupport.extract(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i,
                                  (vec, ix) -> {
                                      short[] vecarr = vec.vec();
@@@ -536,9 -557,10 +564,10 @@@
          }
      }
  
+     @ForceInline
      public Short128Vector withLaneHelper(int i, short e) {
          return VectorSupport.insert(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i, (long)e,
                                  (v, ix, bits) -> {
                                      short[] res = v.vec().clone();
@@@ -551,7 -573,7 +580,7 @@@
  
      static final class Short128Mask extends AbstractMask<Short> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Short> ETYPE = short.class; // used by the JVM
++        static final Class<Short> CTYPE = short.class; // used by the JVM
  
          Short128Mask(boolean[] bits) {
              this(bits, 0);
@@@ -653,7 -675,7 +682,7 @@@
          /*package-private*/
          Short128Mask indexPartiallyInUpperRange(long offset, long limit) {
              return (Short128Mask) VectorSupport.indexPartiallyInUpperRange(
-                 Short128Mask.class, ETYPE, VLENGTH, offset, limit,
 -                Short128Mask.class, short.class, VLENGTH, offset, limit,
++                Short128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                  (o, l) -> (Short128Mask) TRUE_MASK.indexPartiallyInRange(o, l));
          }
  
@@@ -669,8 -691,8 +698,9 @@@
          @ForceInline
          public Short128Mask compress() {
              return (Short128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
--                Short128Vector.class, Short128Mask.class, ETYPE, VLENGTH, null, this,
--                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
++                Short128Vector.class, Short128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                m1.trueCount()));
          }
  
  
@@@ -681,7 -703,7 +711,7 @@@
          public Short128Mask and(VectorMask<Short> mask) {
              Objects.requireNonNull(mask);
              Short128Mask m = (Short128Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_AND, Short128Mask.class, null, short.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, Short128Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
          }
@@@ -691,7 -713,7 +721,7 @@@
          public Short128Mask or(VectorMask<Short> mask) {
              Objects.requireNonNull(mask);
              Short128Mask m = (Short128Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_OR, Short128Mask.class, null, short.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, Short128Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
          }
@@@ -701,7 -723,7 +731,7 @@@
          public Short128Mask xor(VectorMask<Short> mask) {
              Objects.requireNonNull(mask);
              Short128Mask m = (Short128Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short128Mask.class, null, short.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short128Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
          }
@@@ -711,22 -733,22 +741,25 @@@
          @Override
          @ForceInline
          public int trueCount() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short128Mask.class, short.class, VLENGTH, this,
--                                                      (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short128Mask.class, short.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int firstTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short128Mask.class, short.class, VLENGTH, this,
--                                                      (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short128Mask.class, short.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int lastTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short128Mask.class, short.class, VLENGTH, this,
--                                                      (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short128Mask.class, short.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
          }
  
          @Override
@@@ -735,32 -757,42 +768,43 @@@
              if (length() > Long.SIZE) {
                  throw new UnsupportedOperationException("too many lanes for one long");
              }
--            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Short128Mask.class, short.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Short128Mask.class, short.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
                                                        (m) -> toLongHelper(m.getBits()));
          }
  
+         // laneIsSet
+ 
+         @Override
+         @ForceInline
+         public boolean laneIsSet(int i) {
+             Objects.checkIndex(i, length());
 -            return VectorSupport.extract(Short128Mask.class, short.class, VLENGTH,
++            return VectorSupport.extract(Short128Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
+         }
+ 
          // Reductions
  
          @Override
          @ForceInline
          public boolean anyTrue() {
--            return VectorSupport.test(BT_ne, Short128Mask.class, short.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> anyTrueHelper(((Short128Mask)m).getBits()));
++            return VectorSupport.test(BT_ne, Short128Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper(((Short128Mask)m).getBits()));
          }
  
          @Override
          @ForceInline
          public boolean allTrue() {
--            return VectorSupport.test(BT_overflow, Short128Mask.class, short.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> allTrueHelper(((Short128Mask)m).getBits()));
++            return VectorSupport.test(BT_overflow, Short128Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper(((Short128Mask)m).getBits()));
          }
  
          @ForceInline
          /*package-private*/
          static Short128Mask maskAll(boolean bit) {
--            return VectorSupport.fromBitsCoerced(Short128Mask.class, short.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced(Short128Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                                   (bit ? -1 : 0), MODE_BROADCAST, null,
                                                   (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
          }
@@@ -773,7 -805,7 +817,7 @@@
  
      static final class Short128Shuffle extends AbstractShuffle<Short> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Short> ETYPE = short.class; // used by the JVM
++        static final Class<Short> CTYPE = short.class; // used by the JVM
  
          Short128Shuffle(short[] indices) {
              super(indices);
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short256Vector.java
index e58f6a3b99d,14c415afac2..74219ad19d7
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short256Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short256Vector.java
@@@ -52,7 -54,7 +54,11 @@@ final class Short256Vector extends Shor
  
      static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
  
--    static final Class<Short> ETYPE = short.class; // used by the JVM
++    static final Class<Short> CTYPE = short.class; // carrier type used by the JVM
++
++    static final Class<Short> ETYPE = short.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
  
      Short256Vector(short[] v) {
          super(v);
@@@ -86,9 -88,9 +92,12 @@@
          return VSPECIES;
      }
  
++    @ForceInline
++    final Class<Short> carrierType() { return CTYPE; }
++
      @ForceInline
      @Override
--    public final Class<Short> elementType() { return short.class; }
++    public final Class<Short> elementType() { return ETYPE; }
  
      @ForceInline
      @Override
@@@ -518,9 -538,10 +545,10 @@@
          }
      }
  
+     @ForceInline
      public short laneHelper(int i) {
          return (short) VectorSupport.extract(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i,
                                  (vec, ix) -> {
                                      short[] vecarr = vec.vec();
@@@ -552,9 -573,10 +580,10 @@@
          }
      }
  
+     @ForceInline
      public Short256Vector withLaneHelper(int i, short e) {
          return VectorSupport.insert(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i, (long)e,
                                  (v, ix, bits) -> {
                                      short[] res = v.vec().clone();
@@@ -567,7 -589,7 +596,7 @@@
  
      static final class Short256Mask extends AbstractMask<Short> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Short> ETYPE = short.class; // used by the JVM
++        static final Class<Short> CTYPE = short.class; // used by the JVM
  
          Short256Mask(boolean[] bits) {
              this(bits, 0);
@@@ -669,7 -691,7 +698,7 @@@
          /*package-private*/
          Short256Mask indexPartiallyInUpperRange(long offset, long limit) {
              return (Short256Mask) VectorSupport.indexPartiallyInUpperRange(
-                 Short256Mask.class, ETYPE, VLENGTH, offset, limit,
 -                Short256Mask.class, short.class, VLENGTH, offset, limit,
++                Short256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                  (o, l) -> (Short256Mask) TRUE_MASK.indexPartiallyInRange(o, l));
          }
  
@@@ -685,8 -707,8 +714,9 @@@
          @ForceInline
          public Short256Mask compress() {
              return (Short256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
--                Short256Vector.class, Short256Mask.class, ETYPE, VLENGTH, null, this,
--                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
++                Short256Vector.class, Short256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                m1.trueCount()));
          }
  
  
@@@ -697,7 -719,7 +727,7 @@@
          public Short256Mask and(VectorMask<Short> mask) {
              Objects.requireNonNull(mask);
              Short256Mask m = (Short256Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_AND, Short256Mask.class, null, short.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, Short256Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
          }
@@@ -707,7 -729,7 +737,7 @@@
          public Short256Mask or(VectorMask<Short> mask) {
              Objects.requireNonNull(mask);
              Short256Mask m = (Short256Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_OR, Short256Mask.class, null, short.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, Short256Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
          }
@@@ -717,7 -739,7 +747,7 @@@
          public Short256Mask xor(VectorMask<Short> mask) {
              Objects.requireNonNull(mask);
              Short256Mask m = (Short256Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short256Mask.class, null, short.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short256Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
          }
@@@ -727,22 -749,22 +757,25 @@@
          @Override
          @ForceInline
          public int trueCount() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short256Mask.class, short.class, VLENGTH, this,
--                                                      (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short256Mask.class, short.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int firstTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short256Mask.class, short.class, VLENGTH, this,
--                                                      (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short256Mask.class, short.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int lastTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short256Mask.class, short.class, VLENGTH, this,
--                                                      (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short256Mask.class, short.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
          }
  
          @Override
@@@ -751,32 -773,42 +784,43 @@@
              if (length() > Long.SIZE) {
                  throw new UnsupportedOperationException("too many lanes for one long");
              }
--            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Short256Mask.class, short.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Short256Mask.class, short.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
                                                        (m) -> toLongHelper(m.getBits()));
          }
  
+         // laneIsSet
+ 
+         @Override
+         @ForceInline
+         public boolean laneIsSet(int i) {
+             Objects.checkIndex(i, length());
 -            return VectorSupport.extract(Short256Mask.class, short.class, VLENGTH,
++            return VectorSupport.extract(Short256Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
+         }
+ 
          // Reductions
  
          @Override
          @ForceInline
          public boolean anyTrue() {
--            return VectorSupport.test(BT_ne, Short256Mask.class, short.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> anyTrueHelper(((Short256Mask)m).getBits()));
++            return VectorSupport.test(BT_ne, Short256Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper(((Short256Mask)m).getBits()));
          }
  
          @Override
          @ForceInline
          public boolean allTrue() {
--            return VectorSupport.test(BT_overflow, Short256Mask.class, short.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> allTrueHelper(((Short256Mask)m).getBits()));
++            return VectorSupport.test(BT_overflow, Short256Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper(((Short256Mask)m).getBits()));
          }
  
          @ForceInline
          /*package-private*/
          static Short256Mask maskAll(boolean bit) {
--            return VectorSupport.fromBitsCoerced(Short256Mask.class, short.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced(Short256Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                                   (bit ? -1 : 0), MODE_BROADCAST, null,
                                                   (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
          }
@@@ -789,7 -821,7 +833,7 @@@
  
      static final class Short256Shuffle extends AbstractShuffle<Short> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Short> ETYPE = short.class; // used by the JVM
++        static final Class<Short> CTYPE = short.class; // used by the JVM
  
          Short256Shuffle(short[] indices) {
              super(indices);
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short512Vector.java
index e4bb350adda,c92979302a6..a927d8884b1
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short512Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short512Vector.java
@@@ -52,7 -54,7 +54,11 @@@ final class Short512Vector extends Shor
  
      static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
  
--    static final Class<Short> ETYPE = short.class; // used by the JVM
++    static final Class<Short> CTYPE = short.class; // carrier type used by the JVM
++
++    static final Class<Short> ETYPE = short.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
  
      Short512Vector(short[] v) {
          super(v);
@@@ -86,9 -88,9 +92,12 @@@
          return VSPECIES;
      }
  
++    @ForceInline
++    final Class<Short> carrierType() { return CTYPE; }
++
      @ForceInline
      @Override
--    public final Class<Short> elementType() { return short.class; }
++    public final Class<Short> elementType() { return ETYPE; }
  
      @ForceInline
      @Override
@@@ -534,9 -554,10 +561,10 @@@
          }
      }
  
+     @ForceInline
      public short laneHelper(int i) {
          return (short) VectorSupport.extract(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i,
                                  (vec, ix) -> {
                                      short[] vecarr = vec.vec();
@@@ -584,9 -605,10 +612,10 @@@
          }
      }
  
+     @ForceInline
      public Short512Vector withLaneHelper(int i, short e) {
          return VectorSupport.insert(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i, (long)e,
                                  (v, ix, bits) -> {
                                      short[] res = v.vec().clone();
@@@ -599,7 -621,7 +628,7 @@@
  
      static final class Short512Mask extends AbstractMask<Short> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Short> ETYPE = short.class; // used by the JVM
++        static final Class<Short> CTYPE = short.class; // used by the JVM
  
          Short512Mask(boolean[] bits) {
              this(bits, 0);
@@@ -701,7 -723,7 +730,7 @@@
          /*package-private*/
          Short512Mask indexPartiallyInUpperRange(long offset, long limit) {
              return (Short512Mask) VectorSupport.indexPartiallyInUpperRange(
-                 Short512Mask.class, ETYPE, VLENGTH, offset, limit,
 -                Short512Mask.class, short.class, VLENGTH, offset, limit,
++                Short512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                  (o, l) -> (Short512Mask) TRUE_MASK.indexPartiallyInRange(o, l));
          }
  
@@@ -717,8 -739,8 +746,9 @@@
          @ForceInline
          public Short512Mask compress() {
              return (Short512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
--                Short512Vector.class, Short512Mask.class, ETYPE, VLENGTH, null, this,
--                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
++                Short512Vector.class, Short512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                m1.trueCount()));
          }
  
  
@@@ -729,7 -751,7 +759,7 @@@
          public Short512Mask and(VectorMask<Short> mask) {
              Objects.requireNonNull(mask);
              Short512Mask m = (Short512Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_AND, Short512Mask.class, null, short.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, Short512Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
          }
@@@ -739,7 -761,7 +769,7 @@@
          public Short512Mask or(VectorMask<Short> mask) {
              Objects.requireNonNull(mask);
              Short512Mask m = (Short512Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_OR, Short512Mask.class, null, short.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, Short512Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
          }
@@@ -749,7 -771,7 +779,7 @@@
          public Short512Mask xor(VectorMask<Short> mask) {
              Objects.requireNonNull(mask);
              Short512Mask m = (Short512Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short512Mask.class, null, short.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short512Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
          }
@@@ -759,22 -781,22 +789,25 @@@
          @Override
          @ForceInline
          public int trueCount() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short512Mask.class, short.class, VLENGTH, this,
--                                                      (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short512Mask.class, short.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int firstTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short512Mask.class, short.class, VLENGTH, this,
--                                                      (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short512Mask.class, short.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int lastTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short512Mask.class, short.class, VLENGTH, this,
--                                                      (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short512Mask.class, short.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
          }
  
          @Override
@@@ -783,32 -805,42 +816,43 @@@
              if (length() > Long.SIZE) {
                  throw new UnsupportedOperationException("too many lanes for one long");
              }
--            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Short512Mask.class, short.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Short512Mask.class, short.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
                                                        (m) -> toLongHelper(m.getBits()));
          }
  
+         // laneIsSet
+ 
+         @Override
+         @ForceInline
+         public boolean laneIsSet(int i) {
+             Objects.checkIndex(i, length());
 -            return VectorSupport.extract(Short512Mask.class, short.class, VLENGTH,
++            return VectorSupport.extract(Short512Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
+         }
+ 
          // Reductions
  
          @Override
          @ForceInline
          public boolean anyTrue() {
--            return VectorSupport.test(BT_ne, Short512Mask.class, short.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> anyTrueHelper(((Short512Mask)m).getBits()));
++            return VectorSupport.test(BT_ne, Short512Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper(((Short512Mask)m).getBits()));
          }
  
          @Override
          @ForceInline
          public boolean allTrue() {
--            return VectorSupport.test(BT_overflow, Short512Mask.class, short.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> allTrueHelper(((Short512Mask)m).getBits()));
++            return VectorSupport.test(BT_overflow, Short512Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper(((Short512Mask)m).getBits()));
          }
  
          @ForceInline
          /*package-private*/
          static Short512Mask maskAll(boolean bit) {
--            return VectorSupport.fromBitsCoerced(Short512Mask.class, short.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced(Short512Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                                   (bit ? -1 : 0), MODE_BROADCAST, null,
                                                   (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
          }
@@@ -821,7 -853,7 +865,7 @@@
  
      static final class Short512Shuffle extends AbstractShuffle<Short> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Short> ETYPE = short.class; // used by the JVM
++        static final Class<Short> CTYPE = short.class; // used by the JVM
  
          Short512Shuffle(short[] indices) {
              super(indices);
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short64Vector.java
index 513ee27e339,b454989b45f..0899d69face
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short64Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short64Vector.java
@@@ -52,7 -54,7 +54,11 @@@ final class Short64Vector extends Short
  
      static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
  
--    static final Class<Short> ETYPE = short.class; // used by the JVM
++    static final Class<Short> CTYPE = short.class; // carrier type used by the JVM
++
++    static final Class<Short> ETYPE = short.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
  
      Short64Vector(short[] v) {
          super(v);
@@@ -86,9 -88,9 +92,12 @@@
          return VSPECIES;
      }
  
++    @ForceInline
++    final Class<Short> carrierType() { return CTYPE; }
++
      @ForceInline
      @Override
--    public final Class<Short> elementType() { return short.class; }
++    public final Class<Short> elementType() { return ETYPE; }
  
      @ForceInline
      @Override
@@@ -506,9 -526,10 +533,10 @@@
          }
      }
  
+     @ForceInline
      public short laneHelper(int i) {
          return (short) VectorSupport.extract(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i,
                                  (vec, ix) -> {
                                      short[] vecarr = vec.vec();
@@@ -528,9 -549,10 +556,10 @@@
          }
      }
  
+     @ForceInline
      public Short64Vector withLaneHelper(int i, short e) {
          return VectorSupport.insert(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i, (long)e,
                                  (v, ix, bits) -> {
                                      short[] res = v.vec().clone();
@@@ -543,7 -565,7 +572,7 @@@
  
      static final class Short64Mask extends AbstractMask<Short> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Short> ETYPE = short.class; // used by the JVM
++        static final Class<Short> CTYPE = short.class; // used by the JVM
  
          Short64Mask(boolean[] bits) {
              this(bits, 0);
@@@ -645,7 -667,7 +674,7 @@@
          /*package-private*/
          Short64Mask indexPartiallyInUpperRange(long offset, long limit) {
              return (Short64Mask) VectorSupport.indexPartiallyInUpperRange(
-                 Short64Mask.class, ETYPE, VLENGTH, offset, limit,
 -                Short64Mask.class, short.class, VLENGTH, offset, limit,
++                Short64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                  (o, l) -> (Short64Mask) TRUE_MASK.indexPartiallyInRange(o, l));
          }
  
@@@ -661,8 -683,8 +690,9 @@@
          @ForceInline
          public Short64Mask compress() {
              return (Short64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
--                Short64Vector.class, Short64Mask.class, ETYPE, VLENGTH, null, this,
--                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
++                Short64Vector.class, Short64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                m1.trueCount()));
          }
  
  
@@@ -673,7 -695,7 +703,7 @@@
          public Short64Mask and(VectorMask<Short> mask) {
              Objects.requireNonNull(mask);
              Short64Mask m = (Short64Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_AND, Short64Mask.class, null, short.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, Short64Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
          }
@@@ -683,7 -705,7 +713,7 @@@
          public Short64Mask or(VectorMask<Short> mask) {
              Objects.requireNonNull(mask);
              Short64Mask m = (Short64Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_OR, Short64Mask.class, null, short.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, Short64Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
          }
@@@ -693,7 -715,7 +723,7 @@@
          public Short64Mask xor(VectorMask<Short> mask) {
              Objects.requireNonNull(mask);
              Short64Mask m = (Short64Mask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short64Mask.class, null, short.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short64Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
          }
@@@ -703,22 -725,22 +733,25 @@@
          @Override
          @ForceInline
          public int trueCount() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short64Mask.class, short.class, VLENGTH, this,
--                                                      (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short64Mask.class, short.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int firstTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short64Mask.class, short.class, VLENGTH, this,
--                                                      (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short64Mask.class, short.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int lastTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short64Mask.class, short.class, VLENGTH, this,
--                                                      (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short64Mask.class, short.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
          }
  
          @Override
@@@ -727,32 -749,42 +760,43 @@@
              if (length() > Long.SIZE) {
                  throw new UnsupportedOperationException("too many lanes for one long");
              }
--            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Short64Mask.class, short.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Short64Mask.class, short.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
                                                        (m) -> toLongHelper(m.getBits()));
          }
  
+         // laneIsSet
+ 
+         @Override
+         @ForceInline
+         public boolean laneIsSet(int i) {
+             Objects.checkIndex(i, length());
 -            return VectorSupport.extract(Short64Mask.class, short.class, VLENGTH,
++            return VectorSupport.extract(Short64Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
+         }
+ 
          // Reductions
  
          @Override
          @ForceInline
          public boolean anyTrue() {
--            return VectorSupport.test(BT_ne, Short64Mask.class, short.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> anyTrueHelper(((Short64Mask)m).getBits()));
++            return VectorSupport.test(BT_ne, Short64Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper(((Short64Mask)m).getBits()));
          }
  
          @Override
          @ForceInline
          public boolean allTrue() {
--            return VectorSupport.test(BT_overflow, Short64Mask.class, short.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> allTrueHelper(((Short64Mask)m).getBits()));
++            return VectorSupport.test(BT_overflow, Short64Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper(((Short64Mask)m).getBits()));
          }
  
          @ForceInline
          /*package-private*/
          static Short64Mask maskAll(boolean bit) {
--            return VectorSupport.fromBitsCoerced(Short64Mask.class, short.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced(Short64Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                                   (bit ? -1 : 0), MODE_BROADCAST, null,
                                                   (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
          }
@@@ -765,7 -797,7 +809,7 @@@
  
      static final class Short64Shuffle extends AbstractShuffle<Short> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Short> ETYPE = short.class; // used by the JVM
++        static final Class<Short> CTYPE = short.class; // used by the JVM
  
          Short64Shuffle(short[] indices) {
              super(indices);
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ShortMaxVector.java
index d06da6c3c79,bea14b7d5fd..fa7a3fb1383
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ShortMaxVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ShortMaxVector.java
@@@ -52,7 -54,7 +54,11 @@@ final class ShortMaxVector extends Shor
  
      static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
  
--    static final Class<Short> ETYPE = short.class; // used by the JVM
++    static final Class<Short> CTYPE = short.class; // carrier type used by the JVM
++
++    static final Class<Short> ETYPE = short.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
  
      ShortMaxVector(short[] v) {
          super(v);
@@@ -86,9 -88,9 +92,12 @@@
          return VSPECIES;
      }
  
++    @ForceInline
++    final Class<Short> carrierType() { return CTYPE; }
++
      @ForceInline
      @Override
--    public final Class<Short> elementType() { return short.class; }
++    public final Class<Short> elementType() { return ETYPE; }
  
      @ForceInline
      @Override
@@@ -503,9 -523,10 +530,10 @@@
          return laneHelper(i);
      }
  
+     @ForceInline
      public short laneHelper(int i) {
          return (short) VectorSupport.extract(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i,
                                  (vec, ix) -> {
                                      short[] vecarr = vec.vec();
@@@ -522,9 -543,10 +550,10 @@@
          return withLaneHelper(i, e);
      }
  
+     @ForceInline
      public ShortMaxVector withLaneHelper(int i, short e) {
          return VectorSupport.insert(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i, (long)e,
                                  (v, ix, bits) -> {
                                      short[] res = v.vec().clone();
@@@ -537,7 -559,7 +566,7 @@@
  
      static final class ShortMaxMask extends AbstractMask<Short> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Short> ETYPE = short.class; // used by the JVM
++        static final Class<Short> CTYPE = short.class; // used by the JVM
  
          ShortMaxMask(boolean[] bits) {
              this(bits, 0);
@@@ -639,7 -661,7 +668,7 @@@
          /*package-private*/
          ShortMaxMask indexPartiallyInUpperRange(long offset, long limit) {
              return (ShortMaxMask) VectorSupport.indexPartiallyInUpperRange(
-                 ShortMaxMask.class, ETYPE, VLENGTH, offset, limit,
 -                ShortMaxMask.class, short.class, VLENGTH, offset, limit,
++                ShortMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                  (o, l) -> (ShortMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));
          }
  
@@@ -655,8 -677,8 +684,9 @@@
          @ForceInline
          public ShortMaxMask compress() {
              return (ShortMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
--                ShortMaxVector.class, ShortMaxMask.class, ETYPE, VLENGTH, null, this,
--                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
++                ShortMaxVector.class, ShortMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                m1.trueCount()));
          }
  
  
@@@ -667,7 -689,7 +697,7 @@@
          public ShortMaxMask and(VectorMask<Short> mask) {
              Objects.requireNonNull(mask);
              ShortMaxMask m = (ShortMaxMask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_AND, ShortMaxMask.class, null, short.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, ShortMaxMask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
          }
@@@ -677,7 -699,7 +707,7 @@@
          public ShortMaxMask or(VectorMask<Short> mask) {
              Objects.requireNonNull(mask);
              ShortMaxMask m = (ShortMaxMask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_OR, ShortMaxMask.class, null, short.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, ShortMaxMask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
          }
@@@ -687,7 -709,7 +717,7 @@@
          public ShortMaxMask xor(VectorMask<Short> mask) {
              Objects.requireNonNull(mask);
              ShortMaxMask m = (ShortMaxMask)mask;
--            return VectorSupport.binaryOp(VECTOR_OP_XOR, ShortMaxMask.class, null, short.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, ShortMaxMask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
          }
@@@ -697,22 -719,22 +727,25 @@@
          @Override
          @ForceInline
          public int trueCount() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, ShortMaxMask.class, short.class, VLENGTH, this,
--                                                      (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, ShortMaxMask.class, short.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int firstTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, ShortMaxMask.class, short.class, VLENGTH, this,
--                                                      (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, ShortMaxMask.class, short.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int lastTrue() {
--            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, ShortMaxMask.class, short.class, VLENGTH, this,
--                                                      (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, ShortMaxMask.class, short.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
          }
  
          @Override
@@@ -721,32 -743,42 +754,43 @@@
              if (length() > Long.SIZE) {
                  throw new UnsupportedOperationException("too many lanes for one long");
              }
--            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, ShortMaxMask.class, short.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, ShortMaxMask.class, short.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
                                                        (m) -> toLongHelper(m.getBits()));
          }
  
+         // laneIsSet
+ 
+         @Override
+         @ForceInline
+         public boolean laneIsSet(int i) {
+             Objects.checkIndex(i, length());
 -            return VectorSupport.extract(ShortMaxMask.class, short.class, VLENGTH,
++            return VectorSupport.extract(ShortMaxMask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
+         }
+ 
          // Reductions
  
          @Override
          @ForceInline
          public boolean anyTrue() {
--            return VectorSupport.test(BT_ne, ShortMaxMask.class, short.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> anyTrueHelper(((ShortMaxMask)m).getBits()));
++            return VectorSupport.test(BT_ne, ShortMaxMask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper(((ShortMaxMask)m).getBits()));
          }
  
          @Override
          @ForceInline
          public boolean allTrue() {
--            return VectorSupport.test(BT_overflow, ShortMaxMask.class, short.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> allTrueHelper(((ShortMaxMask)m).getBits()));
++            return VectorSupport.test(BT_overflow, ShortMaxMask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper(((ShortMaxMask)m).getBits()));
          }
  
          @ForceInline
          /*package-private*/
          static ShortMaxMask maskAll(boolean bit) {
--            return VectorSupport.fromBitsCoerced(ShortMaxMask.class, short.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced(ShortMaxMask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                                   (bit ? -1 : 0), MODE_BROADCAST, null,
                                                   (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
          }
@@@ -759,7 -791,7 +803,7 @@@
  
      static final class ShortMaxShuffle extends AbstractShuffle<Short> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<Short> ETYPE = short.class; // used by the JVM
++        static final Class<Short> CTYPE = short.class; // used by the JVM
  
          ShortMaxShuffle(short[] indices) {
              super(indices);
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ShortVector.java
index 15567fa0946,e222c6d25f3..a5e6208e354
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ShortVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ShortVector.java
@@@ -57,7 -57,7 +57,9 @@@ public abstract class ShortVector exten
  
      static final int FORBID_OPCODE_KIND = VO_ONLYFP;
  
-     static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withBitAlignment(8);
++    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;
++
+     static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withByteAlignment(1);
  
      @ForceInline
      static int opCode(Operator op) {
@@@ -560,7 -573,7 +575,7 @@@
      @ForceInline
      public static ShortVector zero(VectorSpecies<Short> species) {
          ShortSpecies vsp = (ShortSpecies) species;
--        return VectorSupport.fromBitsCoerced(vsp.vectorType(), short.class, species.length(),
++        return VectorSupport.fromBitsCoerced(vsp.vectorType(), short.class, short.class, VECTOR_OPER_TYPE, species.length(),
                                  0, MODE_BROADCAST, vsp,
                                  ((bits_, s_) -> s_.rvOp(i -> bits_)));
      }
@@@ -682,7 -695,7 +697,7 @@@
          }
          int opc = opCode(op);
          return VectorSupport.unaryOp(
--            opc, getClass(), null, short.class, length(),
++            opc, getClass(), null, short.class, short.class, VECTOR_OPER_TYPE, length(),
              this, null,
              UN_IMPL.find(op, opc, ShortVector::unaryOperations));
      }
@@@ -710,7 -723,7 +725,7 @@@
          }
          int opc = opCode(op);
          return VectorSupport.unaryOp(
--            opc, getClass(), maskClass, short.class, length(),
++            opc, getClass(), maskClass, short.class, short.class, VECTOR_OPER_TYPE, length(),
              this, m,
              UN_IMPL.find(op, opc, ShortVector::unaryOperations));
      }
@@@ -782,7 -796,7 +798,7 @@@
  
          int opc = opCode(op);
          return VectorSupport.binaryOp(
--            opc, getClass(), null, short.class, length(),
++            opc, getClass(), null, short.class, short.class, VECTOR_OPER_TYPE, length(),
              this, that, null,
              BIN_IMPL.find(op, opc, ShortVector::binaryOperations));
      }
@@@ -832,7 -847,7 +849,7 @@@
  
          int opc = opCode(op);
          return VectorSupport.binaryOp(
--            opc, getClass(), maskClass, short.class, length(),
++            opc, getClass(), maskClass, short.class, short.class, VECTOR_OPER_TYPE, length(),
              this, that, m,
              BIN_IMPL.find(op, opc, ShortVector::binaryOperations));
      }
@@@ -1006,7 -1034,7 +1036,7 @@@
          e &= SHIFT_MASK;
          int opc = opCode(op);
          return VectorSupport.broadcastInt(
--            opc, getClass(), null, short.class, length(),
++            opc, getClass(), null, short.class, short.class, VECTOR_OPER_TYPE, length(),
              this, e, null,
              BIN_INT_IMPL.find(op, opc, ShortVector::broadcastIntOperations));
      }
@@@ -1027,7 -1055,7 +1057,7 @@@
          e &= SHIFT_MASK;
          int opc = opCode(op);
          return VectorSupport.broadcastInt(
--            opc, getClass(), maskClass, short.class, length(),
++            opc, getClass(), maskClass, short.class, short.class, VECTOR_OPER_TYPE, length(),
              this, e, m,
              BIN_INT_IMPL.find(op, opc, ShortVector::broadcastIntOperations));
      }
@@@ -1104,7 -1132,7 +1134,7 @@@
          }
          int opc = opCode(op);
          return VectorSupport.ternaryOp(
--            opc, getClass(), null, short.class, length(),
++            opc, getClass(), null, short.class, short.class, VECTOR_OPER_TYPE, length(),
              this, that, tother, null,
              TERN_IMPL.find(op, opc, ShortVector::ternaryOperations));
      }
@@@ -1144,7 -1172,7 +1174,7 @@@
          }
          int opc = opCode(op);
          return VectorSupport.ternaryOp(
--            opc, getClass(), maskClass, short.class, length(),
++            opc, getClass(), maskClass, short.class, short.class, VECTOR_OPER_TYPE, length(),
              this, that, tother, m,
              TERN_IMPL.find(op, opc, ShortVector::ternaryOperations));
      }
@@@ -2043,7 -2071,7 +2073,7 @@@
          that.check(this);
          int opc = opCode(op);
          return VectorSupport.compare(
--            opc, getClass(), maskType, short.class, length(),
++            opc, getClass(), maskType, short.class, short.class, VECTOR_OPER_TYPE, length(),
              this, that, null,
              (cond, v0, v1, m1) -> {
                  AbstractMask<Short> m
@@@ -2065,7 -2093,7 +2095,7 @@@
          m.check(maskType, this);
          int opc = opCode(op);
          return VectorSupport.compare(
--            opc, getClass(), maskType, short.class, length(),
++            opc, getClass(), maskType, short.class, short.class, VECTOR_OPER_TYPE, length(),
              this, that, m,
              (cond, v0, v1, m1) -> {
                  AbstractMask<Short> cmpM
@@@ -2196,7 -2224,7 +2226,7 @@@
      blendTemplate(Class<M> maskType, ShortVector v, M m) {
          v.check(this);
          return VectorSupport.blend(
--            getClass(), maskType, short.class, length(),
++            getClass(), maskType, short.class, short.class, VECTOR_OPER_TYPE, length(),
              this, v, m,
              (v0, v1, m_) -> v0.bOp(v1, m_, (i, a, b) -> b));
      }
@@@ -2213,7 -2241,7 +2243,7 @@@
          // make sure VLENGTH*scale doesn't overflow:
          vsp.checkScale(scale);
          return VectorSupport.indexVector(
--            getClass(), short.class, length(),
++            getClass(), short.class, short.class, VECTOR_OPER_TYPE, length(),
              this, scale, vsp,
              (v, scale_, s)
              -> {
@@@ -2401,12 -2431,12 +2433,12 @@@
      final
      <S extends VectorShuffle<Short>>
      ShortVector rearrangeTemplate(Class<S> shuffletype, S shuffle) {
-         shuffle.checkIndexes();
+         Objects.requireNonNull(shuffle);
          return VectorSupport.rearrangeOp(
--            getClass(), shuffletype, null, short.class, length(),
++            getClass(), shuffletype, null, short.class, short.class, VECTOR_OPER_TYPE, length(),
              this, shuffle, null,
              (v1, s_, m_) -> v1.uOp((i, a) -> {
-                 int ei = s_.laneSource(i);
+                 int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
                  return v1.lane(ei);
              }));
      }
@@@ -2427,19 -2457,14 +2459,14 @@@
                                             Class<M> masktype,
                                             S shuffle,
                                             M m) {
- 
+         Objects.requireNonNull(shuffle);
          m.check(masktype, this);
-         VectorMask<Short> valid = shuffle.laneIsValid();
-         if (m.andNot(valid).anyTrue()) {
-             shuffle.checkIndexes();
-             throw new AssertionError();
-         }
          return VectorSupport.rearrangeOp(
--                   getClass(), shuffletype, masktype, short.class, length(),
++                   getClass(), shuffletype, masktype, short.class, short.class, VECTOR_OPER_TYPE, length(),
                     this, shuffle, m,
                     (v1, s_, m_) -> v1.uOp((i, a) -> {
-                         int ei = s_.laneSource(i);
-                         return ei < 0  || !m_.laneIsSet(i) ? 0 : v1.lane(ei);
+                         int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
+                         return !m_.laneIsSet(i) ? 0 : v1.lane(ei);
                     }));
      }
  
@@@ -2459,22 -2484,20 +2486,20 @@@
                                             S shuffle,
                                             ShortVector v) {
          VectorMask<Short> valid = shuffle.laneIsValid();
-         @SuppressWarnings("unchecked")
-         S ws = (S) shuffle.wrapIndexes();
          ShortVector r0 =
              VectorSupport.rearrangeOp(
--                getClass(), shuffletype, null, short.class, length(),
-                 this, ws, null,
++                getClass(), shuffletype, null, short.class, short.class, VECTOR_OPER_TYPE, length(),
+                 this, shuffle, null,
                  (v0, s_, m_) -> v0.uOp((i, a) -> {
-                     int ei = s_.laneSource(i);
+                     int ei = Integer.remainderUnsigned(s_.laneSource(i), v0.length());
                      return v0.lane(ei);
                  }));
          ShortVector r1 =
              VectorSupport.rearrangeOp(
--                getClass(), shuffletype, null, short.class, length(),
-                 v, ws, null,
++                getClass(), shuffletype, null, short.class, short.class, VECTOR_OPER_TYPE, length(),
+                 v, shuffle, null,
                  (v1, s_, m_) -> v1.uOp((i, a) -> {
-                     int ei = s_.laneSource(i);
+                     int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
                      return v1.lane(ei);
                  }));
          return r1.blend(r0, valid);
@@@ -2506,7 -2544,7 +2546,7 @@@
      ShortVector compressTemplate(Class<M> masktype, M m) {
        m.check(masktype, this);
        return (ShortVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,
--                                                        short.class, length(), this, m,
++                                                        short.class, short.class, VECTOR_OPER_TYPE, length(), this, m,
                                                          (v1, m1) -> compressHelper(v1, m1));
      }
  
@@@ -2525,7 -2563,7 +2565,7 @@@
      ShortVector expandTemplate(Class<M> masktype, M m) {
        m.check(masktype, this);
        return (ShortVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,
--                                                        short.class, length(), this, m,
++                                                        short.class, short.class, VECTOR_OPER_TYPE, length(), this, m,
                                                          (v1, m1) -> expandHelper(v1, m1));
      }
  
@@@ -2540,7 -2578,10 +2580,10 @@@
      /*package-private*/
      @ForceInline
      final ShortVector selectFromTemplate(ShortVector v) {
-         return v.rearrange(this.toShuffle());
 -        return (ShortVector)VectorSupport.selectFromOp(getClass(), null, short.class,
++        return (ShortVector)VectorSupport.selectFromOp(getClass(), null, short.class, short.class, VECTOR_OPER_TYPE,
+                                                         length(), this, v, null,
+                                                         (v1, v2, _m) ->
+                                                          v2.rearrange(v1.toShuffle()));
      }
  
      /**
@@@ -2552,9 -2593,31 +2595,31 @@@
  
      /*package-private*/
      @ForceInline
-     final ShortVector selectFromTemplate(ShortVector v,
-                                                   AbstractMask<Short> m) {
-         return v.rearrange(this.toShuffle(), m);
+     final
+     <M extends VectorMask<Short>>
+     ShortVector selectFromTemplate(ShortVector v,
+                                             Class<M> masktype, M m) {
+         m.check(masktype, this);
 -        return (ShortVector)VectorSupport.selectFromOp(getClass(), masktype, short.class,
++        return (ShortVector)VectorSupport.selectFromOp(getClass(), masktype, short.class, short.class, VECTOR_OPER_TYPE,
+                                                         length(), this, v, m,
+                                                         (v1, v2, _m) ->
+                                                          v2.rearrange(v1.toShuffle(), _m));
+     }
+ 
+ 
+     /**
+      * {@inheritDoc} <!--workaround-->
+      */
+     @Override
+     public abstract
+     ShortVector selectFrom(Vector<Short> v1, Vector<Short> v2);
+ 
+ 
+     /*package-private*/
+     @ForceInline
+     final ShortVector selectFromTemplate(ShortVector v1, ShortVector v2) {
 -        return VectorSupport.selectFromTwoVectorOp(getClass(), short.class, length(), this, v1, v2,
++        return VectorSupport.selectFromTwoVectorOp(getClass(), short.class, short.class, VECTOR_OPER_TYPE, length(), this, v1, v2,
+                                                    (vec1, vec2, vec3) -> selectFromTwoVectorHelper(vec1, vec2, vec3));
      }
  
      /// Ternary operations
@@@ -2773,7 -2836,7 +2838,7 @@@
          }
          int opc = opCode(op);
          return fromBits(VectorSupport.reductionCoerced(
--            opc, getClass(), maskClass, short.class, length(),
++            opc, getClass(), maskClass, short.class, short.class, VECTOR_OPER_TYPE, length(),
              this, m,
              REDUCE_IMPL.find(op, opc, ShortVector::reductionOperations)));
      }
@@@ -2791,7 -2854,7 +2856,7 @@@
          }
          int opc = opCode(op);
          return fromBits(VectorSupport.reductionCoerced(
--            opc, getClass(), null, short.class, length(),
++            opc, getClass(), null, short.class, short.class, VECTOR_OPER_TYPE, length(),
              this, null,
              REDUCE_IMPL.find(op, opc, ShortVector::reductionOperations)));
      }
@@@ -3038,7 -3108,39 +3110,39 @@@
                                     short[] a, int offset,
                                     int[] indexMap, int mapOffset) {
          ShortSpecies vsp = (ShortSpecies) species;
-         return vsp.vOp(n -> a[offset + indexMap[mapOffset + n]]);
+         IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());
+         Objects.requireNonNull(a);
+         Objects.requireNonNull(indexMap);
+         Class<? extends ShortVector> vectorType = vsp.vectorType();
+ 
+ 
+         // Constant folding should sweep out following conditonal logic.
+         VectorSpecies<Integer> lsp;
+         if (isp.length() > IntVector.SPECIES_PREFERRED.length()) {
+             lsp = IntVector.SPECIES_PREFERRED;
+         } else {
+             lsp = isp;
+         }
+ 
+         // Check indices are within array bounds.
+         IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);
+         VectorIntrinsics.checkIndex(vix0, a.length);
+ 
+         int vlen = vsp.length();
+         int idx_vlen = lsp.length();
+         IntVector vix1 = null;
+         if (vlen >= idx_vlen * 2) {
+             vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);
+             VectorIntrinsics.checkIndex(vix1, a.length);
+         }
+ 
+         return VectorSupport.loadWithMap(
 -            vectorType, null, short.class, vsp.laneCount(),
++            vectorType, null, short.class, short.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+             lsp.vectorType(), lsp.length(),
+             a, ARRAY_BASE, vix0, vix1, null, null, null,
+             a, offset, indexMap, mapOffset, vsp,
+             (c, idx, iMap, idy, s, vm) ->
+             s.vOp(n -> c[idx + iMap[idy+n]]));
      }
  
      /**
@@@ -3363,8 -3468,8 +3470,8 @@@
          offset = checkFromIndexSize(offset, length(), a.length);
          ShortSpecies vsp = vspecies();
          VectorSupport.store(
--            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset),
++            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, arrayAddress(a, offset), false,
              this,
              a, offset,
              (arr, off, v)
@@@ -3511,8 -3617,8 +3619,8 @@@
          offset = checkFromIndexSize(offset, length(), a.length);
          ShortSpecies vsp = vspecies();
          VectorSupport.store(
--            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
-             a, charArrayAddress(a, offset),
++            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, charArrayAddress(a, offset), false,
              this,
              a, offset,
              (arr, off, v)
@@@ -3714,8 -3822,8 +3824,8 @@@
      ShortVector fromArray0Template(short[] a, int offset) {
          ShortSpecies vsp = vspecies();
          return VectorSupport.load(
--            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset),
++            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, arrayAddress(a, offset), false,
              a, offset, vsp,
              (arr, off, s) -> s.ldOp(arr, (int) off,
                                      (arr_, off_, i) -> arr_[off_ + i]));
@@@ -3731,13 -3839,60 +3841,60 @@@
          m.check(species());
          ShortSpecies vsp = vspecies();
          return VectorSupport.loadMasked(
--            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset), m, offsetInRange,
++            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, arrayAddress(a, offset), false, m, offsetInRange,
              a, offset, vsp,
              (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,
                                          (arr_, off_, i) -> arr_[off_ + i]));
      }
  
+     /*package-private*/
+     abstract
+     ShortVector fromArray0(short[] a, int offset,
+                                     int[] indexMap, int mapOffset,
+                                     VectorMask<Short> m);
+     @ForceInline
+     final
+     <M extends VectorMask<Short>>
+     ShortVector fromArray0Template(Class<M> maskClass, short[] a, int offset,
+                                             int[] indexMap, int mapOffset, M m) {
+         ShortSpecies vsp = vspecies();
+         IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());
+         Objects.requireNonNull(a);
+         Objects.requireNonNull(indexMap);
+         m.check(vsp);
+         Class<? extends ShortVector> vectorType = vsp.vectorType();
+ 
+ 
+         // Constant folding should sweep out following conditonal logic.
+         VectorSpecies<Integer> lsp;
+         if (isp.length() > IntVector.SPECIES_PREFERRED.length()) {
+             lsp = IntVector.SPECIES_PREFERRED;
+         } else {
+             lsp = isp;
+         }
+ 
+         // Check indices are within array bounds.
+         // FIXME: Check index under mask controlling.
+         IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);
+         VectorIntrinsics.checkIndex(vix0, a.length);
+ 
+         int vlen = vsp.length();
+         int idx_vlen = lsp.length();
+         IntVector vix1 = null;
+         if (vlen >= idx_vlen * 2) {
+             vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);
+             VectorIntrinsics.checkIndex(vix1, a.length);
+         }
+ 
+         return VectorSupport.loadWithMap(
 -            vectorType, maskClass, short.class, vsp.laneCount(),
++            vectorType, maskClass, short.class, short.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+             lsp.vectorType(), lsp.length(),
+             a, ARRAY_BASE, vix0, vix1, null, null, m,
+             a, offset, indexMap, mapOffset, vsp,
+             (c, idx, iMap, idy, s, vm) ->
+             s.vOp(vm, n -> c[idx + iMap[idy+n]]));
+     }
  
      /*package-private*/
      abstract
@@@ -3747,8 -3902,8 +3904,8 @@@
      ShortVector fromCharArray0Template(char[] a, int offset) {
          ShortSpecies vsp = vspecies();
          return VectorSupport.load(
--            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
-             a, charArrayAddress(a, offset),
++            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, charArrayAddress(a, offset), false,
              a, offset, vsp,
              (arr, off, s) -> s.ldOp(arr, (int) off,
                                      (arr_, off_, i) -> (short) arr_[off_ + i]));
@@@ -3764,8 -3919,8 +3921,8 @@@
          m.check(species());
          ShortSpecies vsp = vspecies();
          return VectorSupport.loadMasked(
--                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
-                 a, charArrayAddress(a, offset), m, offsetInRange,
++                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                 a, charArrayAddress(a, offset), false, m, offsetInRange,
                  a, offset, vsp,
                  (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,
                                              (arr_, off_, i) -> (short) arr_[off_ + i]));
@@@ -3779,7 -3934,7 +3936,7 @@@
      ShortVector fromMemorySegment0Template(MemorySegment ms, long offset) {
          ShortSpecies vsp = vspecies();
          return ScopedMemoryAccess.loadFromMemorySegment(
--                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
++                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                  (AbstractMemorySegmentImpl) ms, offset, vsp,
                  (msp, off, s) -> {
                      return s.ldLongOp((MemorySegment) msp, off, ShortVector::memorySegmentGet);
@@@ -3795,7 -3950,7 +3952,7 @@@
          ShortSpecies vsp = vspecies();
          m.check(vsp);
          return ScopedMemoryAccess.loadFromMemorySegmentMasked(
--                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
++                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                  (AbstractMemorySegmentImpl) ms, offset, m, vsp, offsetInRange,
                  (msp, off, s, vm) -> {
                      return s.ldLongOp((MemorySegment) msp, off, vm, ShortVector::memorySegmentGet);
@@@ -3813,8 -3968,8 +3970,8 @@@
      void intoArray0Template(short[] a, int offset) {
          ShortSpecies vsp = vspecies();
          VectorSupport.store(
--            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset),
++            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, arrayAddress(a, offset), false,
              this, a, offset,
              (arr, off, v)
              -> v.stOp(arr, (int) off,
@@@ -3830,8 -3985,8 +3987,8 @@@
          m.check(species());
          ShortSpecies vsp = vspecies();
          VectorSupport.storeMasked(
--            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset),
++            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, arrayAddress(a, offset), false,
              this, m, a, offset,
              (arr, off, v, vm)
              -> v.stOp(arr, (int) off, vm,
@@@ -3845,7 -4000,7 +4002,7 @@@
      void intoMemorySegment0(MemorySegment ms, long offset) {
          ShortSpecies vsp = vspecies();
          ScopedMemoryAccess.storeIntoMemorySegment(
--                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
++                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                  this,
                  (AbstractMemorySegmentImpl) ms, offset,
                  (msp, off, v) -> {
@@@ -3862,7 -4017,7 +4019,7 @@@
          ShortSpecies vsp = vspecies();
          m.check(vsp);
          ScopedMemoryAccess.storeIntoMemorySegmentMasked(
--                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
++                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                  this, m,
                  (AbstractMemorySegmentImpl) ms, offset,
                  (msp, off, v, vm) -> {
@@@ -3880,8 -4035,8 +4037,8 @@@
          m.check(species());
          ShortSpecies vsp = vspecies();
          VectorSupport.storeMasked(
--            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
-             a, charArrayAddress(a, offset),
++            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, charArrayAddress(a, offset), false,
              this, m, a, offset,
              (arr, off, v, vm)
              -> v.stOp(arr, (int) off, vm,
@@@ -4003,10 -4138,11 +4140,11 @@@
      @ForceInline
      @Override
      public final
 -    Vector<?>
 +    HalffloatVector
      viewAsFloatingLanes() {
-         LaneType flt = LaneType.HALFFLOAT.asFloating();
-         return (HalffloatVector) asVectorRaw(flt);
+         LaneType flt = LaneType.SHORT.asFloating();
+         // asFloating() will throw UnsupportedOperationException for the unsupported type short
+         throw new AssertionError("Cannot reach here");
      }
  
      // ================================================
@@@ -4087,6 -4223,6 +4225,19 @@@
  
          // Specializing overrides:
  
++        @ForceInline
++        final Class<?> carrierType() {
++            return short.class;
++        }
++
++        @ForceInline
++        final int operType() {
++            if (short.class.equals(Float16.class)) {
++                return VECTOR_TYPE_FP16;
++            }
++            return VECTOR_TYPE_PRIM;
++        }
++
          @Override
          @ForceInline
          public final Class<Short> elementType() {
@@@ -4119,7 -4255,7 +4270,7 @@@
          final ShortVector broadcastBits(long bits) {
              return (ShortVector)
                  VectorSupport.fromBitsCoerced(
--                    vectorType, short.class, laneCount,
++                    vectorType, short.class, short.class, VECTOR_OPER_TYPE, laneCount,
                      bits, MODE_BROADCAST, this,
                      (bits_, s_) -> s_.rvOp(i -> bits_));
          }
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/VectorIntrinsics.java
index b25e6c9db18,266a843083a..e92ce3bc568
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/VectorIntrinsics.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/VectorIntrinsics.java
@@@ -30,10 -29,9 +30,11 @@@ import jdk.internal.misc.Unsafe
  import java.util.Objects;
  
  /*non-public*/ class VectorIntrinsics {
-     static final int VECTOR_ACCESS_OOB_CHECK = Integer.getInteger("jdk.incubator.vector.VECTOR_ACCESS_OOB_CHECK", 2);
+     static final int VECTOR_ACCESS_OOB_CHECK =
+             Integer.getInteger("jdk.incubator.vector.VECTOR_ACCESS_OOB_CHECK", 2);
  
 +    static final Unsafe U = Unsafe.getUnsafe();
 +
      @ForceInline
      static void requireLength(int haveLength, int length) {
          if (haveLength != length) {
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/VectorMask.java
index 40d20835534,5695dff62fb..5ebc8ce163e
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/VectorMask.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/VectorMask.java
@@@ -28,6 -28,6 +28,8 @@@ import jdk.internal.misc.Unsafe
  import jdk.internal.vm.annotation.ForceInline;
  import jdk.internal.vm.vector.VectorSupport;
  
++import static jdk.internal.vm.vector.VectorSupport.*;
++
  import java.util.Arrays;
  import java.util.Objects;
  
@@@ -206,8 -207,8 +209,8 @@@ public abstract class VectorMask<E> ext
          int laneCount = vsp.laneCount();
          offset = VectorIntrinsics.checkFromIndexSize(offset, laneCount, bits.length);
          return VectorSupport.load(
--                vsp.maskType(), vsp.elementType(), laneCount,
-                 bits, (long) offset + Unsafe.ARRAY_BOOLEAN_BASE_OFFSET,
 -                bits, (long) offset + Unsafe.ARRAY_BOOLEAN_BASE_OFFSET, false,
++                vsp.maskType(), vsp.carrierType(), vsp.elementType(),
++                vsp.operType(), laneCount, bits, (long) offset + Unsafe.ARRAY_BOOLEAN_BASE_OFFSET, false,
                  bits, offset, vsp,
                  (c, idx, s)
                    -> s.opm(n -> c[((int )idx) + n]));
@@@ -239,7 -240,7 +242,8 @@@
      public static <E> VectorMask<E> fromLong(VectorSpecies<E> species, long bits) {
          AbstractSpecies<E> vsp = (AbstractSpecies<E>) species;
          bits = bits & (0xFFFFFFFFFFFFFFFFL >>> (64 - vsp.laneCount()));
--        return VectorSupport.fromBitsCoerced(vsp.maskType(), vsp.elementType(), vsp.laneCount(), bits,
++        return VectorSupport.fromBitsCoerced(vsp.maskType(), vsp.carrierType(), vsp.elementType(),
++                                             vsp.operType(), vsp.laneCount(), bits,
                                               VectorSupport.MODE_BITS_COERCED_LONG_TO_MASK, vsp,
                                               (m, s) -> {
                                                   if (m == (m >> 1)) {
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/VectorOperators.java
index ba741ff0bc1,f4da4f42934..292c9810319
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/VectorOperators.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/VectorOperators.java
@@@ -664,8 -694,6 +694,8 @@@ public abstract class VectorOperators 
      public static final Conversion<Byte,Long> B2L = convert("B2L", 'C', byte.class, long.class, VO_KIND_CAST, VO_ALL);
      /** Convert {@code byteVal} to {@code (short)byteVal}. */
      public static final Conversion<Byte,Short> B2S = convert("B2S", 'C', byte.class, short.class, VO_KIND_CAST, VO_ALL);
 +    /** Convert {@code byteVal} to {@code (halffloat)byteVal}. */
-     public static final Conversion<Byte,Halffloat> B2H = convert("B2H", 'C', byte.class, Halffloat.class, VO_KIND_CAST, VO_ALL);
++    public static final Conversion<Byte,Float16> B2H = convert("B2H", 'C', byte.class, Float16.class, VO_KIND_CAST, VO_ALL);
      /** Convert {@code doubleVal} to {@code (byte)doubleVal}. */
      public static final Conversion<Double,Byte> D2B = convert("D2B", 'C', double.class, byte.class, VO_KIND_CAST, VO_ALL);
      /** Convert {@code doubleVal} to {@code (float)doubleVal}. */
@@@ -676,8 -704,6 +706,8 @@@
      public static final Conversion<Double,Long> D2L = convert("D2L", 'C', double.class, long.class, VO_KIND_CAST, VO_ALL);
      /** Convert {@code doubleVal} to {@code (short)doubleVal}. */
      public static final Conversion<Double,Short> D2S = convert("D2S", 'C', double.class, short.class, VO_KIND_CAST, VO_ALL);
 +    /** Convert {@code doubleVal} to {@code (halffloat)doubleVal}. */
-     public static final Conversion<Double,Halffloat> D2H = convert("D2H", 'C', double.class, Halffloat.class, VO_KIND_CAST, VO_ALL);
++    public static final Conversion<Double,Float16> D2H = convert("D2H", 'C', double.class, Float16.class, VO_KIND_CAST, VO_ALL);
      /** Convert {@code floatVal} to {@code (byte)floatVal}. */
      public static final Conversion<Float,Byte> F2B = convert("F2B", 'C', float.class, byte.class, VO_KIND_CAST, VO_ALL);
      /** Convert {@code floatVal} to {@code (double)floatVal}. */
@@@ -688,8 -714,6 +718,8 @@@
      public static final Conversion<Float,Long> F2L = convert("F2L", 'C', float.class, long.class, VO_KIND_CAST, VO_ALL);
      /** Convert {@code floatVal} to {@code (short)floatVal}. */
      public static final Conversion<Float,Short> F2S = convert("F2S", 'C', float.class, short.class, VO_KIND_CAST, VO_ALL);
 +    /** Convert {@code floatVal} to {@code (halffloat)floatVal}. */
-     public static final Conversion<Float,Halffloat> F2H = convert("F2H", 'C', float.class, Halffloat.class, VO_KIND_CAST, VO_ALL);
++    public static final Conversion<Float,Float16> F2H = convert("F2H", 'C', float.class, Float16.class, VO_KIND_CAST, VO_ALL);
      /** Convert {@code intVal} to {@code (byte)intVal}. */
      public static final Conversion<Integer,Byte> I2B = convert("I2B", 'C', int.class, byte.class, VO_KIND_CAST, VO_ALL);
      /** Convert {@code intVal} to {@code (double)intVal}. */
@@@ -700,8 -724,6 +730,8 @@@
      public static final Conversion<Integer,Long> I2L = convert("I2L", 'C', int.class, long.class, VO_KIND_CAST, VO_ALL);
      /** Convert {@code intVal} to {@code (short)intVal}. */
      public static final Conversion<Integer,Short> I2S = convert("I2S", 'C', int.class, short.class, VO_KIND_CAST, VO_ALL);
 +    /** Convert {@code intVal} to {@code (halffloat)intVal}. */
-     public static final Conversion<Integer,Halffloat> I2H = convert("I2H", 'C', int.class, Halffloat.class, VO_KIND_CAST, VO_ALL);
++    public static final Conversion<Integer,Float16> I2H = convert("I2H", 'C', int.class, Float16.class, VO_KIND_CAST, VO_ALL);
      /** Convert {@code longVal} to {@code (byte)longVal}. */
      public static final Conversion<Long,Byte> L2B = convert("L2B", 'C', long.class, byte.class, VO_KIND_CAST, VO_ALL);
      /** Convert {@code longVal} to {@code (double)longVal}. */
@@@ -712,8 -734,6 +742,8 @@@
      public static final Conversion<Long,Integer> L2I = convert("L2I", 'C', long.class, int.class, VO_KIND_CAST, VO_ALL);
      /** Convert {@code longVal} to {@code (short)longVal}. */
      public static final Conversion<Long,Short> L2S = convert("L2S", 'C', long.class, short.class, VO_KIND_CAST, VO_ALL);
 +    /** Convert {@code longVal} to {@code (halffloat)longVal}. */
-     public static final Conversion<Long,Halffloat> L2H = convert("L2H", 'C', long.class, Halffloat.class, VO_KIND_CAST, VO_ALL);
++    public static final Conversion<Long,Float16> L2H = convert("L2H", 'C', long.class, Float16.class, VO_KIND_CAST, VO_ALL);
      /** Convert {@code shortVal} to {@code (byte)shortVal}. */
      public static final Conversion<Short,Byte> S2B = convert("S2B", 'C', short.class, byte.class, VO_KIND_CAST, VO_ALL);
      /** Convert {@code shortVal} to {@code (double)shortVal}. */
@@@ -724,21 -744,6 +754,21 @@@
      public static final Conversion<Short,Integer> S2I = convert("S2I", 'C', short.class, int.class, VO_KIND_CAST, VO_ALL);
      /** Convert {@code shortVal} to {@code (long)shortVal}. */
      public static final Conversion<Short,Long> S2L = convert("S2L", 'C', short.class, long.class, VO_KIND_CAST, VO_ALL);
 +    /** Convert {@code shortVal} to {@code (halffloat)shortVal}. */
-     public static final Conversion<Short,Halffloat> S2H = convert("S2H", 'C', short.class, Halffloat.class, VO_KIND_CAST, VO_ALL);
++    public static final Conversion<Short,Float16> S2H = convert("S2H", 'C', short.class, Float16.class, VO_KIND_CAST, VO_ALL);
 +    /** Convert {@code halffloatVal} to {@code (byte)halffloatVal}. */
-     public static final Conversion<Halffloat,Byte> H2B = convert("H2B", 'C', Halffloat.class, byte.class, VO_KIND_CAST, VO_ALL);
++    public static final Conversion<Float16,Byte> H2B = convert("H2B", 'C', Float16.class, byte.class, VO_KIND_CAST, VO_ALL);
 +    /** Convert {@code halffloatVal} to {@code (short)halffloatVal}. */
-     public static final Conversion<Halffloat,Short> H2S = convert("H2S", 'C', Halffloat.class, short.class, VO_KIND_CAST, VO_ALL);
++    public static final Conversion<Float16,Short> H2S = convert("H2S", 'C', Float16.class, short.class, VO_KIND_CAST, VO_ALL);
 +    /** Convert {@code halffloatVal} to {@code (double)halffloatVal}. */
-     public static final Conversion<Halffloat,Double> H2D = convert("H2D", 'C', Halffloat.class, double.class, VO_KIND_CAST, VO_ALL);
++    public static final Conversion<Float16,Double> H2D = convert("H2D", 'C', Float16.class, double.class, VO_KIND_CAST, VO_ALL);
 +    /** Convert {@code halffloatVal} to {@code (float)halffloatVal}. */
-     public static final Conversion<Halffloat,Float> H2F = convert("H2F", 'C', Halffloat.class, float.class, VO_KIND_CAST, VO_ALL);
++    public static final Conversion<Float16,Float> H2F = convert("H2F", 'C', Float16.class, float.class, VO_KIND_CAST, VO_ALL);
 +    /** Convert {@code halffloatVal} to {@code (int)halffloatVal}. */
-     public static final Conversion<Halffloat,Integer> H2I = convert("H2I", 'C', Halffloat.class, int.class, VO_KIND_CAST, VO_ALL);
++    public static final Conversion<Float16,Integer> H2I = convert("H2I", 'C', Float16.class, int.class, VO_KIND_CAST, VO_ALL);
 +    /** Convert {@code halffloatVal} to {@code (long)halffloatVal}. */
-     public static final Conversion<Halffloat,Long> H2L = convert("H2L", 'C', Halffloat.class, long.class, VO_KIND_CAST, VO_ALL);
++    public static final Conversion<Float16,Long> H2L = convert("H2L", 'C', Float16.class, long.class, VO_KIND_CAST, VO_ALL);
 +
      /** Reinterpret bits of {@code doubleVal} as {@code long}. As if by {@link Double#doubleToRawLongBits(double)} */
      public static final Conversion<Double,Long> REINTERPRET_D2L = convert("REINTERPRET_D2L", 'R', double.class, long.class, VO_KIND_BITWISE, VO_ALL);
      /** Reinterpret bits of {@code floatVal} as {@code int}. As if by {@link Float#floatToRawIntBits(float)} */
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/VectorShape.java
index e7836b2d927,f6e36450ce0..08c91ff6390
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/VectorShape.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/VectorShape.java
@@@ -263,9 -272,6 +272,9 @@@ public enum VectorShape 
          // VectorSupport.getMaxLaneCount may return -1 if C2 is not enabled,
          // or a value smaller than the S_64_BIT.vectorBitSize / elementSizeInBits if MaxVectorSize < 16
          // If so default to S_64_BIT
-         if (etype == Halffloat.class) {
++        if (etype == Float16.class) {
 +            etype = short.class;
 +        }
          int maxLaneCount = VectorSupport.getMaxLaneCount(etype);
          int elementSizeInBits = LaneType.of(etype).elementSize;
          return Math.max(maxLaneCount * elementSizeInBits, S_64_BIT.vectorBitSize);
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/X-Vector.java.template
index 6aaf30f98f1,f7d987fd280..4c716d099ba
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/X-Vector.java.template
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/X-Vector.java.template
@@@ -41,6 -41,6 +41,9 @@@ import static jdk.internal.vm.vector.Ve
  import static jdk.incubator.vector.VectorIntrinsics.*;
  
  import static jdk.incubator.vector.VectorOperators.*;
++#if[FP16]
++import jdk.incubator.vector.Float16;
++#end[FP16]
  
  #warn This file is preprocessed before being compiled
  
@@@ -61,7 -61,7 +64,9 @@@ public abstract class $abstractvectorty
      static final int FORBID_OPCODE_KIND = VO_ONLYFP;
  #end[FP]
  
-     static final ValueLayout.Of$Elemtype$ ELEMENT_LAYOUT = ValueLayout.JAVA_$TYPE$.withBitAlignment(8);
 -    static final ValueLayout.Of$Type$ ELEMENT_LAYOUT = ValueLayout.JAVA_$TYPE$.withByteAlignment(1);
++    static final int VECTOR_OPER_TYPE = {#if[FP16]?VECTOR_TYPE_FP16:VECTOR_TYPE_PRIM};
++
++    static final ValueLayout.Of$ElemLayout$ ELEMENT_LAYOUT = ValueLayout.JAVA_$TYPE$.withByteAlignment(1);
  
      @ForceInline
      static int opCode(Operator op) {
@@@ -511,13 -511,13 +516,21 @@@
      /*package-private*/
      @ForceInline
      static long toBits($type$ e) {
++#if[FP16]
++        return e;
++#else[FP16]    
          return {#if[FP]? $Type$.$type$ToRaw$Bitstype$Bits(e): e};
++#end[FP16]
      }
  
      /*package-private*/
      @ForceInline
      static $type$ fromBits(long bits) {
++#if[FP16]
++        return Float16.float16ToRawShortBits(Float16.valueOf(bits));
++#else[FP16]
          return {#if[FP]?$Type$.$bitstype$BitsTo$Type$}(($bitstype$)bits);
++#end[FP16]
      }
  
      static $abstractvectortype$ expandHelper(Vector<$Boxtype$> v, VectorMask<$Boxtype$> m) {
@@@ -575,17 -588,11 +601,11 @@@
      public static $abstractvectortype$ zero(VectorSpecies<$Boxtype$> species) {
          $Type$Species vsp = ($Type$Species) species;
  #if[FP]
- #if[short]
-         return VectorSupport.fromBitsCoerced(vsp.vectorType(), Halffloat.class, species.length(),
-                         toBits((short)0), MODE_BROADCAST, vsp,
 -        return VectorSupport.fromBitsCoerced(vsp.vectorType(), $type$.class, species.length(),
 -                        toBits(0.0f), MODE_BROADCAST, vsp,
++        return VectorSupport.fromBitsCoerced(vsp.vectorType(), $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, species.length(),
++                        toBits({#if[FP16]?(short) 0:0.0f}), MODE_BROADCAST, vsp,
                          ((bits_, s_) -> s_.rvOp(i -> bits_)));
- #else[short]
-         return VectorSupport.fromBitsCoerced(vsp.vectorType(), $type$.class, species.length(),
-                         toBits(0.0f), MODE_BROADCAST, vsp,
-                         ((bits_, s_) -> s_.rvOp(i -> bits_)));
- #end[short]
  #else[FP]
--        return VectorSupport.fromBitsCoerced(vsp.vectorType(), $type$.class, species.length(),
++        return VectorSupport.fromBitsCoerced(vsp.vectorType(), $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, species.length(),
                                  0, MODE_BROADCAST, vsp,
                                  ((bits_, s_) -> s_.rvOp(i -> bits_)));
  #end[FP]
@@@ -712,7 -724,7 +737,7 @@@
          }
          int opc = opCode(op);
          return VectorSupport.unaryOp(
-             opc, getClass(), null, $elemtype$.class, length(),
 -            opc, getClass(), null, $type$.class, length(),
++            opc, getClass(), null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
              this, null,
              UN_IMPL.find(op, opc, $abstractvectortype$::unaryOperations));
      }
@@@ -742,7 -759,7 +772,7 @@@
          }
          int opc = opCode(op);
          return VectorSupport.unaryOp(
-             opc, getClass(), maskClass, $elemtype$.class, length(),
 -            opc, getClass(), maskClass, $type$.class, length(),
++            opc, getClass(), maskClass, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
              this, m,
              UN_IMPL.find(op, opc, $abstractvectortype$::unaryOperations));
      }
@@@ -788,7 -814,6 +827,7 @@@
  #end[BITWISE]
  #end[!FP]
  #if[FP]
- #if[!short]
++#if[!FP16]
              case VECTOR_OP_SIN: return (v0, m) ->
                      v0.uOp(m, (i, a) -> ($type$) Math.sin(a));
              case VECTOR_OP_COS: return (v0, m) ->
@@@ -821,40 -846,6 +860,40 @@@
                      v0.uOp(m, (i, a) -> ($type$) Math.expm1(a));
              case VECTOR_OP_LOG1P: return (v0, m) ->
                      v0.uOp(m, (i, a) -> ($type$) Math.log1p(a));
- #else[!short]
++#else[!FP16]
 +            case VECTOR_OP_SIN: return (v0, m) ->
-                     v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.sin(Float.float16ToFloat(a))));
++                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.sin(Float16.shortBitsToFloat16(a).doubleValue()))));
 +            case VECTOR_OP_COS: return (v0, m) ->
-                     v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.cos(Float.float16ToFloat(a))));
++                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.cos(Float16.shortBitsToFloat16(a).doubleValue()))));
 +            case VECTOR_OP_TAN: return (v0, m) ->
-                     v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.tan(Float.float16ToFloat(a))));
++                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.tan(Float16.shortBitsToFloat16(a).doubleValue()))));
 +            case VECTOR_OP_ASIN: return (v0, m) ->
-                     v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.asin(Float.float16ToFloat(a))));
++                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.asin(Float16.shortBitsToFloat16(a).doubleValue()))));
 +            case VECTOR_OP_ACOS: return (v0, m) ->
-                     v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.acos(Float.float16ToFloat(a))));
++                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.acos(Float16.shortBitsToFloat16(a).doubleValue()))));
 +            case VECTOR_OP_ATAN: return (v0, m) ->
-                     v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.atan(Float.float16ToFloat(a))));
++                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.atan(Float16.shortBitsToFloat16(a).doubleValue()))));
 +            case VECTOR_OP_EXP: return (v0, m) ->
-                     v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.exp(Float.float16ToFloat(a))));
++                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.exp(Float16.shortBitsToFloat16(a).doubleValue()))));
 +            case VECTOR_OP_LOG: return (v0, m) ->
-                     v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.log(Float.float16ToFloat(a))));
++                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.log(Float16.shortBitsToFloat16(a).doubleValue()))));
 +            case VECTOR_OP_LOG10: return (v0, m) ->
-                     v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.log10(Float.float16ToFloat(a))));
++                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.log10(Float16.shortBitsToFloat16(a).doubleValue()))));
 +            case VECTOR_OP_SQRT: return (v0, m) ->
-                     v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));
++                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.sqrt(Float16.shortBitsToFloat16(a).doubleValue()))));
 +            case VECTOR_OP_CBRT: return (v0, m) ->
-                     v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.cbrt(Float.float16ToFloat(a))));
++                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.cbrt(Float16.shortBitsToFloat16(a).doubleValue()))));
 +            case VECTOR_OP_SINH: return (v0, m) ->
-                     v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.sinh(Float.float16ToFloat(a))));
++                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.sinh(Float16.shortBitsToFloat16(a).doubleValue()))));
 +            case VECTOR_OP_COSH: return (v0, m) ->
-                     v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.cosh(Float.float16ToFloat(a))));
++                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.cosh(Float16.shortBitsToFloat16(a).doubleValue()))));
 +            case VECTOR_OP_TANH: return (v0, m) ->
-                     v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.tanh(Float.float16ToFloat(a))));
++                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.tanh(Float16.shortBitsToFloat16(a).doubleValue()))));
 +            case VECTOR_OP_EXPM1: return (v0, m) ->
-                     v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.expm1(Float.float16ToFloat(a))));
++                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.expm1(Float16.shortBitsToFloat16(a).doubleValue()))));
 +            case VECTOR_OP_LOG1P: return (v0, m) ->
-                     v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.log1p(Float.float16ToFloat(a))));
- #end[!short]
++                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.log1p(Float16.shortBitsToFloat16(a).doubleValue()))));
++#end[!FP16]
  #end[FP]
              default: return null;
          }
@@@ -907,7 -903,7 +951,7 @@@
  
          int opc = opCode(op);
          return VectorSupport.binaryOp(
-             opc, getClass(), null, $elemtype$.class, length(),
 -            opc, getClass(), null, $type$.class, length(),
++            opc, getClass(), null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
              this, that, null,
              BIN_IMPL.find(op, opc, $abstractvectortype$::binaryOperations));
      }
@@@ -968,7 -970,7 +1018,7 @@@
  
          int opc = opCode(op);
          return VectorSupport.binaryOp(
-             opc, getClass(), maskClass, $elemtype$.class, length(),
 -            opc, getClass(), maskClass, $type$.class, length(),
++            opc, getClass(), maskClass, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
              this, that, m,
              BIN_IMPL.find(op, opc, $abstractvectortype$::binaryOperations));
      }
@@@ -979,20 -990,6 +1038,20 @@@
  
      private static BinaryOperation<$abstractvectortype$, VectorMask<$Boxtype$>> binaryOperations(int opc_) {
          switch (opc_) {
 +#if[FP16]
 +            case VECTOR_OP_ADD: return (v0, v1, vm) ->
-                     v0.bOp(v1, vm, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b)));
++                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.add(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b))));
 +            case VECTOR_OP_SUB: return (v0, v1, vm) ->
-                     v0.bOp(v1, vm, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b)));
++                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.subtract(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b))));
 +            case VECTOR_OP_MUL: return (v0, v1, vm) ->
-                     v0.bOp(v1, vm, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(a) * Float.float16ToFloat(b)));
++                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.multiply(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b))));
 +            case VECTOR_OP_DIV: return (v0, v1, vm) ->
-                     v0.bOp(v1, vm, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(a) / Float.float16ToFloat(b)));
++                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.divide(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b))));
 +            case VECTOR_OP_MAX: return (v0, v1, vm) ->
-                     v0.bOp(v1, vm, (i, a, b) -> Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b))));
++                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.max(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b))));
 +            case VECTOR_OP_MIN: return (v0, v1, vm) ->
-                     v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));
++                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.min(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b))));
 +#else[FP16]
              case VECTOR_OP_ADD: return (v0, v1, vm) ->
                      v0.bOp(v1, vm, (i, a, b) -> ($type$)(a + b));
              case VECTOR_OP_SUB: return (v0, v1, vm) ->
@@@ -1031,7 -1039,6 +1102,7 @@@
  #end[intOrLong]
  #end[BITWISE]
  #if[FP]
- #if[!short]
++#if[!FP16]
              case VECTOR_OP_OR: return (v0, v1, vm) ->
                      v0.bOp(v1, vm, (i, a, b) -> fromBits(toBits(a) | toBits(b)));
              case VECTOR_OP_ATAN2: return (v0, v1, vm) ->
@@@ -1040,14 -1047,6 +1111,14 @@@
                      v0.bOp(v1, vm, (i, a, b) -> ($type$) Math.pow(a, b));
              case VECTOR_OP_HYPOT: return (v0, v1, vm) ->
                      v0.bOp(v1, vm, (i, a, b) -> ($type$) Math.hypot(a, b));
- #else[!short]
++#else[!FP16]
 +            case VECTOR_OP_ATAN2: return (v0, v1, vm) ->
-                     v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf((float) Math.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b))));
++                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.atan2(Float16.shortBitsToFloat16(a).floatValue(), Float16.shortBitsToFloat16(b).floatValue()))));
 +            case VECTOR_OP_POW: return (v0, v1, vm) ->
-                     v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b))));
++                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.pow(Float16.shortBitsToFloat16(a).floatValue(), Float16.shortBitsToFloat16(b).floatValue()))));
 +            case VECTOR_OP_HYPOT: return (v0, v1, vm) ->
-                     v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf((float) Math.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b))));
- #end[!short]
++                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.hypot(Float16.shortBitsToFloat16(a).floatValue(), Float16.shortBitsToFloat16(b).floatValue()))));
++#end[!FP16]
  #end[FP]
              default: return null;
          }
@@@ -1199,7 -1198,7 +1270,7 @@@
          e &= SHIFT_MASK;
          int opc = opCode(op);
          return VectorSupport.broadcastInt(
--            opc, getClass(), null, $type$.class, length(),
++            opc, getClass(), null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
              this, e, null,
              BIN_INT_IMPL.find(op, opc, $abstractvectortype$::broadcastIntOperations));
      }
@@@ -1220,7 -1219,7 +1291,7 @@@
          e &= SHIFT_MASK;
          int opc = opCode(op);
          return VectorSupport.broadcastInt(
-             opc, getClass(), maskClass, $elemtype$.class, length(),
 -            opc, getClass(), maskClass, $type$.class, length(),
++            opc, getClass(), maskClass, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
              this, e, m,
              BIN_INT_IMPL.find(op, opc, $abstractvectortype$::broadcastIntOperations));
      }
@@@ -1304,7 -1303,7 +1375,7 @@@
  #end[BITWISE]
          int opc = opCode(op);
          return VectorSupport.ternaryOp(
-             opc, getClass(), null, $elemtype$.class, length(),
 -            opc, getClass(), null, $type$.class, length(),
++            opc, getClass(), null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
              this, that, tother, null,
              TERN_IMPL.find(op, opc, $abstractvectortype$::ternaryOperations));
      }
@@@ -1346,7 -1345,7 +1417,7 @@@
  #end[BITWISE]
          int opc = opCode(op);
          return VectorSupport.ternaryOp(
-             opc, getClass(), maskClass, $elemtype$.class, length(),
 -            opc, getClass(), maskClass, $type$.class, length(),
++            opc, getClass(), maskClass, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
              this, that, tother, m,
              TERN_IMPL.find(op, opc, $abstractvectortype$::ternaryOperations));
      }
@@@ -1358,13 -1357,8 +1429,13 @@@
      private static TernaryOperation<$abstractvectortype$, VectorMask<$Boxtype$>> ternaryOperations(int opc_) {
          switch (opc_) {
  #if[FP]
- #if[short]
++#if[FP16]
 +            case VECTOR_OP_FMA: return (v0, v1_, v2_, m) -> v0.tOp(v1_, v2_, m, (i, a, b, c) ->
-                     Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));
- #else[short]
++                                        Float16.float16ToRawShortBits(Float16.fma(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b), Float16.shortBitsToFloat16(c))));
++#else[FP16]
              case VECTOR_OP_FMA: return (v0, v1_, v2_, m) ->
                      v0.tOp(v1_, v2_, m, (i, a, b, c) -> Math.fma(a, b, c));
- #end[short]
++#end[FP16]
  #end[FP]
              default: return null;
          }
@@@ -2393,7 -2387,7 +2464,7 @@@
                  // first kill the sign:
                  bits = bits.and($Boxbitstype$.MAX_VALUE);
                  // next find the bit pattern for infinity:
--                $bitstype$ infbits = ($bitstype$) toBits($Boxtype$.POSITIVE_INFINITY);
++                $bitstype$ infbits = ($bitstype$) toBits({#if[FP16]?Float16.float16ToRawShortBits($Boxtype$.POSITIVE_INFINITY):$Boxtype$.POSITIVE_INFINITY});
                  // now compare:
                  if (op == IS_FINITE) {
                      m = bits.compare(LT, infbits);
@@@ -2447,7 -2441,7 +2518,7 @@@
                  // first kill the sign:
                  bits = bits.and($Boxbitstype$.MAX_VALUE);
                  // next find the bit pattern for infinity:
--                $bitstype$ infbits = ($bitstype$) toBits($Boxtype$.POSITIVE_INFINITY);
++                $bitstype$ infbits = ($bitstype$) toBits({#if[FP16]?Float16.float16ToRawShortBits($Boxtype$.POSITIVE_INFINITY):$Boxtype$.POSITIVE_INFINITY});
                  // now compare:
                  if (op == IS_FINITE) {
                      m = bits.compare(LT, infbits, m);
@@@ -2483,7 -2477,7 +2554,7 @@@
          that.check(this);
          int opc = opCode(op);
          return VectorSupport.compare(
-             opc, getClass(), maskType, $elemtype$.class, length(),
 -            opc, getClass(), maskType, $type$.class, length(),
++            opc, getClass(), maskType, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
              this, that, null,
              (cond, v0, v1, m1) -> {
                  AbstractMask<$Boxtype$> m
@@@ -2505,7 -2499,7 +2576,7 @@@
          m.check(maskType, this);
          int opc = opCode(op);
          return VectorSupport.compare(
-             opc, getClass(), maskType, $elemtype$.class, length(),
 -            opc, getClass(), maskType, $type$.class, length(),
++            opc, getClass(), maskType, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
              this, that, m,
              (cond, v0, v1, m1) -> {
                  AbstractMask<$Boxtype$> cmpM
@@@ -2518,33 -2512,14 +2589,23 @@@
      }
  
      @ForceInline
--    private static boolean compareWithOp(int cond, $type$ a, $type$ b) {
++    private static boolean compareWithOp(int cond, $carriertype$ a, $carriertype$ b) {
          return switch (cond) {
- #if[FP]
- #if[!short]
-             case BT_eq -> a == b;
-             case BT_ne -> a != b;
-             case BT_lt -> a < b;
-             case BT_le -> a <= b;
-             case BT_gt -> a > b;
-             case BT_ge -> a >= b;
- #end[!short]
- #if[short]
++#if[FP16]
 +            case BT_eq -> Float.float16ToFloat(a) == Float.float16ToFloat(b);
 +            case BT_ne -> Float.float16ToFloat(a) != Float.float16ToFloat(b);
 +            case BT_lt -> Float.float16ToFloat(a) < Float.float16ToFloat(b);
 +            case BT_le -> Float.float16ToFloat(a) <= Float.float16ToFloat(b);
 +            case BT_gt -> Float.float16ToFloat(a) > Float.float16ToFloat(b);
 +            case BT_ge -> Float.float16ToFloat(a) >= Float.float16ToFloat(b);
- #end[short]
- #else[FP]
++#else[FP16]
              case BT_eq -> a == b;
              case BT_ne -> a != b;
              case BT_lt -> a < b;
              case BT_le -> a <= b;
              case BT_gt -> a > b;
              case BT_ge -> a >= b;
- #end[FP]
++#end[FP16]
  #if[!FP]
              case BT_ult -> $Boxtype$.compareUnsigned(a, b) < 0;
              case BT_ule -> $Boxtype$.compareUnsigned(a, b) <= 0;
@@@ -2659,7 -2634,7 +2720,7 @@@
      blendTemplate(Class<M> maskType, $abstractvectortype$ v, M m) {
          v.check(this);
          return VectorSupport.blend(
-             getClass(), maskType, $elemtype$.class, length(),
 -            getClass(), maskType, $type$.class, length(),
++            getClass(), maskType, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
              this, v, m,
              (v0, v1, m_) -> v0.bOp(v1, m_, (i, a, b) -> b));
      }
@@@ -2676,7 -2651,7 +2737,7 @@@
          // make sure VLENGTH*scale doesn't overflow:
          vsp.checkScale(scale);
          return VectorSupport.indexVector(
-             getClass(), $elemtype$.class, length(),
 -            getClass(), $type$.class, length(),
++            getClass(), $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
              this, scale, vsp,
              (v, scale_, s)
              -> {
@@@ -2685,11 -2660,7 +2746,7 @@@
                  // and multiply.
                  $abstractvectortype$ iota = s.iota();
                  $type$ sc = ($type$) scale_;
- #if[FP16]
-                 return v.add(sc == 1 ? iota : iota.mul(Float.floatToFloat16((float) sc)));
- #else[FP16]
--                return v.add(sc == 1 ? iota : iota.mul(sc));
- #end[FP16]
++                return v.add(sc == 1 ? iota : iota.mul({#if[FP16]?Float16.float16ToRawShortBits(Float16.valueOf(sc)):sc}));
              });
      }
  
@@@ -2870,12 -2863,12 +2949,12 @@@
      final
      <S extends VectorShuffle<$Boxtype$>>
      $abstractvectortype$ rearrangeTemplate(Class<S> shuffletype, S shuffle) {
-         shuffle.checkIndexes();
+         Objects.requireNonNull(shuffle);
          return VectorSupport.rearrangeOp(
-             getClass(), shuffletype, null, $elemtype$.class, length(),
 -            getClass(), shuffletype, null, $type$.class, length(),
++            getClass(), shuffletype, null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
              this, shuffle, null,
              (v1, s_, m_) -> v1.uOp((i, a) -> {
-                 int ei = s_.laneSource(i);
+                 int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
                  return v1.lane(ei);
              }));
      }
@@@ -2896,19 -2889,14 +2975,14 @@@
                                             Class<M> masktype,
                                             S shuffle,
                                             M m) {
- 
+         Objects.requireNonNull(shuffle);
          m.check(masktype, this);
-         VectorMask<$Boxtype$> valid = shuffle.laneIsValid();
-         if (m.andNot(valid).anyTrue()) {
-             shuffle.checkIndexes();
-             throw new AssertionError();
-         }
          return VectorSupport.rearrangeOp(
-                    getClass(), shuffletype, masktype, $elemtype$.class, length(),
 -                   getClass(), shuffletype, masktype, $type$.class, length(),
++                   getClass(), shuffletype, masktype, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
                     this, shuffle, m,
                     (v1, s_, m_) -> v1.uOp((i, a) -> {
-                         int ei = s_.laneSource(i);
-                         return ei < 0  || !m_.laneIsSet(i) ? 0 : v1.lane(ei);
+                         int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
+                         return !m_.laneIsSet(i) ? 0 : v1.lane(ei);
                     }));
      }
  
@@@ -2928,22 -2916,20 +3002,20 @@@
                                             S shuffle,
                                             $abstractvectortype$ v) {
          VectorMask<$Boxtype$> valid = shuffle.laneIsValid();
-         @SuppressWarnings("unchecked")
-         S ws = (S) shuffle.wrapIndexes();
          $abstractvectortype$ r0 =
              VectorSupport.rearrangeOp(
-                 getClass(), shuffletype, null, $elemtype$.class, length(),
-                 this, ws, null,
 -                getClass(), shuffletype, null, $type$.class, length(),
++                getClass(), shuffletype, null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
+                 this, shuffle, null,
                  (v0, s_, m_) -> v0.uOp((i, a) -> {
-                     int ei = s_.laneSource(i);
+                     int ei = Integer.remainderUnsigned(s_.laneSource(i), v0.length());
                      return v0.lane(ei);
                  }));
          $abstractvectortype$ r1 =
              VectorSupport.rearrangeOp(
-                 getClass(), shuffletype, null, $elemtype$.class, length(),
-                 v, ws, null,
 -                getClass(), shuffletype, null, $type$.class, length(),
++                getClass(), shuffletype, null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
+                 v, shuffle, null,
                  (v1, s_, m_) -> v1.uOp((i, a) -> {
-                     int ei = s_.laneSource(i);
+                     int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());
                      return v1.lane(ei);
                  }));
          return r1.blend(r0, valid);
@@@ -2958,6 -2948,29 +3034,32 @@@
              sa[i] = (int) a[i];
          }
          return VectorShuffle.fromArray(dsp, sa, 0);
+ #end[FP]
+     }
+ 
+     @ForceInline
+     final <F>
+     VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp, boolean wrap) {
+         assert(dsp.elementSize() == vspecies().elementSize());
++#if[FP16]
++        ShortVector idx = convert(VectorOperators.H2S, 0).reinterpretAsShorts();
++#end[FP16]
+ #if[float]
+         IntVector idx = convert(VectorOperators.F2I, 0).reinterpretAsInts();
+ #end[float]
+ #if[double]
+         LongVector idx = convert(VectorOperators.D2L, 0).reinterpretAsLongs();
+ #end[double]
+ #if[!FP]
+         $Type$Vector idx = this;
+ #end[!FP]
+         $Bitstype$Vector wrapped = idx.lanewise(VectorOperators.AND, length() - 1);
+         if (!wrap) {
+             $Bitstype$Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, length());
+             VectorMask<$Boxbitstype$> inBound = wrapped.compare(VectorOperators.EQ, idx);
+             wrapped = wrappedEx.blend(wrapped, inBound);
+         }
+         return wrapped.bitsToShuffle(dsp);
      }
  
      /**
@@@ -2975,7 -2988,7 +3077,7 @@@
      $Type$Vector compressTemplate(Class<M> masktype, M m) {
        m.check(masktype, this);
        return ($Type$Vector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,
-                                                         $elemtype$.class, length(), this, m,
 -                                                        $type$.class, length(), this, m,
++                                                        $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(), this, m,
                                                          (v1, m1) -> compressHelper(v1, m1));
      }
  
@@@ -2994,7 -3007,7 +3096,7 @@@
      $Type$Vector expandTemplate(Class<M> masktype, M m) {
        m.check(masktype, this);
        return ($Type$Vector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,
-                                                         $elemtype$.class, length(), this, m,
 -                                                        $type$.class, length(), this, m,
++                                                        $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(), this, m,
                                                          (v1, m1) -> expandHelper(v1, m1));
      }
  
@@@ -3009,7 -3022,10 +3111,10 @@@
      /*package-private*/
      @ForceInline
      final $abstractvectortype$ selectFromTemplate($abstractvectortype$ v) {
-         return v.rearrange(this.toShuffle());
 -        return ($Type$Vector)VectorSupport.selectFromOp(getClass(), null, $type$.class,
++        return ($Type$Vector)VectorSupport.selectFromOp(getClass(), null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE,
+                                                         length(), this, v, null,
+                                                         (v1, v2, _m) ->
+                                                          v2.rearrange(v1.toShuffle()));
      }
  
      /**
@@@ -3021,9 -3037,31 +3126,31 @@@
  
      /*package-private*/
      @ForceInline
-     final $abstractvectortype$ selectFromTemplate($abstractvectortype$ v,
-                                                   AbstractMask<$Boxtype$> m) {
-         return v.rearrange(this.toShuffle(), m);
+     final
+     <M extends VectorMask<$Boxtype$>>
+     $abstractvectortype$ selectFromTemplate($abstractvectortype$ v,
+                                             Class<M> masktype, M m) {
+         m.check(masktype, this);
 -        return ($Type$Vector)VectorSupport.selectFromOp(getClass(), masktype, $type$.class,
++        return ($Type$Vector)VectorSupport.selectFromOp(getClass(), masktype, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE,
+                                                         length(), this, v, m,
+                                                         (v1, v2, _m) ->
+                                                          v2.rearrange(v1.toShuffle(), _m));
+     }
+ 
+ 
+     /**
+      * {@inheritDoc} <!--workaround-->
+      */
+     @Override
+     public abstract
+     $abstractvectortype$ selectFrom(Vector<$Boxtype$> v1, Vector<$Boxtype$> v2);
+ 
+ 
+     /*package-private*/
+     @ForceInline
+     final $abstractvectortype$ selectFromTemplate($abstractvectortype$ v1, $abstractvectortype$ v2) {
 -        return VectorSupport.selectFromTwoVectorOp(getClass(), $type$.class, length(), this, v1, v2,
++        return VectorSupport.selectFromTwoVectorOp(getClass(), $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(), this, v1, v2,
+                                                    (vec1, vec2, vec3) -> selectFromTwoVectorHelper(vec1, vec2, vec3));
      }
  
      /// Ternary operations
@@@ -3371,7 -3409,7 +3498,7 @@@
          }
          int opc = opCode(op);
          return fromBits(VectorSupport.reductionCoerced(
-             opc, getClass(), maskClass, $elemtype$.class, length(),
 -            opc, getClass(), maskClass, $type$.class, length(),
++            opc, getClass(), maskClass, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
              this, m,
              REDUCE_IMPL.find(op, opc, $abstractvectortype$::reductionOperations)));
      }
@@@ -3389,7 -3427,7 +3516,7 @@@
          }
          int opc = opCode(op);
          return fromBits(VectorSupport.reductionCoerced(
-             opc, getClass(), null, $elemtype$.class, length(),
 -            opc, getClass(), null, $type$.class, length(),
++            opc, getClass(), null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),
              this, null,
              REDUCE_IMPL.find(op, opc, $abstractvectortype$::reductionOperations)));
      }
@@@ -3400,16 -3438,6 +3527,16 @@@
  
      private static ReductionOperation<$abstractvectortype$, VectorMask<$Boxtype$>> reductionOperations(int opc_) {
          switch (opc_) {
 +#if[FP16]
 +            case VECTOR_OP_ADD: return (v, m) ->
-                     toBits(v.rOp(($type$)0, m, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b))));
++                    toBits(v.rOp(($type$)0, m, (i, a, b) -> Float16.float16ToRawShortBits(Float16.add(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b)))));
 +            case VECTOR_OP_MUL: return (v, m) ->
-                     toBits(v.rOp(($type$)1, m, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(b) * Float.float16ToFloat(b))));
++                    toBits(v.rOp(($type$)0, m, (i, a, b) -> Float16.float16ToRawShortBits(Float16.multiply(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b)))));
 +            case VECTOR_OP_MIN: return (v, m) ->
-                     toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> Float.floatToFloat16(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b)))));
++                    toBits(v.rOp(($type$)0, m, (i, a, b) -> Float16.float16ToRawShortBits(Float16.min(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b)))));
 +            case VECTOR_OP_MAX: return (v, m) ->
-                     toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b)))));
++                    toBits(v.rOp(($type$)0, m, (i, a, b) -> Float16.float16ToRawShortBits(Float16.max(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b)))));
 +#else[FP16]
              case VECTOR_OP_ADD: return (v, m) ->
                      toBits(v.rOp(($type$)0, m, (i, a, b) -> ($type$)(a + b)));
              case VECTOR_OP_MUL: return (v, m) ->
@@@ -3418,7 -3446,14 +3545,15 @@@
                      toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> ($type$) Math.min(a, b)));
              case VECTOR_OP_MAX: return (v, m) ->
                      toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> ($type$) Math.max(a, b)));
 +#end[FP16]
+ #if[!FP]
+             case VECTOR_OP_UMIN: return (v, m) ->
+                     toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> ($type$) VectorMath.minUnsigned(a, b)));
+             case VECTOR_OP_UMAX: return (v, m) ->
+                     toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> ($type$) VectorMath.maxUnsigned(a, b)));
+             case VECTOR_OP_SUADD: return (v, m) ->
+                     toBits(v.rOp(($type$)0, m, (i, a, b) -> ($type$) VectorMath.addSaturatingUnsigned(a, b)));
+ #end[!FP]
  #if[BITWISE]
              case VECTOR_OP_AND: return (v, m) ->
                      toBits(v.rOp(($type$)-1, m, (i, a, b) -> ($type$)(a & b)));
@@@ -3432,8 -3467,8 +3567,8 @@@
      }
  
  #if[FP]
--    private static final $type$ MIN_OR_INF = $Boxtype$.NEGATIVE_INFINITY;
--    private static final $type$ MAX_OR_INF = $Boxtype$.POSITIVE_INFINITY;
++    private static final $type$ MIN_OR_INF = {#if[FP16]?Float16.float16ToRawShortBits($Boxtype$.NEGATIVE_INFINITY):$Boxtype$.NEGATIVE_INFINITY};
++    private static final $type$ MAX_OR_INF = {#if[FP16]?Float16.float16ToRawShortBits($Boxtype$.POSITIVE_INFINITY):$Boxtype$.POSITIVE_INFINITY};
  #else[FP]
      private static final $type$ MIN_OR_INF = $Boxtype$.MIN_VALUE;
      private static final $type$ MAX_OR_INF = $Boxtype$.MAX_VALUE;
@@@ -3570,11 -3605,7 +3705,7 @@@
          $type$[] a = toArray();
          long[] res = new long[a.length];
          for (int i = 0; i < a.length; i++) {
- #if[FP16]
-             $type$ e = (short) Halffloat.valueOf(a[i]).floatValue();
- #else[FP16]
--            $type$ e = a[i];
- #end[FP16]
++            $type$ e = {#if[FP16]?Float16.shortBitsToFloat16(a[i]).shortValue():a[i]};
              res[i] = $Type$Species.toIntegralChecked(e, false);
          }
          return res;
@@@ -3615,11 -3646,7 +3746,7 @@@
          $type$[] a = toArray();
          double[] res = new double[a.length];
          for (int i = 0; i < a.length; i++) {
- #if[FP16]
-             res[i] = (double) Halffloat.valueOf(a[i]).floatValue();
- #else[FP16]
--            res[i] = (double) a[i];
- #end[FP16]
++            res[i] = (double) {#if[FP16]?Float16.shortBitsToFloat16(a[i]).doubleValue():a[i]};
          }
          return res;
      }
@@@ -3722,7 -3750,58 +3850,58 @@@
                                     $type$[] a, int offset,
                                     int[] indexMap, int mapOffset) {
          $Type$Species vsp = ($Type$Species) species;
-         return vsp.vOp(n -> a[offset + indexMap[mapOffset + n]]);
+         IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());
+         Objects.requireNonNull(a);
+         Objects.requireNonNull(indexMap);
+         Class<? extends $abstractvectortype$> vectorType = vsp.vectorType();
+ 
+ 
+         // Constant folding should sweep out following conditonal logic.
+         VectorSpecies<Integer> lsp;
+         if (isp.length() > IntVector.SPECIES_PREFERRED.length()) {
+             lsp = IntVector.SPECIES_PREFERRED;
+         } else {
+             lsp = isp;
+         }
+ 
+         // Check indices are within array bounds.
+         IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);
+         VectorIntrinsics.checkIndex(vix0, a.length);
+ 
+         int vlen = vsp.length();
+         int idx_vlen = lsp.length();
+         IntVector vix1 = null;
+         if (vlen >= idx_vlen * 2) {
+             vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);
+             VectorIntrinsics.checkIndex(vix1, a.length);
+         }
+ 
+ #if[byte]
+         IntVector vix2 = null;
+         IntVector vix3 = null;
+         if (vlen == idx_vlen * 4) {
+             vix2 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 2).add(offset);
+             VectorIntrinsics.checkIndex(vix2, a.length);
+             vix3 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 3).add(offset);
+             VectorIntrinsics.checkIndex(vix3, a.length);
+         }
+ 
+         return VectorSupport.loadWithMap(
 -            vectorType, null, $type$.class, vsp.laneCount(),
++            vectorType, null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+             lsp.vectorType(), lsp.length(),
+             a, ARRAY_BASE, vix0, vix1, vix2, vix3, null,
+             a, offset, indexMap, mapOffset, vsp,
+             (c, idx, iMap, idy, s, vm) ->
+             s.vOp(n -> c[idx + iMap[idy+n]]));
+ #else[byte]
+         return VectorSupport.loadWithMap(
 -            vectorType, null, $type$.class, vsp.laneCount(),
++            vectorType, null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+             lsp.vectorType(), lsp.length(),
+             a, ARRAY_BASE, vix0, vix1, null, null, null,
+             a, offset, indexMap, mapOffset, vsp,
+             (c, idx, iMap, idy, s, vm) ->
+             s.vOp(n -> c[idx + iMap[idy+n]]));
+ #end[byte]
      }
  #else[byteOrShort]
      @ForceInline
@@@ -3769,9 -3848,9 +3948,9 @@@
          vix = VectorIntrinsics.checkIndex(vix, a.length);
  
          return VectorSupport.loadWithMap(
--            vectorType, null, $type$.class, vsp.laneCount(),
-             isp.vectorType(),
-             a, ARRAY_BASE, vix, null,
++            vectorType, null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+             isp.vectorType(), isp.length(),
+             a, ARRAY_BASE, vix, null, null, null, null,
              a, offset, indexMap, mapOffset, vsp,
              (c, idx, iMap, idy, s, vm) ->
              s.vOp(n -> c[idx + iMap[idy+n]]));
@@@ -4281,8 -4347,8 +4447,8 @@@
          offset = checkFromIndexSize(offset, length(), a.length);
          $Type$Species vsp = vspecies();
          VectorSupport.store(
--            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset),
++            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, arrayAddress(a, offset), false,
              this,
              a, offset,
              (arr, off, v)
@@@ -4407,8 -4474,8 +4574,8 @@@
          vix = VectorIntrinsics.checkIndex(vix, a.length);
  
          VectorSupport.storeWithMap(
--            vsp.vectorType(), null, vsp.elementType(), vsp.laneCount(),
-             isp.vectorType(),
++            vsp.vectorType(), null, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             isp.vectorType(), isp.length(),
              a, arrayAddress(a, 0), vix,
              this, null,
              a, offset, indexMap, mapOffset,
@@@ -4500,8 -4567,8 +4667,8 @@@
          offset = checkFromIndexSize(offset, length(), a.length);
          $Type$Species vsp = vspecies();
          VectorSupport.store(
--            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
-             a, charArrayAddress(a, offset),
++            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, charArrayAddress(a, offset), false,
              this,
              a, offset,
              (arr, off, v)
@@@ -4661,8 -4729,8 +4829,8 @@@
          $Type$Species vsp = vspecies();
          ByteVector normalized = this.and((byte) 1);
          VectorSupport.store(
--            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
-             a, booleanArrayAddress(a, offset),
++            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, booleanArrayAddress(a, offset), false,
              normalized,
              a, offset,
              (arr, off, v)
@@@ -4873,8 -4943,8 +5043,8 @@@
      $abstractvectortype$ fromArray0Template($type$[] a, int offset) {
          $Type$Species vsp = vspecies();
          return VectorSupport.load(
--            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset),
++            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, arrayAddress(a, offset), false,
              a, offset, vsp,
              (arr, off, s) -> s.ldOp(arr, (int) off,
                                      (arr_, off_, i) -> arr_[off_ + i]));
@@@ -4890,8 -4960,8 +5060,8 @@@
          m.check(species());
          $Type$Species vsp = vspecies();
          return VectorSupport.loadMasked(
--            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset), m, offsetInRange,
++            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, arrayAddress(a, offset), false, m, offsetInRange,
              a, offset, vsp,
              (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,
                                          (arr_, off_, i) -> arr_[off_ + i]));
@@@ -4903,6 -4972,69 +5072,69 @@@
      $abstractvectortype$ fromArray0($type$[] a, int offset,
                                      int[] indexMap, int mapOffset,
                                      VectorMask<$Boxtype$> m);
+ #if[byteOrShort]
+     @ForceInline
+     final
+     <M extends VectorMask<$Boxtype$>>
+     $abstractvectortype$ fromArray0Template(Class<M> maskClass, $type$[] a, int offset,
+                                             int[] indexMap, int mapOffset, M m) {
+         $Type$Species vsp = vspecies();
+         IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());
+         Objects.requireNonNull(a);
+         Objects.requireNonNull(indexMap);
+         m.check(vsp);
+         Class<? extends $abstractvectortype$> vectorType = vsp.vectorType();
+ 
+ 
+         // Constant folding should sweep out following conditonal logic.
+         VectorSpecies<Integer> lsp;
+         if (isp.length() > IntVector.SPECIES_PREFERRED.length()) {
+             lsp = IntVector.SPECIES_PREFERRED;
+         } else {
+             lsp = isp;
+         }
+ 
+         // Check indices are within array bounds.
+         // FIXME: Check index under mask controlling.
+         IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);
+         VectorIntrinsics.checkIndex(vix0, a.length);
+ 
+         int vlen = vsp.length();
+         int idx_vlen = lsp.length();
+         IntVector vix1 = null;
+         if (vlen >= idx_vlen * 2) {
+             vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);
+             VectorIntrinsics.checkIndex(vix1, a.length);
+         }
+ 
+ #if[byte]
+         IntVector vix2 = null;
+         IntVector vix3 = null;
+         if (vlen == idx_vlen * 4) {
+             vix2 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 2).add(offset);
+             VectorIntrinsics.checkIndex(vix2, a.length);
+             vix3 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 3).add(offset);
+             VectorIntrinsics.checkIndex(vix3, a.length);
+         }
+ 
+         return VectorSupport.loadWithMap(
 -            vectorType, maskClass, $type$.class, vsp.laneCount(),
++            vectorType, maskClass, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+             lsp.vectorType(), lsp.length(),
+             a, ARRAY_BASE, vix0, vix1, vix2, vix3, m,
+             a, offset, indexMap, mapOffset, vsp,
+             (c, idx, iMap, idy, s, vm) ->
+             s.vOp(vm, n -> c[idx + iMap[idy+n]]));
+ #else[byte]
+         return VectorSupport.loadWithMap(
 -            vectorType, maskClass, $type$.class, vsp.laneCount(),
++            vectorType, maskClass, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+             lsp.vectorType(), lsp.length(),
+             a, ARRAY_BASE, vix0, vix1, null, null, m,
+             a, offset, indexMap, mapOffset, vsp,
+             (c, idx, iMap, idy, s, vm) ->
+             s.vOp(vm, n -> c[idx + iMap[idy+n]]));
+ #end[byte]
+     }
+ #else[byteOrShort]
      @ForceInline
      final
      <M extends VectorMask<$Boxtype$>>
@@@ -4949,9 -5081,9 +5181,9 @@@
          vix = VectorIntrinsics.checkIndex(vix, a.length);
  
          return VectorSupport.loadWithMap(
--            vectorType, maskClass, $type$.class, vsp.laneCount(),
-             isp.vectorType(),
-             a, ARRAY_BASE, vix, m,
++            vectorType, maskClass, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, vsp.laneCount(),
+             isp.vectorType(), isp.length(),
+             a, ARRAY_BASE, vix, null, null, null, m,
              a, offset, indexMap, mapOffset, vsp,
              (c, idx, iMap, idy, s, vm) ->
              s.vOp(vm, n -> c[idx + iMap[idy+n]]));
@@@ -4967,8 -5099,8 +5199,8 @@@
      $abstractvectortype$ fromCharArray0Template(char[] a, int offset) {
          $Type$Species vsp = vspecies();
          return VectorSupport.load(
--            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
-             a, charArrayAddress(a, offset),
++            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, charArrayAddress(a, offset), false,
              a, offset, vsp,
              (arr, off, s) -> s.ldOp(arr, (int) off,
                                      (arr_, off_, i) -> (short) arr_[off_ + i]));
@@@ -4984,8 -5116,8 +5216,8 @@@
          m.check(species());
          $Type$Species vsp = vspecies();
          return VectorSupport.loadMasked(
--                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
-                 a, charArrayAddress(a, offset), m, offsetInRange,
++                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+                 a, charArrayAddress(a, offset), false, m, offsetInRange,
                  a, offset, vsp,
                  (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,
                                              (arr_, off_, i) -> (short) arr_[off_ + i]));
@@@ -5001,8 -5133,8 +5233,8 @@@
      $abstractvectortype$ fromBooleanArray0Template(boolean[] a, int offset) {
          $Type$Species vsp = vspecies();
          return VectorSupport.load(
--            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
-             a, booleanArrayAddress(a, offset),
++            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, booleanArrayAddress(a, offset), false,
              a, offset, vsp,
              (arr, off, s) -> s.ldOp(arr, (int) off,
                                      (arr_, off_, i) -> (byte) (arr_[off_ + i] ? 1 : 0)));
@@@ -5018,8 -5150,8 +5250,8 @@@
          m.check(species());
          $Type$Species vsp = vspecies();
          return VectorSupport.loadMasked(
--            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
-             a, booleanArrayAddress(a, offset), m, offsetInRange,
++            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, booleanArrayAddress(a, offset), false, m, offsetInRange,
              a, offset, vsp,
              (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,
                                          (arr_, off_, i) -> (byte) (arr_[off_ + i] ? 1 : 0)));
@@@ -5033,7 -5165,7 +5265,7 @@@
      $abstractvectortype$ fromMemorySegment0Template(MemorySegment ms, long offset) {
          $Type$Species vsp = vspecies();
          return ScopedMemoryAccess.loadFromMemorySegment(
--                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
++                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                  (AbstractMemorySegmentImpl) ms, offset, vsp,
                  (msp, off, s) -> {
                      return s.ldLongOp((MemorySegment) msp, off, $abstractvectortype$::memorySegmentGet);
@@@ -5049,7 -5181,7 +5281,7 @@@
          $Type$Species vsp = vspecies();
          m.check(vsp);
          return ScopedMemoryAccess.loadFromMemorySegmentMasked(
--                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
++                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                  (AbstractMemorySegmentImpl) ms, offset, m, vsp, offsetInRange,
                  (msp, off, s, vm) -> {
                      return s.ldLongOp((MemorySegment) msp, off, vm, $abstractvectortype$::memorySegmentGet);
@@@ -5067,8 -5199,8 +5299,8 @@@
      void intoArray0Template($type$[] a, int offset) {
          $Type$Species vsp = vspecies();
          VectorSupport.store(
--            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset),
++            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, arrayAddress(a, offset), false,
              this, a, offset,
              (arr, off, v)
              -> v.stOp(arr, (int) off,
@@@ -5084,8 -5216,8 +5316,8 @@@
          m.check(species());
          $Type$Species vsp = vspecies();
          VectorSupport.storeMasked(
--            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
-             a, arrayAddress(a, offset),
++            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, arrayAddress(a, offset), false,
              this, m, a, offset,
              (arr, off, v, vm)
              -> v.stOp(arr, (int) off, vm,
@@@ -5140,8 -5272,8 +5372,8 @@@
          vix = VectorIntrinsics.checkIndex(vix, a.length);
  
          VectorSupport.storeWithMap(
--            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
-             isp.vectorType(),
++            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             isp.vectorType(), isp.length(),
              a, arrayAddress(a, 0), vix,
              this, m,
              a, offset, indexMap, mapOffset,
@@@ -5165,8 -5297,8 +5397,8 @@@
          $Type$Species vsp = vspecies();
          ByteVector normalized = this.and((byte) 1);
          VectorSupport.storeMasked(
--            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
-             a, booleanArrayAddress(a, offset),
++            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, booleanArrayAddress(a, offset), false,
              normalized, m, a, offset,
              (arr, off, v, vm)
              -> v.stOp(arr, (int) off, vm,
@@@ -5179,7 -5311,7 +5411,7 @@@
      void intoMemorySegment0(MemorySegment ms, long offset) {
          $Type$Species vsp = vspecies();
          ScopedMemoryAccess.storeIntoMemorySegment(
--                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
++                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                  this,
                  (AbstractMemorySegmentImpl) ms, offset,
                  (msp, off, v) -> {
@@@ -5196,7 -5328,7 +5428,7 @@@
          $Type$Species vsp = vspecies();
          m.check(vsp);
          ScopedMemoryAccess.storeIntoMemorySegmentMasked(
--                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
++                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
                  this, m,
                  (AbstractMemorySegmentImpl) ms, offset,
                  (msp, off, v, vm) -> {
@@@ -5215,8 -5347,8 +5447,8 @@@
          m.check(species());
          $Type$Species vsp = vspecies();
          VectorSupport.storeMasked(
--            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),
-             a, charArrayAddress(a, offset),
++            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),
+             a, charArrayAddress(a, offset), false,
              this, m, a, offset,
              (arr, off, v, vm)
              -> v.stOp(arr, (int) off, vm,
@@@ -5365,15 -5477,7 +5577,11 @@@
      @ForceInline
      @Override
      public final
- #if[FP]
- #if[short]
 -    {#if[byteOrShort]?Vector<?>:$Fptype$Vector}
++#if[FP16]
 +    $Type$Vector
- #else[short]
-     $Fptype$Vector
- #end[short]
- #else[FP]
++#else[FP16]
 +    {#if[byte]?Vector<?>:$Fptype$Vector}
- #end[FP]
++#end[FP16]
      viewAsFloatingLanes() {
  #if[FP]
          return this;
@@@ -5462,7 -5562,7 +5666,7 @@@
                  Class<? extends AbstractMask<$Boxtype$>> maskType,
                  Class<? extends AbstractShuffle<$Boxtype$>> shuffleType,
                  Function<Object, $abstractvectortype$> vectorFactory) {
-             super(shape, LaneType.of($elemtype$.class),
 -            super(shape, LaneType.of($type$.class),
++            super(shape, LaneType.of($carriertype$.class),
                    vectorType, maskType, shuffleType,
                    vectorFactory);
              assert(this.elementSize() == $Boxtype$.SIZE);
@@@ -5470,6 -5570,6 +5674,19 @@@
  
          // Specializing overrides:
  
++        @ForceInline
++        final Class<?> carrierType() {
++            return $carriertype$.class;
++        }
++
++        @ForceInline
++        final int operType() {
++            if ($elemtype$.class.equals(Float16.class)) {
++                return VECTOR_TYPE_FP16;
++            }
++            return VECTOR_TYPE_PRIM;
++        }
++
          @Override
          @ForceInline
          public final Class<$Boxtype$> elementType() {
@@@ -5502,7 -5602,7 +5719,7 @@@
          final $abstractvectortype$ broadcastBits(long bits) {
              return ($abstractvectortype$)
                  VectorSupport.fromBitsCoerced(
-                     vectorType, $elemtype$.class, laneCount,
 -                    vectorType, $type$.class, laneCount,
++                    vectorType, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, laneCount,
                      bits, MODE_BROADCAST, this,
                      (bits_, s_) -> s_.rvOp(i -> bits_));
          }
@@@ -5556,13 -5656,6 +5773,13 @@@
              $type$[] va = new $type$[laneCount()];
              for (int i = 0; i < va.length; i++) {
                  int lv = values[i];
 +#if[FP16]
-                 $type$ v = Float.floatToFloat16((float) lv);
++                $type$ v = Float16.float16ToRawShortBits(Float16.valueOf(lv));
 +                va[i] = v;
-                 if ((int) Float.float16ToFloat(v) != lv) {
++                if (Float16.valueOf(lv).intValue() != lv) {
 +                    throw badElementBits(lv, v);
 +                }
 +#else[FP16]
                  $type$ v = ($type$) lv;
                  va[i] = v;
                  if ((int)v != lv) {
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/X-VectorBits.java.template
index ea172dfa1d4,fa502e3f29a..1a2f455d525
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/X-VectorBits.java.template
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/X-VectorBits.java.template
@@@ -52,7 -54,7 +54,11 @@@ final class $vectortype$ extends $abstr
  
      static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
  
-     static final Class<$Boxtype$> ETYPE = $elemtype$.class; // used by the JVM
 -    static final Class<$Boxtype$> ETYPE = $type$.class; // used by the JVM
++    static final Class<$Carriertype$> CTYPE = $carriertype$.class; // carrier type used by the JVM
++
++    static final Class<$Boxtype$> ETYPE = $elemtype$.class; // vector element type used by the JVM
++
++    static final int VECTOR_OPER_TYPE = {#if[FP16]?VECTOR_TYPE_FP16:VECTOR_TYPE_PRIM};
  
      $vectortype$($type$[] v) {
          super(v);
@@@ -86,9 -88,9 +92,12 @@@
          return VSPECIES;
      }
  
++    @ForceInline
++    final Class<$Carriertype$> carrierType() { return CTYPE; }
++
      @ForceInline
      @Override
-     public final Class<$Boxtype$> elementType() { return $elemtype$.class; }
 -    public final Class<$Boxtype$> elementType() { return $type$.class; }
++    public final Class<$Boxtype$> elementType() { return ETYPE; }
  
      @ForceInline
      @Override
@@@ -557,16 -571,17 +596,17 @@@
          }
          $bitstype$ bits = laneHelper(i);
  #end[!Max]
--        return $Type$.$bitstype$BitsTo$Fptype$(bits);
++        return {#if[FP16]?bits:$Type$.$bitstype$BitsTo$Fptype$(bits)};
      }
  
+     @ForceInline
      public $bitstype$ laneHelper(int i) {
          return ($bitstype$) VectorSupport.extract(
--                     VCLASS, ETYPE, VLENGTH,
++                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                       this, i,
                       (vec, ix) -> {
                       $type$[] vecarr = vec.vec();
-                      return (long)$Type$.$type$To$Bitstype$Bits(vecarr[ix]);
 -                     return (long)$Type$.$type$ToRaw$Bitstype$Bits(vecarr[ix]);
++                     return {#if[FP16]?vecarr[ix]:(long)$Type$.$type$ToRaw$Bitstype$Bits(vecarr[ix])};
                       });
      }
  
@@@ -627,13 -624,14 +667,14 @@@
  #end[!Max]
      }
  
+     @ForceInline
      public $vectortype$ withLaneHelper(int i, $type$ e) {
          return VectorSupport.insert(
--                                VCLASS, ETYPE, VLENGTH,
-                                 this, i, (long)$Type$.$type$To$Bitstype$Bits(e),
 -                                this, i, (long)$Type$.$type$ToRaw$Bitstype$Bits(e),
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                this, i, (long){#if[FP16]?e:$Type$.$type$ToRaw$Bitstype$Bits(e)},
                                  (v, ix, bits) -> {
                                      $type$[] res = v.vec().clone();
--                                    res[ix] = $Type$.$bitstype$BitsTo$Type$(($bitstype$)bits);
++                                    res[ix] = {#if[FP16]?e:$Type$.$bitstype$BitsTo$Type$(($bitstype$)bits)};
                                      return v.vectorFactory(res);
                                  });
      }
@@@ -729,9 -727,10 +770,10 @@@
  #end[!Max]
      }
  
+     @ForceInline
      public $type$ laneHelper(int i) {
          return ($type$) VectorSupport.extract(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i,
                                  (vec, ix) -> {
                                      $type$[] vecarr = vec.vec();
@@@ -830,9 -829,10 +872,10 @@@
  #end[!Max]
      }
  
+     @ForceInline
      public $vectortype$ withLaneHelper(int i, $type$ e) {
          return VectorSupport.insert(
--                                VCLASS, ETYPE, VLENGTH,
++                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                  this, i, (long)e,
                                  (v, ix, bits) -> {
                                      $type$[] res = v.vec().clone();
@@@ -846,7 -846,7 +889,7 @@@
  
      static final class $masktype$ extends AbstractMask<$Boxtype$> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
-         static final Class<$Boxtype$> ETYPE = $elemtype$.class; // used by the JVM
 -        static final Class<$Boxtype$> ETYPE = $type$.class; // used by the JVM
++        static final Class<$Carriertype$> CTYPE = $carriertype$.class; // used by the JVM
  
          $masktype$(boolean[] bits) {
              this(bits, 0);
@@@ -948,7 -948,7 +991,7 @@@
          /*package-private*/
          $masktype$ indexPartiallyInUpperRange(long offset, long limit) {
              return ($masktype$) VectorSupport.indexPartiallyInUpperRange(
-                 $masktype$.class, ETYPE, VLENGTH, offset, limit,
 -                $masktype$.class, $type$.class, VLENGTH, offset, limit,
++                $masktype$.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,
                  (o, l) -> ($masktype$) TRUE_MASK.indexPartiallyInRange(o, l));
          }
  
@@@ -964,12 -964,8 +1007,9 @@@
          @ForceInline
          public $masktype$ compress() {
              return ($masktype$)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
--                $vectortype$.class, $masktype$.class, ETYPE, VLENGTH, null, this,
- #if[FP16]
-                 (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, Float.floatToFloat16(m1.trueCount())));
- #else[FP16]
--                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
- #end[FP16]
++                $vectortype$.class, $masktype$.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,
++                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,
++                {#if[FP16]?Float16.float16ToShortBits(Float16.valueOf(m1.trueCount())):m1.trueCount()}));
          }
  
  
@@@ -980,7 -976,7 +1020,7 @@@
          public $masktype$ and(VectorMask<$Boxtype$> mask) {
              Objects.requireNonNull(mask);
              $masktype$ m = ($masktype$)mask;
-             return VectorSupport.binaryOp(VECTOR_OP_AND, $masktype$.class, null, $maskbitstype$.class, VLENGTH,
 -            return VectorSupport.binaryOp(VECTOR_OP_AND, $masktype$.class, null, $bitstype$.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_AND, $masktype$.class, null, $bitstype$.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
          }
@@@ -990,7 -986,7 +1030,7 @@@
          public $masktype$ or(VectorMask<$Boxtype$> mask) {
              Objects.requireNonNull(mask);
              $masktype$ m = ($masktype$)mask;
-             return VectorSupport.binaryOp(VECTOR_OP_OR, $masktype$.class, null, $maskbitstype$.class, VLENGTH,
 -            return VectorSupport.binaryOp(VECTOR_OP_OR, $masktype$.class, null, $bitstype$.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_OR, $masktype$.class, null, $bitstype$.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
          }
@@@ -1000,7 -996,7 +1040,7 @@@
          public $masktype$ xor(VectorMask<$Boxtype$> mask) {
              Objects.requireNonNull(mask);
              $masktype$ m = ($masktype$)mask;
-             return VectorSupport.binaryOp(VECTOR_OP_XOR, $masktype$.class, null, $maskbitstype$.class, VLENGTH,
 -            return VectorSupport.binaryOp(VECTOR_OP_XOR, $masktype$.class, null, $bitstype$.class, VLENGTH,
++            return VectorSupport.binaryOp(VECTOR_OP_XOR, $masktype$.class, null, $bitstype$.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                            this, m, null,
                                            (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
          }
@@@ -1010,22 -1006,22 +1050,25 @@@
          @Override
          @ForceInline
          public int trueCount() {
-             return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, $masktype$.class, $maskbitstype$.class, VLENGTH, this,
 -            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, $masktype$.class, $bitstype$.class, VLENGTH, this,
--                                                      (m) -> trueCountHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, $masktype$.class, $bitstype$.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> trueCountHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int firstTrue() {
-             return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, $masktype$.class, $maskbitstype$.class, VLENGTH, this,
 -            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, $masktype$.class, $bitstype$.class, VLENGTH, this,
--                                                      (m) -> firstTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, $masktype$.class, $bitstype$.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> firstTrueHelper(m.getBits()));
          }
  
          @Override
          @ForceInline
          public int lastTrue() {
-             return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, $masktype$.class, $maskbitstype$.class, VLENGTH, this,
 -            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, $masktype$.class, $bitstype$.class, VLENGTH, this,
--                                                      (m) -> lastTrueHelper(m.getBits()));
++            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, $masktype$.class, $bitstype$.class, ETYPE,
++                                                            VECTOR_OPER_TYPE, VLENGTH, this,
++                                                            (m) -> lastTrueHelper(m.getBits()));
          }
  
          @Override
@@@ -1034,32 -1030,42 +1077,43 @@@
              if (length() > Long.SIZE) {
                  throw new UnsupportedOperationException("too many lanes for one long");
              }
-             return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, $masktype$.class, $maskbitstype$.class, VLENGTH, this,
 -            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, $masktype$.class, $bitstype$.class, VLENGTH, this,
++            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, $masktype$.class, $bitstype$.class, ETYPE,
++                                                      VECTOR_OPER_TYPE, VLENGTH, this,
                                                        (m) -> toLongHelper(m.getBits()));
          }
  
+         // laneIsSet
+ 
+         @Override
+         @ForceInline
+         public boolean laneIsSet(int i) {
+             Objects.checkIndex(i, length());
 -            return VectorSupport.extract($masktype$.class, $type$.class, VLENGTH,
++            return VectorSupport.extract($masktype$.class, $type$.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
+                                          this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;
+         }
+ 
          // Reductions
  
          @Override
          @ForceInline
          public boolean anyTrue() {
-             return VectorSupport.test(BT_ne, $masktype$.class, $maskbitstype$.class, VLENGTH,
 -            return VectorSupport.test(BT_ne, $masktype$.class, $bitstype$.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> anyTrueHelper((($masktype$)m).getBits()));
++            return VectorSupport.test(BT_ne, $masktype$.class, $bitstype$.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> anyTrueHelper((($masktype$)m).getBits()));
          }
  
          @Override
          @ForceInline
          public boolean allTrue() {
-             return VectorSupport.test(BT_overflow, $masktype$.class, $maskbitstype$.class, VLENGTH,
 -            return VectorSupport.test(BT_overflow, $masktype$.class, $bitstype$.class, VLENGTH,
--                                         this, vspecies().maskAll(true),
--                                         (m, __) -> allTrueHelper((($masktype$)m).getBits()));
++            return VectorSupport.test(BT_overflow, $masktype$.class, $bitstype$.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
++                                      this, vspecies().maskAll(true),
++                                      (m, __) -> allTrueHelper((($masktype$)m).getBits()));
          }
  
          @ForceInline
          /*package-private*/
          static $masktype$ maskAll(boolean bit) {
-             return VectorSupport.fromBitsCoerced($masktype$.class, $maskbitstype$.class, VLENGTH,
 -            return VectorSupport.fromBitsCoerced($masktype$.class, $bitstype$.class, VLENGTH,
++            return VectorSupport.fromBitsCoerced($masktype$.class, $bitstype$.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,
                                                   (bit ? -1 : 0), MODE_BROADCAST, null,
                                                   (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
          }
@@@ -1087,7 -1093,7 +1141,7 @@@
  
      static final class $shuffletype$ extends AbstractShuffle<$Boxtype$> {
          static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
--        static final Class<$Boxbitstype$> ETYPE = $bitstype$.class; // used by the JVM
++        static final Class<$Boxbitstype$> CTYPE = $bitstype$.class; // used by the JVM
  
          $shuffletype$($bitstype$[] indices) {
              super(indices);
diff --cc src/jdk.incubator.vector/share/classes/jdk/incubator/vector/gen-src.sh
index d2a05bdd30b,6841a47c757..6115dedcfe3
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/gen-src.sh
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/gen-src.sh
@@@ -71,6 -62,6 +71,7 @@@ d
  
    Boxtype=$Type
    Wideboxtype=$Boxtype
++  ElemLayout=$Type
  
    kind=BITWISE
  
@@@ -82,12 -72,9 +83,13 @@@
    fptype=$type
    Fptype=$Type
    Boxfptype=$Boxtype
++  carriertype=$type
++  Carriertype=$Type
 +  elemtype=$type
-   Elemtype=$Type
 +  FPtype=$type
  
 -  case $type in
 -    byte)
 +  case $Type in
 +    Byte)
        Wideboxtype=Integer
        sizeInBytes=1
        args="$args -KbyteOrShort"
@@@ -100,8 -84,8 +102,9 @@@
        sizeInBytes=2
        args="$args -KbyteOrShort"
        ;;
 -    int)
 +    Int)
        Boxtype=Integer
++      Carriertype=Integer
        Wideboxtype=Integer
        Boxbitstype=Integer
        fptype=float
@@@ -135,27 -116,13 +138,31 @@@
        Boxbitstype=Long
        sizeInBytes=8
        args="$args -KintOrFP -KlongOrDouble"
 +      FPtype=FP64
 +      ;;
 +    Halffloat)
 +      kind=FP
 +      bitstype=short
-       maskbitstype=Halffloat
++      maskbitstype=short
 +      Bitstype=Short
 +      Boxbitstype=Short
 +      sizeInBytes=2
-       elemtype=Halffloat
-       Elemtype=Short
++      carriertype=short
++      Carriertype=Short
 +      FPtype=FP16
++      Boxtype=Float16
++      elemtype=Float16
++      ElemLayout=Short
 +      args="$args -KbyteOrShort -KshortOrFP -KshortOrHalffloat"
        ;;
    esac
++   
  
 -  args="$args -K$kind -DBoxtype=$Boxtype -DWideboxtype=$Wideboxtype"
 -  args="$args -Dbitstype=$bitstype -DBitstype=$Bitstype -DBoxbitstype=$Boxbitstype"
 +  args="$args -K$FPtype -K$kind -DBoxtype=$Boxtype -DWideboxtype=$Wideboxtype"
-   args="$args -Dbitstype=$bitstype -Dmaskbitstype=$maskbitstype -DBitstype=$Bitstype -DBoxbitstype=$Boxbitstype"
++  args="$args -DElemLayout=$ElemLayout -Dbitstype=$bitstype -Dmaskbitstype=$maskbitstype -DBitstype=$Bitstype -DBoxbitstype=$Boxbitstype"
    args="$args -Dfptype=$fptype -DFptype=$Fptype -DBoxfptype=$Boxfptype"
    args="$args -DsizeInBytes=$sizeInBytes"
-   args="$args -Delemtype=$elemtype -DElemtype=$Elemtype"
++  args="$args -Dcarriertype=$carriertype -Delemtype=$elemtype -DCarriertype=$Carriertype"
  
    abstractvectortype=${typeprefix}${Type}Vector
    abstractbitsvectortype=${typeprefix}${Bitstype}Vector
diff --cc test/jdk/jdk/incubator/vector/AddTest.java
index 68ffc6f1a27,bd11f0092be..d96a787367a
--- a/test/jdk/jdk/incubator/vector/AddTest.java
+++ b/test/jdk/jdk/incubator/vector/AddTest.java
@@@ -37,13 -36,13 +37,13 @@@ import java.util.Arrays
  import java.util.stream.IntStream;
  
  public class AddTest {
-     static final VectorSpecies<Halffloat> SPECIES =
 -    static final VectorSpecies<Float> SPECIES =
 -            FloatVector.SPECIES_256;
++    static final VectorSpecies<Float16> SPECIES =
 +            HalffloatVector.SPECIES_128;
  
      static final int SIZE = 1024;
 -    static float[] a = new float[SIZE];
 -    static float[] b = new float[SIZE];
 -    static float[] c = new float[SIZE];
 +    static short[] a = new short[SIZE];
 +    static short[] b = new short[SIZE];
 +    static short[] c = new short[SIZE];
  
      static {
          for (int i = 0; i < SIZE; i++) {
diff --cc test/jdk/jdk/incubator/vector/Byte128VectorTests.java
index 2d2875e2986,bea4d541987..5669e28f15b
--- a/test/jdk/jdk/incubator/vector/Byte128VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Byte128VectorTests.java
@@@ -1,5 -1,5 +1,5 @@@
  /*
-  * Copyright (c) 2018, 2022, Oracle and/or its affiliates. All rights reserved.
 - * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
diff --cc test/jdk/jdk/incubator/vector/Byte256VectorTests.java
index ce569803220,be5b3cf6198..19bd29d2b03
--- a/test/jdk/jdk/incubator/vector/Byte256VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Byte256VectorTests.java
@@@ -1,5 -1,5 +1,5 @@@
  /*
-  * Copyright (c) 2018, 2022, Oracle and/or its affiliates. All rights reserved.
 - * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
diff --cc test/jdk/jdk/incubator/vector/Byte512VectorTests.java
index 25e7cbcdf67,0fd68b6f712..b9b2bf534a4
--- a/test/jdk/jdk/incubator/vector/Byte512VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Byte512VectorTests.java
@@@ -1,5 -1,5 +1,5 @@@
  /*
-  * Copyright (c) 2018, 2022, Oracle and/or its affiliates. All rights reserved.
 - * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
diff --cc test/jdk/jdk/incubator/vector/Byte64VectorTests.java
index 200589cb981,112b2e56b6f..08244edff9f
--- a/test/jdk/jdk/incubator/vector/Byte64VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Byte64VectorTests.java
@@@ -1,5 -1,5 +1,5 @@@
  /*
-  * Copyright (c) 2018, 2022, Oracle and/or its affiliates. All rights reserved.
 - * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
diff --cc test/jdk/jdk/incubator/vector/ByteMaxVectorTests.java
index 7deca0cdd43,435cacc013e..c6dffb161e1
--- a/test/jdk/jdk/incubator/vector/ByteMaxVectorTests.java
+++ b/test/jdk/jdk/incubator/vector/ByteMaxVectorTests.java
@@@ -1,5 -1,5 +1,5 @@@
  /*
-  * Copyright (c) 2018, 2022, Oracle and/or its affiliates. All rights reserved.
 - * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
diff --cc test/jdk/jdk/incubator/vector/Double128VectorTests.java
index f5c4e20a64d,f15ce88ddb8..47f77cd8abf
--- a/test/jdk/jdk/incubator/vector/Double128VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Double128VectorTests.java
@@@ -1,5 -1,5 +1,5 @@@
  /*
-  * Copyright (c) 2018, 2022, Oracle and/or its affiliates. All rights reserved.
 - * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
@@@ -1041,17 -1121,17 +1129,17 @@@ relativeError))
      static final List<IntFunction<double[]>> LONG_DOUBLE_GENERATORS = List.of(
              withToString("double[-i * 5]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (double)(-i * 5));
 +                            i -> genValue(-i * 5));
              }),
-             withToString("Halffloat[i * 5]", (int s) -> {
+             withToString("double[i * 5]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (double)(i * 5));
 +                            i -> genValue(i * 5));
              }),
-             withToString("Halffloat[i + 1]", (int s) -> {
+             withToString("double[i + 1]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));
 +                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
              }),
-             withToString("Halffloat[cornerCaseValue(i)]", (int s) -> {
+             withToString("double[cornerCaseValue(i)]", (int s) -> {
                  return fill(s * BUFFER_REPS,
                              i -> (double)longCornerCaseValue(i));
              })
@@@ -1084,8 -1164,16 +1172,16 @@@
              }),
              withToString("double[i + 1]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));
 +                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
              }),
+             withToString("double[0.01 + (i / (i + 1))]", (int s) -> {
+                 return fill(s * BUFFER_REPS,
+                             i -> (double)0.01 + ((double)i / (i + 1)));
+             }),
+             withToString("double[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i / (i + 1))]", (int s) -> {
+                 return fill(s * BUFFER_REPS,
+                             i -> i % 17 == 0 ? cornerCaseValue(i) : (double)0.01 + ((double)i / (i + 1)));
+             }),
              withToString("double[cornerCaseValue(i)]", (int s) -> {
                  return fill(s * BUFFER_REPS,
                              i -> cornerCaseValue(i));
diff --cc test/jdk/jdk/incubator/vector/Double256VectorTests.java
index 52212a85bb2,e6c3662e0ad..b7487e41934
--- a/test/jdk/jdk/incubator/vector/Double256VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Double256VectorTests.java
@@@ -1,5 -1,5 +1,5 @@@
  /*
-  * Copyright (c) 2018, 2022, Oracle and/or its affiliates. All rights reserved.
 - * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
@@@ -1041,17 -1121,17 +1129,17 @@@ relativeError))
      static final List<IntFunction<double[]>> LONG_DOUBLE_GENERATORS = List.of(
              withToString("double[-i * 5]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (double)(-i * 5));
 +                            i -> genValue(-i * 5));
              }),
-             withToString("Halffloat[i * 5]", (int s) -> {
+             withToString("double[i * 5]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (double)(i * 5));
 +                            i -> genValue(i * 5));
              }),
-             withToString("Halffloat[i + 1]", (int s) -> {
+             withToString("double[i + 1]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));
 +                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
              }),
-             withToString("Halffloat[cornerCaseValue(i)]", (int s) -> {
+             withToString("double[cornerCaseValue(i)]", (int s) -> {
                  return fill(s * BUFFER_REPS,
                              i -> (double)longCornerCaseValue(i));
              })
@@@ -1084,8 -1164,16 +1172,16 @@@
              }),
              withToString("double[i + 1]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));
 +                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
              }),
+             withToString("double[0.01 + (i / (i + 1))]", (int s) -> {
+                 return fill(s * BUFFER_REPS,
+                             i -> (double)0.01 + ((double)i / (i + 1)));
+             }),
+             withToString("double[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i / (i + 1))]", (int s) -> {
+                 return fill(s * BUFFER_REPS,
+                             i -> i % 17 == 0 ? cornerCaseValue(i) : (double)0.01 + ((double)i / (i + 1)));
+             }),
              withToString("double[cornerCaseValue(i)]", (int s) -> {
                  return fill(s * BUFFER_REPS,
                              i -> cornerCaseValue(i));
diff --cc test/jdk/jdk/incubator/vector/Double512VectorTests.java
index cb887a19e12,7c37c9878e8..7a8539118b7
--- a/test/jdk/jdk/incubator/vector/Double512VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Double512VectorTests.java
@@@ -1,5 -1,5 +1,5 @@@
  /*
-  * Copyright (c) 2018, 2022, Oracle and/or its affiliates. All rights reserved.
 - * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
@@@ -1041,17 -1121,17 +1129,17 @@@ relativeError))
      static final List<IntFunction<double[]>> LONG_DOUBLE_GENERATORS = List.of(
              withToString("double[-i * 5]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (double)(-i * 5));
 +                            i -> genValue(-i * 5));
              }),
-             withToString("Halffloat[i * 5]", (int s) -> {
+             withToString("double[i * 5]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (double)(i * 5));
 +                            i -> genValue(i * 5));
              }),
-             withToString("Halffloat[i + 1]", (int s) -> {
+             withToString("double[i + 1]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));
 +                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
              }),
-             withToString("Halffloat[cornerCaseValue(i)]", (int s) -> {
+             withToString("double[cornerCaseValue(i)]", (int s) -> {
                  return fill(s * BUFFER_REPS,
                              i -> (double)longCornerCaseValue(i));
              })
@@@ -1084,8 -1164,16 +1172,16 @@@
              }),
              withToString("double[i + 1]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));
 +                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
              }),
+             withToString("double[0.01 + (i / (i + 1))]", (int s) -> {
+                 return fill(s * BUFFER_REPS,
+                             i -> (double)0.01 + ((double)i / (i + 1)));
+             }),
+             withToString("double[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i / (i + 1))]", (int s) -> {
+                 return fill(s * BUFFER_REPS,
+                             i -> i % 17 == 0 ? cornerCaseValue(i) : (double)0.01 + ((double)i / (i + 1)));
+             }),
              withToString("double[cornerCaseValue(i)]", (int s) -> {
                  return fill(s * BUFFER_REPS,
                              i -> cornerCaseValue(i));
diff --cc test/jdk/jdk/incubator/vector/Double64VectorTests.java
index 21a2b63693a,85b96288b37..10c7d338e84
--- a/test/jdk/jdk/incubator/vector/Double64VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Double64VectorTests.java
@@@ -1,5 -1,5 +1,5 @@@
  /*
-  * Copyright (c) 2018, 2022, Oracle and/or its affiliates. All rights reserved.
 - * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
@@@ -1041,17 -1121,17 +1129,17 @@@ relativeError))
      static final List<IntFunction<double[]>> LONG_DOUBLE_GENERATORS = List.of(
              withToString("double[-i * 5]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (double)(-i * 5));
 +                            i -> genValue(-i * 5));
              }),
-             withToString("Halffloat[i * 5]", (int s) -> {
+             withToString("double[i * 5]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (double)(i * 5));
 +                            i -> genValue(i * 5));
              }),
-             withToString("Halffloat[i + 1]", (int s) -> {
+             withToString("double[i + 1]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));
 +                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
              }),
-             withToString("Halffloat[cornerCaseValue(i)]", (int s) -> {
+             withToString("double[cornerCaseValue(i)]", (int s) -> {
                  return fill(s * BUFFER_REPS,
                              i -> (double)longCornerCaseValue(i));
              })
@@@ -1084,8 -1164,16 +1172,16 @@@
              }),
              withToString("double[i + 1]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));
 +                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
              }),
+             withToString("double[0.01 + (i / (i + 1))]", (int s) -> {
+                 return fill(s * BUFFER_REPS,
+                             i -> (double)0.01 + ((double)i / (i + 1)));
+             }),
+             withToString("double[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i / (i + 1))]", (int s) -> {
+                 return fill(s * BUFFER_REPS,
+                             i -> i % 17 == 0 ? cornerCaseValue(i) : (double)0.01 + ((double)i / (i + 1)));
+             }),
              withToString("double[cornerCaseValue(i)]", (int s) -> {
                  return fill(s * BUFFER_REPS,
                              i -> cornerCaseValue(i));
diff --cc test/jdk/jdk/incubator/vector/DoubleMaxVectorTests.java
index 14efdaf7352,7245990d66c..f8b3ff25857
--- a/test/jdk/jdk/incubator/vector/DoubleMaxVectorTests.java
+++ b/test/jdk/jdk/incubator/vector/DoubleMaxVectorTests.java
@@@ -1,5 -1,5 +1,5 @@@
  /*
-  * Copyright (c) 2018, 2022, Oracle and/or its affiliates. All rights reserved.
 - * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
@@@ -1046,17 -1126,17 +1134,17 @@@ relativeError))
      static final List<IntFunction<double[]>> LONG_DOUBLE_GENERATORS = List.of(
              withToString("double[-i * 5]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (double)(-i * 5));
 +                            i -> genValue(-i * 5));
              }),
-             withToString("Halffloat[i * 5]", (int s) -> {
+             withToString("double[i * 5]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (double)(i * 5));
 +                            i -> genValue(i * 5));
              }),
-             withToString("Halffloat[i + 1]", (int s) -> {
+             withToString("double[i + 1]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));
 +                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
              }),
-             withToString("Halffloat[cornerCaseValue(i)]", (int s) -> {
+             withToString("double[cornerCaseValue(i)]", (int s) -> {
                  return fill(s * BUFFER_REPS,
                              i -> (double)longCornerCaseValue(i));
              })
@@@ -1089,8 -1169,16 +1177,16 @@@
              }),
              withToString("double[i + 1]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));
 +                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
              }),
+             withToString("double[0.01 + (i / (i + 1))]", (int s) -> {
+                 return fill(s * BUFFER_REPS,
+                             i -> (double)0.01 + ((double)i / (i + 1)));
+             }),
+             withToString("double[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i / (i + 1))]", (int s) -> {
+                 return fill(s * BUFFER_REPS,
+                             i -> i % 17 == 0 ? cornerCaseValue(i) : (double)0.01 + ((double)i / (i + 1)));
+             }),
              withToString("double[cornerCaseValue(i)]", (int s) -> {
                  return fill(s * BUFFER_REPS,
                              i -> cornerCaseValue(i));
diff --cc test/jdk/jdk/incubator/vector/Float128VectorTests.java
index 3f2e47b5d96,c4f4ed1b966..900a50952ea
--- a/test/jdk/jdk/incubator/vector/Float128VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Float128VectorTests.java
@@@ -1,5 -1,5 +1,5 @@@
  /*
-  * Copyright (c) 2018, 2022, Oracle and/or its affiliates. All rights reserved.
 - * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
@@@ -1041,17 -1121,17 +1129,17 @@@ relativeError))
      static final List<IntFunction<float[]>> LONG_FLOAT_GENERATORS = List.of(
              withToString("float[-i * 5]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (float)(-i * 5));
 +                            i -> genValue(-i * 5));
              }),
-             withToString("Halffloat[i * 5]", (int s) -> {
+             withToString("float[i * 5]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (float)(i * 5));
 +                            i -> genValue(i * 5));
              }),
-             withToString("Halffloat[i + 1]", (int s) -> {
+             withToString("float[i + 1]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));
 +                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
              }),
-             withToString("Halffloat[cornerCaseValue(i)]", (int s) -> {
+             withToString("float[cornerCaseValue(i)]", (int s) -> {
                  return fill(s * BUFFER_REPS,
                              i -> (float)longCornerCaseValue(i));
              })
@@@ -1095,8 -1175,16 +1183,16 @@@
              }),
              withToString("float[i + 1]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));
 +                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
              }),
+             withToString("float[0.01 + (i / (i + 1))]", (int s) -> {
+                 return fill(s * BUFFER_REPS,
+                             i -> (float)0.01 + ((float)i / (i + 1)));
+             }),
+             withToString("float[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i / (i + 1))]", (int s) -> {
+                 return fill(s * BUFFER_REPS,
+                             i -> i % 17 == 0 ? cornerCaseValue(i) : (float)0.01 + ((float)i / (i + 1)));
+             }),
              withToString("float[cornerCaseValue(i)]", (int s) -> {
                  return fill(s * BUFFER_REPS,
                              i -> cornerCaseValue(i));
diff --cc test/jdk/jdk/incubator/vector/Float256VectorTests.java
index a14c9bd141e,87cbc165d59..e891a0e2ba0
--- a/test/jdk/jdk/incubator/vector/Float256VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Float256VectorTests.java
@@@ -1,5 -1,5 +1,5 @@@
  /*
-  * Copyright (c) 2018, 2022, Oracle and/or its affiliates. All rights reserved.
 - * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
@@@ -1041,17 -1121,17 +1129,17 @@@ relativeError))
      static final List<IntFunction<float[]>> LONG_FLOAT_GENERATORS = List.of(
              withToString("float[-i * 5]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (float)(-i * 5));
 +                            i -> genValue(-i * 5));
              }),
-             withToString("Halffloat[i * 5]", (int s) -> {
+             withToString("float[i * 5]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (float)(i * 5));
 +                            i -> genValue(i * 5));
              }),
-             withToString("Halffloat[i + 1]", (int s) -> {
+             withToString("float[i + 1]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));
 +                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
              }),
-             withToString("Halffloat[cornerCaseValue(i)]", (int s) -> {
+             withToString("float[cornerCaseValue(i)]", (int s) -> {
                  return fill(s * BUFFER_REPS,
                              i -> (float)longCornerCaseValue(i));
              })
@@@ -1095,8 -1175,16 +1183,16 @@@
              }),
              withToString("float[i + 1]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));
 +                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
              }),
+             withToString("float[0.01 + (i / (i + 1))]", (int s) -> {
+                 return fill(s * BUFFER_REPS,
+                             i -> (float)0.01 + ((float)i / (i + 1)));
+             }),
+             withToString("float[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i / (i + 1))]", (int s) -> {
+                 return fill(s * BUFFER_REPS,
+                             i -> i % 17 == 0 ? cornerCaseValue(i) : (float)0.01 + ((float)i / (i + 1)));
+             }),
              withToString("float[cornerCaseValue(i)]", (int s) -> {
                  return fill(s * BUFFER_REPS,
                              i -> cornerCaseValue(i));
diff --cc test/jdk/jdk/incubator/vector/Float512VectorTests.java
index f440e119785,beb9561d882..f3294d8fdff
--- a/test/jdk/jdk/incubator/vector/Float512VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Float512VectorTests.java
@@@ -1,5 -1,5 +1,5 @@@
  /*
-  * Copyright (c) 2018, 2022, Oracle and/or its affiliates. All rights reserved.
 - * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
@@@ -1041,17 -1121,17 +1129,17 @@@ relativeError))
      static final List<IntFunction<float[]>> LONG_FLOAT_GENERATORS = List.of(
              withToString("float[-i * 5]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (float)(-i * 5));
 +                            i -> genValue(-i * 5));
              }),
-             withToString("Halffloat[i * 5]", (int s) -> {
+             withToString("float[i * 5]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (float)(i * 5));
 +                            i -> genValue(i * 5));
              }),
-             withToString("Halffloat[i + 1]", (int s) -> {
+             withToString("float[i + 1]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));
 +                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
              }),
-             withToString("Halffloat[cornerCaseValue(i)]", (int s) -> {
+             withToString("float[cornerCaseValue(i)]", (int s) -> {
                  return fill(s * BUFFER_REPS,
                              i -> (float)longCornerCaseValue(i));
              })
@@@ -1095,8 -1175,16 +1183,16 @@@
              }),
              withToString("float[i + 1]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));
 +                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
              }),
+             withToString("float[0.01 + (i / (i + 1))]", (int s) -> {
+                 return fill(s * BUFFER_REPS,
+                             i -> (float)0.01 + ((float)i / (i + 1)));
+             }),
+             withToString("float[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i / (i + 1))]", (int s) -> {
+                 return fill(s * BUFFER_REPS,
+                             i -> i % 17 == 0 ? cornerCaseValue(i) : (float)0.01 + ((float)i / (i + 1)));
+             }),
              withToString("float[cornerCaseValue(i)]", (int s) -> {
                  return fill(s * BUFFER_REPS,
                              i -> cornerCaseValue(i));
diff --cc test/jdk/jdk/incubator/vector/Float64VectorTests.java
index 3dcbc46f530,ee630abd8e0..fb6321ae68c
--- a/test/jdk/jdk/incubator/vector/Float64VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Float64VectorTests.java
@@@ -1,5 -1,5 +1,5 @@@
  /*
-  * Copyright (c) 2018, 2022, Oracle and/or its affiliates. All rights reserved.
 - * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
@@@ -1041,17 -1121,17 +1129,17 @@@ relativeError))
      static final List<IntFunction<float[]>> LONG_FLOAT_GENERATORS = List.of(
              withToString("float[-i * 5]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (float)(-i * 5));
 +                            i -> genValue(-i * 5));
              }),
-             withToString("Halffloat[i * 5]", (int s) -> {
+             withToString("float[i * 5]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (float)(i * 5));
 +                            i -> genValue(i * 5));
              }),
-             withToString("Halffloat[i + 1]", (int s) -> {
+             withToString("float[i + 1]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));
 +                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
              }),
-             withToString("Halffloat[cornerCaseValue(i)]", (int s) -> {
+             withToString("float[cornerCaseValue(i)]", (int s) -> {
                  return fill(s * BUFFER_REPS,
                              i -> (float)longCornerCaseValue(i));
              })
@@@ -1095,8 -1175,16 +1183,16 @@@
              }),
              withToString("float[i + 1]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));
 +                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
              }),
+             withToString("float[0.01 + (i / (i + 1))]", (int s) -> {
+                 return fill(s * BUFFER_REPS,
+                             i -> (float)0.01 + ((float)i / (i + 1)));
+             }),
+             withToString("float[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i / (i + 1))]", (int s) -> {
+                 return fill(s * BUFFER_REPS,
+                             i -> i % 17 == 0 ? cornerCaseValue(i) : (float)0.01 + ((float)i / (i + 1)));
+             }),
              withToString("float[cornerCaseValue(i)]", (int s) -> {
                  return fill(s * BUFFER_REPS,
                              i -> cornerCaseValue(i));
diff --cc test/jdk/jdk/incubator/vector/FloatMaxVectorTests.java
index 9a24c1bb7da,41e4d6e4a5d..501656f515e
--- a/test/jdk/jdk/incubator/vector/FloatMaxVectorTests.java
+++ b/test/jdk/jdk/incubator/vector/FloatMaxVectorTests.java
@@@ -1,5 -1,5 +1,5 @@@
  /*
-  * Copyright (c) 2018, 2022, Oracle and/or its affiliates. All rights reserved.
 - * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
@@@ -1046,17 -1126,17 +1134,17 @@@ relativeError))
      static final List<IntFunction<float[]>> LONG_FLOAT_GENERATORS = List.of(
              withToString("float[-i * 5]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (float)(-i * 5));
 +                            i -> genValue(-i * 5));
              }),
-             withToString("Halffloat[i * 5]", (int s) -> {
+             withToString("float[i * 5]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (float)(i * 5));
 +                            i -> genValue(i * 5));
              }),
-             withToString("Halffloat[i + 1]", (int s) -> {
+             withToString("float[i + 1]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));
 +                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
              }),
-             withToString("Halffloat[cornerCaseValue(i)]", (int s) -> {
+             withToString("float[cornerCaseValue(i)]", (int s) -> {
                  return fill(s * BUFFER_REPS,
                              i -> (float)longCornerCaseValue(i));
              })
@@@ -1100,8 -1180,16 +1188,16 @@@
              }),
              withToString("float[i + 1]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));
 +                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
              }),
+             withToString("float[0.01 + (i / (i + 1))]", (int s) -> {
+                 return fill(s * BUFFER_REPS,
+                             i -> (float)0.01 + ((float)i / (i + 1)));
+             }),
+             withToString("float[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i / (i + 1))]", (int s) -> {
+                 return fill(s * BUFFER_REPS,
+                             i -> i % 17 == 0 ? cornerCaseValue(i) : (float)0.01 + ((float)i / (i + 1)));
+             }),
              withToString("float[cornerCaseValue(i)]", (int s) -> {
                  return fill(s * BUFFER_REPS,
                              i -> cornerCaseValue(i));
diff --cc test/jdk/jdk/incubator/vector/Halffloat128VectorLoadStoreTests.java
index 705228fbc60,00000000000..e2089ab18ad
mode 100644,000000..100644
--- a/test/jdk/jdk/incubator/vector/Halffloat128VectorLoadStoreTests.java
+++ b/test/jdk/jdk/incubator/vector/Halffloat128VectorLoadStoreTests.java
@@@ -1,849 -1,0 +1,1014 @@@
 +/*
-  * Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2018, 2025, Oracle and/or its affiliates. All rights reserved.
 + * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 + *
 + * This code is free software; you can redistribute it and/or modify it
 + * under the terms of the GNU General Public License version 2 only, as
 + * published by the Free Software Foundation.
 + *
 + * This code is distributed in the hope that it will be useful, but WITHOUT
 + * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 + * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 + * version 2 for more details (a copy is included in the LICENSE file that
 + * accompanied this code).
 + *
 + * You should have received a copy of the GNU General Public License version
 + * 2 along with this work; if not, write to the Free Software Foundation,
 + * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 + *
 + * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 + * or visit www.oracle.com if you need additional information or have any
 + * questions.
 + */
 +
 +/*
 + * @test
-  * @enablePreview
++ * @key randomness
++ *
++ * @library /test/lib
 + * @modules jdk.incubator.vector java.base/jdk.internal.vm.annotation
 + * @run testng/othervm -XX:-TieredCompilation Halffloat128VectorLoadStoreTests
 + *
 + */
 +
 +// -- This file was mechanically generated: Do not edit! -- //
 +
 +import java.lang.foreign.MemorySegment;
- import java.lang.foreign.SegmentScope;
++import java.lang.foreign.Arena;
 +import java.lang.foreign.ValueLayout;
- import jdk.incubator.vector.Halffloat;
- import jdk.incubator.vector.HalffloatVector;
 +import jdk.incubator.vector.HalffloatVector;
 +import jdk.incubator.vector.VectorMask;
 +import jdk.incubator.vector.VectorSpecies;
 +import jdk.incubator.vector.VectorShuffle;
 +import jdk.internal.vm.annotation.DontInline;
 +import org.testng.Assert;
 +import org.testng.annotations.DataProvider;
 +import org.testng.annotations.Test;
 +
 +import java.nio.ByteOrder;
 +import java.util.List;
 +import java.util.function.*;
 +
 +@Test
 +public class Halffloat128VectorLoadStoreTests extends AbstractVectorLoadStoreTest {
-     static final VectorSpecies<Halffloat> SPECIES =
++    static final VectorSpecies<Float16> SPECIES =
 +                HalffloatVector.SPECIES_128;
 +
 +    static final int INVOC_COUNT = Integer.getInteger("jdk.incubator.vector.test.loop-iterations", 100);
 +
-     static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withBitAlignment(8);
++    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withByteAlignment(1);
 +
 +
 +    static final int BUFFER_REPS = Integer.getInteger("jdk.incubator.vector.test.buffer-vectors", 25000 / 128);
 +
 +    static void assertArraysEquals(short[] r, short[] a, boolean[] mask) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0);
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0, "at index #" + i);
 +        }
 +    }
 +
 +    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(
 +            withToString("short[i * 5]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (short)(i * 5));
 +            }),
 +            withToString("short[i + 1]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));
 +            })
 +    );
 +
 +    // Relative to array.length
 +    static final List<IntFunction<Integer>> INDEX_GENERATORS = List.of(
 +            withToString("-1", (int l) -> {
 +                return -1;
 +            }),
 +            withToString("l", (int l) -> {
 +                return l;
 +            }),
 +            withToString("l - 1", (int l) -> {
 +                return l - 1;
 +            }),
 +            withToString("l + 1", (int l) -> {
 +                return l + 1;
 +            }),
 +            withToString("l - speciesl + 1", (int l) -> {
 +                return l - SPECIES.length() + 1;
 +            }),
 +            withToString("l + speciesl - 1", (int l) -> {
 +                return l + SPECIES.length() - 1;
 +            }),
 +            withToString("l + speciesl", (int l) -> {
 +                return l + SPECIES.length();
 +            }),
 +            withToString("l + speciesl + 1", (int l) -> {
 +                return l + SPECIES.length() + 1;
 +            })
 +    );
 +
 +    // Relative to byte[] array.length or MemorySegment.byteSize()
 +    static final List<IntFunction<Integer>> BYTE_INDEX_GENERATORS = List.of(
 +            withToString("-1", (int l) -> {
 +                return -1;
 +            }),
 +            withToString("l", (int l) -> {
 +                return l;
 +            }),
 +            withToString("l - 1", (int l) -> {
 +                return l - 1;
 +            }),
 +            withToString("l + 1", (int l) -> {
 +                return l + 1;
 +            }),
 +            withToString("l - speciesl*ebsize + 1", (int l) -> {
 +                return l - SPECIES.vectorByteSize() + 1;
 +            }),
 +            withToString("l + speciesl*ebsize - 1", (int l) -> {
 +                return l + SPECIES.vectorByteSize() - 1;
 +            }),
 +            withToString("l + speciesl*ebsize", (int l) -> {
 +                return l + SPECIES.vectorByteSize();
 +            }),
 +            withToString("l + speciesl*ebsize + 1", (int l) -> {
 +                return l + SPECIES.vectorByteSize() + 1;
 +            })
 +    );
 +
 +    @DataProvider
 +    public Object[][] shortProvider() {
 +        return HALFFLOAT_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] maskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortProviderForIOOBE() {
 +        var f = HALFFLOAT_GENERATORS.get(0);
 +        return INDEX_GENERATORS.stream().map(fi -> {
 +                    return new Object[] {f, fi};
 +                }).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                    return new Object[] {fa, fm};
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortMaskProviderForIOOBE() {
 +        var f = HALFFLOAT_GENERATORS.get(0);
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {
 +                    return new Object[] {f, fi, fm};
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortMemorySegmentProvider() {
 +        return HALFFLOAT_GENERATORS.stream().
 +                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().
 +                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {
 +                            return new Object[]{fa, fb, bo};
 +                        }))).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortMemorySegmentMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_GENERATORS.stream().
 +                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().
 +                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {
 +                            return new Object[]{fa, fb, fm, bo};
 +                        })))).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortByteProviderForIOOBE() {
 +        var f = HALFFLOAT_GENERATORS.get(0);
 +        return BYTE_INDEX_GENERATORS.stream().map(fi -> {
 +                    return new Object[] {f, fi};
 +                }).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortByteMaskProviderForIOOBE() {
 +        var f = HALFFLOAT_GENERATORS.get(0);
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> BYTE_INDEX_GENERATORS.stream().map(fi -> {
 +                    return new Object[] {f, fi, fm};
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {
 +        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() / 8);
 +        for (int i = 0; i < a.length; i++) {
 +            ms.set(ELEMENT_LAYOUT, i * SPECIES.elementSize() / 8 , a[i]);
 +        }
 +        return ms;
 +    }
 +
 +    static short[] segmentToArray(MemorySegment ms) {
 +        return ms.toArray(ELEMENT_LAYOUT);
 +    }
 +
 +
 +    interface ToHalffloatF {
 +        short apply(int i);
 +    }
 +
 +    static short[] fill(int s , ToHalffloatF f) {
 +        return fill(new short[s], f);
 +    }
 +
 +    static short[] fill(short[] a, ToHalffloatF f) {
 +        for (int i = 0; i < a.length; i++) {
 +            a[i] = f.apply(i);
 +        }
 +        return a;
 +    }
 +
++    @DontInline
++    static VectorShuffle<Float16> shuffleFromArray(int[] a, int i) {
++        return SPECIES.shuffleFromArray(a, i);
++    }
++
++    @DontInline
++    static void shuffleIntoArray(VectorShuffle<Float16> s, int[] a, int i) {
++        s.intoArray(a, i);
++    }
++
++    @DontInline
++    static VectorShuffle<Float16> shuffleFromMemorySegment(MemorySegment mem, int i, ByteOrder bo) {
++        return VectorShuffle.fromMemorySegment(SPECIES, mem, i, bo);
++    }
++
++    @DontInline
++    static void shuffleIntoMemorySegment(VectorShuffle<Float16> s, MemorySegment mem, int i, ByteOrder bo) {
++        s.intoMemorySegment(mem, i, bo);
++    }
++
 +    @DontInline
 +    static HalffloatVector fromArray(short[] a, int i) {
-         return HalffloatVector.fromArray(SPECIES, a, i);
++        // Tests the species method and the equivalent vector method it defers to
++        return (HalffloatVector) SPECIES.fromArray(a, i);
 +    }
 +
 +    @DontInline
-     static HalffloatVector fromArray(short[] a, int i, VectorMask<Halffloat> m) {
++    static HalffloatVector fromArray(short[] a, int i, VectorMask<Float16> m) {
 +        return HalffloatVector.fromArray(SPECIES, a, i, m);
 +    }
 +
 +    @DontInline
 +    static void intoArray(HalffloatVector v, short[] a, int i) {
 +        v.intoArray(a, i);
 +    }
 +
 +    @DontInline
-     static void intoArray(HalffloatVector v, short[] a, int i, VectorMask<Halffloat> m) {
++    static void intoArray(HalffloatVector v, short[] a, int i, VectorMask<Float16> m) {
 +        v.intoArray(a, i, m);
 +    }
 +
 +    @DontInline
 +    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {
-         return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);
++        // Tests the species method and the equivalent vector method it defers to
++        return (HalffloatVector) SPECIES.fromMemorySegment(a, i, bo);
 +    }
 +
 +    @DontInline
-     static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Halffloat> m) {
++    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Float16> m) {
 +        return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, m);
 +    }
 +
 +    @DontInline
 +    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo) {
 +        v.intoMemorySegment(a, i, bo);
 +    }
 +
 +    @DontInline
-     static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Halffloat> m) {
++    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Float16> m) {
 +        v.intoMemorySegment(a, i, bo, m);
 +    }
 +
 +    @Test(dataProvider = "shortProvider")
 +    static void loadStoreArray(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = new short[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.intoArray(r, i);
 +            }
 +        }
 +        Assert.assertEquals(r, a);
 +    }
 +
 +    @Test(dataProvider = "shortProviderForIOOBE")
 +    static void loadArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = new short[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = fromArray(a, i);
 +                av.intoArray(r, i);
 +            }
 +        }
 +
 +        int index = fi.apply(a.length);
 +        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);
 +        try {
 +            fromArray(a, index);
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortProviderForIOOBE")
 +    static void storeArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = new short[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                intoArray(av, r, i);
 +            }
 +        }
 +
 +        int index = fi.apply(a.length);
 +        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);
 +        try {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);
 +            intoArray(av, r, index);
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +
 +    @Test(dataProvider = "shortMaskProvider")
 +    static void loadStoreMaskArray(IntFunction<short[]> fa,
 +                                   IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = new short[a.length];
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);
++        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, vmask);
 +                av.intoArray(r, i);
 +            }
 +        }
 +        assertArraysEquals(r, a, mask);
 +
 +
 +        r = new short[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.intoArray(r, i, vmask);
 +            }
 +        }
 +        assertArraysEquals(r, a, mask);
 +    }
 +
 +    @Test(dataProvider = "shortMaskProviderForIOOBE")
 +    static void loadArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = new short[a.length];
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);
++        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = fromArray(a, i, vmask);
 +                av.intoArray(r, i);
 +            }
 +        }
 +
 +        int index = fi.apply(a.length);
 +        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);
 +        try {
 +            fromArray(a, index, vmask);
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortMaskProviderForIOOBE")
 +    static void storeArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = new short[a.length];
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);
++        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                intoArray(av, r, i, vmask);
 +            }
 +        }
 +
 +        int index = fi.apply(a.length);
 +        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);
 +        try {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);
 +            intoArray(av, a, index, vmask);
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +
 +    @Test(dataProvider = "shortMaskProvider")
 +    static void loadStoreMask(IntFunction<short[]> fa,
 +                              IntFunction<boolean[]> fm) {
 +        boolean[] mask = fm.apply(SPECIES.length());
 +        boolean[] r = new boolean[mask.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < mask.length; i += SPECIES.length()) {
-                 VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, i);
++                VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, i);
 +                vmask.intoArray(r, i);
 +            }
 +        }
 +        Assert.assertEquals(r, mask);
 +    }
 +
 +
 +    @Test(dataProvider = "shortMemorySegmentProvider")
 +    static void loadStoreMemorySegment(IntFunction<short[]> fa,
 +                                       IntFunction<MemorySegment> fb,
 +                                       ByteOrder bo) {
 +        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);
 +        MemorySegment r = fb.apply((int) a.byteSize());
 +
 +        int l = (int) a.byteSize();
 +        int s = SPECIES.vectorByteSize();
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < l; i += s) {
 +                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);
 +                av.intoMemorySegment(r, i, bo);
 +            }
 +        }
 +        long m = r.mismatch(a);
 +        Assert.assertEquals(m, -1, "Segments not equal");
 +    }
 +
 +    @Test(dataProvider = "shortByteProviderForIOOBE")
 +    static void loadMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {
-         MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));
-         MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());
++        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));
++        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);
 +
 +        int l = (int) a.byteSize();
 +        int s = SPECIES.vectorByteSize();
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < l; i += s) {
 +                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());
 +                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());
 +            }
 +        }
 +
 +        int index = fi.apply((int) a.byteSize());
 +        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());
 +        try {
 +            fromMemorySegment(a, index, ByteOrder.nativeOrder());
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortByteProviderForIOOBE")
 +    static void storeMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {
-         MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));
-         MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());
++        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));
++        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);
 +
 +        int l = (int) a.byteSize();
 +        int s = SPECIES.vectorByteSize();
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < l; i += s) {
 +                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());
 +                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());
 +            }
 +        }
 +
 +        int index = fi.apply((int) a.byteSize());
 +        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());
 +        try {
 +            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());
 +            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortMemorySegmentMaskProvider")
 +    static void loadStoreMemorySegmentMask(IntFunction<short[]> fa,
 +                                           IntFunction<MemorySegment> fb,
 +                                           IntFunction<boolean[]> fm,
 +                                           ByteOrder bo) {
 +        short[] _a = fa.apply(SPECIES.length());
 +        MemorySegment a = toSegment(_a, fb);
 +        MemorySegment r = fb.apply((int) a.byteSize());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);
++        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);
 +
 +        int l = (int) a.byteSize();
 +        int s = SPECIES.vectorByteSize();
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < l; i += s) {
 +                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, vmask);
 +                av.intoMemorySegment(r, i, bo);
 +            }
 +        }
 +        assertArraysEquals(segmentToArray(r), _a, mask);
 +
 +
 +        r = fb.apply((int) a.byteSize());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < l; i += s) {
 +                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);
 +                av.intoMemorySegment(r, i, bo, vmask);
 +            }
 +        }
 +        assertArraysEquals(segmentToArray(r), _a, mask);
 +    }
 +
 +    @Test(dataProvider = "shortByteMaskProviderForIOOBE")
 +    static void loadMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {
-         MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));
-         MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());
++        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));
++        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);
++        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);
 +
 +        int l = (int) a.byteSize();
 +        int s = SPECIES.vectorByteSize();
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < l; i += s) {
 +                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);
 +                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());
 +            }
 +        }
 +
 +        int index = fi.apply((int) a.byteSize());
 +        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() / 8);
 +        try {
 +            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortByteMaskProviderForIOOBE")
 +    static void storeMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {
-         MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));
-         MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());
++        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));
++        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);
++        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);
 +
 +        int l = (int) a.byteSize();
 +        int s = SPECIES.vectorByteSize();
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < l; i += s) {
 +                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());
 +                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);
 +            }
 +        }
 +
 +        int index = fi.apply((int) a.byteSize());
 +        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() / 8);
 +        try {
 +            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());
 +            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortMemorySegmentProvider")
 +    static void loadStoreReadonlyMemorySegment(IntFunction<short[]> fa,
 +                                               IntFunction<MemorySegment> fb,
 +                                               ByteOrder bo) {
 +        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();
 +
 +        Assert.assertThrows(
 +                UnsupportedOperationException.class,
 +                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)
 +        );
 +
 +        Assert.assertThrows(
 +                UnsupportedOperationException.class,
 +                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))
 +        );
 +
 +        Assert.assertThrows(
 +                UnsupportedOperationException.class,
 +                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))
 +        );
 +
-         VectorMask<Halffloat> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)
++        VectorMask<Float16> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)
 +                .laneIsValid();
 +        Assert.assertThrows(
 +                UnsupportedOperationException.class,
 +                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)
 +        );
 +    }
 +
 +
 +    @Test(dataProvider = "maskProvider")
 +    static void loadStoreMask(IntFunction<boolean[]> fm) {
 +        boolean[] a = fm.apply(SPECIES.length());
 +        boolean[] r = new boolean[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                 VectorMask<Halffloat> vmask = SPECIES.loadMask(a, i);
++                VectorMask<Float16> vmask = SPECIES.loadMask(a, i);
 +                vmask.intoArray(r, i);
 +            }
 +        }
 +        Assert.assertEquals(r, a);
 +    }
 +
 +
-     @Test
-     static void loadStoreShuffle() {
-         IntUnaryOperator fn = a -> a + 5;
-         for (int ic = 0; ic < INVOC_COUNT; ic++) {
-             var shuffle = VectorShuffle.fromOp(SPECIES, fn);
-             int [] r = shuffle.toArray();
++   @Test(dataProvider = "shuffleIntProvider")
++   static void loadStoreShuffleArray(IntFunction<int[]> fa) {
++       int[] a = fa.apply(SPECIES.length());
++       int[] r = new int[a.length];
 +
-             int [] a = expectedShuffle(SPECIES.length(), fn);
-             Assert.assertEquals(r, a);
++       for (int ic = 0; ic < INVOC_COUNT; ic++) {
++           for (int i = 0; i < a.length; i += SPECIES.length()) {
++               VectorShuffle<Float16> shuffle = VectorShuffle.fromArray(SPECIES, a, i);
++               shuffle.intoArray(r, i);
++           }
 +       }
-     }
 +
++       for (int i = 0; i < a.length; i++) {
++          Assert.assertEquals(testPartiallyWrapIndex(SPECIES, a[i]), r[i]);
++       }
++
++   }
++
++   @Test(dataProvider = "shuffleIntProviderForIOOBE")
++   static void storeShuffleArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {
++       int[] a = fa.apply(SPECIES.length());
++       int[] r = new int[a.length];
++
++       for (int ic = 0; ic < INVOC_COUNT; ic++) {
++           for (int i = 0; i < a.length; i += SPECIES.length()) {
++               VectorShuffle<Float16> shuffle = shuffleFromArray(a, i);
++               shuffleIntoArray(shuffle, r, i);
++           }
++       }
++
++       int index = fi.apply(a.length);
++       boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);
++       try {
++           VectorShuffle<Float16> shuffle = shuffleFromArray(a, index);
++           shuffleIntoArray(shuffle, r, index);
++           if (shouldFail) {
++               Assert.fail("Failed to throw IndexOutOfBoundsException");
++           }
++       } catch (IndexOutOfBoundsException e) {
++           if (!shouldFail) {
++               Assert.fail("Unexpected IndexOutOfBoundsException");
++           }
++       }
++   }
++
++   @Test(dataProvider = "shuffleIntProviderForIOOBE")
++   static void loadShuffleArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {
++       int[] a = fa.apply(SPECIES.length());
++       int[] r = new int[a.length];
++
++       for (int ic = 0; ic < INVOC_COUNT; ic++) {
++           for (int i = 0; i < a.length; i += SPECIES.length()) {
++               VectorShuffle<Float16> shuffle = shuffleFromArray(a, i);
++               shuffle.intoArray(r, i);
++           }
++       }
++
++       int index = fi.apply(a.length);
++       boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);
++       try {
++           shuffleFromArray(a, index);
++           if (shouldFail) {
++               Assert.fail("Failed to throw IndexOutOfBoundsException");
++           }
++       } catch (IndexOutOfBoundsException e) {
++           if (!shouldFail) {
++               Assert.fail("Unexpected IndexOutOfBoundsException");
++           }
++       }
++   }
++
++   @Test(dataProvider = "shuffleIntMemorySegmentProvider")
++   static void loadStoreShuffleMemorySegment(IntFunction<int[]> fa,
++                                      IntFunction<MemorySegment> fb,
++                                      ByteOrder bo) {
++       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), fb);
++       MemorySegment r = fb.apply((int) a.byteSize());
++
++       int l = (int) a.byteSize();
++       int s = SPECIES.length() * 4; //An integer for every lane is read out. So 4 bytes per lane
++
++       for (int ic = 0; ic < INVOC_COUNT; ic++) {
++           for (int i = 0; i < l; i += s) {
++               VectorShuffle<Float16> shuffle = VectorShuffle.fromMemorySegment(SPECIES, a, i, bo);
++               shuffle.intoMemorySegment(r, i, bo);
++           }
++       }
++
++       for (int i = 0; i < l / 4; i++) {
++           int ai = a.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED.withOrder(bo), i);
++           int ri = r.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED.withOrder(bo), i);
++           Assert.assertEquals(testPartiallyWrapIndex(SPECIES, ai), ri);
++       }
++   }
++
++   @Test(dataProvider = "shuffleIntByteProviderForIOOBE")
++   static void shuffleLoadMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {
++       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i));
++       MemorySegment r = Arena.ofAuto().allocate(a.byteSize());
++
++       int l = (int) a.byteSize();
++       int s = SPECIES.length() * 4;
++
++       for (int ic = 0; ic < INVOC_COUNT; ic++) {
++           for (int i = 0; i < l; i += s) {
++               VectorShuffle<Float16> shuffle = shuffleFromMemorySegment(a, i, ByteOrder.nativeOrder());
++               shuffle.intoMemorySegment(r, i, ByteOrder.nativeOrder());
++           }
++       }
++
++       int index = fi.apply((int) a.byteSize());
++       boolean shouldFail = isIndexOutOfBounds(s, index, (int) a.byteSize());
++       try {
++           shuffleFromMemorySegment(a, index, ByteOrder.nativeOrder());
++           if (shouldFail) {
++               Assert.fail("Failed to throw IndexOutOfBoundsException");
++           }
++       } catch (IndexOutOfBoundsException e) {
++           if (!shouldFail) {
++               Assert.fail("Unexpected IndexOutOfBoundsException");
++           }
++       }
++   }
++
++   @Test(dataProvider = "shuffleIntByteProviderForIOOBE")
++   static void shuffleStoreMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {
++       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i));
++       MemorySegment r = Arena.ofAuto().allocate(a.byteSize());
++
++       int l = (int) a.byteSize();
++       int s = SPECIES.length() * 4;
++
++       for (int ic = 0; ic < INVOC_COUNT; ic++) {
++           for (int i = 0; i < l; i += s) {
++               VectorShuffle<Float16> shuffle =
++                       VectorShuffle.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());
++               shuffleIntoMemorySegment(shuffle, r, i, ByteOrder.nativeOrder());
++           }
++       }
++
++       int index = fi.apply((int) a.byteSize());
++       boolean shouldFail = isIndexOutOfBounds(s, index, (int) a.byteSize());
++       try {
++           VectorShuffle<Float16> shuffle =
++                   VectorShuffle.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());
++           shuffleIntoMemorySegment(shuffle, r, index, ByteOrder.nativeOrder());
++           if (shouldFail) {
++               Assert.fail("Failed to throw IndexOutOfBoundsException");
++           }
++       } catch (IndexOutOfBoundsException e) {
++           if (!shouldFail) {
++               Assert.fail("Unexpected IndexOutOfBoundsException");
++           }
++       }
++   }
 +
 +
 +
 +
 +    // Gather/Scatter load/store tests
 +
 +    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {
 +        int i = 0;
 +        int j = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                j = i;
 +                for (; j < i + SPECIES.length(); j++) {
 +                    Assert.assertEquals(r[j], a[i + indexMap[j]]);
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[j], a[i + indexMap[j]], "at index #" + j);
 +        }
 +    }
 +
 +    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {
 +        int i = 0;
 +        int j = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                j = i;
 +                for (; j < i + SPECIES.length(); j++) {
 +                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, "at index #" + j);
 +        }
 +    }
 +
 +    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {
 +        short[] expected = new short[r.length];
 +
 +        // Store before checking, since the same location may be stored to more than once
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            for (int j = i; j < i + SPECIES.length(); j++) {
 +                if (mask[j % SPECIES.length()]) {
 +                    expected[i + indexMap[j]] = a[j];
 +                }
 +            }
 +        }
 +
 +        Assert.assertEquals(r, expected);
 +    }
 +
 +    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {
 +        short[] expected = new short[r.length];
 +
 +        // Store before checking, since the same location may be stored to more than once
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            for (int j = i; j < i + SPECIES.length(); j++) {
 +                expected[i + indexMap[j]] = a[j];
 +            }
 +        }
 +
 +        Assert.assertEquals(r, expected);
 +    }
 +
 +    @DataProvider
 +    public Object[][] gatherScatterProvider() {
 +        return INT_INDEX_GENERATORS.stream().
 +                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                    return new Object[] {fa, fs};
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] gatherScatterMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->
 +            HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                    return new Object[] {fa, fm, fs};
 +            }))).
 +            toArray(Object[][]::new);
 +    }
 +
 +
 +    @Test(dataProvider = "gatherScatterProvider")
 +    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {
 +        short[] a = fa.apply(SPECIES.length());
 +        int[] b = fs.apply(a.length, SPECIES.length());
 +        short[] r = new short[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i);
 +                av.intoArray(r, i);
 +            }
 +        }
 +
 +        assertGatherArraysEquals(r, a, b);
 +    }
 +
 +    @Test(dataProvider = "gatherScatterMaskProvider")
 +    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        int[] b = fs.apply(a.length, SPECIES.length());
 +        short[] r = new short[a.length];
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i, vmask);
 +                av.intoArray(r, i);
 +            }
 +        }
 +
 +        assertGatherArraysEquals(r, a, b, mask);
 +    }
 +
 +    @Test(dataProvider = "gatherScatterProvider")
 +    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {
 +        short[] a = fa.apply(SPECIES.length());
 +        int[] b = fs.apply(a.length, SPECIES.length());
 +        short[] r = new short[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.intoArray(r, i, b, i);
 +            }
 +        }
 +
 +        assertScatterArraysEquals(r, a, b);
 +    }
 +
 +    @Test(dataProvider = "gatherScatterMaskProvider")
 +    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        int[] b = fs.apply(a.length, SPECIES.length());
 +        short[] r = new short[a.length];
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.intoArray(r, i, b, i, vmask);
 +            }
 +        }
 +
 +        assertScatterArraysEquals(r, a, b, mask);
 +    }
 +
 +
 +
 +}
diff --cc test/jdk/jdk/incubator/vector/Halffloat128VectorTests.java
index 5ebf375a15f,00000000000..9f7c8bdd190
mode 100644,000000..100644
--- a/test/jdk/jdk/incubator/vector/Halffloat128VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Halffloat128VectorTests.java
@@@ -1,3134 -1,0 +1,3256 @@@
 +/*
-  * Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
 + * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 + *
 + * This code is free software; you can redistribute it and/or modify it
 + * under the terms of the GNU General Public License version 2 only, as
 + * published by the Free Software Foundation.
 + *
 + * This code is distributed in the hope that it will be useful, but WITHOUT
 + * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 + * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 + * version 2 for more details (a copy is included in the LICENSE file that
 + * accompanied this code).
 + *
 + * You should have received a copy of the GNU General Public License version
 + * 2 along with this work; if not, write to the Free Software Foundation,
 + * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 + *
 + * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 + * or visit www.oracle.com if you need additional information or have any
 + * questions.
 + */
 +
 +/*
 + * @test
++ * @key randomness
++ *
++ * @library /test/lib
 + * @modules jdk.incubator.vector
-  * @run testng/othervm -ea -esa -Xbatch -XX:-TieredCompilation Halffloat128VectorTests
++ * @run testng/othervm/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Halffloat128VectorTests
 + */
 +
 +// -- This file was mechanically generated: Do not edit! -- //
 +
 +import jdk.incubator.vector.VectorShape;
 +import jdk.incubator.vector.VectorSpecies;
 +import jdk.incubator.vector.VectorShuffle;
 +import jdk.incubator.vector.VectorMask;
 +import jdk.incubator.vector.VectorOperators;
 +import jdk.incubator.vector.Vector;
 +
- import jdk.incubator.vector.Halffloat;
++import jdk.incubator.vector.Float16;
 +import jdk.incubator.vector.HalffloatVector;
 +
 +import org.testng.Assert;
 +import org.testng.annotations.DataProvider;
 +import org.testng.annotations.Test;
 +
 +import java.lang.Integer;
 +import java.util.List;
 +import java.util.Arrays;
 +import java.util.function.BiFunction;
 +import java.util.function.IntFunction;
 +import java.util.Objects;
 +import java.util.stream.Collectors;
 +import java.util.stream.Stream;
 +
 +@Test
 +public class Halffloat128VectorTests extends AbstractVectorTest {
 +
-     static final VectorSpecies<Halffloat> SPECIES =
++    static final VectorSpecies<Float16> SPECIES =
 +                HalffloatVector.SPECIES_128;
 +
 +    static final int INVOC_COUNT = Integer.getInteger("jdk.incubator.vector.test.loop-iterations", 100);
 +
 +
++    // for floating point addition reduction ops that may introduce rounding errors
++    private static final short RELATIVE_ROUNDING_ERROR_FACTOR_ADD = (short)10.0;
++
++    // for floating point multiplication reduction ops that may introduce rounding errors
++    private static final short RELATIVE_ROUNDING_ERROR_FACTOR_MUL = (short)50.0;
 +
 +    static final int BUFFER_REPS = Integer.getInteger("jdk.incubator.vector.test.buffer-vectors", 25000 / 128);
 +
++    static void assertArraysStrictlyEquals(short[] r, short[] a) {
++        for (int i = 0; i < a.length; i++) {
++            short ir = Float16.shortToRawShortBits(r[i]);
++            short ia = Float16.shortToRawShortBits(a[i]);
++            if (ir != ia) {
++                Assert.fail(String.format("at index #%d, expected = %016X, actual = %016X", i, ia, ir));
++            }
++        }
++    }
++
 +    interface FUnOp {
 +        short apply(short a);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, FUnOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i]), "at index #" + i + ", input = " + a[i]);
 +        }
 +    }
 +
 +    interface FUnArrayOp {
 +        short[] apply(short a);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, FUnArrayOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a[i]));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a[i]);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref, "(ref: " + Arrays.toString(ref)
 +              + ", res: " + Arrays.toString(res)
 +              + "), at index #" + i);
 +        }
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, boolean[] mask, FUnOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], "at index #" + i + ", input = " + a[i] + ", mask = " + mask[i % SPECIES.length()]);
 +        }
 +    }
 +
 +    interface FReductionOp {
 +        short apply(short[] a, int idx);
 +    }
 +
 +    interface FReductionAllOp {
 +        short apply(short[] a);
 +    }
 +
 +    static void assertReductionArraysEquals(short[] r, short rc, short[] a,
 +                                            FReductionOp f, FReductionAllOp fa) {
++        assertReductionArraysEquals(r, rc, a, f, fa, (short)0.0);
++    }
++
++    static void assertReductionArraysEquals(short[] r, short rc, short[] a,
++                                            FReductionOp f, FReductionAllOp fa,
++                                            short relativeErrorFactor) {
 +        int i = 0;
 +        try {
-             Assert.assertEquals(rc, fa.apply(a));
++            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor);
 +            for (; i < a.length; i += SPECIES.length()) {
-                 Assert.assertEquals(r[i], f.apply(a, i));
++                Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor);
 +            }
 +        } catch (AssertionError e) {
-             Assert.assertEquals(rc, fa.apply(a), "Final result is incorrect!");
-             Assert.assertEquals(r[i], f.apply(a, i), "at index #" + i);
++            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor, "Final result is incorrect!");
++            Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor, "at index #" + i);
 +        }
 +    }
 +
 +    interface FReductionMaskedOp {
 +        short apply(short[] a, int idx, boolean[] mask);
 +    }
 +
 +    interface FReductionAllMaskedOp {
 +        short apply(short[] a, boolean[] mask);
 +    }
 +
 +    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,
 +                                            FReductionMaskedOp f, FReductionAllMaskedOp fa) {
++        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, (short)0.0);
++    }
++
++    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,
++                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,
++                                            short relativeError) {
 +        int i = 0;
 +        try {
-             Assert.assertEquals(rc, fa.apply(a, mask));
++            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));
 +            for (; i < a.length; i += SPECIES.length()) {
-                 Assert.assertEquals(r[i], f.apply(a, i, mask));
++                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *
++relativeError));
 +            }
 +        } catch (AssertionError e) {
-             Assert.assertEquals(rc, fa.apply(a, mask), "Final result is incorrect!");
-             Assert.assertEquals(r[i], f.apply(a, i, mask), "at index #" + i);
++            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), "Final result is incorrect!");
++            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), "at index #" + i);
 +        }
 +    }
 +
 +    interface FReductionOpLong {
 +        long apply(short[] a, int idx);
 +    }
 +
 +    interface FReductionAllOpLong {
 +        long apply(short[] a);
 +    }
 +
 +    static void assertReductionLongArraysEquals(long[] r, long rc, short[] a,
 +                                            FReductionOpLong f, FReductionAllOpLong fa) {
 +        int i = 0;
 +        try {
 +            Assert.assertEquals(rc, fa.apply(a));
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(r[i], f.apply(a, i));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(rc, fa.apply(a), "Final result is incorrect!");
 +            Assert.assertEquals(r[i], f.apply(a, i), "at index #" + i);
 +        }
 +    }
 +
 +    interface FReductionMaskedOpLong {
 +        long apply(short[] a, int idx, boolean[] mask);
 +    }
 +
 +    interface FReductionAllMaskedOpLong {
 +        long apply(short[] a, boolean[] mask);
 +    }
 +
 +    static void assertReductionLongArraysEqualsMasked(long[] r, long rc, short[] a, boolean[] mask,
 +                                            FReductionMaskedOpLong f, FReductionAllMaskedOpLong fa) {
 +        int i = 0;
 +        try {
 +            Assert.assertEquals(rc, fa.apply(a, mask));
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(r[i], f.apply(a, i, mask));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(rc, fa.apply(a, mask), "Final result is incorrect!");
 +            Assert.assertEquals(r[i], f.apply(a, i, mask), "at index #" + i);
 +        }
 +    }
 +
 +    interface FBoolReductionOp {
 +        boolean apply(boolean[] a, int idx);
 +    }
 +
 +    static void assertReductionBoolArraysEquals(boolean[] r, boolean[] a, FBoolReductionOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(r[i], f.apply(a, i));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a, i), "at index #" + i);
 +        }
 +    }
 +
 +    interface FMaskReductionOp {
 +        int apply(boolean[] a, int idx);
 +    }
 +
 +    static void assertMaskReductionArraysEquals(int[] r, boolean[] a, FMaskReductionOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(r[i], f.apply(a, i));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a, i), "at index #" + i);
 +        }
 +    }
 +
-     static void assertInsertArraysEquals(short[] r, short[] a, short element, int index, int start, int end) {
-         int i = start;
-         try {
-             for (; i < end; i += 1) {
-                 if(i%SPECIES.length() == index) {
-                     Assert.assertEquals(r[i], element);
-                 } else {
-                     Assert.assertEquals(r[i], a[i]);
-                 }
-             }
-         } catch (AssertionError e) {
-             if (i%SPECIES.length() == index) {
-                 Assert.assertEquals(r[i], element, "at index #" + i);
-             } else {
-                 Assert.assertEquals(r[i], a[i], "at index #" + i);
-             }
-         }
-     }
- 
 +    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, int vector_len) {
 +        int i = 0, j = 0;
 +        try {
 +            for (; i < a.length; i += vector_len) {
 +                for (j = 0; j < vector_len; j++) {
 +                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            int idx = i + j;
 +            Assert.assertEquals(r[i+j], a[i+order[i+j]], "at index #" + idx + ", input = " + a[i+order[i+j]]);
 +        }
 +    }
 +
 +    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {
 +        int i = 0, j = 0, k = 0;
 +        try {
 +            for (; i < a.length; i += vector_len) {
 +                k = 0;
 +                for (j = 0; j < vector_len; j++) {
 +                    if (m[(i + j) % SPECIES.length()]) {
 +                        Assert.assertEquals(r[i + k], a[i + j]);
 +                        k++;
 +                    }
 +                }
 +                for (; k < vector_len; k++) {
 +                    Assert.assertEquals(r[i + k], (short)0);
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            int idx = i + k;
 +            if (m[(i + j) % SPECIES.length()]) {
 +                Assert.assertEquals(r[idx], a[i + j], "at index #" + idx);
 +            } else {
 +                Assert.assertEquals(r[idx], (short)0, "at index #" + idx);
 +            }
 +        }
 +    }
 +
 +    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {
 +        int i = 0, j = 0, k = 0;
 +        try {
 +            for (; i < a.length; i += vector_len) {
 +                k = 0;
 +                for (j = 0; j < vector_len; j++) {
 +                    if (m[(i + j) % SPECIES.length()]) {
 +                        Assert.assertEquals(r[i + j], a[i + k]);
 +                        k++;
 +                    } else {
 +                        Assert.assertEquals(r[i + j], (short)0);
 +                    }
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            int idx = i + j;
 +            if (m[idx % SPECIES.length()]) {
 +                Assert.assertEquals(r[idx], a[i + k], "at index #" + idx);
 +            } else {
 +                Assert.assertEquals(r[idx], (short)0, "at index #" + idx);
 +            }
 +        }
 +    }
 +
++    static void assertSelectFromTwoVectorEquals(short[] r, short[] order, short[] a, short[] b, int vector_len) {
++        int i = 0, j = 0;
++        boolean is_exceptional_idx = false;
++        int idx = 0, wrapped_index = 0, oidx = 0;
++        try {
++            for (; i < a.length; i += vector_len) {
++                for (j = 0; j < vector_len; j++) {
++                    idx = i + j;
++                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);
++                    is_exceptional_idx = wrapped_index >= vector_len;
++                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;
++                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));
++                }
++            }
++        } catch (AssertionError e) {
++            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), "at index #" + idx + ", order = " + order[idx] + ", a = " + a[i + oidx] + ", b = " + b[i + oidx]);
++        }
++    }
++
 +    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, int vector_len) {
 +        int i = 0, j = 0;
 +        try {
 +            for (; i < a.length; i += vector_len) {
 +                for (j = 0; j < vector_len; j++) {
 +                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            int idx = i + j;
 +            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], "at index #" + idx + ", input = " + a[i+(int)order[i+j]]);
 +        }
 +    }
 +
 +    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, boolean[] mask, int vector_len) {
 +        int i = 0, j = 0;
 +        try {
 +            for (; i < a.length; i += vector_len) {
 +                for (j = 0; j < vector_len; j++) {
 +                    if (mask[j % SPECIES.length()])
 +                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);
 +                    else
 +                         Assert.assertEquals(r[i+j], (short)0);
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            int idx = i + j;
 +            if (mask[j % SPECIES.length()])
 +                Assert.assertEquals(r[i+j], a[i+order[i+j]], "at index #" + idx + ", input = " + a[i+order[i+j]] + ", mask = " + mask[j % SPECIES.length()]);
 +            else
 +                Assert.assertEquals(r[i+j], (short)0, "at index #" + idx + ", input = " + a[i+order[i+j]] + ", mask = " + mask[j % SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, boolean[] mask, int vector_len) {
 +        int i = 0, j = 0;
 +        try {
 +            for (; i < a.length; i += vector_len) {
 +                for (j = 0; j < vector_len; j++) {
 +                    if (mask[j % SPECIES.length()])
 +                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);
 +                    else
 +                         Assert.assertEquals(r[i+j], (short)0);
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            int idx = i + j;
 +            if (mask[j % SPECIES.length()])
 +                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], "at index #" + idx + ", input = " + a[i+(int)order[i+j]] + ", mask = " + mask[j % SPECIES.length()]);
 +            else
 +                Assert.assertEquals(r[i+j], (short)0, "at index #" + idx + ", input = " + a[i+(int)order[i+j]] + ", mask = " + mask[j % SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertBroadcastArraysEquals(short[] r, short[] a) {
 +        int i = 0;
 +        for (; i < a.length; i += SPECIES.length()) {
 +            int idx = i;
 +            for (int j = idx; j < (idx + SPECIES.length()); j++)
 +                a[j]=a[idx];
 +        }
 +
 +        try {
 +            for (i = 0; i < a.length; i++) {
 +                Assert.assertEquals(r[i], a[i]);
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], a[i], "at index #" + i + ", input = " + a[i]);
 +        }
 +    }
 +
 +    interface FBinOp {
 +        short apply(short a, short b);
 +    }
 +
 +    interface FBinMaskOp {
 +        short apply(short a, short b, boolean m);
 +
 +        static FBinMaskOp lift(FBinOp f) {
 +            return (a, b, m) -> m ? f.apply(a, b) : a;
 +        }
 +    }
 +
++    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, FBinOp f) {
++        int i = 0;
++        try {
++            for (; i < a.length; i++) {
++                //Left associative
++                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));
++
++                //Right associative
++                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));
++
++                //Results equal sanity check
++                Assert.assertEquals(rl[i], rr[i]);
++            }
++        } catch (AssertionError e) {
++            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), "left associative test at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", input3 = " + c[i]);
++            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), "right associative test at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", input3 = " + c[i]);
++            Assert.assertEquals(rl[i], rr[i], "Result checks not equal at index #" + i + "leftRes = " + rl[i] + ", rightRes = " + rr[i]);
++        }
++    }
++
++   static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinOp f) {
++       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));
++   }
++
++    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinMaskOp f) {
++        int i = 0;
++        boolean mask_bit = false;
++        try {
++            for (; i < a.length; i++) {
++                mask_bit = mask[i % SPECIES.length()];
++                //Left associative
++                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));
++
++                //Right associative
++                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));
++
++                //Results equal sanity check
++                Assert.assertEquals(rl[i], rr[i]);
++            }
++        } catch (AssertionError e) {
++            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), "left associative masked test at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", input3 = " + c[i] + ", mask = " + mask_bit);
++            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), "right associative masked test at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", input3 = " + c[i] + ", mask = " + mask_bit);
++            Assert.assertEquals(rl[i], rr[i], "Result checks not equal at index #" + i + "leftRes = " + rl[i] + ", rightRes = " + rr[i]);
++        }
++    }
++
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[i]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[i]), "(" + a[i] + ", " + b[i] + ") at index #" + i);
 +        }
 +    }
 +
++    static void assertArraysEquals(short[] r, short[] a, short b, FBinOp f) {
++        int i = 0;
++        try {
++            for (; i < a.length; i++) {
++                Assert.assertEquals(r[i], f.apply(a[i], b));
++            }
++        } catch (AssertionError e) {
++            Assert.assertEquals(r[i], f.apply(a[i], b), "(" + a[i] + ", " + b + ") at index #" + i);
++        }
++    }
++
 +    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()]),
 +                                "(" + a[i] + ", " + b[(i / SPECIES.length()) * SPECIES.length()] + ") at index #" + i);
 +        }
 +    }
 +
 +    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i / SPECIES.length()) * SPECIES.length()])));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i / SPECIES.length()) * SPECIES.length()])),
 +                                "(" + a[i] + ", " + b[(i / SPECIES.length()) * SPECIES.length()] + ") at index #" + i);
 +        }
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {
 +        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), "at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", mask = " + mask[i % SPECIES.length()]);
 +        }
 +    }
 +
++    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinOp f) {
++        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));
++    }
++
++    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinMaskOp f) {
++        int i = 0;
++        try {
++            for (; i < a.length; i++) {
++                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));
++            }
++        } catch (AssertionError err) {
++            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), "at index #" + i + ", input1 = " + a[i] + ", input2 = " + b + ", mask = " + mask[i % SPECIES.length()]);
++        }
++    }
++
 +    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {
 +        assertBroadcastArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));
 +    }
 +
 +    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()],
 +                                mask[i % SPECIES.length()]), "at index #" + i + ", input1 = " + a[i] +
 +                                ", input2 = " + b[(i / SPECIES.length()) * SPECIES.length()] + ", mask = " +
 +                                mask[i % SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {
 +        assertBroadcastLongArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));
 +    }
 +
 +    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i / SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i / SPECIES.length()) * SPECIES.length()]),
 +                                mask[i % SPECIES.length()]), "at index #" + i + ", input1 = " + a[i] +
 +                                ", input2 = " + b[(i / SPECIES.length()) * SPECIES.length()] + ", mask = " +
 +                                mask[i % SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {
 +        int i = 0;
 +        int j = 0;
 +        try {
 +            for (; j < a.length; j += SPECIES.length()) {
 +                for (i = 0; i < SPECIES.length(); i++) {
 +                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), "at index #" + i + ", " + j);
 +        }
 +    }
 +
 +    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {
 +        assertShiftArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));
 +    }
 +
 +    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {
 +        int i = 0;
 +        int j = 0;
 +        try {
 +            for (; j < a.length; j += SPECIES.length()) {
 +                for (i = 0; i < SPECIES.length(); i++) {
 +                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));
 +                }
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), "at index #" + i + ", input1 = " + a[i+j] + ", input2 = " + b[j] + ", mask = " + mask[i]);
 +        }
 +    }
 +
 +    interface FBinConstOp {
 +        short apply(short a);
 +    }
 +
 +    interface FBinConstMaskOp {
 +        short apply(short a, boolean m);
 +
 +        static FBinConstMaskOp lift(FBinConstOp f) {
 +            return (a, m) -> m ? f.apply(a) : a;
 +        }
 +    }
 +
 +    static void assertShiftConstEquals(short[] r, short[] a, FBinConstOp f) {
 +        int i = 0;
 +        int j = 0;
 +        try {
 +            for (; j < a.length; j += SPECIES.length()) {
 +                for (i = 0; i < SPECIES.length(); i++) {
 +                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i+j], f.apply(a[i+j]), "at index #" + i + ", " + j);
 +        }
 +    }
 +
 +    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstOp f) {
 +        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));
 +    }
 +
 +    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstMaskOp f) {
 +        int i = 0;
 +        int j = 0;
 +        try {
 +            for (; j < a.length; j += SPECIES.length()) {
 +                for (i = 0; i < SPECIES.length(); i++) {
 +                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));
 +                }
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), "at index #" + i + ", input1 = " + a[i+j] + ", mask = " + mask[i]);
 +        }
 +    }
 +
 +    interface FTernOp {
 +        short apply(short a, short b, short c);
 +    }
 +
 +    interface FTernMaskOp {
 +        short apply(short a, short b, short c, boolean m);
 +
 +        static FTernMaskOp lift(FTernOp f) {
 +            return (a, b, c, m) -> m ? f.apply(a, b, c) : a;
 +        }
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), "at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", input3 = " + c[i]);
 +        }
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernOp f) {
 +        assertArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernMaskOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), "at index #" + i + ", input1 = " + a[i] + ", input2 = "
 +              + b[i] + ", input3 = " + c[i] + ", mask = " + mask[i % SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i / SPECIES.length()) * SPECIES.length()]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i / SPECIES.length()) * SPECIES.length()]), "at index #" +
 +                                i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", input3 = " +
 +                                c[(i / SPECIES.length()) * SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()], c[i]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()], c[i]), "at index #" +
 +                                i + ", input1 = " + a[i] + ", input2 = " +
 +                                b[(i / SPECIES.length()) * SPECIES.length()] + ",  input3 = " + c[i]);
 +        }
 +    }
 +
 +    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,
 +                                            FTernOp f) {
 +        assertBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));
 +    }
 +
 +    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,
 +                                            FTernMaskOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i / SPECIES.length()) * SPECIES.length()],
 +                                    mask[i % SPECIES.length()]));
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i / SPECIES.length()) * SPECIES.length()],
 +                                mask[i % SPECIES.length()]), "at index #" + i + ", input1 = " + a[i] + ", input2 = " +
 +                                b[i] + ", input3 = " + c[(i / SPECIES.length()) * SPECIES.length()] + ", mask = " +
 +                                mask[i % SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,
 +                                            FTernOp f) {
 +        assertAltBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));
 +    }
 +
 +    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,
 +                                            FTernMaskOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()], c[i],
 +                                    mask[i % SPECIES.length()]));
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()], c[i],
 +                                mask[i % SPECIES.length()]), "at index #" + i + ", input1 = " + a[i] +
 +                                ", input2 = " + b[(i / SPECIES.length()) * SPECIES.length()] +
 +                                ", input3 = " + c[i] + ", mask = " + mask[i % SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()],
 +                                    c[(i / SPECIES.length()) * SPECIES.length()]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()],
 +                                c[(i / SPECIES.length()) * SPECIES.length()]), "at index #" + i + ", input1 = " + a[i]
 +                                + ", input2 = " + b[(i / SPECIES.length()) * SPECIES.length()] + ", input3 = " +
 +                                c[(i / SPECIES.length()) * SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,
 +                                                  FTernOp f) {
 +        assertDoubleBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));
 +    }
 +
 +    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,
 +                                                  FTernMaskOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()],
 +                                    c[(i / SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()],
 +                                c[(i / SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]), "at index #"
 +                                + i + ", input1 = " + a[i] + ", input2 = " + b[(i / SPECIES.length()) * SPECIES.length()] +
 +                                ", input3 = " + c[(i / SPECIES.length()) * SPECIES.length()] + ", mask = " +
 +                                mask[i % SPECIES.length()]);
 +        }
 +    }
 +
 +
 +    static boolean isWithin1Ulp(short actual, short expected) {
 +        float act = Float.float16ToFloat(actual);
 +        float exp = Float.float16ToFloat(expected);
 +        if (Float.isNaN(exp) && !Float.isNaN(act)) {
 +            return false;
 +        } else if (!Float.isNaN(exp) && Float.isNaN(act)) {
 +             return false;
 +        }
 +
 +        float low = Math.nextDown(exp);
 +        float high = Math.nextUp(exp);
 +
 +        if (Float.compare(low, exp) > 0) {
 +            return false;
 +        }
 +
 +        if (Float.compare(high, exp) < 0) {
 +            return false;
 +        }
 +
 +        return true;
 +    }
 +
 +    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, FUnOp mathf, FUnOp strictmathf) {
 +        int i = 0;
 +        try {
 +            // Check that result is within 1 ulp of strict math or equivalent to math implementation.
 +            for (; i < a.length; i++) {
 +                Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i])) == 0 ||
 +                                    isWithin1Ulp(r[i], strictmathf.apply(a[i])));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i])) == 0, "at index #" + i + ", input = " + a[i] + ", actual = " + r[i] + ", expected = " + mathf.apply(a[i]));
 +            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i])), "at index #" + i + ", input = " + a[i] + ", actual = " + r[i] + ", expected (within 1 ulp) = " + strictmathf.apply(a[i]));
 +        }
 +    }
 +
 +    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b, FBinOp mathf, FBinOp strictmathf) {
 +        int i = 0;
 +        try {
 +            // Check that result is within 1 ulp of strict math or equivalent to math implementation.
 +            for (; i < a.length; i++) {
 +                Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i], b[i])) == 0 ||
 +                                    isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i], b[i])) == 0, "at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", actual = " + r[i] + ", expected = " + mathf.apply(a[i], b[i]));
 +            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])), "at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", actual = " + r[i] + ", expected (within 1 ulp) = " + strictmathf.apply(a[i], b[i]));
 +        }
 +    }
 +
 +    static void assertBroadcastArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b,
 +                                                        FBinOp mathf, FBinOp strictmathf) {
 +        int i = 0;
 +        try {
 +            // Check that result is within 1 ulp of strict math or equivalent to math implementation.
 +            for (; i < a.length; i++) {
 +                Assert.assertTrue(Halffloat.compare(r[i],
 +                                  mathf.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()])) == 0 ||
 +                                  isWithin1Ulp(r[i],
 +                                  strictmathf.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()])));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertTrue(Halffloat.compare(r[i],
 +                              mathf.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()])) == 0,
 +                              "at index #" + i + ", input1 = " + a[i] + ", input2 = " +
 +                              b[(i / SPECIES.length()) * SPECIES.length()] + ", actual = " + r[i] +
 +                              ", expected = " + mathf.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()]));
 +            Assert.assertTrue(isWithin1Ulp(r[i],
 +                              strictmathf.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()])),
 +                             "at index #" + i + ", input1 = " + a[i] + ", input2 = " +
 +                             b[(i / SPECIES.length()) * SPECIES.length()] + ", actual = " + r[i] +
 +                             ", expected (within 1 ulp) = " + strictmathf.apply(a[i],
 +                             b[(i / SPECIES.length()) * SPECIES.length()]));
 +        }
 +    }
 +
-     interface FBinArrayOp {
-         short apply(short[] a, int b);
-     }
- 
-     static void assertArraysEquals(short[] r, short[] a, FBinArrayOp f) {
-         int i = 0;
-         try {
-             for (; i < a.length; i++) {
-                 Assert.assertEquals(r[i], f.apply(a, i));
-             }
-         } catch (AssertionError e) {
-             Assert.assertEquals(r[i], f.apply(a,i), "at index #" + i);
-         }
-     }
- 
 +    interface FGatherScatterOp {
 +        short[] apply(short[] a, int ix, int[] b, int iy);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, int[] b, FGatherScatterOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a, i, b, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a, i, b, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref,
 +              "(ref: " + Arrays.toString(ref) + ", res: " + Arrays.toString(res) + ", a: "
 +              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))
 +              + ", b: "
 +              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))
 +              + " at index #" + i);
 +        }
 +    }
 +
 +    interface FGatherMaskedOp {
 +        short[] apply(short[] a, int ix, boolean[] mask, int[] b, int iy);
 +    }
 +
 +    interface FScatterMaskedOp {
 +        short[] apply(short[] r, short[] a, int ix, boolean[] mask, int[] b, int iy);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FGatherMaskedOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a, i, mask, b, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a, i, mask, b, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref,
 +              "(ref: " + Arrays.toString(ref) + ", res: " + Arrays.toString(res) + ", a: "
 +              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))
 +              + ", b: "
 +              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))
 +              + ", mask: "
 +              + Arrays.toString(mask)
 +              + " at index #" + i);
 +        }
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FScatterMaskedOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(r, a, i, mask, b, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(r, a, i, mask, b, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref,
 +              "(ref: " + Arrays.toString(ref) + ", res: " + Arrays.toString(res) + ", a: "
 +              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))
 +              + ", b: "
 +              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))
 +              + ", r: "
 +              + Arrays.toString(Arrays.copyOfRange(r, i, i+SPECIES.length()))
 +              + ", mask: "
 +              + Arrays.toString(mask)
 +              + " at index #" + i);
 +        }
 +    }
 +
 +    interface FLaneOp {
 +        short[] apply(short[] a, int origin, int idx);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, int origin, FLaneOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a, origin, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a, origin, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref, "(ref: " + Arrays.toString(ref)
 +              + ", res: " + Arrays.toString(res)
 +              + "), at index #" + i);
 +        }
 +    }
 +
 +    interface FLaneBop {
 +        short[] apply(short[] a, short[] b, int origin, int idx);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, FLaneBop f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a, b, origin, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a, b, origin, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref, "(ref: " + Arrays.toString(ref)
 +              + ", res: " + Arrays.toString(res)
 +              + "), at index #" + i
 +              + ", at origin #" + origin);
 +        }
 +    }
 +
 +    interface FLaneMaskedBop {
 +        short[] apply(short[] a, short[] b, int origin, boolean[] mask, int idx);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, boolean[] mask, FLaneMaskedBop f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a, b, origin, mask, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a, b, origin, mask, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref, "(ref: " + Arrays.toString(ref)
 +              + ", res: " + Arrays.toString(res)
 +              + "), at index #" + i
 +              + ", at origin #" + origin);
 +        }
 +    }
 +
 +    interface FLanePartBop {
 +        short[] apply(short[] a, short[] b, int origin, int part, int idx);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, FLanePartBop f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a, b, origin, part, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a, b, origin, part, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref, "(ref: " + Arrays.toString(ref)
 +              + ", res: " + Arrays.toString(res)
 +              + "), at index #" + i
 +              + ", at origin #" + origin
 +              + ", with part #" + part);
 +        }
 +    }
 +
 +    interface FLanePartMaskedBop {
 +        short[] apply(short[] a, short[] b, int origin, int part, boolean[] mask, int idx);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, boolean[] mask, FLanePartMaskedBop f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a, b, origin, part, mask, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a, b, origin, part, mask, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref, "(ref: " + Arrays.toString(ref)
 +              + ", res: " + Arrays.toString(res)
 +              + "), at index #" + i
 +              + ", at origin #" + origin
 +              + ", with part #" + part);
 +        }
 +    }
 +
 +    static short genValue(int i) {
-         return (short) Halffloat.valueOf(i);
++        return Float16.float16ToRawShortBits(Float16.valueOf(i));
 +    }
 +
 +    static int intCornerCaseValue(int i) {
 +        switch(i % 5) {
 +            case 0:
 +                return Integer.MAX_VALUE;
 +            case 1:
 +                return Integer.MIN_VALUE;
 +            case 2:
 +                return Integer.MIN_VALUE;
 +            case 3:
 +                return Integer.MAX_VALUE;
 +            default:
 +                return (int)0;
 +        }
 +    }
 +
 +    static final List<IntFunction<short[]>> INT_HALFFLOAT_GENERATORS = List.of(
-             withToString("Halffloat[-i * 5]", (int s) -> {
++            withToString("Float16[-i * 5]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> genValue(-i * 5));
 +            }),
-             withToString("Halffloat[i * 5]", (int s) -> {
++            withToString("Float16[i * 5]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> genValue(i * 5));
 +            }),
-             withToString("Halffloat[i + 1]", (int s) -> {
++            withToString("Float16[i + 1]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
 +            }),
-             withToString("Halffloat[intCornerCaseValue(i)]", (int s) -> {
++            withToString("Float16[intCornerCaseValue(i)]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (short)intCornerCaseValue(i));
 +            })
 +    );
 +
 +    static void assertArraysEquals(int[] r, short[] a, int offs) {
 +        int i = 0;
 +        try {
 +            for (; i < r.length; i++) {
 +                Assert.assertEquals(r[i], (int)Float.float16ToFloat(a[i+offs]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], (int)(a[i+offs]), "at index #" + i + ", input = " + a[i+offs]);
 +        }
 +    }
 +
 +    static long longCornerCaseValue(int i) {
 +        switch(i % 5) {
 +            case 0:
 +                return Long.MAX_VALUE;
 +            case 1:
 +                return Long.MIN_VALUE;
 +            case 2:
 +                return Long.MIN_VALUE;
 +            case 3:
 +                return Long.MAX_VALUE;
 +            default:
 +                return (long)0;
 +        }
 +    }
 +
 +    static short genValue(long i) {
-         return (short) Halffloat.valueOf(i);
++        return Float16.float16ToRawShortBits(Float16.valueOf(i));
 +    }
 +
 +    static final List<IntFunction<short[]>> LONG_HALFFLOAT_GENERATORS = List.of(
-             withToString("Halffloat[-i * 5]", (int s) -> {
++            withToString("Float16[-i * 5]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> genValue(-i * 5));
 +            }),
-             withToString("Halffloat[i * 5]", (int s) -> {
++            withToString("Float16[i * 5]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> genValue(i * 5));
 +            }),
-             withToString("Halffloat[i + 1]", (int s) -> {
++            withToString("Float16[i + 1]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
 +            }),
-             withToString("Halffloat[cornerCaseValue(i)]", (int s) -> {
++            withToString("Float16[cornerCaseValue(i)]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (short)longCornerCaseValue(i));
 +            })
 +    );
 +
 +
 +    static void assertArraysEquals(long[] r, short[] a, int offs) {
 +        int i = 0;
 +        try {
 +            for (; i < r.length; i++) {
 +                Assert.assertEquals(r[i], (long)Float.float16ToFloat(a[i+offs]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], (long)(a[i+offs]), "at index #" + i + ", input = " + a[i+offs]);
 +        }
 +    }
 +
 +    static void assertArraysEquals(double[] r, short[] a, int offs) {
 +        int i = 0;
 +        try {
 +            for (; i < r.length; i++) {
 +                Assert.assertEquals(r[i], (double)Float.float16ToFloat(a[i+offs]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], (double)(a[i+offs]), "at index #" + i + ", input = " + a[i+offs]);
 +        }
 +    }
 +
 +    static short bits(short e) {
-         return  Halffloat.shortToShortBits(e);
++        return  Float16.shortToShortBits(e);
 +    }
 +
 +    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(
-             withToString("Halffloat[-i * 5]", (int s) -> {
++            withToString("Float16[-i * 5]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> genValue(-i * 5));
 +            }),
-             withToString("Halffloat[i * 5]", (int s) -> {
++            withToString("Float16[i * 5]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> genValue(i * 5));
 +            }),
-             withToString("Halffloat[i + 1]", (int s) -> {
++            withToString("Float16[i + 1]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
 +            }),
-             withToString("Halffloat[cornerCaseValue(i)]", (int s) -> {
++            withToString("short[0.01 + (i / (i + 1))]", (int s) -> {
++                return fill(s * BUFFER_REPS,
++                            i -> (short)0.01 + ((short)i / (i + 1)));
++            }),
++            withToString("short[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i / (i + 1))]", (int s) -> {
++                return fill(s * BUFFER_REPS,
++                            i -> i % 17 == 0 ? cornerCaseValue(i) : (short)0.01 + ((short)i / (i + 1)));
++            }),
++            withToString("short[cornerCaseValue(i)]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> cornerCaseValue(i));
 +            })
 +    );
 +
 +    // Create combinations of pairs
 +    // @@@ Might be sensitive to order e.g. div by 0
 +    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_PAIRS =
 +        Stream.of(HALFFLOAT_GENERATORS.get(0)).
 +                flatMap(fa -> HALFFLOAT_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).
 +                collect(Collectors.toList());
 +
 +    @DataProvider
 +    public Object[][] boolUnaryOpProvider() {
 +        return BOOL_ARRAY_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_TRIPLES =
 +        HALFFLOAT_GENERATOR_PAIRS.stream().
 +                flatMap(pair -> HALFFLOAT_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).
 +                collect(Collectors.toList());
 +
++    static final List<IntFunction<short[]>> SELECT_FROM_INDEX_GENERATORS = List.of(
++            withToString("short[0..VECLEN*2)", (int s) -> {
++                return fill(s * BUFFER_REPS,
++                            i -> (short)(RAND.nextInt()));
++            })
++    );
++
++    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_SELECT_FROM_TRIPLES =
++        HALFFLOAT_GENERATOR_PAIRS.stream().
++                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).
++                collect(Collectors.toList());
++
 +    @DataProvider
 +    public Object[][] shortBinaryOpProvider() {
 +        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortIndexedOpProvider() {
 +        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortBinaryOpMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_GENERATOR_PAIRS.stream().map(lfa -> {
 +                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortTernaryOpProvider() {
 +        return HALFFLOAT_GENERATOR_TRIPLES.stream().map(List::toArray).
 +                toArray(Object[][]::new);
 +    }
 +
++    @DataProvider
++    public Object[][] shortSelectFromTwoVectorOpProvider() {
++        return HALFFLOAT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).
++                toArray(Object[][]::new);
++    }
++
 +    @DataProvider
 +    public Object[][] shortTernaryOpMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_GENERATOR_TRIPLES.stream().map(lfa -> {
 +                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortUnaryOpProvider() {
 +        return HALFFLOAT_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortUnaryOpMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                    return new Object[] {fa, fm};
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shorttoIntUnaryOpProvider() {
 +        return INT_HALFFLOAT_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shorttoLongUnaryOpProvider() {
 +        return LONG_HALFFLOAT_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] maskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] maskCompareOpProvider() {
 +        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shuffleProvider() {
 +        return INT_SHUFFLE_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shuffleCompareOpProvider() {
 +        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortUnaryOpShuffleProvider() {
 +        return INT_SHUFFLE_GENERATORS.stream().
 +                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                    return new Object[] {fa, fs};
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortUnaryOpShuffleMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> INT_SHUFFLE_GENERATORS.stream().
 +                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                        return new Object[] {fa, fs, fm};
 +                }))).
 +                toArray(Object[][]::new);
 +    }
 +
 +    static final List<BiFunction<Integer,Integer,short[]>> HALFFLOAT_SHUFFLE_GENERATORS = List.of(
 +            withToStringBi("shuffle[random]", (Integer l, Integer m) -> {
 +                short[] a = new short[l];
 +                int upper = m;
 +                for (int i = 0; i < 1; i++) {
 +                    a[i] = (short)RAND.nextInt(upper);
 +                }
 +                return a;
 +            })
 +    );
 +
 +    @DataProvider
 +    public Object[][] shortUnaryOpSelectFromProvider() {
 +        return HALFFLOAT_SHUFFLE_GENERATORS.stream().
 +                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                    return new Object[] {fa, fs};
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortUnaryOpSelectFromMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_SHUFFLE_GENERATORS.stream().
 +                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                        return new Object[] {fa, fs, fm};
 +                }))).
 +                toArray(Object[][]::new);
 +    }
 +
 +    static final List<IntFunction<short[]>> HALFFLOAT_COMPARE_GENERATORS = List.of(
 +            withToString("short[i]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (short)i);
 +            }),
 +            withToString("short[i - length / 2]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (short)(i - (s * BUFFER_REPS / 2)));
 +            }),
 +            withToString("short[i + 1]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (short)(i + 1));
 +            }),
 +            withToString("short[i - 2]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (short)(i - 2));
 +            }),
 +            withToString("short[zigZag(i)]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> i%3 == 0 ? (short)i : (i%3 == 1 ? (short)(i + 1) : (short)(i - 2)));
 +            }),
 +            withToString("short[cornerCaseValue(i)]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> cornerCaseValue(i));
 +            })
 +    );
 +
 +    static final List<List<IntFunction<short[]>>> HALFFLOAT_TEST_GENERATOR_ARGS =
 +        HALFFLOAT_COMPARE_GENERATORS.stream().
 +                map(fa -> List.of(fa)).
 +                collect(Collectors.toList());
 +
 +    @DataProvider
 +    public Object[][] shortTestOpProvider() {
 +        return HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(List::toArray).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortTestOpMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(lfa -> {
 +                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    static final List<List<IntFunction<short[]>>> HALFFLOAT_COMPARE_GENERATOR_PAIRS =
 +        HALFFLOAT_COMPARE_GENERATORS.stream().
 +                flatMap(fa -> HALFFLOAT_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).
 +                collect(Collectors.toList());
 +
 +    @DataProvider
 +    public Object[][] shortCompareOpProvider() {
 +        return HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortCompareOpMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {
 +                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    interface ToHalffloatF {
 +        short apply(int i);
 +    }
 +
 +    static short[] fill(int s , ToHalffloatF f) {
 +        return fill(new short[s], f);
 +    }
 +
 +    static short[] fill(short[] a, ToHalffloatF f) {
 +        for (int i = 0; i < a.length; i++) {
 +            a[i] = f.apply(i);
 +        }
 +        return a;
 +    }
 +
 +    static short cornerCaseValue(int i) {
-         switch(i % 7) {
-             case 0:
-                 return Halffloat.MAX_VALUE;
-             case 1:
-                 return Halffloat.MIN_VALUE;
-             case 2:
-                 return Halffloat.NEGATIVE_INFINITY;
-             case 3:
-                 return Halffloat.POSITIVE_INFINITY;
-             case 4:
-                 return Halffloat.NaN;
-             case 5:
-                 return (short)0.0;
-             default:
-                 return Short.MIN_VALUE;
-         }
-     }
- 
-     static short get(short[] a, int i) {
-         return (short) a[i];
++        return switch(i % 8) {
++            case 0  -> Float16.MAX_VALUE;
++            case 1  -> Float16.MIN_VALUE;
++            case 2  -> Float16.NEGATIVE_INFINITY;
++            case 3  -> Float16.POSITIVE_INFINITY;
++            case 4  -> Float16.NaN;
++            case 5  -> Double.longBitsToDouble(0x7FF123456789ABCDL);
++            case 6  -> (short)0.0;
++            default -> (short)-0.0;
++        };
 +    }
 +
 +    static final IntFunction<short[]> fr = (vl) -> {
 +        int length = BUFFER_REPS * vl;
 +        return new short[length];
 +    };
 +
 +    static final IntFunction<boolean[]> fmr = (vl) -> {
 +        int length = BUFFER_REPS * vl;
 +        return new boolean[length];
 +    };
 +
 +    static final IntFunction<long[]> lfr = (vl) -> {
 +        int length = BUFFER_REPS * vl;
 +        return new long[length];
 +    };
 +
 +    static boolean eq(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() == bt.floatValue();
 +    }
 +
 +    static boolean neq(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() != bt.floatValue();
 +    }
 +
 +    static boolean lt(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() < bt.floatValue();
 +    }
 +
 +    static boolean le(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() <= bt.floatValue();
 +    }
 +
 +    static boolean gt(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() > bt.floatValue();
 +    }
 +
 +    static boolean ge(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() >= bt.floatValue();
 +    }
 +
 +    static short firstNonZero(short a, short b) {
 +        return Short.compare(a, (short) 0) != 0 ? a : b;
 +    }
 +
 +    @Test
 +    static void smokeTest1() {
-         HalffloatVector three = HalffloatVector.broadcast(SPECIES, Halffloat.valueOf(-3));
-         HalffloatVector three2 = (HalffloatVector) SPECIES.broadcast(Halffloat.valueOf(-3));
++        HalffloatVector three = HalffloatVector.broadcast(SPECIES, Float16.float16ToRawShortBits(Float16.valueOf(-3)));
++        HalffloatVector three2 = (HalffloatVector) SPECIES.broadcast(Float16.float16ToRawShortBits(Float16.valueOf(-3)));
 +        assert(three.eq(three2).allTrue());
-         HalffloatVector three3 = three2.broadcast(Halffloat.valueOf(1)).broadcast(Halffloat.valueOf(-3));
++        HalffloatVector three3 = three2.broadcast(Float16.float16ToRawShortBits(Float16.valueOf(1))).broadcast(Float16.float16ToRawShortBits(Float16.valueOf(-3)));
 +        assert(three.eq(three3).allTrue());
 +        int scale = 2;
 +        HalffloatVector higher = three.addIndex(scale);
-         VectorMask<Halffloat> m = three.compare(VectorOperators.LE, higher);
++        VectorMask<Float16> m = three.compare(VectorOperators.LE, higher);
 +        assert(m.allTrue());
-         m = higher.min((Halffloat.valueOf(-1))).test(VectorOperators.IS_NEGATIVE);
++        m = higher.min((Float16.float16ToRawShortBits(Float16.valueOf(-1)))).test(VectorOperators.IS_NEGATIVE);
 +        assert(m.allTrue());
 +        m = higher.test(VectorOperators.IS_FINITE);
 +        assert(m.allTrue());
 +        short max = higher.reduceLanes(VectorOperators.MAX);
 +        assert((short) Float.float16ToFloat(max) == -3 + scale * (SPECIES.length()-1));
 +    }
 +
 +    private static short[]
 +    bothToArray(HalffloatVector a, HalffloatVector b) {
 +        short[] r = new short[a.length() + b.length()];
 +        a.intoArray(r, 0);
 +        b.intoArray(r, a.length());
 +        return r;
 +    }
 +
 +    @Test
 +    static void smokeTest2() {
 +        // Do some zipping and shuffling.
 +        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);
 +        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES,0,1,false).toVector();
 +        Assert.assertEquals(io, io2);
 +        HalffloatVector a = io.add((short)1); //[1,2]
 +        HalffloatVector b = a.neg();  //[-1,-2]
 +        short[] abValues = bothToArray(a,b); //[1,2,-1,-2]
-         VectorShuffle<Halffloat> zip0 = VectorShuffle.makeZip(SPECIES, 0);
-         VectorShuffle<Halffloat> zip1 = VectorShuffle.makeZip(SPECIES, 1);
++        VectorShuffle<Float16> zip0 = VectorShuffle.makeZip(SPECIES, 0);
++        VectorShuffle<Float16> zip1 = VectorShuffle.makeZip(SPECIES, 1);
 +        HalffloatVector zab0 = a.rearrange(zip0,b); //[1,-1]
 +        HalffloatVector zab1 = a.rearrange(zip1,b); //[2,-2]
 +        short[] zabValues = bothToArray(zab0, zab1); //[1,-1,2,-2]
 +        // manually zip
 +        short[] manual = new short[zabValues.length];
 +        for (int i = 0; i < manual.length; i += 2) {
 +            manual[i+0] = abValues[i/2];
 +            manual[i+1] = abValues[a.length() + i/2];
 +        }
 +        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));
-         VectorShuffle<Halffloat> unz0 = VectorShuffle.makeUnzip(SPECIES, 0);
-         VectorShuffle<Halffloat> unz1 = VectorShuffle.makeUnzip(SPECIES, 1);
++        VectorShuffle<Float16> unz0 = VectorShuffle.makeUnzip(SPECIES, 0);
++        VectorShuffle<Float16> unz1 = VectorShuffle.makeUnzip(SPECIES, 1);
 +        HalffloatVector uab0 = zab0.rearrange(unz0,zab1);
 +        HalffloatVector uab1 = zab0.rearrange(unz1,zab1);
 +        short[] abValues1 = bothToArray(uab0, uab1);
 +        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));
 +    }
 +
 +    static void iotaShuffle() {
 +        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);
 +        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES, 0 , 1, false).toVector();
 +        Assert.assertEquals(io, io2);
 +    }
 +
 +    @Test
 +    // Test all shuffle related operations.
 +    static void shuffleTest() {
 +        // To test backend instructions, make sure that C2 is used.
 +        for (int loop = 0; loop < INVOC_COUNT * INVOC_COUNT; loop++) {
 +            iotaShuffle();
 +        }
 +    }
 +
 +    @Test
 +    void viewAsIntegeralLanesTest() {
 +        Vector<?> asIntegral = SPECIES.zero().viewAsIntegralLanes();
 +        VectorSpecies<?> asIntegralSpecies = asIntegral.species();
 +        Assert.assertNotEquals(asIntegralSpecies.elementType(), SPECIES.elementType());
 +        Assert.assertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());
 +        Assert.assertEquals(asIntegralSpecies.length(), SPECIES.length());
 +        Assert.assertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);
 +    }
 +
 +    @Test
 +    void viewAsFloatingLanesTest() {
 +        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();
 +        Assert.assertEquals(asFloating.species(), SPECIES);
 +    }
 +
 +    static short ADD(short a, short b) {
 +        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b)));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void ADDHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, Halffloat128VectorTests::ADD);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void ADDHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::ADD);
 +    }
 +
 +    static short SUB(short a, short b) {
 +        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b)));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void SUBHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, Halffloat128VectorTests::SUB);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void SUBHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::SUB);
 +    }
 +
 +    static short MUL(short a, short b) {
 +        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) * Float.float16ToFloat(b)));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void MULHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, Halffloat128VectorTests::MUL);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void MULHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::MUL);
 +    }
 +
 +    static short DIV(short a, short b) {
 +        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) / Float.float16ToFloat(b)));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void DIVHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, Halffloat128VectorTests::DIV);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void DIVHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::DIV);
 +    }
 +
 +    static short MAX(short a, short b) {
 +        return (short)(Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b))));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void MAXHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, Halffloat128VectorTests::MAX);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void MAXHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::MAX);
 +    }
 +
 +    static short MIN(short a, short b) {
-         return (short)(Halffloat.valueOf(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));
++        return (short)(Float.floatToFloat16(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void MINHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, Halffloat128VectorTests::MIN);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void MINHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::MIN);
 +    }
 +
 +    static short ABS(short a) {
 +        return (short)(Math.abs(a));
 +    }
 +
 +    static short abs(short a) {
 +        return (short)(Math.abs(a));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void ABSHalffloat128VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ABS).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, Halffloat128VectorTests::ABS);
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void absHalffloat128VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.abs().intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, Halffloat128VectorTests::abs);
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpMaskProvider")
 +    static void ABSMaskedHalffloat128VectorTests(IntFunction<short[]> fa,
 +                                                IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, mask, Halffloat128VectorTests::ABS);
 +    }
 +
 +    static short NEG(short a) {
 +        return (short)(-a);
 +    }
 +
 +    static short neg(short a) {
 +        return (short)(-a);
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void NEGHalffloat128VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.NEG).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, Halffloat128VectorTests::NEG);
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void negHalffloat128VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.neg().intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, Halffloat128VectorTests::neg);
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpMaskProvider")
 +    static void NEGMaskedHalffloat128VectorTests(IntFunction<short[]> fa,
 +                                                IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, mask, Halffloat128VectorTests::NEG);
 +    }
 +
 +    static short FMA(short a, short b, short c) {
 +        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));
 +    }
 +
 +    static short fma(short a, short b, short c) {
 +        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));
 +    }
 +
 +    @Test(dataProvider = "shortTernaryOpProvider")
 +    static void FMAHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] c = fc.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);
 +                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, c, Halffloat128VectorTests::FMA);
 +    }
 +
 +    @Test(dataProvider = "shortTernaryOpProvider")
 +    static void fmaHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] c = fc.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +            HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);
 +            av.fma(bv, cv).intoArray(r, i);
 +        }
 +
 +        assertArraysEquals(r, a, b, c, Halffloat128VectorTests::fma);
 +    }
 +
 +    @Test(dataProvider = "shortTernaryOpMaskProvider")
 +    static void FMAHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] c = fc.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);
 +                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, c, mask, Halffloat128VectorTests::FMA);
 +    }
 +
 +    static short SQRT(short a) {
-         return (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));
++        return (short)(Float.floatToFloat16((float) Math.sqrt(Float.float16ToFloat(a))));
 +    }
 +
 +    static short sqrt(short a) {
-         return (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));
++        return (short)(Float.floatToFloat16((float) Math.sqrt(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void SQRTHalffloat128VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SQRT).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, Halffloat128VectorTests::SQRT);
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void sqrtHalffloat128VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.sqrt().intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, Halffloat128VectorTests::sqrt);
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpMaskProvider")
 +    static void SQRTMaskedHalffloat128VectorTests(IntFunction<short[]> fa,
 +                                                IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, mask, Halffloat128VectorTests::SQRT);
 +    }
 +
 +    static short SIN(short a) {
-         return Halffloat.valueOf((float) Math.sin(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.sin(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictSIN(short a) {
-         return Halffloat.valueOf((float) StrictMath.sin(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.sin(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void SINHalffloat128VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SIN).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::SIN, Halffloat128VectorTests::strictSIN);
 +    }
 +
 +    static short EXP(short a) {
-         return Halffloat.valueOf((float) Math.exp(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.exp(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictEXP(short a) {
-         return Halffloat.valueOf((float) StrictMath.exp(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.exp(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void EXPHalffloat128VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.EXP).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::EXP, Halffloat128VectorTests::strictEXP);
 +    }
 +
 +    static short LOG1P(short a) {
-         return Halffloat.valueOf((float) Math.log1p(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.log1p(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictLOG1P(short a) {
-         return Halffloat.valueOf((float) StrictMath.log1p(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.log1p(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void LOG1PHalffloat128VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::LOG1P, Halffloat128VectorTests::strictLOG1P);
 +    }
 +
 +    static short LOG(short a) {
-         return Halffloat.valueOf((float) Math.log(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.log(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictLOG(short a) {
-         return Halffloat.valueOf((float) StrictMath.log(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.log(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void LOGHalffloat128VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.LOG).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::LOG, Halffloat128VectorTests::strictLOG);
 +    }
 +
 +    static short LOG10(short a) {
-         return Halffloat.valueOf((float) Math.log10(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.log10(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictLOG10(short a) {
-         return Halffloat.valueOf((float) StrictMath.log10(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.log10(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void LOG10Halffloat128VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.LOG10).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::LOG10, Halffloat128VectorTests::strictLOG10);
 +    }
 +
 +    static short EXPM1(short a) {
-         return Halffloat.valueOf((float) Math.expm1(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.expm1(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictEXPM1(short a) {
-         return Halffloat.valueOf((float) StrictMath.expm1(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.expm1(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void EXPM1Halffloat128VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::EXPM1, Halffloat128VectorTests::strictEXPM1);
 +    }
 +
 +    static short COS(short a) {
-         return Halffloat.valueOf((float) Math.cos(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.cos(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictCOS(short a) {
-         return Halffloat.valueOf((float) StrictMath.cos(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.cos(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void COSHalffloat128VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.COS).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::COS, Halffloat128VectorTests::strictCOS);
 +    }
 +
 +    static short TAN(short a) {
-         return Halffloat.valueOf((float) Math.tan(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.tan(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictTAN(short a) {
-         return Halffloat.valueOf((float) StrictMath.tan(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.tan(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void TANHalffloat128VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.TAN).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::TAN, Halffloat128VectorTests::strictTAN);
 +    }
 +
 +    static short SINH(short a) {
-         return Halffloat.valueOf((float) Math.sinh(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.sinh(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictSINH(short a) {
-         return Halffloat.valueOf((float) StrictMath.sinh(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.sinh(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void SINHHalffloat128VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SINH).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::SINH, Halffloat128VectorTests::strictSINH);
 +    }
 +
 +    static short COSH(short a) {
-         return Halffloat.valueOf((float) Math.cosh(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.cosh(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictCOSH(short a) {
-         return Halffloat.valueOf((float) StrictMath.cosh(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.cosh(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void COSHHalffloat128VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.COSH).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::COSH, Halffloat128VectorTests::strictCOSH);
 +    }
 +
 +    static short TANH(short a) {
-         return Halffloat.valueOf((float) Math.tanh(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.tanh(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictTANH(short a) {
-         return Halffloat.valueOf((float) StrictMath.tanh(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.tanh(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void TANHHalffloat128VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.TANH).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::TANH, Halffloat128VectorTests::strictTANH);
 +    }
 +
 +    static short ASIN(short a) {
-         return Halffloat.valueOf((float) Math.asin(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.asin(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictASIN(short a) {
-         return Halffloat.valueOf((float) StrictMath.asin(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.asin(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void ASINHalffloat128VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ASIN).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::ASIN, Halffloat128VectorTests::strictASIN);
 +    }
 +
 +    static short ACOS(short a) {
-         return Halffloat.valueOf((float) Math.acos(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.acos(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictACOS(short a) {
-         return Halffloat.valueOf((float) StrictMath.acos(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.acos(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void ACOSHalffloat128VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ACOS).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::ACOS, Halffloat128VectorTests::strictACOS);
 +    }
 +
 +    static short ATAN(short a) {
-         return Halffloat.valueOf((float) Math.atan(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.atan(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictATAN(short a) {
-         return Halffloat.valueOf((float) StrictMath.atan(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.atan(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void ATANHalffloat128VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ATAN).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::ATAN, Halffloat128VectorTests::strictATAN);
 +    }
 +
 +    static short CBRT(short a) {
-         return Halffloat.valueOf((float) Math.cbrt(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.cbrt(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictCBRT(short a) {
-         return Halffloat.valueOf((float) StrictMath.cbrt(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.cbrt(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void CBRTHalffloat128VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.CBRT).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::CBRT, Halffloat128VectorTests::strictCBRT);
 +    }
 +
 +    static short HYPOT(short a, short b) {
-         return Halffloat.valueOf((float) Math.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)));
 +    }
 +
 +    static short strictHYPOT(short a, short b) {
-         return Halffloat.valueOf((float) StrictMath.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b))));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void HYPOTHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat128VectorTests::HYPOT, Halffloat128VectorTests::strictHYPOT);
 +    }
 +
 +    static short POW(short a, short b) {
-         return Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));
 +    }
 +
 +    static short strictPOW(short a, short b) {
-         return Halffloat.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b))));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void POWHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat128VectorTests::POW, Halffloat128VectorTests::strictPOW);
 +    }
 +
 +    static short pow(short a, short b) {
-         return Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));
 +    }
 +
 +    static short strictpow(short a, short b) {
-         return Halffloat.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b))));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void powHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.pow(bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat128VectorTests::pow, Halffloat128VectorTests::strictpow);
 +    }
 +
 +    static short ATAN2(short a, short b) {
-         return Halffloat.valueOf((float) Math.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)));
 +    }
 +
 +    static short strictATAN2(short a, short b) {
-         return Halffloat.valueOf((float) StrictMath.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b))));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void ATAN2Halffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat128VectorTests::ATAN2, Halffloat128VectorTests::strictATAN2);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void POWHalffloat128VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            av.lanewise(VectorOperators.POW, b[i]).intoArray(r, i);
 +        }
 +
 +        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat128VectorTests::POW, Halffloat128VectorTests::strictPOW);
 +    }
 +
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void powHalffloat128VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            av.pow(b[i]).intoArray(r, i);
 +        }
 +
 +        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat128VectorTests::pow, Halffloat128VectorTests::strictpow);
 +    }
 +
 +
 +    static short blend(short a, short b, boolean mask) {
 +        return mask ? b : a;
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void blendHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.blend(bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::blend);
 +    }
 +
 +    @Test(dataProvider = "shortCompareOpProvider")
 +    static void ltHalffloat128VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
-             VectorMask<Halffloat> mv = av.lt(b[i]);
++            VectorMask<Float16> mv = av.lt(b[i]);
 +
 +            // Check results as part of computation.
 +            for (int j = 0; j < SPECIES.length(); j++) {
 +                Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortCompareOpProvider")
 +    static void eqHalffloat128VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
-             VectorMask<Halffloat> mv = av.eq(b[i]);
++            VectorMask<Float16> mv = av.eq(b[i]);
 +
 +            // Check results as part of computation.
 +            for (int j = 0; j < SPECIES.length(); j++) {
 +                Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shorttoIntUnaryOpProvider")
 +    static void toIntArrayHalffloat128VectorTestsSmokeTest(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            int[] r = av.toIntArray();
 +            assertArraysEquals(r, a, i);
 +        }
 +    }
 +
 +    @Test(dataProvider = "shorttoLongUnaryOpProvider")
 +    static void toLongArrayHalffloat128VectorTestsSmokeTest(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            long[] r = av.toLongArray();
 +            assertArraysEquals(r, a, i);
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void toDoubleArrayHalffloat128VectorTestsSmokeTest(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            double[] r = av.toDoubleArray();
 +            assertArraysEquals(r, a, i);
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void toStringHalffloat128VectorTestsSmokeTest(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            String str = av.toString();
 +
 +            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());
 +            Assert.assertTrue(str.equals(Arrays.toString(subarr)), "at index " + i + ", string should be = " + Arrays.toString(subarr) + ", but is = " + str);
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void hashCodeHalffloat128VectorTestsSmokeTest(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            int hash = av.hashCode();
 +
 +            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());
 +            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));
 +            Assert.assertTrue(hash == expectedHash, "at index " + i + ", hash should be = " + expectedHash + ", but is = " + hash);
 +        }
 +    }
 +
 +
 +    static long ADDReduceLong(short[] a, int idx) {
 +        short res = 0;
 +        for (int i = idx; i < (idx + SPECIES.length()); i++) {
 +            res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));
 +        }
 +
 +        return (long)res;
 +    }
 +
 +    static long ADDReduceAllLong(short[] a) {
 +        long res = 0;
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            res += ADDReduceLong(a, i);
 +        }
 +
 +        return res;
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void ADDReduceLongHalffloat128VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        long[] r = lfr.apply(SPECIES.length());
 +        long ra = 0;
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            r[i] = av.reduceLanesToLong(VectorOperators.ADD);
 +        }
 +
 +        ra = 0;
 +        for (int i = 0; i < a.length; i ++) {
 +            ra += r[i];
 +        }
 +
 +        assertReductionLongArraysEquals(r, ra, a,
 +                Halffloat128VectorTests::ADDReduceLong, Halffloat128VectorTests::ADDReduceAllLong);
 +    }
 +
 +    static long ADDReduceLongMasked(short[] a, int idx, boolean[] mask) {
 +        short res = 0;
 +        for (int i = idx; i < (idx + SPECIES.length()); i++) {
 +            if(mask[i % SPECIES.length()])
 +                res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));
 +        }
 +
 +        return (long)res;
 +    }
 +
 +    static long ADDReduceAllLongMasked(short[] a, boolean[] mask) {
 +        long res = 0;
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            res += ADDReduceLongMasked(a, i, mask);
 +        }
 +
 +        return res;
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpMaskProvider")
 +    static void ADDReduceLongHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        long[] r = lfr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +        long ra = 0;
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            r[i] = av.reduceLanesToLong(VectorOperators.ADD, vmask);
 +        }
 +
 +        ra = 0;
 +        for (int i = 0; i < a.length; i ++) {
 +            ra += r[i];
 +        }
 +
 +        assertReductionLongArraysEqualsMasked(r, ra, a, mask,
 +                Halffloat128VectorTests::ADDReduceLongMasked, Halffloat128VectorTests::ADDReduceAllLongMasked);
 +    }
 +
 +    @Test(dataProvider = "shorttoLongUnaryOpProvider")
 +    static void BroadcastLongHalffloat128VectorTestsSmokeTest(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = new short[a.length];
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);
 +        }
 +        assertBroadcastArraysEquals(r, a);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void blendHalffloat128VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.blend((long)b[i], vmask).intoArray(r, i);
 +            }
 +        }
 +        assertBroadcastLongArraysEquals(r, a, b, mask, Halffloat128VectorTests::blend);
 +    }
 +
 +
 +    @Test(dataProvider = "shortUnaryOpSelectFromProvider")
 +    static void SelectFromHalffloat128VectorTests(IntFunction<short[]> fa,
 +                                           BiFunction<Integer,Integer,short[]> fs) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] order = fs.apply(a.length, SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);
 +            bv.selectFrom(av).intoArray(r, i);
 +        }
 +
 +        assertSelectFromArraysEquals(r, a, order, SPECIES.length());
 +    }
 +
++    @Test(dataProvider = "shortSelectFromTwoVectorOpProvider")
++    static void SelectFromTwoVectorHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] b = fb.apply(SPECIES.length());
++        short[] idx = fc.apply(SPECIES.length());
++        short[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < idx.length; i += SPECIES.length()) {
++                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
++                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
++                HalffloatVector idxv = HalffloatVector.fromArray(SPECIES, idx, i);
++                idxv.selectFrom(av, bv).intoArray(r, i);
++            }
++        }
++        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());
++    }
++
 +    @Test(dataProvider = "shortUnaryOpSelectFromMaskProvider")
 +    static void SelectFromHalffloat128VectorTestsMaskedSmokeTest(IntFunction<short[]> fa,
 +                                                           BiFunction<Integer,Integer,short[]> fs,
 +                                                           IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] order = fs.apply(a.length, SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);
 +            bv.selectFrom(av, vmask).intoArray(r, i);
 +        }
 +
 +        assertSelectFromArraysEquals(r, a, order, mask, SPECIES.length());
 +    }
 +
 +    @Test(dataProvider = "shuffleProvider")
 +    static void shuffleMiscellaneousHalffloat128VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {
 +        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);
 +            int hash = shuffle.hashCode();
 +            int length = shuffle.length();
 +
 +            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());
 +            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));
 +            Assert.assertTrue(hash == expectedHash, "at index " + i + ", hash should be = " + expectedHash + ", but is = " + hash);
 +            Assert.assertEquals(length, SPECIES.length());
 +        }
 +    }
 +
 +    @Test(dataProvider = "shuffleProvider")
 +    static void shuffleToStringHalffloat128VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {
 +        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);
 +            String str = shuffle.toString();
 +
 +            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());
 +            Assert.assertTrue(str.equals("Shuffle" + Arrays.toString(subarr)), "at index " +
 +                i + ", string should be = " + Arrays.toString(subarr) + ", but is = " + str);
 +        }
 +    }
 +
 +    @Test(dataProvider = "shuffleCompareOpProvider")
 +    static void shuffleEqualsHalffloat128VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {
 +        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());
 +        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var av = VectorShuffle.fromArray(SPECIES, a, i);
 +            var bv = VectorShuffle.fromArray(SPECIES, b, i);
 +            boolean eq = av.equals(bv);
 +            int to = i + SPECIES.length();
 +            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));
 +        }
 +    }
 +
 +    @Test(dataProvider = "maskCompareOpProvider")
 +    static void maskEqualsHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        boolean[] b = fb.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var av = SPECIES.loadMask(a, i);
 +            var bv = SPECIES.loadMask(b, i);
 +            boolean equals = av.equals(bv);
 +            int to = i + SPECIES.length();
 +            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));
 +        }
 +    }
 +
 +    static boolean band(boolean a, boolean b) {
 +        return a & b;
 +    }
 +
 +    @Test(dataProvider = "maskCompareOpProvider")
 +    static void maskAndHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        boolean[] b = fb.apply(SPECIES.length());
 +        boolean[] r = new boolean[a.length];
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var av = SPECIES.loadMask(a, i);
 +            var bv = SPECIES.loadMask(b, i);
 +            var cv = av.and(bv);
 +            cv.intoArray(r, i);
 +        }
 +        assertArraysEquals(r, a, b, Halffloat128VectorTests::band);
 +    }
 +
 +    static boolean bor(boolean a, boolean b) {
 +        return a | b;
 +    }
 +
 +    @Test(dataProvider = "maskCompareOpProvider")
 +    static void maskOrHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        boolean[] b = fb.apply(SPECIES.length());
 +        boolean[] r = new boolean[a.length];
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var av = SPECIES.loadMask(a, i);
 +            var bv = SPECIES.loadMask(b, i);
 +            var cv = av.or(bv);
 +            cv.intoArray(r, i);
 +        }
 +        assertArraysEquals(r, a, b, Halffloat128VectorTests::bor);
 +    }
 +
 +    static boolean bxor(boolean a, boolean b) {
 +        return a != b;
 +    }
 +
 +    @Test(dataProvider = "maskCompareOpProvider")
 +    static void maskXorHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        boolean[] b = fb.apply(SPECIES.length());
 +        boolean[] r = new boolean[a.length];
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var av = SPECIES.loadMask(a, i);
 +            var bv = SPECIES.loadMask(b, i);
 +            var cv = av.xor(bv);
 +            cv.intoArray(r, i);
 +        }
 +        assertArraysEquals(r, a, b, Halffloat128VectorTests::bxor);
 +    }
 +
 +    static boolean bandNot(boolean a, boolean b) {
 +        return a & !b;
 +    }
 +
 +    @Test(dataProvider = "maskCompareOpProvider")
 +    static void maskAndNotHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        boolean[] b = fb.apply(SPECIES.length());
 +        boolean[] r = new boolean[a.length];
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var av = SPECIES.loadMask(a, i);
 +            var bv = SPECIES.loadMask(b, i);
 +            var cv = av.andNot(bv);
 +            cv.intoArray(r, i);
 +        }
 +        assertArraysEquals(r, a, b, Halffloat128VectorTests::bandNot);
 +    }
 +
 +    static boolean beq(boolean a, boolean b) {
 +        return (a == b);
 +    }
 +
 +    @Test(dataProvider = "maskCompareOpProvider")
 +    static void maskEqHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        boolean[] b = fb.apply(SPECIES.length());
 +        boolean[] r = new boolean[a.length];
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var av = SPECIES.loadMask(a, i);
 +            var bv = SPECIES.loadMask(b, i);
 +            var cv = av.eq(bv);
 +            cv.intoArray(r, i);
 +        }
 +        assertArraysEquals(r, a, b, Halffloat128VectorTests::beq);
 +    }
 +
 +    @Test(dataProvider = "maskProvider")
 +    static void maskHashCodeHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var vmask = SPECIES.loadMask(a, i);
 +            int hash = vmask.hashCode();
 +
 +            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());
 +            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));
 +            Assert.assertTrue(hash == expectedHash, "at index " + i + ", hash should be = " + expectedHash + ", but is = " + hash);
 +        }
 +    }
 +
 +    static int maskTrueCount(boolean[] a, int idx) {
 +        int trueCount = 0;
 +        for (int i = idx; i < idx + SPECIES.length(); i++) {
 +            trueCount += a[i] ? 1 : 0;
 +        }
 +        return trueCount;
 +    }
 +
 +    @Test(dataProvider = "maskProvider")
 +    static void maskTrueCountHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        int[] r = new int[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                var vmask = SPECIES.loadMask(a, i);
 +                r[i] = vmask.trueCount();
 +            }
 +        }
 +
 +        assertMaskReductionArraysEquals(r, a, Halffloat128VectorTests::maskTrueCount);
 +    }
 +
 +    static int maskLastTrue(boolean[] a, int idx) {
 +        int i = idx + SPECIES.length() - 1;
 +        for (; i >= idx; i--) {
 +            if (a[i]) {
 +                break;
 +            }
 +        }
 +        return i - idx;
 +    }
 +
 +    @Test(dataProvider = "maskProvider")
 +    static void maskLastTrueHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        int[] r = new int[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                var vmask = SPECIES.loadMask(a, i);
 +                r[i] = vmask.lastTrue();
 +            }
 +        }
 +
 +        assertMaskReductionArraysEquals(r, a, Halffloat128VectorTests::maskLastTrue);
 +    }
 +
 +    static int maskFirstTrue(boolean[] a, int idx) {
 +        int i = idx;
 +        for (; i < idx + SPECIES.length(); i++) {
 +            if (a[i]) {
 +                break;
 +            }
 +        }
 +        return i - idx;
 +    }
 +
 +    @Test(dataProvider = "maskProvider")
 +    static void maskFirstTrueHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        int[] r = new int[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                var vmask = SPECIES.loadMask(a, i);
 +                r[i] = vmask.firstTrue();
 +            }
 +        }
 +
 +        assertMaskReductionArraysEquals(r, a, Halffloat128VectorTests::maskFirstTrue);
 +    }
 +
 +    @Test(dataProvider = "maskProvider")
 +    static void maskCompressHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
 +        int trueCount = 0;
 +        boolean[] a = fa.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                var vmask = SPECIES.loadMask(a, i);
 +                trueCount = vmask.trueCount();
 +                var rmask = vmask.compress();
 +                for (int j = 0; j < SPECIES.length(); j++)  {
 +                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
 +                }
 +            }
 +        }
 +    }
 +
 +    @DataProvider
 +    public static Object[][] longMaskProvider() {
 +        return new Object[][]{
 +                {0xFFFFFFFFFFFFFFFFL},
 +                {0x0000000000000000L},
 +                {0x5555555555555555L},
 +                {0x0123456789abcdefL},
 +        };
 +    }
 +
 +    @Test(dataProvider = "longMaskProvider")
 +    static void maskFromToLongHalffloat128VectorTestsSmokeTest(long inputLong) {
 +        var vmask = VectorMask.fromLong(SPECIES, inputLong);
 +        long outputLong = vmask.toLong();
 +        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));
 +    }
 +
 +    @DataProvider
 +    public static Object[][] offsetProvider() {
 +        return new Object[][]{
 +                {0},
 +                {-1},
 +                {+1},
 +                {+2},
 +                {-2},
 +        };
 +    }
 +
 +    @Test(dataProvider = "offsetProvider")
 +    static void indexInRangeHalffloat128VectorTestsSmokeTest(int offset) {
 +        int limit = SPECIES.length() * BUFFER_REPS;
 +        for (int i = 0; i < limit; i += SPECIES.length()) {
 +            var actualMask = SPECIES.indexInRange(i + offset, limit);
 +            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);
 +            assert(actualMask.equals(expectedMask));
 +            for (int j = 0; j < SPECIES.length(); j++)  {
 +                int index = i + j + offset;
 +                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "offsetProvider")
 +    static void indexInRangeLongHalffloat128VectorTestsSmokeTest(int offset) {
 +        long limit = SPECIES.length() * BUFFER_REPS;
 +        for (long i = 0; i < limit; i += SPECIES.length()) {
 +            var actualMask = SPECIES.indexInRange(i + offset, limit);
 +            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);
 +            assert(actualMask.equals(expectedMask));
 +            for (int j = 0; j < SPECIES.length(); j++)  {
 +                long index = i + j + offset;
 +                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);
 +            }
 +        }
 +    }
 +
 +    @DataProvider
 +    public static Object[][] lengthProvider() {
 +        return new Object[][]{
 +                {0},
 +                {1},
 +                {32},
 +                {37},
 +                {1024},
 +                {1024+1},
 +                {1024+5},
 +        };
 +    }
 +
 +    @Test(dataProvider = "lengthProvider")
 +    static void loopBoundHalffloat128VectorTestsSmokeTest(int length) {
 +        int actualLoopBound = SPECIES.loopBound(length);
 +        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());
 +        Assert.assertEquals(actualLoopBound, expectedLoopBound);
 +    }
 +
 +    @Test(dataProvider = "lengthProvider")
 +    static void loopBoundLongHalffloat128VectorTestsSmokeTest(int _length) {
 +        long length = _length;
 +        long actualLoopBound = SPECIES.loopBound(length);
 +        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());
 +        Assert.assertEquals(actualLoopBound, expectedLoopBound);
 +    }
 +
 +    @Test
 +    static void ElementSizeHalffloat128VectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
 +        int elsize = av.elementSize();
-         Assert.assertEquals(elsize, Halffloat.SIZE);
++        Assert.assertEquals(elsize, Float16.SIZE);
 +    }
 +
 +    @Test
 +    static void VectorShapeHalffloat128VectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
 +        VectorShape vsh = av.shape();
 +        assert(vsh.equals(VectorShape.S_128_BIT));
 +    }
 +
 +    @Test
 +    static void ShapeWithLanesHalffloat128VectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
 +        VectorShape vsh = av.shape();
-         VectorSpecies species = vsh.withLanes(Halffloat.class);
++        VectorSpecies species = vsh.withLanes(Float16.class);
 +        assert(species.equals(SPECIES));
 +    }
 +
 +    @Test
 +    static void ElementTypeHalffloat128VectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
-         assert(av.species().elementType() == Halffloat.class);
++        assert(av.species().elementType() == Float16.class);
 +    }
 +
 +    @Test
 +    static void SpeciesElementSizeHalffloat128VectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
-         assert(av.species().elementSize() == Halffloat.SIZE);
++        assert(av.species().elementSize() == Float16.SIZE);
 +    }
 +
 +    @Test
 +    static void VectorTypeHalffloat128VectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
 +        assert(av.species().vectorType() == av.getClass());
 +    }
 +
 +    @Test
 +    static void WithLanesHalffloat128VectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
-         VectorSpecies species = av.species().withLanes(Halffloat.class);
++        VectorSpecies species = av.species().withLanes(Float16.class);
 +        assert(species.equals(SPECIES));
 +    }
 +
 +    @Test
 +    static void WithShapeHalffloat128VectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
 +        VectorShape vsh = av.shape();
 +        VectorSpecies species = av.species().withShape(vsh);
 +        assert(species.equals(SPECIES));
 +    }
 +
 +    @Test
 +    static void MaskAllTrueHalffloat128VectorTestsSmokeTest() {
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));
 +        }
 +    }
 +}
diff --cc test/jdk/jdk/incubator/vector/Halffloat256VectorLoadStoreTests.java
index ecc5c775fda,00000000000..3738e5a57ef
mode 100644,000000..100644
--- a/test/jdk/jdk/incubator/vector/Halffloat256VectorLoadStoreTests.java
+++ b/test/jdk/jdk/incubator/vector/Halffloat256VectorLoadStoreTests.java
@@@ -1,849 -1,0 +1,1014 @@@
 +/*
-  * Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2018, 2025, Oracle and/or its affiliates. All rights reserved.
 + * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 + *
 + * This code is free software; you can redistribute it and/or modify it
 + * under the terms of the GNU General Public License version 2 only, as
 + * published by the Free Software Foundation.
 + *
 + * This code is distributed in the hope that it will be useful, but WITHOUT
 + * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 + * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 + * version 2 for more details (a copy is included in the LICENSE file that
 + * accompanied this code).
 + *
 + * You should have received a copy of the GNU General Public License version
 + * 2 along with this work; if not, write to the Free Software Foundation,
 + * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 + *
 + * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 + * or visit www.oracle.com if you need additional information or have any
 + * questions.
 + */
 +
 +/*
 + * @test
-  * @enablePreview
++ * @key randomness
++ *
++ * @library /test/lib
 + * @modules jdk.incubator.vector java.base/jdk.internal.vm.annotation
 + * @run testng/othervm -XX:-TieredCompilation Halffloat256VectorLoadStoreTests
 + *
 + */
 +
 +// -- This file was mechanically generated: Do not edit! -- //
 +
 +import java.lang.foreign.MemorySegment;
- import java.lang.foreign.SegmentScope;
++import java.lang.foreign.Arena;
 +import java.lang.foreign.ValueLayout;
- import jdk.incubator.vector.Halffloat;
- import jdk.incubator.vector.HalffloatVector;
 +import jdk.incubator.vector.HalffloatVector;
 +import jdk.incubator.vector.VectorMask;
 +import jdk.incubator.vector.VectorSpecies;
 +import jdk.incubator.vector.VectorShuffle;
 +import jdk.internal.vm.annotation.DontInline;
 +import org.testng.Assert;
 +import org.testng.annotations.DataProvider;
 +import org.testng.annotations.Test;
 +
 +import java.nio.ByteOrder;
 +import java.util.List;
 +import java.util.function.*;
 +
 +@Test
 +public class Halffloat256VectorLoadStoreTests extends AbstractVectorLoadStoreTest {
-     static final VectorSpecies<Halffloat> SPECIES =
++    static final VectorSpecies<Float16> SPECIES =
 +                HalffloatVector.SPECIES_256;
 +
 +    static final int INVOC_COUNT = Integer.getInteger("jdk.incubator.vector.test.loop-iterations", 100);
 +
-     static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withBitAlignment(8);
++    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withByteAlignment(1);
 +
 +
 +    static final int BUFFER_REPS = Integer.getInteger("jdk.incubator.vector.test.buffer-vectors", 25000 / 256);
 +
 +    static void assertArraysEquals(short[] r, short[] a, boolean[] mask) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0);
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0, "at index #" + i);
 +        }
 +    }
 +
 +    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(
 +            withToString("short[i * 5]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (short)(i * 5));
 +            }),
 +            withToString("short[i + 1]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));
 +            })
 +    );
 +
 +    // Relative to array.length
 +    static final List<IntFunction<Integer>> INDEX_GENERATORS = List.of(
 +            withToString("-1", (int l) -> {
 +                return -1;
 +            }),
 +            withToString("l", (int l) -> {
 +                return l;
 +            }),
 +            withToString("l - 1", (int l) -> {
 +                return l - 1;
 +            }),
 +            withToString("l + 1", (int l) -> {
 +                return l + 1;
 +            }),
 +            withToString("l - speciesl + 1", (int l) -> {
 +                return l - SPECIES.length() + 1;
 +            }),
 +            withToString("l + speciesl - 1", (int l) -> {
 +                return l + SPECIES.length() - 1;
 +            }),
 +            withToString("l + speciesl", (int l) -> {
 +                return l + SPECIES.length();
 +            }),
 +            withToString("l + speciesl + 1", (int l) -> {
 +                return l + SPECIES.length() + 1;
 +            })
 +    );
 +
 +    // Relative to byte[] array.length or MemorySegment.byteSize()
 +    static final List<IntFunction<Integer>> BYTE_INDEX_GENERATORS = List.of(
 +            withToString("-1", (int l) -> {
 +                return -1;
 +            }),
 +            withToString("l", (int l) -> {
 +                return l;
 +            }),
 +            withToString("l - 1", (int l) -> {
 +                return l - 1;
 +            }),
 +            withToString("l + 1", (int l) -> {
 +                return l + 1;
 +            }),
 +            withToString("l - speciesl*ebsize + 1", (int l) -> {
 +                return l - SPECIES.vectorByteSize() + 1;
 +            }),
 +            withToString("l + speciesl*ebsize - 1", (int l) -> {
 +                return l + SPECIES.vectorByteSize() - 1;
 +            }),
 +            withToString("l + speciesl*ebsize", (int l) -> {
 +                return l + SPECIES.vectorByteSize();
 +            }),
 +            withToString("l + speciesl*ebsize + 1", (int l) -> {
 +                return l + SPECIES.vectorByteSize() + 1;
 +            })
 +    );
 +
 +    @DataProvider
 +    public Object[][] shortProvider() {
 +        return HALFFLOAT_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] maskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortProviderForIOOBE() {
 +        var f = HALFFLOAT_GENERATORS.get(0);
 +        return INDEX_GENERATORS.stream().map(fi -> {
 +                    return new Object[] {f, fi};
 +                }).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                    return new Object[] {fa, fm};
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortMaskProviderForIOOBE() {
 +        var f = HALFFLOAT_GENERATORS.get(0);
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {
 +                    return new Object[] {f, fi, fm};
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortMemorySegmentProvider() {
 +        return HALFFLOAT_GENERATORS.stream().
 +                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().
 +                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {
 +                            return new Object[]{fa, fb, bo};
 +                        }))).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortMemorySegmentMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_GENERATORS.stream().
 +                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().
 +                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {
 +                            return new Object[]{fa, fb, fm, bo};
 +                        })))).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortByteProviderForIOOBE() {
 +        var f = HALFFLOAT_GENERATORS.get(0);
 +        return BYTE_INDEX_GENERATORS.stream().map(fi -> {
 +                    return new Object[] {f, fi};
 +                }).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortByteMaskProviderForIOOBE() {
 +        var f = HALFFLOAT_GENERATORS.get(0);
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> BYTE_INDEX_GENERATORS.stream().map(fi -> {
 +                    return new Object[] {f, fi, fm};
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {
 +        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() / 8);
 +        for (int i = 0; i < a.length; i++) {
 +            ms.set(ELEMENT_LAYOUT, i * SPECIES.elementSize() / 8 , a[i]);
 +        }
 +        return ms;
 +    }
 +
 +    static short[] segmentToArray(MemorySegment ms) {
 +        return ms.toArray(ELEMENT_LAYOUT);
 +    }
 +
 +
 +    interface ToHalffloatF {
 +        short apply(int i);
 +    }
 +
 +    static short[] fill(int s , ToHalffloatF f) {
 +        return fill(new short[s], f);
 +    }
 +
 +    static short[] fill(short[] a, ToHalffloatF f) {
 +        for (int i = 0; i < a.length; i++) {
 +            a[i] = f.apply(i);
 +        }
 +        return a;
 +    }
 +
++    @DontInline
++    static VectorShuffle<Float16> shuffleFromArray(int[] a, int i) {
++        return SPECIES.shuffleFromArray(a, i);
++    }
++
++    @DontInline
++    static void shuffleIntoArray(VectorShuffle<Float16> s, int[] a, int i) {
++        s.intoArray(a, i);
++    }
++
++    @DontInline
++    static VectorShuffle<Float16> shuffleFromMemorySegment(MemorySegment mem, int i, ByteOrder bo) {
++        return VectorShuffle.fromMemorySegment(SPECIES, mem, i, bo);
++    }
++
++    @DontInline
++    static void shuffleIntoMemorySegment(VectorShuffle<Float16> s, MemorySegment mem, int i, ByteOrder bo) {
++        s.intoMemorySegment(mem, i, bo);
++    }
++
 +    @DontInline
 +    static HalffloatVector fromArray(short[] a, int i) {
-         return HalffloatVector.fromArray(SPECIES, a, i);
++        // Tests the species method and the equivalent vector method it defers to
++        return (HalffloatVector) SPECIES.fromArray(a, i);
 +    }
 +
 +    @DontInline
-     static HalffloatVector fromArray(short[] a, int i, VectorMask<Halffloat> m) {
++    static HalffloatVector fromArray(short[] a, int i, VectorMask<Float16> m) {
 +        return HalffloatVector.fromArray(SPECIES, a, i, m);
 +    }
 +
 +    @DontInline
 +    static void intoArray(HalffloatVector v, short[] a, int i) {
 +        v.intoArray(a, i);
 +    }
 +
 +    @DontInline
-     static void intoArray(HalffloatVector v, short[] a, int i, VectorMask<Halffloat> m) {
++    static void intoArray(HalffloatVector v, short[] a, int i, VectorMask<Float16> m) {
 +        v.intoArray(a, i, m);
 +    }
 +
 +    @DontInline
 +    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {
-         return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);
++        // Tests the species method and the equivalent vector method it defers to
++        return (HalffloatVector) SPECIES.fromMemorySegment(a, i, bo);
 +    }
 +
 +    @DontInline
-     static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Halffloat> m) {
++    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Float16> m) {
 +        return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, m);
 +    }
 +
 +    @DontInline
 +    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo) {
 +        v.intoMemorySegment(a, i, bo);
 +    }
 +
 +    @DontInline
-     static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Halffloat> m) {
++    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Float16> m) {
 +        v.intoMemorySegment(a, i, bo, m);
 +    }
 +
 +    @Test(dataProvider = "shortProvider")
 +    static void loadStoreArray(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = new short[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.intoArray(r, i);
 +            }
 +        }
 +        Assert.assertEquals(r, a);
 +    }
 +
 +    @Test(dataProvider = "shortProviderForIOOBE")
 +    static void loadArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = new short[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = fromArray(a, i);
 +                av.intoArray(r, i);
 +            }
 +        }
 +
 +        int index = fi.apply(a.length);
 +        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);
 +        try {
 +            fromArray(a, index);
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortProviderForIOOBE")
 +    static void storeArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = new short[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                intoArray(av, r, i);
 +            }
 +        }
 +
 +        int index = fi.apply(a.length);
 +        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);
 +        try {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);
 +            intoArray(av, r, index);
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +
 +    @Test(dataProvider = "shortMaskProvider")
 +    static void loadStoreMaskArray(IntFunction<short[]> fa,
 +                                   IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = new short[a.length];
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);
++        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, vmask);
 +                av.intoArray(r, i);
 +            }
 +        }
 +        assertArraysEquals(r, a, mask);
 +
 +
 +        r = new short[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.intoArray(r, i, vmask);
 +            }
 +        }
 +        assertArraysEquals(r, a, mask);
 +    }
 +
 +    @Test(dataProvider = "shortMaskProviderForIOOBE")
 +    static void loadArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = new short[a.length];
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);
++        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = fromArray(a, i, vmask);
 +                av.intoArray(r, i);
 +            }
 +        }
 +
 +        int index = fi.apply(a.length);
 +        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);
 +        try {
 +            fromArray(a, index, vmask);
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortMaskProviderForIOOBE")
 +    static void storeArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = new short[a.length];
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);
++        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                intoArray(av, r, i, vmask);
 +            }
 +        }
 +
 +        int index = fi.apply(a.length);
 +        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);
 +        try {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);
 +            intoArray(av, a, index, vmask);
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +
 +    @Test(dataProvider = "shortMaskProvider")
 +    static void loadStoreMask(IntFunction<short[]> fa,
 +                              IntFunction<boolean[]> fm) {
 +        boolean[] mask = fm.apply(SPECIES.length());
 +        boolean[] r = new boolean[mask.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < mask.length; i += SPECIES.length()) {
-                 VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, i);
++                VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, i);
 +                vmask.intoArray(r, i);
 +            }
 +        }
 +        Assert.assertEquals(r, mask);
 +    }
 +
 +
 +    @Test(dataProvider = "shortMemorySegmentProvider")
 +    static void loadStoreMemorySegment(IntFunction<short[]> fa,
 +                                       IntFunction<MemorySegment> fb,
 +                                       ByteOrder bo) {
 +        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);
 +        MemorySegment r = fb.apply((int) a.byteSize());
 +
 +        int l = (int) a.byteSize();
 +        int s = SPECIES.vectorByteSize();
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < l; i += s) {
 +                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);
 +                av.intoMemorySegment(r, i, bo);
 +            }
 +        }
 +        long m = r.mismatch(a);
 +        Assert.assertEquals(m, -1, "Segments not equal");
 +    }
 +
 +    @Test(dataProvider = "shortByteProviderForIOOBE")
 +    static void loadMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {
-         MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));
-         MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());
++        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));
++        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);
 +
 +        int l = (int) a.byteSize();
 +        int s = SPECIES.vectorByteSize();
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < l; i += s) {
 +                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());
 +                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());
 +            }
 +        }
 +
 +        int index = fi.apply((int) a.byteSize());
 +        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());
 +        try {
 +            fromMemorySegment(a, index, ByteOrder.nativeOrder());
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortByteProviderForIOOBE")
 +    static void storeMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {
-         MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));
-         MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());
++        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));
++        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);
 +
 +        int l = (int) a.byteSize();
 +        int s = SPECIES.vectorByteSize();
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < l; i += s) {
 +                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());
 +                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());
 +            }
 +        }
 +
 +        int index = fi.apply((int) a.byteSize());
 +        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());
 +        try {
 +            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());
 +            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortMemorySegmentMaskProvider")
 +    static void loadStoreMemorySegmentMask(IntFunction<short[]> fa,
 +                                           IntFunction<MemorySegment> fb,
 +                                           IntFunction<boolean[]> fm,
 +                                           ByteOrder bo) {
 +        short[] _a = fa.apply(SPECIES.length());
 +        MemorySegment a = toSegment(_a, fb);
 +        MemorySegment r = fb.apply((int) a.byteSize());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);
++        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);
 +
 +        int l = (int) a.byteSize();
 +        int s = SPECIES.vectorByteSize();
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < l; i += s) {
 +                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, vmask);
 +                av.intoMemorySegment(r, i, bo);
 +            }
 +        }
 +        assertArraysEquals(segmentToArray(r), _a, mask);
 +
 +
 +        r = fb.apply((int) a.byteSize());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < l; i += s) {
 +                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);
 +                av.intoMemorySegment(r, i, bo, vmask);
 +            }
 +        }
 +        assertArraysEquals(segmentToArray(r), _a, mask);
 +    }
 +
 +    @Test(dataProvider = "shortByteMaskProviderForIOOBE")
 +    static void loadMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {
-         MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));
-         MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());
++        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));
++        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);
++        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);
 +
 +        int l = (int) a.byteSize();
 +        int s = SPECIES.vectorByteSize();
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < l; i += s) {
 +                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);
 +                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());
 +            }
 +        }
 +
 +        int index = fi.apply((int) a.byteSize());
 +        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() / 8);
 +        try {
 +            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortByteMaskProviderForIOOBE")
 +    static void storeMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {
-         MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));
-         MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());
++        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));
++        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);
++        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);
 +
 +        int l = (int) a.byteSize();
 +        int s = SPECIES.vectorByteSize();
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < l; i += s) {
 +                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());
 +                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);
 +            }
 +        }
 +
 +        int index = fi.apply((int) a.byteSize());
 +        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() / 8);
 +        try {
 +            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());
 +            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortMemorySegmentProvider")
 +    static void loadStoreReadonlyMemorySegment(IntFunction<short[]> fa,
 +                                               IntFunction<MemorySegment> fb,
 +                                               ByteOrder bo) {
 +        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();
 +
 +        Assert.assertThrows(
 +                UnsupportedOperationException.class,
 +                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)
 +        );
 +
 +        Assert.assertThrows(
 +                UnsupportedOperationException.class,
 +                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))
 +        );
 +
 +        Assert.assertThrows(
 +                UnsupportedOperationException.class,
 +                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))
 +        );
 +
-         VectorMask<Halffloat> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)
++        VectorMask<Float16> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)
 +                .laneIsValid();
 +        Assert.assertThrows(
 +                UnsupportedOperationException.class,
 +                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)
 +        );
 +    }
 +
 +
 +    @Test(dataProvider = "maskProvider")
 +    static void loadStoreMask(IntFunction<boolean[]> fm) {
 +        boolean[] a = fm.apply(SPECIES.length());
 +        boolean[] r = new boolean[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                 VectorMask<Halffloat> vmask = SPECIES.loadMask(a, i);
++                VectorMask<Float16> vmask = SPECIES.loadMask(a, i);
 +                vmask.intoArray(r, i);
 +            }
 +        }
 +        Assert.assertEquals(r, a);
 +    }
 +
 +
-     @Test
-     static void loadStoreShuffle() {
-         IntUnaryOperator fn = a -> a + 5;
-         for (int ic = 0; ic < INVOC_COUNT; ic++) {
-             var shuffle = VectorShuffle.fromOp(SPECIES, fn);
-             int [] r = shuffle.toArray();
++   @Test(dataProvider = "shuffleIntProvider")
++   static void loadStoreShuffleArray(IntFunction<int[]> fa) {
++       int[] a = fa.apply(SPECIES.length());
++       int[] r = new int[a.length];
 +
-             int [] a = expectedShuffle(SPECIES.length(), fn);
-             Assert.assertEquals(r, a);
++       for (int ic = 0; ic < INVOC_COUNT; ic++) {
++           for (int i = 0; i < a.length; i += SPECIES.length()) {
++               VectorShuffle<Float16> shuffle = VectorShuffle.fromArray(SPECIES, a, i);
++               shuffle.intoArray(r, i);
++           }
 +       }
-     }
 +
++       for (int i = 0; i < a.length; i++) {
++          Assert.assertEquals(testPartiallyWrapIndex(SPECIES, a[i]), r[i]);
++       }
++
++   }
++
++   @Test(dataProvider = "shuffleIntProviderForIOOBE")
++   static void storeShuffleArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {
++       int[] a = fa.apply(SPECIES.length());
++       int[] r = new int[a.length];
++
++       for (int ic = 0; ic < INVOC_COUNT; ic++) {
++           for (int i = 0; i < a.length; i += SPECIES.length()) {
++               VectorShuffle<Float16> shuffle = shuffleFromArray(a, i);
++               shuffleIntoArray(shuffle, r, i);
++           }
++       }
++
++       int index = fi.apply(a.length);
++       boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);
++       try {
++           VectorShuffle<Float16> shuffle = shuffleFromArray(a, index);
++           shuffleIntoArray(shuffle, r, index);
++           if (shouldFail) {
++               Assert.fail("Failed to throw IndexOutOfBoundsException");
++           }
++       } catch (IndexOutOfBoundsException e) {
++           if (!shouldFail) {
++               Assert.fail("Unexpected IndexOutOfBoundsException");
++           }
++       }
++   }
++
++   @Test(dataProvider = "shuffleIntProviderForIOOBE")
++   static void loadShuffleArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {
++       int[] a = fa.apply(SPECIES.length());
++       int[] r = new int[a.length];
++
++       for (int ic = 0; ic < INVOC_COUNT; ic++) {
++           for (int i = 0; i < a.length; i += SPECIES.length()) {
++               VectorShuffle<Float16> shuffle = shuffleFromArray(a, i);
++               shuffle.intoArray(r, i);
++           }
++       }
++
++       int index = fi.apply(a.length);
++       boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);
++       try {
++           shuffleFromArray(a, index);
++           if (shouldFail) {
++               Assert.fail("Failed to throw IndexOutOfBoundsException");
++           }
++       } catch (IndexOutOfBoundsException e) {
++           if (!shouldFail) {
++               Assert.fail("Unexpected IndexOutOfBoundsException");
++           }
++       }
++   }
++
++   @Test(dataProvider = "shuffleIntMemorySegmentProvider")
++   static void loadStoreShuffleMemorySegment(IntFunction<int[]> fa,
++                                      IntFunction<MemorySegment> fb,
++                                      ByteOrder bo) {
++       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), fb);
++       MemorySegment r = fb.apply((int) a.byteSize());
++
++       int l = (int) a.byteSize();
++       int s = SPECIES.length() * 4; //An integer for every lane is read out. So 4 bytes per lane
++
++       for (int ic = 0; ic < INVOC_COUNT; ic++) {
++           for (int i = 0; i < l; i += s) {
++               VectorShuffle<Float16> shuffle = VectorShuffle.fromMemorySegment(SPECIES, a, i, bo);
++               shuffle.intoMemorySegment(r, i, bo);
++           }
++       }
++
++       for (int i = 0; i < l / 4; i++) {
++           int ai = a.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED.withOrder(bo), i);
++           int ri = r.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED.withOrder(bo), i);
++           Assert.assertEquals(testPartiallyWrapIndex(SPECIES, ai), ri);
++       }
++   }
++
++   @Test(dataProvider = "shuffleIntByteProviderForIOOBE")
++   static void shuffleLoadMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {
++       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i));
++       MemorySegment r = Arena.ofAuto().allocate(a.byteSize());
++
++       int l = (int) a.byteSize();
++       int s = SPECIES.length() * 4;
++
++       for (int ic = 0; ic < INVOC_COUNT; ic++) {
++           for (int i = 0; i < l; i += s) {
++               VectorShuffle<Float16> shuffle = shuffleFromMemorySegment(a, i, ByteOrder.nativeOrder());
++               shuffle.intoMemorySegment(r, i, ByteOrder.nativeOrder());
++           }
++       }
++
++       int index = fi.apply((int) a.byteSize());
++       boolean shouldFail = isIndexOutOfBounds(s, index, (int) a.byteSize());
++       try {
++           shuffleFromMemorySegment(a, index, ByteOrder.nativeOrder());
++           if (shouldFail) {
++               Assert.fail("Failed to throw IndexOutOfBoundsException");
++           }
++       } catch (IndexOutOfBoundsException e) {
++           if (!shouldFail) {
++               Assert.fail("Unexpected IndexOutOfBoundsException");
++           }
++       }
++   }
++
++   @Test(dataProvider = "shuffleIntByteProviderForIOOBE")
++   static void shuffleStoreMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {
++       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i));
++       MemorySegment r = Arena.ofAuto().allocate(a.byteSize());
++
++       int l = (int) a.byteSize();
++       int s = SPECIES.length() * 4;
++
++       for (int ic = 0; ic < INVOC_COUNT; ic++) {
++           for (int i = 0; i < l; i += s) {
++               VectorShuffle<Float16> shuffle =
++                       VectorShuffle.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());
++               shuffleIntoMemorySegment(shuffle, r, i, ByteOrder.nativeOrder());
++           }
++       }
++
++       int index = fi.apply((int) a.byteSize());
++       boolean shouldFail = isIndexOutOfBounds(s, index, (int) a.byteSize());
++       try {
++           VectorShuffle<Float16> shuffle =
++                   VectorShuffle.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());
++           shuffleIntoMemorySegment(shuffle, r, index, ByteOrder.nativeOrder());
++           if (shouldFail) {
++               Assert.fail("Failed to throw IndexOutOfBoundsException");
++           }
++       } catch (IndexOutOfBoundsException e) {
++           if (!shouldFail) {
++               Assert.fail("Unexpected IndexOutOfBoundsException");
++           }
++       }
++   }
 +
 +
 +
 +
 +    // Gather/Scatter load/store tests
 +
 +    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {
 +        int i = 0;
 +        int j = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                j = i;
 +                for (; j < i + SPECIES.length(); j++) {
 +                    Assert.assertEquals(r[j], a[i + indexMap[j]]);
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[j], a[i + indexMap[j]], "at index #" + j);
 +        }
 +    }
 +
 +    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {
 +        int i = 0;
 +        int j = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                j = i;
 +                for (; j < i + SPECIES.length(); j++) {
 +                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, "at index #" + j);
 +        }
 +    }
 +
 +    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {
 +        short[] expected = new short[r.length];
 +
 +        // Store before checking, since the same location may be stored to more than once
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            for (int j = i; j < i + SPECIES.length(); j++) {
 +                if (mask[j % SPECIES.length()]) {
 +                    expected[i + indexMap[j]] = a[j];
 +                }
 +            }
 +        }
 +
 +        Assert.assertEquals(r, expected);
 +    }
 +
 +    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {
 +        short[] expected = new short[r.length];
 +
 +        // Store before checking, since the same location may be stored to more than once
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            for (int j = i; j < i + SPECIES.length(); j++) {
 +                expected[i + indexMap[j]] = a[j];
 +            }
 +        }
 +
 +        Assert.assertEquals(r, expected);
 +    }
 +
 +    @DataProvider
 +    public Object[][] gatherScatterProvider() {
 +        return INT_INDEX_GENERATORS.stream().
 +                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                    return new Object[] {fa, fs};
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] gatherScatterMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->
 +            HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                    return new Object[] {fa, fm, fs};
 +            }))).
 +            toArray(Object[][]::new);
 +    }
 +
 +
 +    @Test(dataProvider = "gatherScatterProvider")
 +    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {
 +        short[] a = fa.apply(SPECIES.length());
 +        int[] b = fs.apply(a.length, SPECIES.length());
 +        short[] r = new short[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i);
 +                av.intoArray(r, i);
 +            }
 +        }
 +
 +        assertGatherArraysEquals(r, a, b);
 +    }
 +
 +    @Test(dataProvider = "gatherScatterMaskProvider")
 +    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        int[] b = fs.apply(a.length, SPECIES.length());
 +        short[] r = new short[a.length];
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i, vmask);
 +                av.intoArray(r, i);
 +            }
 +        }
 +
 +        assertGatherArraysEquals(r, a, b, mask);
 +    }
 +
 +    @Test(dataProvider = "gatherScatterProvider")
 +    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {
 +        short[] a = fa.apply(SPECIES.length());
 +        int[] b = fs.apply(a.length, SPECIES.length());
 +        short[] r = new short[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.intoArray(r, i, b, i);
 +            }
 +        }
 +
 +        assertScatterArraysEquals(r, a, b);
 +    }
 +
 +    @Test(dataProvider = "gatherScatterMaskProvider")
 +    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        int[] b = fs.apply(a.length, SPECIES.length());
 +        short[] r = new short[a.length];
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.intoArray(r, i, b, i, vmask);
 +            }
 +        }
 +
 +        assertScatterArraysEquals(r, a, b, mask);
 +    }
 +
 +
 +
 +}
diff --cc test/jdk/jdk/incubator/vector/Halffloat256VectorTests.java
index 40fe0515316,00000000000..dd7fdf3d060
mode 100644,000000..100644
--- a/test/jdk/jdk/incubator/vector/Halffloat256VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Halffloat256VectorTests.java
@@@ -1,3134 -1,0 +1,3256 @@@
 +/*
-  * Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
 + * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 + *
 + * This code is free software; you can redistribute it and/or modify it
 + * under the terms of the GNU General Public License version 2 only, as
 + * published by the Free Software Foundation.
 + *
 + * This code is distributed in the hope that it will be useful, but WITHOUT
 + * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 + * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 + * version 2 for more details (a copy is included in the LICENSE file that
 + * accompanied this code).
 + *
 + * You should have received a copy of the GNU General Public License version
 + * 2 along with this work; if not, write to the Free Software Foundation,
 + * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 + *
 + * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 + * or visit www.oracle.com if you need additional information or have any
 + * questions.
 + */
 +
 +/*
 + * @test
++ * @key randomness
++ *
++ * @library /test/lib
 + * @modules jdk.incubator.vector
-  * @run testng/othervm -ea -esa -Xbatch -XX:-TieredCompilation Halffloat256VectorTests
++ * @run testng/othervm/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Halffloat256VectorTests
 + */
 +
 +// -- This file was mechanically generated: Do not edit! -- //
 +
 +import jdk.incubator.vector.VectorShape;
 +import jdk.incubator.vector.VectorSpecies;
 +import jdk.incubator.vector.VectorShuffle;
 +import jdk.incubator.vector.VectorMask;
 +import jdk.incubator.vector.VectorOperators;
 +import jdk.incubator.vector.Vector;
 +
- import jdk.incubator.vector.Halffloat;
++import jdk.incubator.vector.Float16;
 +import jdk.incubator.vector.HalffloatVector;
 +
 +import org.testng.Assert;
 +import org.testng.annotations.DataProvider;
 +import org.testng.annotations.Test;
 +
 +import java.lang.Integer;
 +import java.util.List;
 +import java.util.Arrays;
 +import java.util.function.BiFunction;
 +import java.util.function.IntFunction;
 +import java.util.Objects;
 +import java.util.stream.Collectors;
 +import java.util.stream.Stream;
 +
 +@Test
 +public class Halffloat256VectorTests extends AbstractVectorTest {
 +
-     static final VectorSpecies<Halffloat> SPECIES =
++    static final VectorSpecies<Float16> SPECIES =
 +                HalffloatVector.SPECIES_256;
 +
 +    static final int INVOC_COUNT = Integer.getInteger("jdk.incubator.vector.test.loop-iterations", 100);
 +
 +
++    // for floating point addition reduction ops that may introduce rounding errors
++    private static final short RELATIVE_ROUNDING_ERROR_FACTOR_ADD = (short)10.0;
++
++    // for floating point multiplication reduction ops that may introduce rounding errors
++    private static final short RELATIVE_ROUNDING_ERROR_FACTOR_MUL = (short)50.0;
 +
 +    static final int BUFFER_REPS = Integer.getInteger("jdk.incubator.vector.test.buffer-vectors", 25000 / 256);
 +
++    static void assertArraysStrictlyEquals(short[] r, short[] a) {
++        for (int i = 0; i < a.length; i++) {
++            short ir = Float16.shortToRawShortBits(r[i]);
++            short ia = Float16.shortToRawShortBits(a[i]);
++            if (ir != ia) {
++                Assert.fail(String.format("at index #%d, expected = %016X, actual = %016X", i, ia, ir));
++            }
++        }
++    }
++
 +    interface FUnOp {
 +        short apply(short a);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, FUnOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i]), "at index #" + i + ", input = " + a[i]);
 +        }
 +    }
 +
 +    interface FUnArrayOp {
 +        short[] apply(short a);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, FUnArrayOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a[i]));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a[i]);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref, "(ref: " + Arrays.toString(ref)
 +              + ", res: " + Arrays.toString(res)
 +              + "), at index #" + i);
 +        }
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, boolean[] mask, FUnOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], "at index #" + i + ", input = " + a[i] + ", mask = " + mask[i % SPECIES.length()]);
 +        }
 +    }
 +
 +    interface FReductionOp {
 +        short apply(short[] a, int idx);
 +    }
 +
 +    interface FReductionAllOp {
 +        short apply(short[] a);
 +    }
 +
 +    static void assertReductionArraysEquals(short[] r, short rc, short[] a,
 +                                            FReductionOp f, FReductionAllOp fa) {
++        assertReductionArraysEquals(r, rc, a, f, fa, (short)0.0);
++    }
++
++    static void assertReductionArraysEquals(short[] r, short rc, short[] a,
++                                            FReductionOp f, FReductionAllOp fa,
++                                            short relativeErrorFactor) {
 +        int i = 0;
 +        try {
-             Assert.assertEquals(rc, fa.apply(a));
++            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor);
 +            for (; i < a.length; i += SPECIES.length()) {
-                 Assert.assertEquals(r[i], f.apply(a, i));
++                Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor);
 +            }
 +        } catch (AssertionError e) {
-             Assert.assertEquals(rc, fa.apply(a), "Final result is incorrect!");
-             Assert.assertEquals(r[i], f.apply(a, i), "at index #" + i);
++            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor, "Final result is incorrect!");
++            Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor, "at index #" + i);
 +        }
 +    }
 +
 +    interface FReductionMaskedOp {
 +        short apply(short[] a, int idx, boolean[] mask);
 +    }
 +
 +    interface FReductionAllMaskedOp {
 +        short apply(short[] a, boolean[] mask);
 +    }
 +
 +    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,
 +                                            FReductionMaskedOp f, FReductionAllMaskedOp fa) {
++        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, (short)0.0);
++    }
++
++    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,
++                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,
++                                            short relativeError) {
 +        int i = 0;
 +        try {
-             Assert.assertEquals(rc, fa.apply(a, mask));
++            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));
 +            for (; i < a.length; i += SPECIES.length()) {
-                 Assert.assertEquals(r[i], f.apply(a, i, mask));
++                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *
++relativeError));
 +            }
 +        } catch (AssertionError e) {
-             Assert.assertEquals(rc, fa.apply(a, mask), "Final result is incorrect!");
-             Assert.assertEquals(r[i], f.apply(a, i, mask), "at index #" + i);
++            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), "Final result is incorrect!");
++            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), "at index #" + i);
 +        }
 +    }
 +
 +    interface FReductionOpLong {
 +        long apply(short[] a, int idx);
 +    }
 +
 +    interface FReductionAllOpLong {
 +        long apply(short[] a);
 +    }
 +
 +    static void assertReductionLongArraysEquals(long[] r, long rc, short[] a,
 +                                            FReductionOpLong f, FReductionAllOpLong fa) {
 +        int i = 0;
 +        try {
 +            Assert.assertEquals(rc, fa.apply(a));
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(r[i], f.apply(a, i));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(rc, fa.apply(a), "Final result is incorrect!");
 +            Assert.assertEquals(r[i], f.apply(a, i), "at index #" + i);
 +        }
 +    }
 +
 +    interface FReductionMaskedOpLong {
 +        long apply(short[] a, int idx, boolean[] mask);
 +    }
 +
 +    interface FReductionAllMaskedOpLong {
 +        long apply(short[] a, boolean[] mask);
 +    }
 +
 +    static void assertReductionLongArraysEqualsMasked(long[] r, long rc, short[] a, boolean[] mask,
 +                                            FReductionMaskedOpLong f, FReductionAllMaskedOpLong fa) {
 +        int i = 0;
 +        try {
 +            Assert.assertEquals(rc, fa.apply(a, mask));
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(r[i], f.apply(a, i, mask));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(rc, fa.apply(a, mask), "Final result is incorrect!");
 +            Assert.assertEquals(r[i], f.apply(a, i, mask), "at index #" + i);
 +        }
 +    }
 +
 +    interface FBoolReductionOp {
 +        boolean apply(boolean[] a, int idx);
 +    }
 +
 +    static void assertReductionBoolArraysEquals(boolean[] r, boolean[] a, FBoolReductionOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(r[i], f.apply(a, i));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a, i), "at index #" + i);
 +        }
 +    }
 +
 +    interface FMaskReductionOp {
 +        int apply(boolean[] a, int idx);
 +    }
 +
 +    static void assertMaskReductionArraysEquals(int[] r, boolean[] a, FMaskReductionOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(r[i], f.apply(a, i));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a, i), "at index #" + i);
 +        }
 +    }
 +
-     static void assertInsertArraysEquals(short[] r, short[] a, short element, int index, int start, int end) {
-         int i = start;
-         try {
-             for (; i < end; i += 1) {
-                 if(i%SPECIES.length() == index) {
-                     Assert.assertEquals(r[i], element);
-                 } else {
-                     Assert.assertEquals(r[i], a[i]);
-                 }
-             }
-         } catch (AssertionError e) {
-             if (i%SPECIES.length() == index) {
-                 Assert.assertEquals(r[i], element, "at index #" + i);
-             } else {
-                 Assert.assertEquals(r[i], a[i], "at index #" + i);
-             }
-         }
-     }
- 
 +    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, int vector_len) {
 +        int i = 0, j = 0;
 +        try {
 +            for (; i < a.length; i += vector_len) {
 +                for (j = 0; j < vector_len; j++) {
 +                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            int idx = i + j;
 +            Assert.assertEquals(r[i+j], a[i+order[i+j]], "at index #" + idx + ", input = " + a[i+order[i+j]]);
 +        }
 +    }
 +
 +    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {
 +        int i = 0, j = 0, k = 0;
 +        try {
 +            for (; i < a.length; i += vector_len) {
 +                k = 0;
 +                for (j = 0; j < vector_len; j++) {
 +                    if (m[(i + j) % SPECIES.length()]) {
 +                        Assert.assertEquals(r[i + k], a[i + j]);
 +                        k++;
 +                    }
 +                }
 +                for (; k < vector_len; k++) {
 +                    Assert.assertEquals(r[i + k], (short)0);
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            int idx = i + k;
 +            if (m[(i + j) % SPECIES.length()]) {
 +                Assert.assertEquals(r[idx], a[i + j], "at index #" + idx);
 +            } else {
 +                Assert.assertEquals(r[idx], (short)0, "at index #" + idx);
 +            }
 +        }
 +    }
 +
 +    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {
 +        int i = 0, j = 0, k = 0;
 +        try {
 +            for (; i < a.length; i += vector_len) {
 +                k = 0;
 +                for (j = 0; j < vector_len; j++) {
 +                    if (m[(i + j) % SPECIES.length()]) {
 +                        Assert.assertEquals(r[i + j], a[i + k]);
 +                        k++;
 +                    } else {
 +                        Assert.assertEquals(r[i + j], (short)0);
 +                    }
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            int idx = i + j;
 +            if (m[idx % SPECIES.length()]) {
 +                Assert.assertEquals(r[idx], a[i + k], "at index #" + idx);
 +            } else {
 +                Assert.assertEquals(r[idx], (short)0, "at index #" + idx);
 +            }
 +        }
 +    }
 +
++    static void assertSelectFromTwoVectorEquals(short[] r, short[] order, short[] a, short[] b, int vector_len) {
++        int i = 0, j = 0;
++        boolean is_exceptional_idx = false;
++        int idx = 0, wrapped_index = 0, oidx = 0;
++        try {
++            for (; i < a.length; i += vector_len) {
++                for (j = 0; j < vector_len; j++) {
++                    idx = i + j;
++                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);
++                    is_exceptional_idx = wrapped_index >= vector_len;
++                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;
++                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));
++                }
++            }
++        } catch (AssertionError e) {
++            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), "at index #" + idx + ", order = " + order[idx] + ", a = " + a[i + oidx] + ", b = " + b[i + oidx]);
++        }
++    }
++
 +    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, int vector_len) {
 +        int i = 0, j = 0;
 +        try {
 +            for (; i < a.length; i += vector_len) {
 +                for (j = 0; j < vector_len; j++) {
 +                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            int idx = i + j;
 +            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], "at index #" + idx + ", input = " + a[i+(int)order[i+j]]);
 +        }
 +    }
 +
 +    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, boolean[] mask, int vector_len) {
 +        int i = 0, j = 0;
 +        try {
 +            for (; i < a.length; i += vector_len) {
 +                for (j = 0; j < vector_len; j++) {
 +                    if (mask[j % SPECIES.length()])
 +                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);
 +                    else
 +                         Assert.assertEquals(r[i+j], (short)0);
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            int idx = i + j;
 +            if (mask[j % SPECIES.length()])
 +                Assert.assertEquals(r[i+j], a[i+order[i+j]], "at index #" + idx + ", input = " + a[i+order[i+j]] + ", mask = " + mask[j % SPECIES.length()]);
 +            else
 +                Assert.assertEquals(r[i+j], (short)0, "at index #" + idx + ", input = " + a[i+order[i+j]] + ", mask = " + mask[j % SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, boolean[] mask, int vector_len) {
 +        int i = 0, j = 0;
 +        try {
 +            for (; i < a.length; i += vector_len) {
 +                for (j = 0; j < vector_len; j++) {
 +                    if (mask[j % SPECIES.length()])
 +                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);
 +                    else
 +                         Assert.assertEquals(r[i+j], (short)0);
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            int idx = i + j;
 +            if (mask[j % SPECIES.length()])
 +                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], "at index #" + idx + ", input = " + a[i+(int)order[i+j]] + ", mask = " + mask[j % SPECIES.length()]);
 +            else
 +                Assert.assertEquals(r[i+j], (short)0, "at index #" + idx + ", input = " + a[i+(int)order[i+j]] + ", mask = " + mask[j % SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertBroadcastArraysEquals(short[] r, short[] a) {
 +        int i = 0;
 +        for (; i < a.length; i += SPECIES.length()) {
 +            int idx = i;
 +            for (int j = idx; j < (idx + SPECIES.length()); j++)
 +                a[j]=a[idx];
 +        }
 +
 +        try {
 +            for (i = 0; i < a.length; i++) {
 +                Assert.assertEquals(r[i], a[i]);
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], a[i], "at index #" + i + ", input = " + a[i]);
 +        }
 +    }
 +
 +    interface FBinOp {
 +        short apply(short a, short b);
 +    }
 +
 +    interface FBinMaskOp {
 +        short apply(short a, short b, boolean m);
 +
 +        static FBinMaskOp lift(FBinOp f) {
 +            return (a, b, m) -> m ? f.apply(a, b) : a;
 +        }
 +    }
 +
++    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, FBinOp f) {
++        int i = 0;
++        try {
++            for (; i < a.length; i++) {
++                //Left associative
++                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));
++
++                //Right associative
++                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));
++
++                //Results equal sanity check
++                Assert.assertEquals(rl[i], rr[i]);
++            }
++        } catch (AssertionError e) {
++            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), "left associative test at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", input3 = " + c[i]);
++            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), "right associative test at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", input3 = " + c[i]);
++            Assert.assertEquals(rl[i], rr[i], "Result checks not equal at index #" + i + "leftRes = " + rl[i] + ", rightRes = " + rr[i]);
++        }
++    }
++
++   static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinOp f) {
++       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));
++   }
++
++    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinMaskOp f) {
++        int i = 0;
++        boolean mask_bit = false;
++        try {
++            for (; i < a.length; i++) {
++                mask_bit = mask[i % SPECIES.length()];
++                //Left associative
++                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));
++
++                //Right associative
++                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));
++
++                //Results equal sanity check
++                Assert.assertEquals(rl[i], rr[i]);
++            }
++        } catch (AssertionError e) {
++            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), "left associative masked test at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", input3 = " + c[i] + ", mask = " + mask_bit);
++            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), "right associative masked test at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", input3 = " + c[i] + ", mask = " + mask_bit);
++            Assert.assertEquals(rl[i], rr[i], "Result checks not equal at index #" + i + "leftRes = " + rl[i] + ", rightRes = " + rr[i]);
++        }
++    }
++
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[i]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[i]), "(" + a[i] + ", " + b[i] + ") at index #" + i);
 +        }
 +    }
 +
++    static void assertArraysEquals(short[] r, short[] a, short b, FBinOp f) {
++        int i = 0;
++        try {
++            for (; i < a.length; i++) {
++                Assert.assertEquals(r[i], f.apply(a[i], b));
++            }
++        } catch (AssertionError e) {
++            Assert.assertEquals(r[i], f.apply(a[i], b), "(" + a[i] + ", " + b + ") at index #" + i);
++        }
++    }
++
 +    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()]),
 +                                "(" + a[i] + ", " + b[(i / SPECIES.length()) * SPECIES.length()] + ") at index #" + i);
 +        }
 +    }
 +
 +    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i / SPECIES.length()) * SPECIES.length()])));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i / SPECIES.length()) * SPECIES.length()])),
 +                                "(" + a[i] + ", " + b[(i / SPECIES.length()) * SPECIES.length()] + ") at index #" + i);
 +        }
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {
 +        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), "at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", mask = " + mask[i % SPECIES.length()]);
 +        }
 +    }
 +
++    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinOp f) {
++        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));
++    }
++
++    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinMaskOp f) {
++        int i = 0;
++        try {
++            for (; i < a.length; i++) {
++                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));
++            }
++        } catch (AssertionError err) {
++            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), "at index #" + i + ", input1 = " + a[i] + ", input2 = " + b + ", mask = " + mask[i % SPECIES.length()]);
++        }
++    }
++
 +    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {
 +        assertBroadcastArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));
 +    }
 +
 +    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()],
 +                                mask[i % SPECIES.length()]), "at index #" + i + ", input1 = " + a[i] +
 +                                ", input2 = " + b[(i / SPECIES.length()) * SPECIES.length()] + ", mask = " +
 +                                mask[i % SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {
 +        assertBroadcastLongArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));
 +    }
 +
 +    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i / SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i / SPECIES.length()) * SPECIES.length()]),
 +                                mask[i % SPECIES.length()]), "at index #" + i + ", input1 = " + a[i] +
 +                                ", input2 = " + b[(i / SPECIES.length()) * SPECIES.length()] + ", mask = " +
 +                                mask[i % SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {
 +        int i = 0;
 +        int j = 0;
 +        try {
 +            for (; j < a.length; j += SPECIES.length()) {
 +                for (i = 0; i < SPECIES.length(); i++) {
 +                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), "at index #" + i + ", " + j);
 +        }
 +    }
 +
 +    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {
 +        assertShiftArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));
 +    }
 +
 +    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {
 +        int i = 0;
 +        int j = 0;
 +        try {
 +            for (; j < a.length; j += SPECIES.length()) {
 +                for (i = 0; i < SPECIES.length(); i++) {
 +                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));
 +                }
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), "at index #" + i + ", input1 = " + a[i+j] + ", input2 = " + b[j] + ", mask = " + mask[i]);
 +        }
 +    }
 +
 +    interface FBinConstOp {
 +        short apply(short a);
 +    }
 +
 +    interface FBinConstMaskOp {
 +        short apply(short a, boolean m);
 +
 +        static FBinConstMaskOp lift(FBinConstOp f) {
 +            return (a, m) -> m ? f.apply(a) : a;
 +        }
 +    }
 +
 +    static void assertShiftConstEquals(short[] r, short[] a, FBinConstOp f) {
 +        int i = 0;
 +        int j = 0;
 +        try {
 +            for (; j < a.length; j += SPECIES.length()) {
 +                for (i = 0; i < SPECIES.length(); i++) {
 +                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i+j], f.apply(a[i+j]), "at index #" + i + ", " + j);
 +        }
 +    }
 +
 +    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstOp f) {
 +        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));
 +    }
 +
 +    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstMaskOp f) {
 +        int i = 0;
 +        int j = 0;
 +        try {
 +            for (; j < a.length; j += SPECIES.length()) {
 +                for (i = 0; i < SPECIES.length(); i++) {
 +                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));
 +                }
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), "at index #" + i + ", input1 = " + a[i+j] + ", mask = " + mask[i]);
 +        }
 +    }
 +
 +    interface FTernOp {
 +        short apply(short a, short b, short c);
 +    }
 +
 +    interface FTernMaskOp {
 +        short apply(short a, short b, short c, boolean m);
 +
 +        static FTernMaskOp lift(FTernOp f) {
 +            return (a, b, c, m) -> m ? f.apply(a, b, c) : a;
 +        }
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), "at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", input3 = " + c[i]);
 +        }
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernOp f) {
 +        assertArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernMaskOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), "at index #" + i + ", input1 = " + a[i] + ", input2 = "
 +              + b[i] + ", input3 = " + c[i] + ", mask = " + mask[i % SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i / SPECIES.length()) * SPECIES.length()]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i / SPECIES.length()) * SPECIES.length()]), "at index #" +
 +                                i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", input3 = " +
 +                                c[(i / SPECIES.length()) * SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()], c[i]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()], c[i]), "at index #" +
 +                                i + ", input1 = " + a[i] + ", input2 = " +
 +                                b[(i / SPECIES.length()) * SPECIES.length()] + ",  input3 = " + c[i]);
 +        }
 +    }
 +
 +    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,
 +                                            FTernOp f) {
 +        assertBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));
 +    }
 +
 +    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,
 +                                            FTernMaskOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i / SPECIES.length()) * SPECIES.length()],
 +                                    mask[i % SPECIES.length()]));
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i / SPECIES.length()) * SPECIES.length()],
 +                                mask[i % SPECIES.length()]), "at index #" + i + ", input1 = " + a[i] + ", input2 = " +
 +                                b[i] + ", input3 = " + c[(i / SPECIES.length()) * SPECIES.length()] + ", mask = " +
 +                                mask[i % SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,
 +                                            FTernOp f) {
 +        assertAltBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));
 +    }
 +
 +    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,
 +                                            FTernMaskOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()], c[i],
 +                                    mask[i % SPECIES.length()]));
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()], c[i],
 +                                mask[i % SPECIES.length()]), "at index #" + i + ", input1 = " + a[i] +
 +                                ", input2 = " + b[(i / SPECIES.length()) * SPECIES.length()] +
 +                                ", input3 = " + c[i] + ", mask = " + mask[i % SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()],
 +                                    c[(i / SPECIES.length()) * SPECIES.length()]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()],
 +                                c[(i / SPECIES.length()) * SPECIES.length()]), "at index #" + i + ", input1 = " + a[i]
 +                                + ", input2 = " + b[(i / SPECIES.length()) * SPECIES.length()] + ", input3 = " +
 +                                c[(i / SPECIES.length()) * SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,
 +                                                  FTernOp f) {
 +        assertDoubleBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));
 +    }
 +
 +    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,
 +                                                  FTernMaskOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()],
 +                                    c[(i / SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()],
 +                                c[(i / SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]), "at index #"
 +                                + i + ", input1 = " + a[i] + ", input2 = " + b[(i / SPECIES.length()) * SPECIES.length()] +
 +                                ", input3 = " + c[(i / SPECIES.length()) * SPECIES.length()] + ", mask = " +
 +                                mask[i % SPECIES.length()]);
 +        }
 +    }
 +
 +
 +    static boolean isWithin1Ulp(short actual, short expected) {
 +        float act = Float.float16ToFloat(actual);
 +        float exp = Float.float16ToFloat(expected);
 +        if (Float.isNaN(exp) && !Float.isNaN(act)) {
 +            return false;
 +        } else if (!Float.isNaN(exp) && Float.isNaN(act)) {
 +             return false;
 +        }
 +
 +        float low = Math.nextDown(exp);
 +        float high = Math.nextUp(exp);
 +
 +        if (Float.compare(low, exp) > 0) {
 +            return false;
 +        }
 +
 +        if (Float.compare(high, exp) < 0) {
 +            return false;
 +        }
 +
 +        return true;
 +    }
 +
 +    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, FUnOp mathf, FUnOp strictmathf) {
 +        int i = 0;
 +        try {
 +            // Check that result is within 1 ulp of strict math or equivalent to math implementation.
 +            for (; i < a.length; i++) {
 +                Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i])) == 0 ||
 +                                    isWithin1Ulp(r[i], strictmathf.apply(a[i])));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i])) == 0, "at index #" + i + ", input = " + a[i] + ", actual = " + r[i] + ", expected = " + mathf.apply(a[i]));
 +            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i])), "at index #" + i + ", input = " + a[i] + ", actual = " + r[i] + ", expected (within 1 ulp) = " + strictmathf.apply(a[i]));
 +        }
 +    }
 +
 +    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b, FBinOp mathf, FBinOp strictmathf) {
 +        int i = 0;
 +        try {
 +            // Check that result is within 1 ulp of strict math or equivalent to math implementation.
 +            for (; i < a.length; i++) {
 +                Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i], b[i])) == 0 ||
 +                                    isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i], b[i])) == 0, "at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", actual = " + r[i] + ", expected = " + mathf.apply(a[i], b[i]));
 +            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])), "at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", actual = " + r[i] + ", expected (within 1 ulp) = " + strictmathf.apply(a[i], b[i]));
 +        }
 +    }
 +
 +    static void assertBroadcastArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b,
 +                                                        FBinOp mathf, FBinOp strictmathf) {
 +        int i = 0;
 +        try {
 +            // Check that result is within 1 ulp of strict math or equivalent to math implementation.
 +            for (; i < a.length; i++) {
 +                Assert.assertTrue(Halffloat.compare(r[i],
 +                                  mathf.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()])) == 0 ||
 +                                  isWithin1Ulp(r[i],
 +                                  strictmathf.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()])));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertTrue(Halffloat.compare(r[i],
 +                              mathf.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()])) == 0,
 +                              "at index #" + i + ", input1 = " + a[i] + ", input2 = " +
 +                              b[(i / SPECIES.length()) * SPECIES.length()] + ", actual = " + r[i] +
 +                              ", expected = " + mathf.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()]));
 +            Assert.assertTrue(isWithin1Ulp(r[i],
 +                              strictmathf.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()])),
 +                             "at index #" + i + ", input1 = " + a[i] + ", input2 = " +
 +                             b[(i / SPECIES.length()) * SPECIES.length()] + ", actual = " + r[i] +
 +                             ", expected (within 1 ulp) = " + strictmathf.apply(a[i],
 +                             b[(i / SPECIES.length()) * SPECIES.length()]));
 +        }
 +    }
 +
-     interface FBinArrayOp {
-         short apply(short[] a, int b);
-     }
- 
-     static void assertArraysEquals(short[] r, short[] a, FBinArrayOp f) {
-         int i = 0;
-         try {
-             for (; i < a.length; i++) {
-                 Assert.assertEquals(r[i], f.apply(a, i));
-             }
-         } catch (AssertionError e) {
-             Assert.assertEquals(r[i], f.apply(a,i), "at index #" + i);
-         }
-     }
- 
 +    interface FGatherScatterOp {
 +        short[] apply(short[] a, int ix, int[] b, int iy);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, int[] b, FGatherScatterOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a, i, b, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a, i, b, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref,
 +              "(ref: " + Arrays.toString(ref) + ", res: " + Arrays.toString(res) + ", a: "
 +              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))
 +              + ", b: "
 +              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))
 +              + " at index #" + i);
 +        }
 +    }
 +
 +    interface FGatherMaskedOp {
 +        short[] apply(short[] a, int ix, boolean[] mask, int[] b, int iy);
 +    }
 +
 +    interface FScatterMaskedOp {
 +        short[] apply(short[] r, short[] a, int ix, boolean[] mask, int[] b, int iy);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FGatherMaskedOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a, i, mask, b, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a, i, mask, b, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref,
 +              "(ref: " + Arrays.toString(ref) + ", res: " + Arrays.toString(res) + ", a: "
 +              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))
 +              + ", b: "
 +              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))
 +              + ", mask: "
 +              + Arrays.toString(mask)
 +              + " at index #" + i);
 +        }
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FScatterMaskedOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(r, a, i, mask, b, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(r, a, i, mask, b, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref,
 +              "(ref: " + Arrays.toString(ref) + ", res: " + Arrays.toString(res) + ", a: "
 +              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))
 +              + ", b: "
 +              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))
 +              + ", r: "
 +              + Arrays.toString(Arrays.copyOfRange(r, i, i+SPECIES.length()))
 +              + ", mask: "
 +              + Arrays.toString(mask)
 +              + " at index #" + i);
 +        }
 +    }
 +
 +    interface FLaneOp {
 +        short[] apply(short[] a, int origin, int idx);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, int origin, FLaneOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a, origin, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a, origin, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref, "(ref: " + Arrays.toString(ref)
 +              + ", res: " + Arrays.toString(res)
 +              + "), at index #" + i);
 +        }
 +    }
 +
 +    interface FLaneBop {
 +        short[] apply(short[] a, short[] b, int origin, int idx);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, FLaneBop f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a, b, origin, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a, b, origin, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref, "(ref: " + Arrays.toString(ref)
 +              + ", res: " + Arrays.toString(res)
 +              + "), at index #" + i
 +              + ", at origin #" + origin);
 +        }
 +    }
 +
 +    interface FLaneMaskedBop {
 +        short[] apply(short[] a, short[] b, int origin, boolean[] mask, int idx);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, boolean[] mask, FLaneMaskedBop f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a, b, origin, mask, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a, b, origin, mask, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref, "(ref: " + Arrays.toString(ref)
 +              + ", res: " + Arrays.toString(res)
 +              + "), at index #" + i
 +              + ", at origin #" + origin);
 +        }
 +    }
 +
 +    interface FLanePartBop {
 +        short[] apply(short[] a, short[] b, int origin, int part, int idx);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, FLanePartBop f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a, b, origin, part, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a, b, origin, part, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref, "(ref: " + Arrays.toString(ref)
 +              + ", res: " + Arrays.toString(res)
 +              + "), at index #" + i
 +              + ", at origin #" + origin
 +              + ", with part #" + part);
 +        }
 +    }
 +
 +    interface FLanePartMaskedBop {
 +        short[] apply(short[] a, short[] b, int origin, int part, boolean[] mask, int idx);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, boolean[] mask, FLanePartMaskedBop f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a, b, origin, part, mask, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a, b, origin, part, mask, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref, "(ref: " + Arrays.toString(ref)
 +              + ", res: " + Arrays.toString(res)
 +              + "), at index #" + i
 +              + ", at origin #" + origin
 +              + ", with part #" + part);
 +        }
 +    }
 +
 +    static short genValue(int i) {
-         return (short) Halffloat.valueOf(i);
++        return Float16.float16ToRawShortBits(Float16.valueOf(i));
 +    }
 +
 +    static int intCornerCaseValue(int i) {
 +        switch(i % 5) {
 +            case 0:
 +                return Integer.MAX_VALUE;
 +            case 1:
 +                return Integer.MIN_VALUE;
 +            case 2:
 +                return Integer.MIN_VALUE;
 +            case 3:
 +                return Integer.MAX_VALUE;
 +            default:
 +                return (int)0;
 +        }
 +    }
 +
 +    static final List<IntFunction<short[]>> INT_HALFFLOAT_GENERATORS = List.of(
-             withToString("Halffloat[-i * 5]", (int s) -> {
++            withToString("Float16[-i * 5]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> genValue(-i * 5));
 +            }),
-             withToString("Halffloat[i * 5]", (int s) -> {
++            withToString("Float16[i * 5]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> genValue(i * 5));
 +            }),
-             withToString("Halffloat[i + 1]", (int s) -> {
++            withToString("Float16[i + 1]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
 +            }),
-             withToString("Halffloat[intCornerCaseValue(i)]", (int s) -> {
++            withToString("Float16[intCornerCaseValue(i)]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (short)intCornerCaseValue(i));
 +            })
 +    );
 +
 +    static void assertArraysEquals(int[] r, short[] a, int offs) {
 +        int i = 0;
 +        try {
 +            for (; i < r.length; i++) {
 +                Assert.assertEquals(r[i], (int)Float.float16ToFloat(a[i+offs]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], (int)(a[i+offs]), "at index #" + i + ", input = " + a[i+offs]);
 +        }
 +    }
 +
 +    static long longCornerCaseValue(int i) {
 +        switch(i % 5) {
 +            case 0:
 +                return Long.MAX_VALUE;
 +            case 1:
 +                return Long.MIN_VALUE;
 +            case 2:
 +                return Long.MIN_VALUE;
 +            case 3:
 +                return Long.MAX_VALUE;
 +            default:
 +                return (long)0;
 +        }
 +    }
 +
 +    static short genValue(long i) {
-         return (short) Halffloat.valueOf(i);
++        return Float16.float16ToRawShortBits(Float16.valueOf(i));
 +    }
 +
 +    static final List<IntFunction<short[]>> LONG_HALFFLOAT_GENERATORS = List.of(
-             withToString("Halffloat[-i * 5]", (int s) -> {
++            withToString("Float16[-i * 5]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> genValue(-i * 5));
 +            }),
-             withToString("Halffloat[i * 5]", (int s) -> {
++            withToString("Float16[i * 5]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> genValue(i * 5));
 +            }),
-             withToString("Halffloat[i + 1]", (int s) -> {
++            withToString("Float16[i + 1]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
 +            }),
-             withToString("Halffloat[cornerCaseValue(i)]", (int s) -> {
++            withToString("Float16[cornerCaseValue(i)]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (short)longCornerCaseValue(i));
 +            })
 +    );
 +
 +
 +    static void assertArraysEquals(long[] r, short[] a, int offs) {
 +        int i = 0;
 +        try {
 +            for (; i < r.length; i++) {
 +                Assert.assertEquals(r[i], (long)Float.float16ToFloat(a[i+offs]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], (long)(a[i+offs]), "at index #" + i + ", input = " + a[i+offs]);
 +        }
 +    }
 +
 +    static void assertArraysEquals(double[] r, short[] a, int offs) {
 +        int i = 0;
 +        try {
 +            for (; i < r.length; i++) {
 +                Assert.assertEquals(r[i], (double)Float.float16ToFloat(a[i+offs]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], (double)(a[i+offs]), "at index #" + i + ", input = " + a[i+offs]);
 +        }
 +    }
 +
 +    static short bits(short e) {
-         return  Halffloat.shortToShortBits(e);
++        return  Float16.shortToShortBits(e);
 +    }
 +
 +    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(
-             withToString("Halffloat[-i * 5]", (int s) -> {
++            withToString("Float16[-i * 5]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> genValue(-i * 5));
 +            }),
-             withToString("Halffloat[i * 5]", (int s) -> {
++            withToString("Float16[i * 5]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> genValue(i * 5));
 +            }),
-             withToString("Halffloat[i + 1]", (int s) -> {
++            withToString("Float16[i + 1]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
 +            }),
-             withToString("Halffloat[cornerCaseValue(i)]", (int s) -> {
++            withToString("short[0.01 + (i / (i + 1))]", (int s) -> {
++                return fill(s * BUFFER_REPS,
++                            i -> (short)0.01 + ((short)i / (i + 1)));
++            }),
++            withToString("short[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i / (i + 1))]", (int s) -> {
++                return fill(s * BUFFER_REPS,
++                            i -> i % 17 == 0 ? cornerCaseValue(i) : (short)0.01 + ((short)i / (i + 1)));
++            }),
++            withToString("short[cornerCaseValue(i)]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> cornerCaseValue(i));
 +            })
 +    );
 +
 +    // Create combinations of pairs
 +    // @@@ Might be sensitive to order e.g. div by 0
 +    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_PAIRS =
 +        Stream.of(HALFFLOAT_GENERATORS.get(0)).
 +                flatMap(fa -> HALFFLOAT_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).
 +                collect(Collectors.toList());
 +
 +    @DataProvider
 +    public Object[][] boolUnaryOpProvider() {
 +        return BOOL_ARRAY_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_TRIPLES =
 +        HALFFLOAT_GENERATOR_PAIRS.stream().
 +                flatMap(pair -> HALFFLOAT_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).
 +                collect(Collectors.toList());
 +
++    static final List<IntFunction<short[]>> SELECT_FROM_INDEX_GENERATORS = List.of(
++            withToString("short[0..VECLEN*2)", (int s) -> {
++                return fill(s * BUFFER_REPS,
++                            i -> (short)(RAND.nextInt()));
++            })
++    );
++
++    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_SELECT_FROM_TRIPLES =
++        HALFFLOAT_GENERATOR_PAIRS.stream().
++                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).
++                collect(Collectors.toList());
++
 +    @DataProvider
 +    public Object[][] shortBinaryOpProvider() {
 +        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortIndexedOpProvider() {
 +        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortBinaryOpMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_GENERATOR_PAIRS.stream().map(lfa -> {
 +                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortTernaryOpProvider() {
 +        return HALFFLOAT_GENERATOR_TRIPLES.stream().map(List::toArray).
 +                toArray(Object[][]::new);
 +    }
 +
++    @DataProvider
++    public Object[][] shortSelectFromTwoVectorOpProvider() {
++        return HALFFLOAT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).
++                toArray(Object[][]::new);
++    }
++
 +    @DataProvider
 +    public Object[][] shortTernaryOpMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_GENERATOR_TRIPLES.stream().map(lfa -> {
 +                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortUnaryOpProvider() {
 +        return HALFFLOAT_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortUnaryOpMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                    return new Object[] {fa, fm};
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shorttoIntUnaryOpProvider() {
 +        return INT_HALFFLOAT_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shorttoLongUnaryOpProvider() {
 +        return LONG_HALFFLOAT_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] maskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] maskCompareOpProvider() {
 +        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shuffleProvider() {
 +        return INT_SHUFFLE_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shuffleCompareOpProvider() {
 +        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortUnaryOpShuffleProvider() {
 +        return INT_SHUFFLE_GENERATORS.stream().
 +                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                    return new Object[] {fa, fs};
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortUnaryOpShuffleMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> INT_SHUFFLE_GENERATORS.stream().
 +                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                        return new Object[] {fa, fs, fm};
 +                }))).
 +                toArray(Object[][]::new);
 +    }
 +
 +    static final List<BiFunction<Integer,Integer,short[]>> HALFFLOAT_SHUFFLE_GENERATORS = List.of(
 +            withToStringBi("shuffle[random]", (Integer l, Integer m) -> {
 +                short[] a = new short[l];
 +                int upper = m;
 +                for (int i = 0; i < 1; i++) {
 +                    a[i] = (short)RAND.nextInt(upper);
 +                }
 +                return a;
 +            })
 +    );
 +
 +    @DataProvider
 +    public Object[][] shortUnaryOpSelectFromProvider() {
 +        return HALFFLOAT_SHUFFLE_GENERATORS.stream().
 +                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                    return new Object[] {fa, fs};
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortUnaryOpSelectFromMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_SHUFFLE_GENERATORS.stream().
 +                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                        return new Object[] {fa, fs, fm};
 +                }))).
 +                toArray(Object[][]::new);
 +    }
 +
 +    static final List<IntFunction<short[]>> HALFFLOAT_COMPARE_GENERATORS = List.of(
 +            withToString("short[i]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (short)i);
 +            }),
 +            withToString("short[i - length / 2]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (short)(i - (s * BUFFER_REPS / 2)));
 +            }),
 +            withToString("short[i + 1]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (short)(i + 1));
 +            }),
 +            withToString("short[i - 2]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (short)(i - 2));
 +            }),
 +            withToString("short[zigZag(i)]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> i%3 == 0 ? (short)i : (i%3 == 1 ? (short)(i + 1) : (short)(i - 2)));
 +            }),
 +            withToString("short[cornerCaseValue(i)]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> cornerCaseValue(i));
 +            })
 +    );
 +
 +    static final List<List<IntFunction<short[]>>> HALFFLOAT_TEST_GENERATOR_ARGS =
 +        HALFFLOAT_COMPARE_GENERATORS.stream().
 +                map(fa -> List.of(fa)).
 +                collect(Collectors.toList());
 +
 +    @DataProvider
 +    public Object[][] shortTestOpProvider() {
 +        return HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(List::toArray).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortTestOpMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(lfa -> {
 +                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    static final List<List<IntFunction<short[]>>> HALFFLOAT_COMPARE_GENERATOR_PAIRS =
 +        HALFFLOAT_COMPARE_GENERATORS.stream().
 +                flatMap(fa -> HALFFLOAT_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).
 +                collect(Collectors.toList());
 +
 +    @DataProvider
 +    public Object[][] shortCompareOpProvider() {
 +        return HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortCompareOpMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {
 +                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    interface ToHalffloatF {
 +        short apply(int i);
 +    }
 +
 +    static short[] fill(int s , ToHalffloatF f) {
 +        return fill(new short[s], f);
 +    }
 +
 +    static short[] fill(short[] a, ToHalffloatF f) {
 +        for (int i = 0; i < a.length; i++) {
 +            a[i] = f.apply(i);
 +        }
 +        return a;
 +    }
 +
 +    static short cornerCaseValue(int i) {
-         switch(i % 7) {
-             case 0:
-                 return Halffloat.MAX_VALUE;
-             case 1:
-                 return Halffloat.MIN_VALUE;
-             case 2:
-                 return Halffloat.NEGATIVE_INFINITY;
-             case 3:
-                 return Halffloat.POSITIVE_INFINITY;
-             case 4:
-                 return Halffloat.NaN;
-             case 5:
-                 return (short)0.0;
-             default:
-                 return Short.MIN_VALUE;
-         }
-     }
- 
-     static short get(short[] a, int i) {
-         return (short) a[i];
++        return switch(i % 8) {
++            case 0  -> Float16.MAX_VALUE;
++            case 1  -> Float16.MIN_VALUE;
++            case 2  -> Float16.NEGATIVE_INFINITY;
++            case 3  -> Float16.POSITIVE_INFINITY;
++            case 4  -> Float16.NaN;
++            case 5  -> Double.longBitsToDouble(0x7FF123456789ABCDL);
++            case 6  -> (short)0.0;
++            default -> (short)-0.0;
++        };
 +    }
 +
 +    static final IntFunction<short[]> fr = (vl) -> {
 +        int length = BUFFER_REPS * vl;
 +        return new short[length];
 +    };
 +
 +    static final IntFunction<boolean[]> fmr = (vl) -> {
 +        int length = BUFFER_REPS * vl;
 +        return new boolean[length];
 +    };
 +
 +    static final IntFunction<long[]> lfr = (vl) -> {
 +        int length = BUFFER_REPS * vl;
 +        return new long[length];
 +    };
 +
 +    static boolean eq(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() == bt.floatValue();
 +    }
 +
 +    static boolean neq(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() != bt.floatValue();
 +    }
 +
 +    static boolean lt(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() < bt.floatValue();
 +    }
 +
 +    static boolean le(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() <= bt.floatValue();
 +    }
 +
 +    static boolean gt(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() > bt.floatValue();
 +    }
 +
 +    static boolean ge(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() >= bt.floatValue();
 +    }
 +
 +    static short firstNonZero(short a, short b) {
 +        return Short.compare(a, (short) 0) != 0 ? a : b;
 +    }
 +
 +    @Test
 +    static void smokeTest1() {
-         HalffloatVector three = HalffloatVector.broadcast(SPECIES, Halffloat.valueOf(-3));
-         HalffloatVector three2 = (HalffloatVector) SPECIES.broadcast(Halffloat.valueOf(-3));
++        HalffloatVector three = HalffloatVector.broadcast(SPECIES, Float16.float16ToRawShortBits(Float16.valueOf(-3)));
++        HalffloatVector three2 = (HalffloatVector) SPECIES.broadcast(Float16.float16ToRawShortBits(Float16.valueOf(-3)));
 +        assert(three.eq(three2).allTrue());
-         HalffloatVector three3 = three2.broadcast(Halffloat.valueOf(1)).broadcast(Halffloat.valueOf(-3));
++        HalffloatVector three3 = three2.broadcast(Float16.float16ToRawShortBits(Float16.valueOf(1))).broadcast(Float16.float16ToRawShortBits(Float16.valueOf(-3)));
 +        assert(three.eq(three3).allTrue());
 +        int scale = 2;
 +        HalffloatVector higher = three.addIndex(scale);
-         VectorMask<Halffloat> m = three.compare(VectorOperators.LE, higher);
++        VectorMask<Float16> m = three.compare(VectorOperators.LE, higher);
 +        assert(m.allTrue());
-         m = higher.min((Halffloat.valueOf(-1))).test(VectorOperators.IS_NEGATIVE);
++        m = higher.min((Float16.float16ToRawShortBits(Float16.valueOf(-1)))).test(VectorOperators.IS_NEGATIVE);
 +        assert(m.allTrue());
 +        m = higher.test(VectorOperators.IS_FINITE);
 +        assert(m.allTrue());
 +        short max = higher.reduceLanes(VectorOperators.MAX);
 +        assert((short) Float.float16ToFloat(max) == -3 + scale * (SPECIES.length()-1));
 +    }
 +
 +    private static short[]
 +    bothToArray(HalffloatVector a, HalffloatVector b) {
 +        short[] r = new short[a.length() + b.length()];
 +        a.intoArray(r, 0);
 +        b.intoArray(r, a.length());
 +        return r;
 +    }
 +
 +    @Test
 +    static void smokeTest2() {
 +        // Do some zipping and shuffling.
 +        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);
 +        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES,0,1,false).toVector();
 +        Assert.assertEquals(io, io2);
 +        HalffloatVector a = io.add((short)1); //[1,2]
 +        HalffloatVector b = a.neg();  //[-1,-2]
 +        short[] abValues = bothToArray(a,b); //[1,2,-1,-2]
-         VectorShuffle<Halffloat> zip0 = VectorShuffle.makeZip(SPECIES, 0);
-         VectorShuffle<Halffloat> zip1 = VectorShuffle.makeZip(SPECIES, 1);
++        VectorShuffle<Float16> zip0 = VectorShuffle.makeZip(SPECIES, 0);
++        VectorShuffle<Float16> zip1 = VectorShuffle.makeZip(SPECIES, 1);
 +        HalffloatVector zab0 = a.rearrange(zip0,b); //[1,-1]
 +        HalffloatVector zab1 = a.rearrange(zip1,b); //[2,-2]
 +        short[] zabValues = bothToArray(zab0, zab1); //[1,-1,2,-2]
 +        // manually zip
 +        short[] manual = new short[zabValues.length];
 +        for (int i = 0; i < manual.length; i += 2) {
 +            manual[i+0] = abValues[i/2];
 +            manual[i+1] = abValues[a.length() + i/2];
 +        }
 +        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));
-         VectorShuffle<Halffloat> unz0 = VectorShuffle.makeUnzip(SPECIES, 0);
-         VectorShuffle<Halffloat> unz1 = VectorShuffle.makeUnzip(SPECIES, 1);
++        VectorShuffle<Float16> unz0 = VectorShuffle.makeUnzip(SPECIES, 0);
++        VectorShuffle<Float16> unz1 = VectorShuffle.makeUnzip(SPECIES, 1);
 +        HalffloatVector uab0 = zab0.rearrange(unz0,zab1);
 +        HalffloatVector uab1 = zab0.rearrange(unz1,zab1);
 +        short[] abValues1 = bothToArray(uab0, uab1);
 +        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));
 +    }
 +
 +    static void iotaShuffle() {
 +        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);
 +        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES, 0 , 1, false).toVector();
 +        Assert.assertEquals(io, io2);
 +    }
 +
 +    @Test
 +    // Test all shuffle related operations.
 +    static void shuffleTest() {
 +        // To test backend instructions, make sure that C2 is used.
 +        for (int loop = 0; loop < INVOC_COUNT * INVOC_COUNT; loop++) {
 +            iotaShuffle();
 +        }
 +    }
 +
 +    @Test
 +    void viewAsIntegeralLanesTest() {
 +        Vector<?> asIntegral = SPECIES.zero().viewAsIntegralLanes();
 +        VectorSpecies<?> asIntegralSpecies = asIntegral.species();
 +        Assert.assertNotEquals(asIntegralSpecies.elementType(), SPECIES.elementType());
 +        Assert.assertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());
 +        Assert.assertEquals(asIntegralSpecies.length(), SPECIES.length());
 +        Assert.assertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);
 +    }
 +
 +    @Test
 +    void viewAsFloatingLanesTest() {
 +        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();
 +        Assert.assertEquals(asFloating.species(), SPECIES);
 +    }
 +
 +    static short ADD(short a, short b) {
 +        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b)));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void ADDHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, Halffloat256VectorTests::ADD);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void ADDHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::ADD);
 +    }
 +
 +    static short SUB(short a, short b) {
 +        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b)));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void SUBHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, Halffloat256VectorTests::SUB);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void SUBHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::SUB);
 +    }
 +
 +    static short MUL(short a, short b) {
 +        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) * Float.float16ToFloat(b)));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void MULHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, Halffloat256VectorTests::MUL);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void MULHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::MUL);
 +    }
 +
 +    static short DIV(short a, short b) {
 +        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) / Float.float16ToFloat(b)));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void DIVHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, Halffloat256VectorTests::DIV);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void DIVHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::DIV);
 +    }
 +
 +    static short MAX(short a, short b) {
 +        return (short)(Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b))));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void MAXHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, Halffloat256VectorTests::MAX);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void MAXHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::MAX);
 +    }
 +
 +    static short MIN(short a, short b) {
-         return (short)(Halffloat.valueOf(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));
++        return (short)(Float.floatToFloat16(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void MINHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, Halffloat256VectorTests::MIN);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void MINHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::MIN);
 +    }
 +
 +    static short ABS(short a) {
 +        return (short)(Math.abs(a));
 +    }
 +
 +    static short abs(short a) {
 +        return (short)(Math.abs(a));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void ABSHalffloat256VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ABS).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, Halffloat256VectorTests::ABS);
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void absHalffloat256VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.abs().intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, Halffloat256VectorTests::abs);
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpMaskProvider")
 +    static void ABSMaskedHalffloat256VectorTests(IntFunction<short[]> fa,
 +                                                IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, mask, Halffloat256VectorTests::ABS);
 +    }
 +
 +    static short NEG(short a) {
 +        return (short)(-a);
 +    }
 +
 +    static short neg(short a) {
 +        return (short)(-a);
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void NEGHalffloat256VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.NEG).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, Halffloat256VectorTests::NEG);
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void negHalffloat256VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.neg().intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, Halffloat256VectorTests::neg);
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpMaskProvider")
 +    static void NEGMaskedHalffloat256VectorTests(IntFunction<short[]> fa,
 +                                                IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, mask, Halffloat256VectorTests::NEG);
 +    }
 +
 +    static short FMA(short a, short b, short c) {
 +        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));
 +    }
 +
 +    static short fma(short a, short b, short c) {
 +        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));
 +    }
 +
 +    @Test(dataProvider = "shortTernaryOpProvider")
 +    static void FMAHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] c = fc.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);
 +                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, c, Halffloat256VectorTests::FMA);
 +    }
 +
 +    @Test(dataProvider = "shortTernaryOpProvider")
 +    static void fmaHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] c = fc.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +            HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);
 +            av.fma(bv, cv).intoArray(r, i);
 +        }
 +
 +        assertArraysEquals(r, a, b, c, Halffloat256VectorTests::fma);
 +    }
 +
 +    @Test(dataProvider = "shortTernaryOpMaskProvider")
 +    static void FMAHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] c = fc.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);
 +                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, c, mask, Halffloat256VectorTests::FMA);
 +    }
 +
 +    static short SQRT(short a) {
-         return (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));
++        return (short)(Float.floatToFloat16((float) Math.sqrt(Float.float16ToFloat(a))));
 +    }
 +
 +    static short sqrt(short a) {
-         return (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));
++        return (short)(Float.floatToFloat16((float) Math.sqrt(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void SQRTHalffloat256VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SQRT).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, Halffloat256VectorTests::SQRT);
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void sqrtHalffloat256VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.sqrt().intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, Halffloat256VectorTests::sqrt);
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpMaskProvider")
 +    static void SQRTMaskedHalffloat256VectorTests(IntFunction<short[]> fa,
 +                                                IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, mask, Halffloat256VectorTests::SQRT);
 +    }
 +
 +    static short SIN(short a) {
-         return Halffloat.valueOf((float) Math.sin(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.sin(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictSIN(short a) {
-         return Halffloat.valueOf((float) StrictMath.sin(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.sin(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void SINHalffloat256VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SIN).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::SIN, Halffloat256VectorTests::strictSIN);
 +    }
 +
 +    static short EXP(short a) {
-         return Halffloat.valueOf((float) Math.exp(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.exp(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictEXP(short a) {
-         return Halffloat.valueOf((float) StrictMath.exp(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.exp(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void EXPHalffloat256VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.EXP).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::EXP, Halffloat256VectorTests::strictEXP);
 +    }
 +
 +    static short LOG1P(short a) {
-         return Halffloat.valueOf((float) Math.log1p(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.log1p(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictLOG1P(short a) {
-         return Halffloat.valueOf((float) StrictMath.log1p(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.log1p(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void LOG1PHalffloat256VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::LOG1P, Halffloat256VectorTests::strictLOG1P);
 +    }
 +
 +    static short LOG(short a) {
-         return Halffloat.valueOf((float) Math.log(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.log(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictLOG(short a) {
-         return Halffloat.valueOf((float) StrictMath.log(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.log(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void LOGHalffloat256VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.LOG).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::LOG, Halffloat256VectorTests::strictLOG);
 +    }
 +
 +    static short LOG10(short a) {
-         return Halffloat.valueOf((float) Math.log10(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.log10(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictLOG10(short a) {
-         return Halffloat.valueOf((float) StrictMath.log10(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.log10(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void LOG10Halffloat256VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.LOG10).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::LOG10, Halffloat256VectorTests::strictLOG10);
 +    }
 +
 +    static short EXPM1(short a) {
-         return Halffloat.valueOf((float) Math.expm1(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.expm1(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictEXPM1(short a) {
-         return Halffloat.valueOf((float) StrictMath.expm1(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.expm1(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void EXPM1Halffloat256VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::EXPM1, Halffloat256VectorTests::strictEXPM1);
 +    }
 +
 +    static short COS(short a) {
-         return Halffloat.valueOf((float) Math.cos(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.cos(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictCOS(short a) {
-         return Halffloat.valueOf((float) StrictMath.cos(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.cos(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void COSHalffloat256VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.COS).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::COS, Halffloat256VectorTests::strictCOS);
 +    }
 +
 +    static short TAN(short a) {
-         return Halffloat.valueOf((float) Math.tan(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.tan(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictTAN(short a) {
-         return Halffloat.valueOf((float) StrictMath.tan(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.tan(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void TANHalffloat256VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.TAN).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::TAN, Halffloat256VectorTests::strictTAN);
 +    }
 +
 +    static short SINH(short a) {
-         return Halffloat.valueOf((float) Math.sinh(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.sinh(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictSINH(short a) {
-         return Halffloat.valueOf((float) StrictMath.sinh(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.sinh(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void SINHHalffloat256VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SINH).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::SINH, Halffloat256VectorTests::strictSINH);
 +    }
 +
 +    static short COSH(short a) {
-         return Halffloat.valueOf((float) Math.cosh(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.cosh(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictCOSH(short a) {
-         return Halffloat.valueOf((float) StrictMath.cosh(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.cosh(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void COSHHalffloat256VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.COSH).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::COSH, Halffloat256VectorTests::strictCOSH);
 +    }
 +
 +    static short TANH(short a) {
-         return Halffloat.valueOf((float) Math.tanh(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.tanh(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictTANH(short a) {
-         return Halffloat.valueOf((float) StrictMath.tanh(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.tanh(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void TANHHalffloat256VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.TANH).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::TANH, Halffloat256VectorTests::strictTANH);
 +    }
 +
 +    static short ASIN(short a) {
-         return Halffloat.valueOf((float) Math.asin(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.asin(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictASIN(short a) {
-         return Halffloat.valueOf((float) StrictMath.asin(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.asin(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void ASINHalffloat256VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ASIN).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::ASIN, Halffloat256VectorTests::strictASIN);
 +    }
 +
 +    static short ACOS(short a) {
-         return Halffloat.valueOf((float) Math.acos(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.acos(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictACOS(short a) {
-         return Halffloat.valueOf((float) StrictMath.acos(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.acos(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void ACOSHalffloat256VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ACOS).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::ACOS, Halffloat256VectorTests::strictACOS);
 +    }
 +
 +    static short ATAN(short a) {
-         return Halffloat.valueOf((float) Math.atan(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.atan(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictATAN(short a) {
-         return Halffloat.valueOf((float) StrictMath.atan(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.atan(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void ATANHalffloat256VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ATAN).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::ATAN, Halffloat256VectorTests::strictATAN);
 +    }
 +
 +    static short CBRT(short a) {
-         return Halffloat.valueOf((float) Math.cbrt(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.cbrt(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictCBRT(short a) {
-         return Halffloat.valueOf((float) StrictMath.cbrt(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.cbrt(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void CBRTHalffloat256VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.CBRT).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::CBRT, Halffloat256VectorTests::strictCBRT);
 +    }
 +
 +    static short HYPOT(short a, short b) {
-         return Halffloat.valueOf((float) Math.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)));
 +    }
 +
 +    static short strictHYPOT(short a, short b) {
-         return Halffloat.valueOf((float) StrictMath.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b))));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void HYPOTHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat256VectorTests::HYPOT, Halffloat256VectorTests::strictHYPOT);
 +    }
 +
 +    static short POW(short a, short b) {
-         return Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));
 +    }
 +
 +    static short strictPOW(short a, short b) {
-         return Halffloat.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b))));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void POWHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat256VectorTests::POW, Halffloat256VectorTests::strictPOW);
 +    }
 +
 +    static short pow(short a, short b) {
-         return Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));
 +    }
 +
 +    static short strictpow(short a, short b) {
-         return Halffloat.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b))));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void powHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.pow(bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat256VectorTests::pow, Halffloat256VectorTests::strictpow);
 +    }
 +
 +    static short ATAN2(short a, short b) {
-         return Halffloat.valueOf((float) Math.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)));
 +    }
 +
 +    static short strictATAN2(short a, short b) {
-         return Halffloat.valueOf((float) StrictMath.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b))));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void ATAN2Halffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat256VectorTests::ATAN2, Halffloat256VectorTests::strictATAN2);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void POWHalffloat256VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            av.lanewise(VectorOperators.POW, b[i]).intoArray(r, i);
 +        }
 +
 +        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat256VectorTests::POW, Halffloat256VectorTests::strictPOW);
 +    }
 +
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void powHalffloat256VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            av.pow(b[i]).intoArray(r, i);
 +        }
 +
 +        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat256VectorTests::pow, Halffloat256VectorTests::strictpow);
 +    }
 +
 +
 +    static short blend(short a, short b, boolean mask) {
 +        return mask ? b : a;
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void blendHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.blend(bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::blend);
 +    }
 +
 +    @Test(dataProvider = "shortCompareOpProvider")
 +    static void ltHalffloat256VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
-             VectorMask<Halffloat> mv = av.lt(b[i]);
++            VectorMask<Float16> mv = av.lt(b[i]);
 +
 +            // Check results as part of computation.
 +            for (int j = 0; j < SPECIES.length(); j++) {
 +                Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortCompareOpProvider")
 +    static void eqHalffloat256VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
-             VectorMask<Halffloat> mv = av.eq(b[i]);
++            VectorMask<Float16> mv = av.eq(b[i]);
 +
 +            // Check results as part of computation.
 +            for (int j = 0; j < SPECIES.length(); j++) {
 +                Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shorttoIntUnaryOpProvider")
 +    static void toIntArrayHalffloat256VectorTestsSmokeTest(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            int[] r = av.toIntArray();
 +            assertArraysEquals(r, a, i);
 +        }
 +    }
 +
 +    @Test(dataProvider = "shorttoLongUnaryOpProvider")
 +    static void toLongArrayHalffloat256VectorTestsSmokeTest(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            long[] r = av.toLongArray();
 +            assertArraysEquals(r, a, i);
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void toDoubleArrayHalffloat256VectorTestsSmokeTest(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            double[] r = av.toDoubleArray();
 +            assertArraysEquals(r, a, i);
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void toStringHalffloat256VectorTestsSmokeTest(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            String str = av.toString();
 +
 +            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());
 +            Assert.assertTrue(str.equals(Arrays.toString(subarr)), "at index " + i + ", string should be = " + Arrays.toString(subarr) + ", but is = " + str);
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void hashCodeHalffloat256VectorTestsSmokeTest(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            int hash = av.hashCode();
 +
 +            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());
 +            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));
 +            Assert.assertTrue(hash == expectedHash, "at index " + i + ", hash should be = " + expectedHash + ", but is = " + hash);
 +        }
 +    }
 +
 +
 +    static long ADDReduceLong(short[] a, int idx) {
 +        short res = 0;
 +        for (int i = idx; i < (idx + SPECIES.length()); i++) {
 +            res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));
 +        }
 +
 +        return (long)res;
 +    }
 +
 +    static long ADDReduceAllLong(short[] a) {
 +        long res = 0;
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            res += ADDReduceLong(a, i);
 +        }
 +
 +        return res;
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void ADDReduceLongHalffloat256VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        long[] r = lfr.apply(SPECIES.length());
 +        long ra = 0;
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            r[i] = av.reduceLanesToLong(VectorOperators.ADD);
 +        }
 +
 +        ra = 0;
 +        for (int i = 0; i < a.length; i ++) {
 +            ra += r[i];
 +        }
 +
 +        assertReductionLongArraysEquals(r, ra, a,
 +                Halffloat256VectorTests::ADDReduceLong, Halffloat256VectorTests::ADDReduceAllLong);
 +    }
 +
 +    static long ADDReduceLongMasked(short[] a, int idx, boolean[] mask) {
 +        short res = 0;
 +        for (int i = idx; i < (idx + SPECIES.length()); i++) {
 +            if(mask[i % SPECIES.length()])
 +                res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));
 +        }
 +
 +        return (long)res;
 +    }
 +
 +    static long ADDReduceAllLongMasked(short[] a, boolean[] mask) {
 +        long res = 0;
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            res += ADDReduceLongMasked(a, i, mask);
 +        }
 +
 +        return res;
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpMaskProvider")
 +    static void ADDReduceLongHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        long[] r = lfr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +        long ra = 0;
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            r[i] = av.reduceLanesToLong(VectorOperators.ADD, vmask);
 +        }
 +
 +        ra = 0;
 +        for (int i = 0; i < a.length; i ++) {
 +            ra += r[i];
 +        }
 +
 +        assertReductionLongArraysEqualsMasked(r, ra, a, mask,
 +                Halffloat256VectorTests::ADDReduceLongMasked, Halffloat256VectorTests::ADDReduceAllLongMasked);
 +    }
 +
 +    @Test(dataProvider = "shorttoLongUnaryOpProvider")
 +    static void BroadcastLongHalffloat256VectorTestsSmokeTest(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = new short[a.length];
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);
 +        }
 +        assertBroadcastArraysEquals(r, a);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void blendHalffloat256VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.blend((long)b[i], vmask).intoArray(r, i);
 +            }
 +        }
 +        assertBroadcastLongArraysEquals(r, a, b, mask, Halffloat256VectorTests::blend);
 +    }
 +
 +
 +    @Test(dataProvider = "shortUnaryOpSelectFromProvider")
 +    static void SelectFromHalffloat256VectorTests(IntFunction<short[]> fa,
 +                                           BiFunction<Integer,Integer,short[]> fs) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] order = fs.apply(a.length, SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);
 +            bv.selectFrom(av).intoArray(r, i);
 +        }
 +
 +        assertSelectFromArraysEquals(r, a, order, SPECIES.length());
 +    }
 +
++    @Test(dataProvider = "shortSelectFromTwoVectorOpProvider")
++    static void SelectFromTwoVectorHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] b = fb.apply(SPECIES.length());
++        short[] idx = fc.apply(SPECIES.length());
++        short[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < idx.length; i += SPECIES.length()) {
++                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
++                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
++                HalffloatVector idxv = HalffloatVector.fromArray(SPECIES, idx, i);
++                idxv.selectFrom(av, bv).intoArray(r, i);
++            }
++        }
++        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());
++    }
++
 +    @Test(dataProvider = "shortUnaryOpSelectFromMaskProvider")
 +    static void SelectFromHalffloat256VectorTestsMaskedSmokeTest(IntFunction<short[]> fa,
 +                                                           BiFunction<Integer,Integer,short[]> fs,
 +                                                           IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] order = fs.apply(a.length, SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);
 +            bv.selectFrom(av, vmask).intoArray(r, i);
 +        }
 +
 +        assertSelectFromArraysEquals(r, a, order, mask, SPECIES.length());
 +    }
 +
 +    @Test(dataProvider = "shuffleProvider")
 +    static void shuffleMiscellaneousHalffloat256VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {
 +        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);
 +            int hash = shuffle.hashCode();
 +            int length = shuffle.length();
 +
 +            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());
 +            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));
 +            Assert.assertTrue(hash == expectedHash, "at index " + i + ", hash should be = " + expectedHash + ", but is = " + hash);
 +            Assert.assertEquals(length, SPECIES.length());
 +        }
 +    }
 +
 +    @Test(dataProvider = "shuffleProvider")
 +    static void shuffleToStringHalffloat256VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {
 +        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);
 +            String str = shuffle.toString();
 +
 +            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());
 +            Assert.assertTrue(str.equals("Shuffle" + Arrays.toString(subarr)), "at index " +
 +                i + ", string should be = " + Arrays.toString(subarr) + ", but is = " + str);
 +        }
 +    }
 +
 +    @Test(dataProvider = "shuffleCompareOpProvider")
 +    static void shuffleEqualsHalffloat256VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {
 +        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());
 +        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var av = VectorShuffle.fromArray(SPECIES, a, i);
 +            var bv = VectorShuffle.fromArray(SPECIES, b, i);
 +            boolean eq = av.equals(bv);
 +            int to = i + SPECIES.length();
 +            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));
 +        }
 +    }
 +
 +    @Test(dataProvider = "maskCompareOpProvider")
 +    static void maskEqualsHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        boolean[] b = fb.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var av = SPECIES.loadMask(a, i);
 +            var bv = SPECIES.loadMask(b, i);
 +            boolean equals = av.equals(bv);
 +            int to = i + SPECIES.length();
 +            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));
 +        }
 +    }
 +
 +    static boolean band(boolean a, boolean b) {
 +        return a & b;
 +    }
 +
 +    @Test(dataProvider = "maskCompareOpProvider")
 +    static void maskAndHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        boolean[] b = fb.apply(SPECIES.length());
 +        boolean[] r = new boolean[a.length];
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var av = SPECIES.loadMask(a, i);
 +            var bv = SPECIES.loadMask(b, i);
 +            var cv = av.and(bv);
 +            cv.intoArray(r, i);
 +        }
 +        assertArraysEquals(r, a, b, Halffloat256VectorTests::band);
 +    }
 +
 +    static boolean bor(boolean a, boolean b) {
 +        return a | b;
 +    }
 +
 +    @Test(dataProvider = "maskCompareOpProvider")
 +    static void maskOrHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        boolean[] b = fb.apply(SPECIES.length());
 +        boolean[] r = new boolean[a.length];
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var av = SPECIES.loadMask(a, i);
 +            var bv = SPECIES.loadMask(b, i);
 +            var cv = av.or(bv);
 +            cv.intoArray(r, i);
 +        }
 +        assertArraysEquals(r, a, b, Halffloat256VectorTests::bor);
 +    }
 +
 +    static boolean bxor(boolean a, boolean b) {
 +        return a != b;
 +    }
 +
 +    @Test(dataProvider = "maskCompareOpProvider")
 +    static void maskXorHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        boolean[] b = fb.apply(SPECIES.length());
 +        boolean[] r = new boolean[a.length];
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var av = SPECIES.loadMask(a, i);
 +            var bv = SPECIES.loadMask(b, i);
 +            var cv = av.xor(bv);
 +            cv.intoArray(r, i);
 +        }
 +        assertArraysEquals(r, a, b, Halffloat256VectorTests::bxor);
 +    }
 +
 +    static boolean bandNot(boolean a, boolean b) {
 +        return a & !b;
 +    }
 +
 +    @Test(dataProvider = "maskCompareOpProvider")
 +    static void maskAndNotHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        boolean[] b = fb.apply(SPECIES.length());
 +        boolean[] r = new boolean[a.length];
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var av = SPECIES.loadMask(a, i);
 +            var bv = SPECIES.loadMask(b, i);
 +            var cv = av.andNot(bv);
 +            cv.intoArray(r, i);
 +        }
 +        assertArraysEquals(r, a, b, Halffloat256VectorTests::bandNot);
 +    }
 +
 +    static boolean beq(boolean a, boolean b) {
 +        return (a == b);
 +    }
 +
 +    @Test(dataProvider = "maskCompareOpProvider")
 +    static void maskEqHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        boolean[] b = fb.apply(SPECIES.length());
 +        boolean[] r = new boolean[a.length];
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var av = SPECIES.loadMask(a, i);
 +            var bv = SPECIES.loadMask(b, i);
 +            var cv = av.eq(bv);
 +            cv.intoArray(r, i);
 +        }
 +        assertArraysEquals(r, a, b, Halffloat256VectorTests::beq);
 +    }
 +
 +    @Test(dataProvider = "maskProvider")
 +    static void maskHashCodeHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var vmask = SPECIES.loadMask(a, i);
 +            int hash = vmask.hashCode();
 +
 +            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());
 +            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));
 +            Assert.assertTrue(hash == expectedHash, "at index " + i + ", hash should be = " + expectedHash + ", but is = " + hash);
 +        }
 +    }
 +
 +    static int maskTrueCount(boolean[] a, int idx) {
 +        int trueCount = 0;
 +        for (int i = idx; i < idx + SPECIES.length(); i++) {
 +            trueCount += a[i] ? 1 : 0;
 +        }
 +        return trueCount;
 +    }
 +
 +    @Test(dataProvider = "maskProvider")
 +    static void maskTrueCountHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        int[] r = new int[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                var vmask = SPECIES.loadMask(a, i);
 +                r[i] = vmask.trueCount();
 +            }
 +        }
 +
 +        assertMaskReductionArraysEquals(r, a, Halffloat256VectorTests::maskTrueCount);
 +    }
 +
 +    static int maskLastTrue(boolean[] a, int idx) {
 +        int i = idx + SPECIES.length() - 1;
 +        for (; i >= idx; i--) {
 +            if (a[i]) {
 +                break;
 +            }
 +        }
 +        return i - idx;
 +    }
 +
 +    @Test(dataProvider = "maskProvider")
 +    static void maskLastTrueHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        int[] r = new int[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                var vmask = SPECIES.loadMask(a, i);
 +                r[i] = vmask.lastTrue();
 +            }
 +        }
 +
 +        assertMaskReductionArraysEquals(r, a, Halffloat256VectorTests::maskLastTrue);
 +    }
 +
 +    static int maskFirstTrue(boolean[] a, int idx) {
 +        int i = idx;
 +        for (; i < idx + SPECIES.length(); i++) {
 +            if (a[i]) {
 +                break;
 +            }
 +        }
 +        return i - idx;
 +    }
 +
 +    @Test(dataProvider = "maskProvider")
 +    static void maskFirstTrueHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        int[] r = new int[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                var vmask = SPECIES.loadMask(a, i);
 +                r[i] = vmask.firstTrue();
 +            }
 +        }
 +
 +        assertMaskReductionArraysEquals(r, a, Halffloat256VectorTests::maskFirstTrue);
 +    }
 +
 +    @Test(dataProvider = "maskProvider")
 +    static void maskCompressHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
 +        int trueCount = 0;
 +        boolean[] a = fa.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                var vmask = SPECIES.loadMask(a, i);
 +                trueCount = vmask.trueCount();
 +                var rmask = vmask.compress();
 +                for (int j = 0; j < SPECIES.length(); j++)  {
 +                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
 +                }
 +            }
 +        }
 +    }
 +
 +    @DataProvider
 +    public static Object[][] longMaskProvider() {
 +        return new Object[][]{
 +                {0xFFFFFFFFFFFFFFFFL},
 +                {0x0000000000000000L},
 +                {0x5555555555555555L},
 +                {0x0123456789abcdefL},
 +        };
 +    }
 +
 +    @Test(dataProvider = "longMaskProvider")
 +    static void maskFromToLongHalffloat256VectorTestsSmokeTest(long inputLong) {
 +        var vmask = VectorMask.fromLong(SPECIES, inputLong);
 +        long outputLong = vmask.toLong();
 +        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));
 +    }
 +
 +    @DataProvider
 +    public static Object[][] offsetProvider() {
 +        return new Object[][]{
 +                {0},
 +                {-1},
 +                {+1},
 +                {+2},
 +                {-2},
 +        };
 +    }
 +
 +    @Test(dataProvider = "offsetProvider")
 +    static void indexInRangeHalffloat256VectorTestsSmokeTest(int offset) {
 +        int limit = SPECIES.length() * BUFFER_REPS;
 +        for (int i = 0; i < limit; i += SPECIES.length()) {
 +            var actualMask = SPECIES.indexInRange(i + offset, limit);
 +            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);
 +            assert(actualMask.equals(expectedMask));
 +            for (int j = 0; j < SPECIES.length(); j++)  {
 +                int index = i + j + offset;
 +                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "offsetProvider")
 +    static void indexInRangeLongHalffloat256VectorTestsSmokeTest(int offset) {
 +        long limit = SPECIES.length() * BUFFER_REPS;
 +        for (long i = 0; i < limit; i += SPECIES.length()) {
 +            var actualMask = SPECIES.indexInRange(i + offset, limit);
 +            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);
 +            assert(actualMask.equals(expectedMask));
 +            for (int j = 0; j < SPECIES.length(); j++)  {
 +                long index = i + j + offset;
 +                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);
 +            }
 +        }
 +    }
 +
 +    @DataProvider
 +    public static Object[][] lengthProvider() {
 +        return new Object[][]{
 +                {0},
 +                {1},
 +                {32},
 +                {37},
 +                {1024},
 +                {1024+1},
 +                {1024+5},
 +        };
 +    }
 +
 +    @Test(dataProvider = "lengthProvider")
 +    static void loopBoundHalffloat256VectorTestsSmokeTest(int length) {
 +        int actualLoopBound = SPECIES.loopBound(length);
 +        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());
 +        Assert.assertEquals(actualLoopBound, expectedLoopBound);
 +    }
 +
 +    @Test(dataProvider = "lengthProvider")
 +    static void loopBoundLongHalffloat256VectorTestsSmokeTest(int _length) {
 +        long length = _length;
 +        long actualLoopBound = SPECIES.loopBound(length);
 +        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());
 +        Assert.assertEquals(actualLoopBound, expectedLoopBound);
 +    }
 +
 +    @Test
 +    static void ElementSizeHalffloat256VectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
 +        int elsize = av.elementSize();
-         Assert.assertEquals(elsize, Halffloat.SIZE);
++        Assert.assertEquals(elsize, Float16.SIZE);
 +    }
 +
 +    @Test
 +    static void VectorShapeHalffloat256VectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
 +        VectorShape vsh = av.shape();
 +        assert(vsh.equals(VectorShape.S_256_BIT));
 +    }
 +
 +    @Test
 +    static void ShapeWithLanesHalffloat256VectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
 +        VectorShape vsh = av.shape();
-         VectorSpecies species = vsh.withLanes(Halffloat.class);
++        VectorSpecies species = vsh.withLanes(Float16.class);
 +        assert(species.equals(SPECIES));
 +    }
 +
 +    @Test
 +    static void ElementTypeHalffloat256VectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
-         assert(av.species().elementType() == Halffloat.class);
++        assert(av.species().elementType() == Float16.class);
 +    }
 +
 +    @Test
 +    static void SpeciesElementSizeHalffloat256VectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
-         assert(av.species().elementSize() == Halffloat.SIZE);
++        assert(av.species().elementSize() == Float16.SIZE);
 +    }
 +
 +    @Test
 +    static void VectorTypeHalffloat256VectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
 +        assert(av.species().vectorType() == av.getClass());
 +    }
 +
 +    @Test
 +    static void WithLanesHalffloat256VectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
-         VectorSpecies species = av.species().withLanes(Halffloat.class);
++        VectorSpecies species = av.species().withLanes(Float16.class);
 +        assert(species.equals(SPECIES));
 +    }
 +
 +    @Test
 +    static void WithShapeHalffloat256VectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
 +        VectorShape vsh = av.shape();
 +        VectorSpecies species = av.species().withShape(vsh);
 +        assert(species.equals(SPECIES));
 +    }
 +
 +    @Test
 +    static void MaskAllTrueHalffloat256VectorTestsSmokeTest() {
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));
 +        }
 +    }
 +}
diff --cc test/jdk/jdk/incubator/vector/Halffloat512VectorLoadStoreTests.java
index e53ad669ee7,00000000000..75d601a9c48
mode 100644,000000..100644
--- a/test/jdk/jdk/incubator/vector/Halffloat512VectorLoadStoreTests.java
+++ b/test/jdk/jdk/incubator/vector/Halffloat512VectorLoadStoreTests.java
@@@ -1,849 -1,0 +1,1014 @@@
 +/*
-  * Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2018, 2025, Oracle and/or its affiliates. All rights reserved.
 + * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 + *
 + * This code is free software; you can redistribute it and/or modify it
 + * under the terms of the GNU General Public License version 2 only, as
 + * published by the Free Software Foundation.
 + *
 + * This code is distributed in the hope that it will be useful, but WITHOUT
 + * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 + * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 + * version 2 for more details (a copy is included in the LICENSE file that
 + * accompanied this code).
 + *
 + * You should have received a copy of the GNU General Public License version
 + * 2 along with this work; if not, write to the Free Software Foundation,
 + * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 + *
 + * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 + * or visit www.oracle.com if you need additional information or have any
 + * questions.
 + */
 +
 +/*
 + * @test
-  * @enablePreview
++ * @key randomness
++ *
++ * @library /test/lib
 + * @modules jdk.incubator.vector java.base/jdk.internal.vm.annotation
 + * @run testng/othervm -XX:-TieredCompilation Halffloat512VectorLoadStoreTests
 + *
 + */
 +
 +// -- This file was mechanically generated: Do not edit! -- //
 +
 +import java.lang.foreign.MemorySegment;
- import java.lang.foreign.SegmentScope;
++import java.lang.foreign.Arena;
 +import java.lang.foreign.ValueLayout;
- import jdk.incubator.vector.Halffloat;
- import jdk.incubator.vector.HalffloatVector;
 +import jdk.incubator.vector.HalffloatVector;
 +import jdk.incubator.vector.VectorMask;
 +import jdk.incubator.vector.VectorSpecies;
 +import jdk.incubator.vector.VectorShuffle;
 +import jdk.internal.vm.annotation.DontInline;
 +import org.testng.Assert;
 +import org.testng.annotations.DataProvider;
 +import org.testng.annotations.Test;
 +
 +import java.nio.ByteOrder;
 +import java.util.List;
 +import java.util.function.*;
 +
 +@Test
 +public class Halffloat512VectorLoadStoreTests extends AbstractVectorLoadStoreTest {
-     static final VectorSpecies<Halffloat> SPECIES =
++    static final VectorSpecies<Float16> SPECIES =
 +                HalffloatVector.SPECIES_512;
 +
 +    static final int INVOC_COUNT = Integer.getInteger("jdk.incubator.vector.test.loop-iterations", 100);
 +
-     static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withBitAlignment(8);
++    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withByteAlignment(1);
 +
 +
 +    static final int BUFFER_REPS = Integer.getInteger("jdk.incubator.vector.test.buffer-vectors", 25000 / 512);
 +
 +    static void assertArraysEquals(short[] r, short[] a, boolean[] mask) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0);
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0, "at index #" + i);
 +        }
 +    }
 +
 +    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(
 +            withToString("short[i * 5]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (short)(i * 5));
 +            }),
 +            withToString("short[i + 1]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));
 +            })
 +    );
 +
 +    // Relative to array.length
 +    static final List<IntFunction<Integer>> INDEX_GENERATORS = List.of(
 +            withToString("-1", (int l) -> {
 +                return -1;
 +            }),
 +            withToString("l", (int l) -> {
 +                return l;
 +            }),
 +            withToString("l - 1", (int l) -> {
 +                return l - 1;
 +            }),
 +            withToString("l + 1", (int l) -> {
 +                return l + 1;
 +            }),
 +            withToString("l - speciesl + 1", (int l) -> {
 +                return l - SPECIES.length() + 1;
 +            }),
 +            withToString("l + speciesl - 1", (int l) -> {
 +                return l + SPECIES.length() - 1;
 +            }),
 +            withToString("l + speciesl", (int l) -> {
 +                return l + SPECIES.length();
 +            }),
 +            withToString("l + speciesl + 1", (int l) -> {
 +                return l + SPECIES.length() + 1;
 +            })
 +    );
 +
 +    // Relative to byte[] array.length or MemorySegment.byteSize()
 +    static final List<IntFunction<Integer>> BYTE_INDEX_GENERATORS = List.of(
 +            withToString("-1", (int l) -> {
 +                return -1;
 +            }),
 +            withToString("l", (int l) -> {
 +                return l;
 +            }),
 +            withToString("l - 1", (int l) -> {
 +                return l - 1;
 +            }),
 +            withToString("l + 1", (int l) -> {
 +                return l + 1;
 +            }),
 +            withToString("l - speciesl*ebsize + 1", (int l) -> {
 +                return l - SPECIES.vectorByteSize() + 1;
 +            }),
 +            withToString("l + speciesl*ebsize - 1", (int l) -> {
 +                return l + SPECIES.vectorByteSize() - 1;
 +            }),
 +            withToString("l + speciesl*ebsize", (int l) -> {
 +                return l + SPECIES.vectorByteSize();
 +            }),
 +            withToString("l + speciesl*ebsize + 1", (int l) -> {
 +                return l + SPECIES.vectorByteSize() + 1;
 +            })
 +    );
 +
 +    @DataProvider
 +    public Object[][] shortProvider() {
 +        return HALFFLOAT_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] maskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortProviderForIOOBE() {
 +        var f = HALFFLOAT_GENERATORS.get(0);
 +        return INDEX_GENERATORS.stream().map(fi -> {
 +                    return new Object[] {f, fi};
 +                }).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                    return new Object[] {fa, fm};
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortMaskProviderForIOOBE() {
 +        var f = HALFFLOAT_GENERATORS.get(0);
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {
 +                    return new Object[] {f, fi, fm};
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortMemorySegmentProvider() {
 +        return HALFFLOAT_GENERATORS.stream().
 +                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().
 +                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {
 +                            return new Object[]{fa, fb, bo};
 +                        }))).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortMemorySegmentMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_GENERATORS.stream().
 +                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().
 +                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {
 +                            return new Object[]{fa, fb, fm, bo};
 +                        })))).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortByteProviderForIOOBE() {
 +        var f = HALFFLOAT_GENERATORS.get(0);
 +        return BYTE_INDEX_GENERATORS.stream().map(fi -> {
 +                    return new Object[] {f, fi};
 +                }).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortByteMaskProviderForIOOBE() {
 +        var f = HALFFLOAT_GENERATORS.get(0);
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> BYTE_INDEX_GENERATORS.stream().map(fi -> {
 +                    return new Object[] {f, fi, fm};
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {
 +        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() / 8);
 +        for (int i = 0; i < a.length; i++) {
 +            ms.set(ELEMENT_LAYOUT, i * SPECIES.elementSize() / 8 , a[i]);
 +        }
 +        return ms;
 +    }
 +
 +    static short[] segmentToArray(MemorySegment ms) {
 +        return ms.toArray(ELEMENT_LAYOUT);
 +    }
 +
 +
 +    interface ToHalffloatF {
 +        short apply(int i);
 +    }
 +
 +    static short[] fill(int s , ToHalffloatF f) {
 +        return fill(new short[s], f);
 +    }
 +
 +    static short[] fill(short[] a, ToHalffloatF f) {
 +        for (int i = 0; i < a.length; i++) {
 +            a[i] = f.apply(i);
 +        }
 +        return a;
 +    }
 +
++    @DontInline
++    static VectorShuffle<Float16> shuffleFromArray(int[] a, int i) {
++        return SPECIES.shuffleFromArray(a, i);
++    }
++
++    @DontInline
++    static void shuffleIntoArray(VectorShuffle<Float16> s, int[] a, int i) {
++        s.intoArray(a, i);
++    }
++
++    @DontInline
++    static VectorShuffle<Float16> shuffleFromMemorySegment(MemorySegment mem, int i, ByteOrder bo) {
++        return VectorShuffle.fromMemorySegment(SPECIES, mem, i, bo);
++    }
++
++    @DontInline
++    static void shuffleIntoMemorySegment(VectorShuffle<Float16> s, MemorySegment mem, int i, ByteOrder bo) {
++        s.intoMemorySegment(mem, i, bo);
++    }
++
 +    @DontInline
 +    static HalffloatVector fromArray(short[] a, int i) {
-         return HalffloatVector.fromArray(SPECIES, a, i);
++        // Tests the species method and the equivalent vector method it defers to
++        return (HalffloatVector) SPECIES.fromArray(a, i);
 +    }
 +
 +    @DontInline
-     static HalffloatVector fromArray(short[] a, int i, VectorMask<Halffloat> m) {
++    static HalffloatVector fromArray(short[] a, int i, VectorMask<Float16> m) {
 +        return HalffloatVector.fromArray(SPECIES, a, i, m);
 +    }
 +
 +    @DontInline
 +    static void intoArray(HalffloatVector v, short[] a, int i) {
 +        v.intoArray(a, i);
 +    }
 +
 +    @DontInline
-     static void intoArray(HalffloatVector v, short[] a, int i, VectorMask<Halffloat> m) {
++    static void intoArray(HalffloatVector v, short[] a, int i, VectorMask<Float16> m) {
 +        v.intoArray(a, i, m);
 +    }
 +
 +    @DontInline
 +    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {
-         return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);
++        // Tests the species method and the equivalent vector method it defers to
++        return (HalffloatVector) SPECIES.fromMemorySegment(a, i, bo);
 +    }
 +
 +    @DontInline
-     static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Halffloat> m) {
++    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Float16> m) {
 +        return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, m);
 +    }
 +
 +    @DontInline
 +    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo) {
 +        v.intoMemorySegment(a, i, bo);
 +    }
 +
 +    @DontInline
-     static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Halffloat> m) {
++    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Float16> m) {
 +        v.intoMemorySegment(a, i, bo, m);
 +    }
 +
 +    @Test(dataProvider = "shortProvider")
 +    static void loadStoreArray(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = new short[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.intoArray(r, i);
 +            }
 +        }
 +        Assert.assertEquals(r, a);
 +    }
 +
 +    @Test(dataProvider = "shortProviderForIOOBE")
 +    static void loadArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = new short[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = fromArray(a, i);
 +                av.intoArray(r, i);
 +            }
 +        }
 +
 +        int index = fi.apply(a.length);
 +        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);
 +        try {
 +            fromArray(a, index);
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortProviderForIOOBE")
 +    static void storeArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = new short[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                intoArray(av, r, i);
 +            }
 +        }
 +
 +        int index = fi.apply(a.length);
 +        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);
 +        try {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);
 +            intoArray(av, r, index);
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +
 +    @Test(dataProvider = "shortMaskProvider")
 +    static void loadStoreMaskArray(IntFunction<short[]> fa,
 +                                   IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = new short[a.length];
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);
++        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, vmask);
 +                av.intoArray(r, i);
 +            }
 +        }
 +        assertArraysEquals(r, a, mask);
 +
 +
 +        r = new short[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.intoArray(r, i, vmask);
 +            }
 +        }
 +        assertArraysEquals(r, a, mask);
 +    }
 +
 +    @Test(dataProvider = "shortMaskProviderForIOOBE")
 +    static void loadArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = new short[a.length];
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);
++        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = fromArray(a, i, vmask);
 +                av.intoArray(r, i);
 +            }
 +        }
 +
 +        int index = fi.apply(a.length);
 +        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);
 +        try {
 +            fromArray(a, index, vmask);
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortMaskProviderForIOOBE")
 +    static void storeArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = new short[a.length];
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);
++        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                intoArray(av, r, i, vmask);
 +            }
 +        }
 +
 +        int index = fi.apply(a.length);
 +        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);
 +        try {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);
 +            intoArray(av, a, index, vmask);
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +
 +    @Test(dataProvider = "shortMaskProvider")
 +    static void loadStoreMask(IntFunction<short[]> fa,
 +                              IntFunction<boolean[]> fm) {
 +        boolean[] mask = fm.apply(SPECIES.length());
 +        boolean[] r = new boolean[mask.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < mask.length; i += SPECIES.length()) {
-                 VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, i);
++                VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, i);
 +                vmask.intoArray(r, i);
 +            }
 +        }
 +        Assert.assertEquals(r, mask);
 +    }
 +
 +
 +    @Test(dataProvider = "shortMemorySegmentProvider")
 +    static void loadStoreMemorySegment(IntFunction<short[]> fa,
 +                                       IntFunction<MemorySegment> fb,
 +                                       ByteOrder bo) {
 +        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);
 +        MemorySegment r = fb.apply((int) a.byteSize());
 +
 +        int l = (int) a.byteSize();
 +        int s = SPECIES.vectorByteSize();
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < l; i += s) {
 +                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);
 +                av.intoMemorySegment(r, i, bo);
 +            }
 +        }
 +        long m = r.mismatch(a);
 +        Assert.assertEquals(m, -1, "Segments not equal");
 +    }
 +
 +    @Test(dataProvider = "shortByteProviderForIOOBE")
 +    static void loadMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {
-         MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));
-         MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());
++        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));
++        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);
 +
 +        int l = (int) a.byteSize();
 +        int s = SPECIES.vectorByteSize();
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < l; i += s) {
 +                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());
 +                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());
 +            }
 +        }
 +
 +        int index = fi.apply((int) a.byteSize());
 +        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());
 +        try {
 +            fromMemorySegment(a, index, ByteOrder.nativeOrder());
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortByteProviderForIOOBE")
 +    static void storeMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {
-         MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));
-         MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());
++        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));
++        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);
 +
 +        int l = (int) a.byteSize();
 +        int s = SPECIES.vectorByteSize();
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < l; i += s) {
 +                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());
 +                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());
 +            }
 +        }
 +
 +        int index = fi.apply((int) a.byteSize());
 +        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());
 +        try {
 +            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());
 +            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortMemorySegmentMaskProvider")
 +    static void loadStoreMemorySegmentMask(IntFunction<short[]> fa,
 +                                           IntFunction<MemorySegment> fb,
 +                                           IntFunction<boolean[]> fm,
 +                                           ByteOrder bo) {
 +        short[] _a = fa.apply(SPECIES.length());
 +        MemorySegment a = toSegment(_a, fb);
 +        MemorySegment r = fb.apply((int) a.byteSize());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);
++        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);
 +
 +        int l = (int) a.byteSize();
 +        int s = SPECIES.vectorByteSize();
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < l; i += s) {
 +                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, vmask);
 +                av.intoMemorySegment(r, i, bo);
 +            }
 +        }
 +        assertArraysEquals(segmentToArray(r), _a, mask);
 +
 +
 +        r = fb.apply((int) a.byteSize());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < l; i += s) {
 +                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);
 +                av.intoMemorySegment(r, i, bo, vmask);
 +            }
 +        }
 +        assertArraysEquals(segmentToArray(r), _a, mask);
 +    }
 +
 +    @Test(dataProvider = "shortByteMaskProviderForIOOBE")
 +    static void loadMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {
-         MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));
-         MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());
++        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));
++        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);
++        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);
 +
 +        int l = (int) a.byteSize();
 +        int s = SPECIES.vectorByteSize();
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < l; i += s) {
 +                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);
 +                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());
 +            }
 +        }
 +
 +        int index = fi.apply((int) a.byteSize());
 +        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() / 8);
 +        try {
 +            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortByteMaskProviderForIOOBE")
 +    static void storeMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {
-         MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));
-         MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());
++        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));
++        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);
++        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);
 +
 +        int l = (int) a.byteSize();
 +        int s = SPECIES.vectorByteSize();
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < l; i += s) {
 +                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());
 +                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);
 +            }
 +        }
 +
 +        int index = fi.apply((int) a.byteSize());
 +        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() / 8);
 +        try {
 +            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());
 +            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortMemorySegmentProvider")
 +    static void loadStoreReadonlyMemorySegment(IntFunction<short[]> fa,
 +                                               IntFunction<MemorySegment> fb,
 +                                               ByteOrder bo) {
 +        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();
 +
 +        Assert.assertThrows(
 +                UnsupportedOperationException.class,
 +                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)
 +        );
 +
 +        Assert.assertThrows(
 +                UnsupportedOperationException.class,
 +                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))
 +        );
 +
 +        Assert.assertThrows(
 +                UnsupportedOperationException.class,
 +                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))
 +        );
 +
-         VectorMask<Halffloat> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)
++        VectorMask<Float16> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)
 +                .laneIsValid();
 +        Assert.assertThrows(
 +                UnsupportedOperationException.class,
 +                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)
 +        );
 +    }
 +
 +
 +    @Test(dataProvider = "maskProvider")
 +    static void loadStoreMask(IntFunction<boolean[]> fm) {
 +        boolean[] a = fm.apply(SPECIES.length());
 +        boolean[] r = new boolean[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                 VectorMask<Halffloat> vmask = SPECIES.loadMask(a, i);
++                VectorMask<Float16> vmask = SPECIES.loadMask(a, i);
 +                vmask.intoArray(r, i);
 +            }
 +        }
 +        Assert.assertEquals(r, a);
 +    }
 +
 +
-     @Test
-     static void loadStoreShuffle() {
-         IntUnaryOperator fn = a -> a + 5;
-         for (int ic = 0; ic < INVOC_COUNT; ic++) {
-             var shuffle = VectorShuffle.fromOp(SPECIES, fn);
-             int [] r = shuffle.toArray();
++   @Test(dataProvider = "shuffleIntProvider")
++   static void loadStoreShuffleArray(IntFunction<int[]> fa) {
++       int[] a = fa.apply(SPECIES.length());
++       int[] r = new int[a.length];
 +
-             int [] a = expectedShuffle(SPECIES.length(), fn);
-             Assert.assertEquals(r, a);
++       for (int ic = 0; ic < INVOC_COUNT; ic++) {
++           for (int i = 0; i < a.length; i += SPECIES.length()) {
++               VectorShuffle<Float16> shuffle = VectorShuffle.fromArray(SPECIES, a, i);
++               shuffle.intoArray(r, i);
++           }
 +       }
-     }
 +
++       for (int i = 0; i < a.length; i++) {
++          Assert.assertEquals(testPartiallyWrapIndex(SPECIES, a[i]), r[i]);
++       }
++
++   }
++
++   @Test(dataProvider = "shuffleIntProviderForIOOBE")
++   static void storeShuffleArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {
++       int[] a = fa.apply(SPECIES.length());
++       int[] r = new int[a.length];
++
++       for (int ic = 0; ic < INVOC_COUNT; ic++) {
++           for (int i = 0; i < a.length; i += SPECIES.length()) {
++               VectorShuffle<Float16> shuffle = shuffleFromArray(a, i);
++               shuffleIntoArray(shuffle, r, i);
++           }
++       }
++
++       int index = fi.apply(a.length);
++       boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);
++       try {
++           VectorShuffle<Float16> shuffle = shuffleFromArray(a, index);
++           shuffleIntoArray(shuffle, r, index);
++           if (shouldFail) {
++               Assert.fail("Failed to throw IndexOutOfBoundsException");
++           }
++       } catch (IndexOutOfBoundsException e) {
++           if (!shouldFail) {
++               Assert.fail("Unexpected IndexOutOfBoundsException");
++           }
++       }
++   }
++
++   @Test(dataProvider = "shuffleIntProviderForIOOBE")
++   static void loadShuffleArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {
++       int[] a = fa.apply(SPECIES.length());
++       int[] r = new int[a.length];
++
++       for (int ic = 0; ic < INVOC_COUNT; ic++) {
++           for (int i = 0; i < a.length; i += SPECIES.length()) {
++               VectorShuffle<Float16> shuffle = shuffleFromArray(a, i);
++               shuffle.intoArray(r, i);
++           }
++       }
++
++       int index = fi.apply(a.length);
++       boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);
++       try {
++           shuffleFromArray(a, index);
++           if (shouldFail) {
++               Assert.fail("Failed to throw IndexOutOfBoundsException");
++           }
++       } catch (IndexOutOfBoundsException e) {
++           if (!shouldFail) {
++               Assert.fail("Unexpected IndexOutOfBoundsException");
++           }
++       }
++   }
++
++   @Test(dataProvider = "shuffleIntMemorySegmentProvider")
++   static void loadStoreShuffleMemorySegment(IntFunction<int[]> fa,
++                                      IntFunction<MemorySegment> fb,
++                                      ByteOrder bo) {
++       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), fb);
++       MemorySegment r = fb.apply((int) a.byteSize());
++
++       int l = (int) a.byteSize();
++       int s = SPECIES.length() * 4; //An integer for every lane is read out. So 4 bytes per lane
++
++       for (int ic = 0; ic < INVOC_COUNT; ic++) {
++           for (int i = 0; i < l; i += s) {
++               VectorShuffle<Float16> shuffle = VectorShuffle.fromMemorySegment(SPECIES, a, i, bo);
++               shuffle.intoMemorySegment(r, i, bo);
++           }
++       }
++
++       for (int i = 0; i < l / 4; i++) {
++           int ai = a.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED.withOrder(bo), i);
++           int ri = r.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED.withOrder(bo), i);
++           Assert.assertEquals(testPartiallyWrapIndex(SPECIES, ai), ri);
++       }
++   }
++
++   @Test(dataProvider = "shuffleIntByteProviderForIOOBE")
++   static void shuffleLoadMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {
++       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i));
++       MemorySegment r = Arena.ofAuto().allocate(a.byteSize());
++
++       int l = (int) a.byteSize();
++       int s = SPECIES.length() * 4;
++
++       for (int ic = 0; ic < INVOC_COUNT; ic++) {
++           for (int i = 0; i < l; i += s) {
++               VectorShuffle<Float16> shuffle = shuffleFromMemorySegment(a, i, ByteOrder.nativeOrder());
++               shuffle.intoMemorySegment(r, i, ByteOrder.nativeOrder());
++           }
++       }
++
++       int index = fi.apply((int) a.byteSize());
++       boolean shouldFail = isIndexOutOfBounds(s, index, (int) a.byteSize());
++       try {
++           shuffleFromMemorySegment(a, index, ByteOrder.nativeOrder());
++           if (shouldFail) {
++               Assert.fail("Failed to throw IndexOutOfBoundsException");
++           }
++       } catch (IndexOutOfBoundsException e) {
++           if (!shouldFail) {
++               Assert.fail("Unexpected IndexOutOfBoundsException");
++           }
++       }
++   }
++
++   @Test(dataProvider = "shuffleIntByteProviderForIOOBE")
++   static void shuffleStoreMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {
++       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i));
++       MemorySegment r = Arena.ofAuto().allocate(a.byteSize());
++
++       int l = (int) a.byteSize();
++       int s = SPECIES.length() * 4;
++
++       for (int ic = 0; ic < INVOC_COUNT; ic++) {
++           for (int i = 0; i < l; i += s) {
++               VectorShuffle<Float16> shuffle =
++                       VectorShuffle.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());
++               shuffleIntoMemorySegment(shuffle, r, i, ByteOrder.nativeOrder());
++           }
++       }
++
++       int index = fi.apply((int) a.byteSize());
++       boolean shouldFail = isIndexOutOfBounds(s, index, (int) a.byteSize());
++       try {
++           VectorShuffle<Float16> shuffle =
++                   VectorShuffle.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());
++           shuffleIntoMemorySegment(shuffle, r, index, ByteOrder.nativeOrder());
++           if (shouldFail) {
++               Assert.fail("Failed to throw IndexOutOfBoundsException");
++           }
++       } catch (IndexOutOfBoundsException e) {
++           if (!shouldFail) {
++               Assert.fail("Unexpected IndexOutOfBoundsException");
++           }
++       }
++   }
 +
 +
 +
 +
 +    // Gather/Scatter load/store tests
 +
 +    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {
 +        int i = 0;
 +        int j = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                j = i;
 +                for (; j < i + SPECIES.length(); j++) {
 +                    Assert.assertEquals(r[j], a[i + indexMap[j]]);
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[j], a[i + indexMap[j]], "at index #" + j);
 +        }
 +    }
 +
 +    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {
 +        int i = 0;
 +        int j = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                j = i;
 +                for (; j < i + SPECIES.length(); j++) {
 +                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, "at index #" + j);
 +        }
 +    }
 +
 +    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {
 +        short[] expected = new short[r.length];
 +
 +        // Store before checking, since the same location may be stored to more than once
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            for (int j = i; j < i + SPECIES.length(); j++) {
 +                if (mask[j % SPECIES.length()]) {
 +                    expected[i + indexMap[j]] = a[j];
 +                }
 +            }
 +        }
 +
 +        Assert.assertEquals(r, expected);
 +    }
 +
 +    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {
 +        short[] expected = new short[r.length];
 +
 +        // Store before checking, since the same location may be stored to more than once
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            for (int j = i; j < i + SPECIES.length(); j++) {
 +                expected[i + indexMap[j]] = a[j];
 +            }
 +        }
 +
 +        Assert.assertEquals(r, expected);
 +    }
 +
 +    @DataProvider
 +    public Object[][] gatherScatterProvider() {
 +        return INT_INDEX_GENERATORS.stream().
 +                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                    return new Object[] {fa, fs};
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] gatherScatterMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->
 +            HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                    return new Object[] {fa, fm, fs};
 +            }))).
 +            toArray(Object[][]::new);
 +    }
 +
 +
 +    @Test(dataProvider = "gatherScatterProvider")
 +    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {
 +        short[] a = fa.apply(SPECIES.length());
 +        int[] b = fs.apply(a.length, SPECIES.length());
 +        short[] r = new short[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i);
 +                av.intoArray(r, i);
 +            }
 +        }
 +
 +        assertGatherArraysEquals(r, a, b);
 +    }
 +
 +    @Test(dataProvider = "gatherScatterMaskProvider")
 +    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        int[] b = fs.apply(a.length, SPECIES.length());
 +        short[] r = new short[a.length];
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i, vmask);
 +                av.intoArray(r, i);
 +            }
 +        }
 +
 +        assertGatherArraysEquals(r, a, b, mask);
 +    }
 +
 +    @Test(dataProvider = "gatherScatterProvider")
 +    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {
 +        short[] a = fa.apply(SPECIES.length());
 +        int[] b = fs.apply(a.length, SPECIES.length());
 +        short[] r = new short[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.intoArray(r, i, b, i);
 +            }
 +        }
 +
 +        assertScatterArraysEquals(r, a, b);
 +    }
 +
 +    @Test(dataProvider = "gatherScatterMaskProvider")
 +    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        int[] b = fs.apply(a.length, SPECIES.length());
 +        short[] r = new short[a.length];
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.intoArray(r, i, b, i, vmask);
 +            }
 +        }
 +
 +        assertScatterArraysEquals(r, a, b, mask);
 +    }
 +
 +
 +
 +}
diff --cc test/jdk/jdk/incubator/vector/Halffloat512VectorTests.java
index e4cd235a20a,00000000000..85f2cd8ecb5
mode 100644,000000..100644
--- a/test/jdk/jdk/incubator/vector/Halffloat512VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Halffloat512VectorTests.java
@@@ -1,3134 -1,0 +1,3256 @@@
 +/*
-  * Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
 + * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 + *
 + * This code is free software; you can redistribute it and/or modify it
 + * under the terms of the GNU General Public License version 2 only, as
 + * published by the Free Software Foundation.
 + *
 + * This code is distributed in the hope that it will be useful, but WITHOUT
 + * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 + * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 + * version 2 for more details (a copy is included in the LICENSE file that
 + * accompanied this code).
 + *
 + * You should have received a copy of the GNU General Public License version
 + * 2 along with this work; if not, write to the Free Software Foundation,
 + * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 + *
 + * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 + * or visit www.oracle.com if you need additional information or have any
 + * questions.
 + */
 +
 +/*
 + * @test
++ * @key randomness
++ *
++ * @library /test/lib
 + * @modules jdk.incubator.vector
-  * @run testng/othervm -ea -esa -Xbatch -XX:-TieredCompilation Halffloat512VectorTests
++ * @run testng/othervm/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Halffloat512VectorTests
 + */
 +
 +// -- This file was mechanically generated: Do not edit! -- //
 +
 +import jdk.incubator.vector.VectorShape;
 +import jdk.incubator.vector.VectorSpecies;
 +import jdk.incubator.vector.VectorShuffle;
 +import jdk.incubator.vector.VectorMask;
 +import jdk.incubator.vector.VectorOperators;
 +import jdk.incubator.vector.Vector;
 +
- import jdk.incubator.vector.Halffloat;
++import jdk.incubator.vector.Float16;
 +import jdk.incubator.vector.HalffloatVector;
 +
 +import org.testng.Assert;
 +import org.testng.annotations.DataProvider;
 +import org.testng.annotations.Test;
 +
 +import java.lang.Integer;
 +import java.util.List;
 +import java.util.Arrays;
 +import java.util.function.BiFunction;
 +import java.util.function.IntFunction;
 +import java.util.Objects;
 +import java.util.stream.Collectors;
 +import java.util.stream.Stream;
 +
 +@Test
 +public class Halffloat512VectorTests extends AbstractVectorTest {
 +
-     static final VectorSpecies<Halffloat> SPECIES =
++    static final VectorSpecies<Float16> SPECIES =
 +                HalffloatVector.SPECIES_512;
 +
 +    static final int INVOC_COUNT = Integer.getInteger("jdk.incubator.vector.test.loop-iterations", 100);
 +
 +
++    // for floating point addition reduction ops that may introduce rounding errors
++    private static final short RELATIVE_ROUNDING_ERROR_FACTOR_ADD = (short)10.0;
++
++    // for floating point multiplication reduction ops that may introduce rounding errors
++    private static final short RELATIVE_ROUNDING_ERROR_FACTOR_MUL = (short)50.0;
 +
 +    static final int BUFFER_REPS = Integer.getInteger("jdk.incubator.vector.test.buffer-vectors", 25000 / 512);
 +
++    static void assertArraysStrictlyEquals(short[] r, short[] a) {
++        for (int i = 0; i < a.length; i++) {
++            short ir = Float16.shortToRawShortBits(r[i]);
++            short ia = Float16.shortToRawShortBits(a[i]);
++            if (ir != ia) {
++                Assert.fail(String.format("at index #%d, expected = %016X, actual = %016X", i, ia, ir));
++            }
++        }
++    }
++
 +    interface FUnOp {
 +        short apply(short a);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, FUnOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i]), "at index #" + i + ", input = " + a[i]);
 +        }
 +    }
 +
 +    interface FUnArrayOp {
 +        short[] apply(short a);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, FUnArrayOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a[i]));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a[i]);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref, "(ref: " + Arrays.toString(ref)
 +              + ", res: " + Arrays.toString(res)
 +              + "), at index #" + i);
 +        }
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, boolean[] mask, FUnOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], "at index #" + i + ", input = " + a[i] + ", mask = " + mask[i % SPECIES.length()]);
 +        }
 +    }
 +
 +    interface FReductionOp {
 +        short apply(short[] a, int idx);
 +    }
 +
 +    interface FReductionAllOp {
 +        short apply(short[] a);
 +    }
 +
 +    static void assertReductionArraysEquals(short[] r, short rc, short[] a,
 +                                            FReductionOp f, FReductionAllOp fa) {
++        assertReductionArraysEquals(r, rc, a, f, fa, (short)0.0);
++    }
++
++    static void assertReductionArraysEquals(short[] r, short rc, short[] a,
++                                            FReductionOp f, FReductionAllOp fa,
++                                            short relativeErrorFactor) {
 +        int i = 0;
 +        try {
-             Assert.assertEquals(rc, fa.apply(a));
++            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor);
 +            for (; i < a.length; i += SPECIES.length()) {
-                 Assert.assertEquals(r[i], f.apply(a, i));
++                Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor);
 +            }
 +        } catch (AssertionError e) {
-             Assert.assertEquals(rc, fa.apply(a), "Final result is incorrect!");
-             Assert.assertEquals(r[i], f.apply(a, i), "at index #" + i);
++            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor, "Final result is incorrect!");
++            Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor, "at index #" + i);
 +        }
 +    }
 +
 +    interface FReductionMaskedOp {
 +        short apply(short[] a, int idx, boolean[] mask);
 +    }
 +
 +    interface FReductionAllMaskedOp {
 +        short apply(short[] a, boolean[] mask);
 +    }
 +
 +    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,
 +                                            FReductionMaskedOp f, FReductionAllMaskedOp fa) {
++        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, (short)0.0);
++    }
++
++    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,
++                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,
++                                            short relativeError) {
 +        int i = 0;
 +        try {
-             Assert.assertEquals(rc, fa.apply(a, mask));
++            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));
 +            for (; i < a.length; i += SPECIES.length()) {
-                 Assert.assertEquals(r[i], f.apply(a, i, mask));
++                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *
++relativeError));
 +            }
 +        } catch (AssertionError e) {
-             Assert.assertEquals(rc, fa.apply(a, mask), "Final result is incorrect!");
-             Assert.assertEquals(r[i], f.apply(a, i, mask), "at index #" + i);
++            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), "Final result is incorrect!");
++            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), "at index #" + i);
 +        }
 +    }
 +
 +    interface FReductionOpLong {
 +        long apply(short[] a, int idx);
 +    }
 +
 +    interface FReductionAllOpLong {
 +        long apply(short[] a);
 +    }
 +
 +    static void assertReductionLongArraysEquals(long[] r, long rc, short[] a,
 +                                            FReductionOpLong f, FReductionAllOpLong fa) {
 +        int i = 0;
 +        try {
 +            Assert.assertEquals(rc, fa.apply(a));
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(r[i], f.apply(a, i));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(rc, fa.apply(a), "Final result is incorrect!");
 +            Assert.assertEquals(r[i], f.apply(a, i), "at index #" + i);
 +        }
 +    }
 +
 +    interface FReductionMaskedOpLong {
 +        long apply(short[] a, int idx, boolean[] mask);
 +    }
 +
 +    interface FReductionAllMaskedOpLong {
 +        long apply(short[] a, boolean[] mask);
 +    }
 +
 +    static void assertReductionLongArraysEqualsMasked(long[] r, long rc, short[] a, boolean[] mask,
 +                                            FReductionMaskedOpLong f, FReductionAllMaskedOpLong fa) {
 +        int i = 0;
 +        try {
 +            Assert.assertEquals(rc, fa.apply(a, mask));
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(r[i], f.apply(a, i, mask));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(rc, fa.apply(a, mask), "Final result is incorrect!");
 +            Assert.assertEquals(r[i], f.apply(a, i, mask), "at index #" + i);
 +        }
 +    }
 +
 +    interface FBoolReductionOp {
 +        boolean apply(boolean[] a, int idx);
 +    }
 +
 +    static void assertReductionBoolArraysEquals(boolean[] r, boolean[] a, FBoolReductionOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(r[i], f.apply(a, i));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a, i), "at index #" + i);
 +        }
 +    }
 +
 +    interface FMaskReductionOp {
 +        int apply(boolean[] a, int idx);
 +    }
 +
 +    static void assertMaskReductionArraysEquals(int[] r, boolean[] a, FMaskReductionOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(r[i], f.apply(a, i));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a, i), "at index #" + i);
 +        }
 +    }
 +
-     static void assertInsertArraysEquals(short[] r, short[] a, short element, int index, int start, int end) {
-         int i = start;
-         try {
-             for (; i < end; i += 1) {
-                 if(i%SPECIES.length() == index) {
-                     Assert.assertEquals(r[i], element);
-                 } else {
-                     Assert.assertEquals(r[i], a[i]);
-                 }
-             }
-         } catch (AssertionError e) {
-             if (i%SPECIES.length() == index) {
-                 Assert.assertEquals(r[i], element, "at index #" + i);
-             } else {
-                 Assert.assertEquals(r[i], a[i], "at index #" + i);
-             }
-         }
-     }
- 
 +    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, int vector_len) {
 +        int i = 0, j = 0;
 +        try {
 +            for (; i < a.length; i += vector_len) {
 +                for (j = 0; j < vector_len; j++) {
 +                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            int idx = i + j;
 +            Assert.assertEquals(r[i+j], a[i+order[i+j]], "at index #" + idx + ", input = " + a[i+order[i+j]]);
 +        }
 +    }
 +
 +    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {
 +        int i = 0, j = 0, k = 0;
 +        try {
 +            for (; i < a.length; i += vector_len) {
 +                k = 0;
 +                for (j = 0; j < vector_len; j++) {
 +                    if (m[(i + j) % SPECIES.length()]) {
 +                        Assert.assertEquals(r[i + k], a[i + j]);
 +                        k++;
 +                    }
 +                }
 +                for (; k < vector_len; k++) {
 +                    Assert.assertEquals(r[i + k], (short)0);
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            int idx = i + k;
 +            if (m[(i + j) % SPECIES.length()]) {
 +                Assert.assertEquals(r[idx], a[i + j], "at index #" + idx);
 +            } else {
 +                Assert.assertEquals(r[idx], (short)0, "at index #" + idx);
 +            }
 +        }
 +    }
 +
 +    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {
 +        int i = 0, j = 0, k = 0;
 +        try {
 +            for (; i < a.length; i += vector_len) {
 +                k = 0;
 +                for (j = 0; j < vector_len; j++) {
 +                    if (m[(i + j) % SPECIES.length()]) {
 +                        Assert.assertEquals(r[i + j], a[i + k]);
 +                        k++;
 +                    } else {
 +                        Assert.assertEquals(r[i + j], (short)0);
 +                    }
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            int idx = i + j;
 +            if (m[idx % SPECIES.length()]) {
 +                Assert.assertEquals(r[idx], a[i + k], "at index #" + idx);
 +            } else {
 +                Assert.assertEquals(r[idx], (short)0, "at index #" + idx);
 +            }
 +        }
 +    }
 +
++    static void assertSelectFromTwoVectorEquals(short[] r, short[] order, short[] a, short[] b, int vector_len) {
++        int i = 0, j = 0;
++        boolean is_exceptional_idx = false;
++        int idx = 0, wrapped_index = 0, oidx = 0;
++        try {
++            for (; i < a.length; i += vector_len) {
++                for (j = 0; j < vector_len; j++) {
++                    idx = i + j;
++                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);
++                    is_exceptional_idx = wrapped_index >= vector_len;
++                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;
++                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));
++                }
++            }
++        } catch (AssertionError e) {
++            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), "at index #" + idx + ", order = " + order[idx] + ", a = " + a[i + oidx] + ", b = " + b[i + oidx]);
++        }
++    }
++
 +    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, int vector_len) {
 +        int i = 0, j = 0;
 +        try {
 +            for (; i < a.length; i += vector_len) {
 +                for (j = 0; j < vector_len; j++) {
 +                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            int idx = i + j;
 +            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], "at index #" + idx + ", input = " + a[i+(int)order[i+j]]);
 +        }
 +    }
 +
 +    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, boolean[] mask, int vector_len) {
 +        int i = 0, j = 0;
 +        try {
 +            for (; i < a.length; i += vector_len) {
 +                for (j = 0; j < vector_len; j++) {
 +                    if (mask[j % SPECIES.length()])
 +                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);
 +                    else
 +                         Assert.assertEquals(r[i+j], (short)0);
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            int idx = i + j;
 +            if (mask[j % SPECIES.length()])
 +                Assert.assertEquals(r[i+j], a[i+order[i+j]], "at index #" + idx + ", input = " + a[i+order[i+j]] + ", mask = " + mask[j % SPECIES.length()]);
 +            else
 +                Assert.assertEquals(r[i+j], (short)0, "at index #" + idx + ", input = " + a[i+order[i+j]] + ", mask = " + mask[j % SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, boolean[] mask, int vector_len) {
 +        int i = 0, j = 0;
 +        try {
 +            for (; i < a.length; i += vector_len) {
 +                for (j = 0; j < vector_len; j++) {
 +                    if (mask[j % SPECIES.length()])
 +                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);
 +                    else
 +                         Assert.assertEquals(r[i+j], (short)0);
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            int idx = i + j;
 +            if (mask[j % SPECIES.length()])
 +                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], "at index #" + idx + ", input = " + a[i+(int)order[i+j]] + ", mask = " + mask[j % SPECIES.length()]);
 +            else
 +                Assert.assertEquals(r[i+j], (short)0, "at index #" + idx + ", input = " + a[i+(int)order[i+j]] + ", mask = " + mask[j % SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertBroadcastArraysEquals(short[] r, short[] a) {
 +        int i = 0;
 +        for (; i < a.length; i += SPECIES.length()) {
 +            int idx = i;
 +            for (int j = idx; j < (idx + SPECIES.length()); j++)
 +                a[j]=a[idx];
 +        }
 +
 +        try {
 +            for (i = 0; i < a.length; i++) {
 +                Assert.assertEquals(r[i], a[i]);
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], a[i], "at index #" + i + ", input = " + a[i]);
 +        }
 +    }
 +
 +    interface FBinOp {
 +        short apply(short a, short b);
 +    }
 +
 +    interface FBinMaskOp {
 +        short apply(short a, short b, boolean m);
 +
 +        static FBinMaskOp lift(FBinOp f) {
 +            return (a, b, m) -> m ? f.apply(a, b) : a;
 +        }
 +    }
 +
++    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, FBinOp f) {
++        int i = 0;
++        try {
++            for (; i < a.length; i++) {
++                //Left associative
++                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));
++
++                //Right associative
++                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));
++
++                //Results equal sanity check
++                Assert.assertEquals(rl[i], rr[i]);
++            }
++        } catch (AssertionError e) {
++            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), "left associative test at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", input3 = " + c[i]);
++            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), "right associative test at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", input3 = " + c[i]);
++            Assert.assertEquals(rl[i], rr[i], "Result checks not equal at index #" + i + "leftRes = " + rl[i] + ", rightRes = " + rr[i]);
++        }
++    }
++
++   static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinOp f) {
++       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));
++   }
++
++    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinMaskOp f) {
++        int i = 0;
++        boolean mask_bit = false;
++        try {
++            for (; i < a.length; i++) {
++                mask_bit = mask[i % SPECIES.length()];
++                //Left associative
++                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));
++
++                //Right associative
++                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));
++
++                //Results equal sanity check
++                Assert.assertEquals(rl[i], rr[i]);
++            }
++        } catch (AssertionError e) {
++            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), "left associative masked test at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", input3 = " + c[i] + ", mask = " + mask_bit);
++            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), "right associative masked test at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", input3 = " + c[i] + ", mask = " + mask_bit);
++            Assert.assertEquals(rl[i], rr[i], "Result checks not equal at index #" + i + "leftRes = " + rl[i] + ", rightRes = " + rr[i]);
++        }
++    }
++
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[i]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[i]), "(" + a[i] + ", " + b[i] + ") at index #" + i);
 +        }
 +    }
 +
++    static void assertArraysEquals(short[] r, short[] a, short b, FBinOp f) {
++        int i = 0;
++        try {
++            for (; i < a.length; i++) {
++                Assert.assertEquals(r[i], f.apply(a[i], b));
++            }
++        } catch (AssertionError e) {
++            Assert.assertEquals(r[i], f.apply(a[i], b), "(" + a[i] + ", " + b + ") at index #" + i);
++        }
++    }
++
 +    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()]),
 +                                "(" + a[i] + ", " + b[(i / SPECIES.length()) * SPECIES.length()] + ") at index #" + i);
 +        }
 +    }
 +
 +    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i / SPECIES.length()) * SPECIES.length()])));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i / SPECIES.length()) * SPECIES.length()])),
 +                                "(" + a[i] + ", " + b[(i / SPECIES.length()) * SPECIES.length()] + ") at index #" + i);
 +        }
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {
 +        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), "at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", mask = " + mask[i % SPECIES.length()]);
 +        }
 +    }
 +
++    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinOp f) {
++        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));
++    }
++
++    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinMaskOp f) {
++        int i = 0;
++        try {
++            for (; i < a.length; i++) {
++                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));
++            }
++        } catch (AssertionError err) {
++            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), "at index #" + i + ", input1 = " + a[i] + ", input2 = " + b + ", mask = " + mask[i % SPECIES.length()]);
++        }
++    }
++
 +    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {
 +        assertBroadcastArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));
 +    }
 +
 +    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()],
 +                                mask[i % SPECIES.length()]), "at index #" + i + ", input1 = " + a[i] +
 +                                ", input2 = " + b[(i / SPECIES.length()) * SPECIES.length()] + ", mask = " +
 +                                mask[i % SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {
 +        assertBroadcastLongArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));
 +    }
 +
 +    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i / SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i / SPECIES.length()) * SPECIES.length()]),
 +                                mask[i % SPECIES.length()]), "at index #" + i + ", input1 = " + a[i] +
 +                                ", input2 = " + b[(i / SPECIES.length()) * SPECIES.length()] + ", mask = " +
 +                                mask[i % SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {
 +        int i = 0;
 +        int j = 0;
 +        try {
 +            for (; j < a.length; j += SPECIES.length()) {
 +                for (i = 0; i < SPECIES.length(); i++) {
 +                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), "at index #" + i + ", " + j);
 +        }
 +    }
 +
 +    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {
 +        assertShiftArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));
 +    }
 +
 +    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {
 +        int i = 0;
 +        int j = 0;
 +        try {
 +            for (; j < a.length; j += SPECIES.length()) {
 +                for (i = 0; i < SPECIES.length(); i++) {
 +                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));
 +                }
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), "at index #" + i + ", input1 = " + a[i+j] + ", input2 = " + b[j] + ", mask = " + mask[i]);
 +        }
 +    }
 +
 +    interface FBinConstOp {
 +        short apply(short a);
 +    }
 +
 +    interface FBinConstMaskOp {
 +        short apply(short a, boolean m);
 +
 +        static FBinConstMaskOp lift(FBinConstOp f) {
 +            return (a, m) -> m ? f.apply(a) : a;
 +        }
 +    }
 +
 +    static void assertShiftConstEquals(short[] r, short[] a, FBinConstOp f) {
 +        int i = 0;
 +        int j = 0;
 +        try {
 +            for (; j < a.length; j += SPECIES.length()) {
 +                for (i = 0; i < SPECIES.length(); i++) {
 +                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i+j], f.apply(a[i+j]), "at index #" + i + ", " + j);
 +        }
 +    }
 +
 +    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstOp f) {
 +        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));
 +    }
 +
 +    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstMaskOp f) {
 +        int i = 0;
 +        int j = 0;
 +        try {
 +            for (; j < a.length; j += SPECIES.length()) {
 +                for (i = 0; i < SPECIES.length(); i++) {
 +                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));
 +                }
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), "at index #" + i + ", input1 = " + a[i+j] + ", mask = " + mask[i]);
 +        }
 +    }
 +
 +    interface FTernOp {
 +        short apply(short a, short b, short c);
 +    }
 +
 +    interface FTernMaskOp {
 +        short apply(short a, short b, short c, boolean m);
 +
 +        static FTernMaskOp lift(FTernOp f) {
 +            return (a, b, c, m) -> m ? f.apply(a, b, c) : a;
 +        }
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), "at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", input3 = " + c[i]);
 +        }
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernOp f) {
 +        assertArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernMaskOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), "at index #" + i + ", input1 = " + a[i] + ", input2 = "
 +              + b[i] + ", input3 = " + c[i] + ", mask = " + mask[i % SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i / SPECIES.length()) * SPECIES.length()]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i / SPECIES.length()) * SPECIES.length()]), "at index #" +
 +                                i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", input3 = " +
 +                                c[(i / SPECIES.length()) * SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()], c[i]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()], c[i]), "at index #" +
 +                                i + ", input1 = " + a[i] + ", input2 = " +
 +                                b[(i / SPECIES.length()) * SPECIES.length()] + ",  input3 = " + c[i]);
 +        }
 +    }
 +
 +    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,
 +                                            FTernOp f) {
 +        assertBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));
 +    }
 +
 +    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,
 +                                            FTernMaskOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i / SPECIES.length()) * SPECIES.length()],
 +                                    mask[i % SPECIES.length()]));
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i / SPECIES.length()) * SPECIES.length()],
 +                                mask[i % SPECIES.length()]), "at index #" + i + ", input1 = " + a[i] + ", input2 = " +
 +                                b[i] + ", input3 = " + c[(i / SPECIES.length()) * SPECIES.length()] + ", mask = " +
 +                                mask[i % SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,
 +                                            FTernOp f) {
 +        assertAltBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));
 +    }
 +
 +    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,
 +                                            FTernMaskOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()], c[i],
 +                                    mask[i % SPECIES.length()]));
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()], c[i],
 +                                mask[i % SPECIES.length()]), "at index #" + i + ", input1 = " + a[i] +
 +                                ", input2 = " + b[(i / SPECIES.length()) * SPECIES.length()] +
 +                                ", input3 = " + c[i] + ", mask = " + mask[i % SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()],
 +                                    c[(i / SPECIES.length()) * SPECIES.length()]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()],
 +                                c[(i / SPECIES.length()) * SPECIES.length()]), "at index #" + i + ", input1 = " + a[i]
 +                                + ", input2 = " + b[(i / SPECIES.length()) * SPECIES.length()] + ", input3 = " +
 +                                c[(i / SPECIES.length()) * SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,
 +                                                  FTernOp f) {
 +        assertDoubleBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));
 +    }
 +
 +    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,
 +                                                  FTernMaskOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()],
 +                                    c[(i / SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()],
 +                                c[(i / SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]), "at index #"
 +                                + i + ", input1 = " + a[i] + ", input2 = " + b[(i / SPECIES.length()) * SPECIES.length()] +
 +                                ", input3 = " + c[(i / SPECIES.length()) * SPECIES.length()] + ", mask = " +
 +                                mask[i % SPECIES.length()]);
 +        }
 +    }
 +
 +
 +    static boolean isWithin1Ulp(short actual, short expected) {
 +        float act = Float.float16ToFloat(actual);
 +        float exp = Float.float16ToFloat(expected);
 +        if (Float.isNaN(exp) && !Float.isNaN(act)) {
 +            return false;
 +        } else if (!Float.isNaN(exp) && Float.isNaN(act)) {
 +             return false;
 +        }
 +
 +        float low = Math.nextDown(exp);
 +        float high = Math.nextUp(exp);
 +
 +        if (Float.compare(low, exp) > 0) {
 +            return false;
 +        }
 +
 +        if (Float.compare(high, exp) < 0) {
 +            return false;
 +        }
 +
 +        return true;
 +    }
 +
 +    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, FUnOp mathf, FUnOp strictmathf) {
 +        int i = 0;
 +        try {
 +            // Check that result is within 1 ulp of strict math or equivalent to math implementation.
 +            for (; i < a.length; i++) {
 +                Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i])) == 0 ||
 +                                    isWithin1Ulp(r[i], strictmathf.apply(a[i])));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i])) == 0, "at index #" + i + ", input = " + a[i] + ", actual = " + r[i] + ", expected = " + mathf.apply(a[i]));
 +            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i])), "at index #" + i + ", input = " + a[i] + ", actual = " + r[i] + ", expected (within 1 ulp) = " + strictmathf.apply(a[i]));
 +        }
 +    }
 +
 +    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b, FBinOp mathf, FBinOp strictmathf) {
 +        int i = 0;
 +        try {
 +            // Check that result is within 1 ulp of strict math or equivalent to math implementation.
 +            for (; i < a.length; i++) {
 +                Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i], b[i])) == 0 ||
 +                                    isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i], b[i])) == 0, "at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", actual = " + r[i] + ", expected = " + mathf.apply(a[i], b[i]));
 +            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])), "at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", actual = " + r[i] + ", expected (within 1 ulp) = " + strictmathf.apply(a[i], b[i]));
 +        }
 +    }
 +
 +    static void assertBroadcastArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b,
 +                                                        FBinOp mathf, FBinOp strictmathf) {
 +        int i = 0;
 +        try {
 +            // Check that result is within 1 ulp of strict math or equivalent to math implementation.
 +            for (; i < a.length; i++) {
 +                Assert.assertTrue(Halffloat.compare(r[i],
 +                                  mathf.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()])) == 0 ||
 +                                  isWithin1Ulp(r[i],
 +                                  strictmathf.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()])));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertTrue(Halffloat.compare(r[i],
 +                              mathf.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()])) == 0,
 +                              "at index #" + i + ", input1 = " + a[i] + ", input2 = " +
 +                              b[(i / SPECIES.length()) * SPECIES.length()] + ", actual = " + r[i] +
 +                              ", expected = " + mathf.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()]));
 +            Assert.assertTrue(isWithin1Ulp(r[i],
 +                              strictmathf.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()])),
 +                             "at index #" + i + ", input1 = " + a[i] + ", input2 = " +
 +                             b[(i / SPECIES.length()) * SPECIES.length()] + ", actual = " + r[i] +
 +                             ", expected (within 1 ulp) = " + strictmathf.apply(a[i],
 +                             b[(i / SPECIES.length()) * SPECIES.length()]));
 +        }
 +    }
 +
-     interface FBinArrayOp {
-         short apply(short[] a, int b);
-     }
- 
-     static void assertArraysEquals(short[] r, short[] a, FBinArrayOp f) {
-         int i = 0;
-         try {
-             for (; i < a.length; i++) {
-                 Assert.assertEquals(r[i], f.apply(a, i));
-             }
-         } catch (AssertionError e) {
-             Assert.assertEquals(r[i], f.apply(a,i), "at index #" + i);
-         }
-     }
- 
 +    interface FGatherScatterOp {
 +        short[] apply(short[] a, int ix, int[] b, int iy);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, int[] b, FGatherScatterOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a, i, b, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a, i, b, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref,
 +              "(ref: " + Arrays.toString(ref) + ", res: " + Arrays.toString(res) + ", a: "
 +              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))
 +              + ", b: "
 +              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))
 +              + " at index #" + i);
 +        }
 +    }
 +
 +    interface FGatherMaskedOp {
 +        short[] apply(short[] a, int ix, boolean[] mask, int[] b, int iy);
 +    }
 +
 +    interface FScatterMaskedOp {
 +        short[] apply(short[] r, short[] a, int ix, boolean[] mask, int[] b, int iy);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FGatherMaskedOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a, i, mask, b, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a, i, mask, b, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref,
 +              "(ref: " + Arrays.toString(ref) + ", res: " + Arrays.toString(res) + ", a: "
 +              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))
 +              + ", b: "
 +              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))
 +              + ", mask: "
 +              + Arrays.toString(mask)
 +              + " at index #" + i);
 +        }
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FScatterMaskedOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(r, a, i, mask, b, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(r, a, i, mask, b, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref,
 +              "(ref: " + Arrays.toString(ref) + ", res: " + Arrays.toString(res) + ", a: "
 +              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))
 +              + ", b: "
 +              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))
 +              + ", r: "
 +              + Arrays.toString(Arrays.copyOfRange(r, i, i+SPECIES.length()))
 +              + ", mask: "
 +              + Arrays.toString(mask)
 +              + " at index #" + i);
 +        }
 +    }
 +
 +    interface FLaneOp {
 +        short[] apply(short[] a, int origin, int idx);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, int origin, FLaneOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a, origin, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a, origin, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref, "(ref: " + Arrays.toString(ref)
 +              + ", res: " + Arrays.toString(res)
 +              + "), at index #" + i);
 +        }
 +    }
 +
 +    interface FLaneBop {
 +        short[] apply(short[] a, short[] b, int origin, int idx);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, FLaneBop f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a, b, origin, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a, b, origin, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref, "(ref: " + Arrays.toString(ref)
 +              + ", res: " + Arrays.toString(res)
 +              + "), at index #" + i
 +              + ", at origin #" + origin);
 +        }
 +    }
 +
 +    interface FLaneMaskedBop {
 +        short[] apply(short[] a, short[] b, int origin, boolean[] mask, int idx);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, boolean[] mask, FLaneMaskedBop f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a, b, origin, mask, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a, b, origin, mask, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref, "(ref: " + Arrays.toString(ref)
 +              + ", res: " + Arrays.toString(res)
 +              + "), at index #" + i
 +              + ", at origin #" + origin);
 +        }
 +    }
 +
 +    interface FLanePartBop {
 +        short[] apply(short[] a, short[] b, int origin, int part, int idx);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, FLanePartBop f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a, b, origin, part, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a, b, origin, part, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref, "(ref: " + Arrays.toString(ref)
 +              + ", res: " + Arrays.toString(res)
 +              + "), at index #" + i
 +              + ", at origin #" + origin
 +              + ", with part #" + part);
 +        }
 +    }
 +
 +    interface FLanePartMaskedBop {
 +        short[] apply(short[] a, short[] b, int origin, int part, boolean[] mask, int idx);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, boolean[] mask, FLanePartMaskedBop f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a, b, origin, part, mask, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a, b, origin, part, mask, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref, "(ref: " + Arrays.toString(ref)
 +              + ", res: " + Arrays.toString(res)
 +              + "), at index #" + i
 +              + ", at origin #" + origin
 +              + ", with part #" + part);
 +        }
 +    }
 +
 +    static short genValue(int i) {
-         return (short) Halffloat.valueOf(i);
++        return Float16.float16ToRawShortBits(Float16.valueOf(i));
 +    }
 +
 +    static int intCornerCaseValue(int i) {
 +        switch(i % 5) {
 +            case 0:
 +                return Integer.MAX_VALUE;
 +            case 1:
 +                return Integer.MIN_VALUE;
 +            case 2:
 +                return Integer.MIN_VALUE;
 +            case 3:
 +                return Integer.MAX_VALUE;
 +            default:
 +                return (int)0;
 +        }
 +    }
 +
 +    static final List<IntFunction<short[]>> INT_HALFFLOAT_GENERATORS = List.of(
-             withToString("Halffloat[-i * 5]", (int s) -> {
++            withToString("Float16[-i * 5]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> genValue(-i * 5));
 +            }),
-             withToString("Halffloat[i * 5]", (int s) -> {
++            withToString("Float16[i * 5]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> genValue(i * 5));
 +            }),
-             withToString("Halffloat[i + 1]", (int s) -> {
++            withToString("Float16[i + 1]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
 +            }),
-             withToString("Halffloat[intCornerCaseValue(i)]", (int s) -> {
++            withToString("Float16[intCornerCaseValue(i)]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (short)intCornerCaseValue(i));
 +            })
 +    );
 +
 +    static void assertArraysEquals(int[] r, short[] a, int offs) {
 +        int i = 0;
 +        try {
 +            for (; i < r.length; i++) {
 +                Assert.assertEquals(r[i], (int)Float.float16ToFloat(a[i+offs]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], (int)(a[i+offs]), "at index #" + i + ", input = " + a[i+offs]);
 +        }
 +    }
 +
 +    static long longCornerCaseValue(int i) {
 +        switch(i % 5) {
 +            case 0:
 +                return Long.MAX_VALUE;
 +            case 1:
 +                return Long.MIN_VALUE;
 +            case 2:
 +                return Long.MIN_VALUE;
 +            case 3:
 +                return Long.MAX_VALUE;
 +            default:
 +                return (long)0;
 +        }
 +    }
 +
 +    static short genValue(long i) {
-         return (short) Halffloat.valueOf(i);
++        return Float16.float16ToRawShortBits(Float16.valueOf(i));
 +    }
 +
 +    static final List<IntFunction<short[]>> LONG_HALFFLOAT_GENERATORS = List.of(
-             withToString("Halffloat[-i * 5]", (int s) -> {
++            withToString("Float16[-i * 5]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> genValue(-i * 5));
 +            }),
-             withToString("Halffloat[i * 5]", (int s) -> {
++            withToString("Float16[i * 5]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> genValue(i * 5));
 +            }),
-             withToString("Halffloat[i + 1]", (int s) -> {
++            withToString("Float16[i + 1]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
 +            }),
-             withToString("Halffloat[cornerCaseValue(i)]", (int s) -> {
++            withToString("Float16[cornerCaseValue(i)]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (short)longCornerCaseValue(i));
 +            })
 +    );
 +
 +
 +    static void assertArraysEquals(long[] r, short[] a, int offs) {
 +        int i = 0;
 +        try {
 +            for (; i < r.length; i++) {
 +                Assert.assertEquals(r[i], (long)Float.float16ToFloat(a[i+offs]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], (long)(a[i+offs]), "at index #" + i + ", input = " + a[i+offs]);
 +        }
 +    }
 +
 +    static void assertArraysEquals(double[] r, short[] a, int offs) {
 +        int i = 0;
 +        try {
 +            for (; i < r.length; i++) {
 +                Assert.assertEquals(r[i], (double)Float.float16ToFloat(a[i+offs]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], (double)(a[i+offs]), "at index #" + i + ", input = " + a[i+offs]);
 +        }
 +    }
 +
 +    static short bits(short e) {
-         return  Halffloat.shortToShortBits(e);
++        return  Float16.shortToShortBits(e);
 +    }
 +
 +    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(
-             withToString("Halffloat[-i * 5]", (int s) -> {
++            withToString("Float16[-i * 5]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> genValue(-i * 5));
 +            }),
-             withToString("Halffloat[i * 5]", (int s) -> {
++            withToString("Float16[i * 5]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> genValue(i * 5));
 +            }),
-             withToString("Halffloat[i + 1]", (int s) -> {
++            withToString("Float16[i + 1]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
 +            }),
-             withToString("Halffloat[cornerCaseValue(i)]", (int s) -> {
++            withToString("short[0.01 + (i / (i + 1))]", (int s) -> {
++                return fill(s * BUFFER_REPS,
++                            i -> (short)0.01 + ((short)i / (i + 1)));
++            }),
++            withToString("short[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i / (i + 1))]", (int s) -> {
++                return fill(s * BUFFER_REPS,
++                            i -> i % 17 == 0 ? cornerCaseValue(i) : (short)0.01 + ((short)i / (i + 1)));
++            }),
++            withToString("short[cornerCaseValue(i)]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> cornerCaseValue(i));
 +            })
 +    );
 +
 +    // Create combinations of pairs
 +    // @@@ Might be sensitive to order e.g. div by 0
 +    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_PAIRS =
 +        Stream.of(HALFFLOAT_GENERATORS.get(0)).
 +                flatMap(fa -> HALFFLOAT_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).
 +                collect(Collectors.toList());
 +
 +    @DataProvider
 +    public Object[][] boolUnaryOpProvider() {
 +        return BOOL_ARRAY_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_TRIPLES =
 +        HALFFLOAT_GENERATOR_PAIRS.stream().
 +                flatMap(pair -> HALFFLOAT_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).
 +                collect(Collectors.toList());
 +
++    static final List<IntFunction<short[]>> SELECT_FROM_INDEX_GENERATORS = List.of(
++            withToString("short[0..VECLEN*2)", (int s) -> {
++                return fill(s * BUFFER_REPS,
++                            i -> (short)(RAND.nextInt()));
++            })
++    );
++
++    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_SELECT_FROM_TRIPLES =
++        HALFFLOAT_GENERATOR_PAIRS.stream().
++                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).
++                collect(Collectors.toList());
++
 +    @DataProvider
 +    public Object[][] shortBinaryOpProvider() {
 +        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortIndexedOpProvider() {
 +        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortBinaryOpMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_GENERATOR_PAIRS.stream().map(lfa -> {
 +                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortTernaryOpProvider() {
 +        return HALFFLOAT_GENERATOR_TRIPLES.stream().map(List::toArray).
 +                toArray(Object[][]::new);
 +    }
 +
++    @DataProvider
++    public Object[][] shortSelectFromTwoVectorOpProvider() {
++        return HALFFLOAT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).
++                toArray(Object[][]::new);
++    }
++
 +    @DataProvider
 +    public Object[][] shortTernaryOpMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_GENERATOR_TRIPLES.stream().map(lfa -> {
 +                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortUnaryOpProvider() {
 +        return HALFFLOAT_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortUnaryOpMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                    return new Object[] {fa, fm};
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shorttoIntUnaryOpProvider() {
 +        return INT_HALFFLOAT_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shorttoLongUnaryOpProvider() {
 +        return LONG_HALFFLOAT_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] maskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] maskCompareOpProvider() {
 +        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shuffleProvider() {
 +        return INT_SHUFFLE_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shuffleCompareOpProvider() {
 +        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortUnaryOpShuffleProvider() {
 +        return INT_SHUFFLE_GENERATORS.stream().
 +                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                    return new Object[] {fa, fs};
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortUnaryOpShuffleMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> INT_SHUFFLE_GENERATORS.stream().
 +                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                        return new Object[] {fa, fs, fm};
 +                }))).
 +                toArray(Object[][]::new);
 +    }
 +
 +    static final List<BiFunction<Integer,Integer,short[]>> HALFFLOAT_SHUFFLE_GENERATORS = List.of(
 +            withToStringBi("shuffle[random]", (Integer l, Integer m) -> {
 +                short[] a = new short[l];
 +                int upper = m;
 +                for (int i = 0; i < 1; i++) {
 +                    a[i] = (short)RAND.nextInt(upper);
 +                }
 +                return a;
 +            })
 +    );
 +
 +    @DataProvider
 +    public Object[][] shortUnaryOpSelectFromProvider() {
 +        return HALFFLOAT_SHUFFLE_GENERATORS.stream().
 +                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                    return new Object[] {fa, fs};
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortUnaryOpSelectFromMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_SHUFFLE_GENERATORS.stream().
 +                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                        return new Object[] {fa, fs, fm};
 +                }))).
 +                toArray(Object[][]::new);
 +    }
 +
 +    static final List<IntFunction<short[]>> HALFFLOAT_COMPARE_GENERATORS = List.of(
 +            withToString("short[i]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (short)i);
 +            }),
 +            withToString("short[i - length / 2]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (short)(i - (s * BUFFER_REPS / 2)));
 +            }),
 +            withToString("short[i + 1]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (short)(i + 1));
 +            }),
 +            withToString("short[i - 2]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (short)(i - 2));
 +            }),
 +            withToString("short[zigZag(i)]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> i%3 == 0 ? (short)i : (i%3 == 1 ? (short)(i + 1) : (short)(i - 2)));
 +            }),
 +            withToString("short[cornerCaseValue(i)]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> cornerCaseValue(i));
 +            })
 +    );
 +
 +    static final List<List<IntFunction<short[]>>> HALFFLOAT_TEST_GENERATOR_ARGS =
 +        HALFFLOAT_COMPARE_GENERATORS.stream().
 +                map(fa -> List.of(fa)).
 +                collect(Collectors.toList());
 +
 +    @DataProvider
 +    public Object[][] shortTestOpProvider() {
 +        return HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(List::toArray).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortTestOpMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(lfa -> {
 +                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    static final List<List<IntFunction<short[]>>> HALFFLOAT_COMPARE_GENERATOR_PAIRS =
 +        HALFFLOAT_COMPARE_GENERATORS.stream().
 +                flatMap(fa -> HALFFLOAT_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).
 +                collect(Collectors.toList());
 +
 +    @DataProvider
 +    public Object[][] shortCompareOpProvider() {
 +        return HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortCompareOpMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {
 +                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    interface ToHalffloatF {
 +        short apply(int i);
 +    }
 +
 +    static short[] fill(int s , ToHalffloatF f) {
 +        return fill(new short[s], f);
 +    }
 +
 +    static short[] fill(short[] a, ToHalffloatF f) {
 +        for (int i = 0; i < a.length; i++) {
 +            a[i] = f.apply(i);
 +        }
 +        return a;
 +    }
 +
 +    static short cornerCaseValue(int i) {
-         switch(i % 7) {
-             case 0:
-                 return Halffloat.MAX_VALUE;
-             case 1:
-                 return Halffloat.MIN_VALUE;
-             case 2:
-                 return Halffloat.NEGATIVE_INFINITY;
-             case 3:
-                 return Halffloat.POSITIVE_INFINITY;
-             case 4:
-                 return Halffloat.NaN;
-             case 5:
-                 return (short)0.0;
-             default:
-                 return Short.MIN_VALUE;
-         }
-     }
- 
-     static short get(short[] a, int i) {
-         return (short) a[i];
++        return switch(i % 8) {
++            case 0  -> Float16.MAX_VALUE;
++            case 1  -> Float16.MIN_VALUE;
++            case 2  -> Float16.NEGATIVE_INFINITY;
++            case 3  -> Float16.POSITIVE_INFINITY;
++            case 4  -> Float16.NaN;
++            case 5  -> Double.longBitsToDouble(0x7FF123456789ABCDL);
++            case 6  -> (short)0.0;
++            default -> (short)-0.0;
++        };
 +    }
 +
 +    static final IntFunction<short[]> fr = (vl) -> {
 +        int length = BUFFER_REPS * vl;
 +        return new short[length];
 +    };
 +
 +    static final IntFunction<boolean[]> fmr = (vl) -> {
 +        int length = BUFFER_REPS * vl;
 +        return new boolean[length];
 +    };
 +
 +    static final IntFunction<long[]> lfr = (vl) -> {
 +        int length = BUFFER_REPS * vl;
 +        return new long[length];
 +    };
 +
 +    static boolean eq(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() == bt.floatValue();
 +    }
 +
 +    static boolean neq(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() != bt.floatValue();
 +    }
 +
 +    static boolean lt(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() < bt.floatValue();
 +    }
 +
 +    static boolean le(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() <= bt.floatValue();
 +    }
 +
 +    static boolean gt(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() > bt.floatValue();
 +    }
 +
 +    static boolean ge(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() >= bt.floatValue();
 +    }
 +
 +    static short firstNonZero(short a, short b) {
 +        return Short.compare(a, (short) 0) != 0 ? a : b;
 +    }
 +
 +    @Test
 +    static void smokeTest1() {
-         HalffloatVector three = HalffloatVector.broadcast(SPECIES, Halffloat.valueOf(-3));
-         HalffloatVector three2 = (HalffloatVector) SPECIES.broadcast(Halffloat.valueOf(-3));
++        HalffloatVector three = HalffloatVector.broadcast(SPECIES, Float16.float16ToRawShortBits(Float16.valueOf(-3)));
++        HalffloatVector three2 = (HalffloatVector) SPECIES.broadcast(Float16.float16ToRawShortBits(Float16.valueOf(-3)));
 +        assert(three.eq(three2).allTrue());
-         HalffloatVector three3 = three2.broadcast(Halffloat.valueOf(1)).broadcast(Halffloat.valueOf(-3));
++        HalffloatVector three3 = three2.broadcast(Float16.float16ToRawShortBits(Float16.valueOf(1))).broadcast(Float16.float16ToRawShortBits(Float16.valueOf(-3)));
 +        assert(three.eq(three3).allTrue());
 +        int scale = 2;
 +        HalffloatVector higher = three.addIndex(scale);
-         VectorMask<Halffloat> m = three.compare(VectorOperators.LE, higher);
++        VectorMask<Float16> m = three.compare(VectorOperators.LE, higher);
 +        assert(m.allTrue());
-         m = higher.min((Halffloat.valueOf(-1))).test(VectorOperators.IS_NEGATIVE);
++        m = higher.min((Float16.float16ToRawShortBits(Float16.valueOf(-1)))).test(VectorOperators.IS_NEGATIVE);
 +        assert(m.allTrue());
 +        m = higher.test(VectorOperators.IS_FINITE);
 +        assert(m.allTrue());
 +        short max = higher.reduceLanes(VectorOperators.MAX);
 +        assert((short) Float.float16ToFloat(max) == -3 + scale * (SPECIES.length()-1));
 +    }
 +
 +    private static short[]
 +    bothToArray(HalffloatVector a, HalffloatVector b) {
 +        short[] r = new short[a.length() + b.length()];
 +        a.intoArray(r, 0);
 +        b.intoArray(r, a.length());
 +        return r;
 +    }
 +
 +    @Test
 +    static void smokeTest2() {
 +        // Do some zipping and shuffling.
 +        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);
 +        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES,0,1,false).toVector();
 +        Assert.assertEquals(io, io2);
 +        HalffloatVector a = io.add((short)1); //[1,2]
 +        HalffloatVector b = a.neg();  //[-1,-2]
 +        short[] abValues = bothToArray(a,b); //[1,2,-1,-2]
-         VectorShuffle<Halffloat> zip0 = VectorShuffle.makeZip(SPECIES, 0);
-         VectorShuffle<Halffloat> zip1 = VectorShuffle.makeZip(SPECIES, 1);
++        VectorShuffle<Float16> zip0 = VectorShuffle.makeZip(SPECIES, 0);
++        VectorShuffle<Float16> zip1 = VectorShuffle.makeZip(SPECIES, 1);
 +        HalffloatVector zab0 = a.rearrange(zip0,b); //[1,-1]
 +        HalffloatVector zab1 = a.rearrange(zip1,b); //[2,-2]
 +        short[] zabValues = bothToArray(zab0, zab1); //[1,-1,2,-2]
 +        // manually zip
 +        short[] manual = new short[zabValues.length];
 +        for (int i = 0; i < manual.length; i += 2) {
 +            manual[i+0] = abValues[i/2];
 +            manual[i+1] = abValues[a.length() + i/2];
 +        }
 +        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));
-         VectorShuffle<Halffloat> unz0 = VectorShuffle.makeUnzip(SPECIES, 0);
-         VectorShuffle<Halffloat> unz1 = VectorShuffle.makeUnzip(SPECIES, 1);
++        VectorShuffle<Float16> unz0 = VectorShuffle.makeUnzip(SPECIES, 0);
++        VectorShuffle<Float16> unz1 = VectorShuffle.makeUnzip(SPECIES, 1);
 +        HalffloatVector uab0 = zab0.rearrange(unz0,zab1);
 +        HalffloatVector uab1 = zab0.rearrange(unz1,zab1);
 +        short[] abValues1 = bothToArray(uab0, uab1);
 +        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));
 +    }
 +
 +    static void iotaShuffle() {
 +        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);
 +        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES, 0 , 1, false).toVector();
 +        Assert.assertEquals(io, io2);
 +    }
 +
 +    @Test
 +    // Test all shuffle related operations.
 +    static void shuffleTest() {
 +        // To test backend instructions, make sure that C2 is used.
 +        for (int loop = 0; loop < INVOC_COUNT * INVOC_COUNT; loop++) {
 +            iotaShuffle();
 +        }
 +    }
 +
 +    @Test
 +    void viewAsIntegeralLanesTest() {
 +        Vector<?> asIntegral = SPECIES.zero().viewAsIntegralLanes();
 +        VectorSpecies<?> asIntegralSpecies = asIntegral.species();
 +        Assert.assertNotEquals(asIntegralSpecies.elementType(), SPECIES.elementType());
 +        Assert.assertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());
 +        Assert.assertEquals(asIntegralSpecies.length(), SPECIES.length());
 +        Assert.assertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);
 +    }
 +
 +    @Test
 +    void viewAsFloatingLanesTest() {
 +        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();
 +        Assert.assertEquals(asFloating.species(), SPECIES);
 +    }
 +
 +    static short ADD(short a, short b) {
 +        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b)));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void ADDHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, Halffloat512VectorTests::ADD);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void ADDHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::ADD);
 +    }
 +
 +    static short SUB(short a, short b) {
 +        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b)));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void SUBHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, Halffloat512VectorTests::SUB);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void SUBHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::SUB);
 +    }
 +
 +    static short MUL(short a, short b) {
 +        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) * Float.float16ToFloat(b)));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void MULHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, Halffloat512VectorTests::MUL);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void MULHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::MUL);
 +    }
 +
 +    static short DIV(short a, short b) {
 +        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) / Float.float16ToFloat(b)));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void DIVHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, Halffloat512VectorTests::DIV);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void DIVHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::DIV);
 +    }
 +
 +    static short MAX(short a, short b) {
 +        return (short)(Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b))));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void MAXHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, Halffloat512VectorTests::MAX);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void MAXHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::MAX);
 +    }
 +
 +    static short MIN(short a, short b) {
-         return (short)(Halffloat.valueOf(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));
++        return (short)(Float.floatToFloat16(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void MINHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, Halffloat512VectorTests::MIN);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void MINHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::MIN);
 +    }
 +
 +    static short ABS(short a) {
 +        return (short)(Math.abs(a));
 +    }
 +
 +    static short abs(short a) {
 +        return (short)(Math.abs(a));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void ABSHalffloat512VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ABS).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, Halffloat512VectorTests::ABS);
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void absHalffloat512VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.abs().intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, Halffloat512VectorTests::abs);
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpMaskProvider")
 +    static void ABSMaskedHalffloat512VectorTests(IntFunction<short[]> fa,
 +                                                IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, mask, Halffloat512VectorTests::ABS);
 +    }
 +
 +    static short NEG(short a) {
 +        return (short)(-a);
 +    }
 +
 +    static short neg(short a) {
 +        return (short)(-a);
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void NEGHalffloat512VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.NEG).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, Halffloat512VectorTests::NEG);
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void negHalffloat512VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.neg().intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, Halffloat512VectorTests::neg);
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpMaskProvider")
 +    static void NEGMaskedHalffloat512VectorTests(IntFunction<short[]> fa,
 +                                                IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, mask, Halffloat512VectorTests::NEG);
 +    }
 +
 +    static short FMA(short a, short b, short c) {
 +        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));
 +    }
 +
 +    static short fma(short a, short b, short c) {
 +        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));
 +    }
 +
 +    @Test(dataProvider = "shortTernaryOpProvider")
 +    static void FMAHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] c = fc.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);
 +                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, c, Halffloat512VectorTests::FMA);
 +    }
 +
 +    @Test(dataProvider = "shortTernaryOpProvider")
 +    static void fmaHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] c = fc.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +            HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);
 +            av.fma(bv, cv).intoArray(r, i);
 +        }
 +
 +        assertArraysEquals(r, a, b, c, Halffloat512VectorTests::fma);
 +    }
 +
 +    @Test(dataProvider = "shortTernaryOpMaskProvider")
 +    static void FMAHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] c = fc.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);
 +                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, c, mask, Halffloat512VectorTests::FMA);
 +    }
 +
 +    static short SQRT(short a) {
-         return (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));
++        return (short)(Float.floatToFloat16((float) Math.sqrt(Float.float16ToFloat(a))));
 +    }
 +
 +    static short sqrt(short a) {
-         return (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));
++        return (short)(Float.floatToFloat16((float) Math.sqrt(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void SQRTHalffloat512VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SQRT).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, Halffloat512VectorTests::SQRT);
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void sqrtHalffloat512VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.sqrt().intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, Halffloat512VectorTests::sqrt);
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpMaskProvider")
 +    static void SQRTMaskedHalffloat512VectorTests(IntFunction<short[]> fa,
 +                                                IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, mask, Halffloat512VectorTests::SQRT);
 +    }
 +
 +    static short SIN(short a) {
-         return Halffloat.valueOf((float) Math.sin(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.sin(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictSIN(short a) {
-         return Halffloat.valueOf((float) StrictMath.sin(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.sin(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void SINHalffloat512VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SIN).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::SIN, Halffloat512VectorTests::strictSIN);
 +    }
 +
 +    static short EXP(short a) {
-         return Halffloat.valueOf((float) Math.exp(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.exp(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictEXP(short a) {
-         return Halffloat.valueOf((float) StrictMath.exp(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.exp(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void EXPHalffloat512VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.EXP).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::EXP, Halffloat512VectorTests::strictEXP);
 +    }
 +
 +    static short LOG1P(short a) {
-         return Halffloat.valueOf((float) Math.log1p(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.log1p(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictLOG1P(short a) {
-         return Halffloat.valueOf((float) StrictMath.log1p(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.log1p(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void LOG1PHalffloat512VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::LOG1P, Halffloat512VectorTests::strictLOG1P);
 +    }
 +
 +    static short LOG(short a) {
-         return Halffloat.valueOf((float) Math.log(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.log(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictLOG(short a) {
-         return Halffloat.valueOf((float) StrictMath.log(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.log(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void LOGHalffloat512VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.LOG).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::LOG, Halffloat512VectorTests::strictLOG);
 +    }
 +
 +    static short LOG10(short a) {
-         return Halffloat.valueOf((float) Math.log10(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.log10(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictLOG10(short a) {
-         return Halffloat.valueOf((float) StrictMath.log10(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.log10(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void LOG10Halffloat512VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.LOG10).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::LOG10, Halffloat512VectorTests::strictLOG10);
 +    }
 +
 +    static short EXPM1(short a) {
-         return Halffloat.valueOf((float) Math.expm1(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.expm1(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictEXPM1(short a) {
-         return Halffloat.valueOf((float) StrictMath.expm1(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.expm1(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void EXPM1Halffloat512VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::EXPM1, Halffloat512VectorTests::strictEXPM1);
 +    }
 +
 +    static short COS(short a) {
-         return Halffloat.valueOf((float) Math.cos(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.cos(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictCOS(short a) {
-         return Halffloat.valueOf((float) StrictMath.cos(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.cos(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void COSHalffloat512VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.COS).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::COS, Halffloat512VectorTests::strictCOS);
 +    }
 +
 +    static short TAN(short a) {
-         return Halffloat.valueOf((float) Math.tan(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.tan(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictTAN(short a) {
-         return Halffloat.valueOf((float) StrictMath.tan(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.tan(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void TANHalffloat512VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.TAN).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::TAN, Halffloat512VectorTests::strictTAN);
 +    }
 +
 +    static short SINH(short a) {
-         return Halffloat.valueOf((float) Math.sinh(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.sinh(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictSINH(short a) {
-         return Halffloat.valueOf((float) StrictMath.sinh(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.sinh(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void SINHHalffloat512VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SINH).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::SINH, Halffloat512VectorTests::strictSINH);
 +    }
 +
 +    static short COSH(short a) {
-         return Halffloat.valueOf((float) Math.cosh(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.cosh(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictCOSH(short a) {
-         return Halffloat.valueOf((float) StrictMath.cosh(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.cosh(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void COSHHalffloat512VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.COSH).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::COSH, Halffloat512VectorTests::strictCOSH);
 +    }
 +
 +    static short TANH(short a) {
-         return Halffloat.valueOf((float) Math.tanh(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.tanh(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictTANH(short a) {
-         return Halffloat.valueOf((float) StrictMath.tanh(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.tanh(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void TANHHalffloat512VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.TANH).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::TANH, Halffloat512VectorTests::strictTANH);
 +    }
 +
 +    static short ASIN(short a) {
-         return Halffloat.valueOf((float) Math.asin(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.asin(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictASIN(short a) {
-         return Halffloat.valueOf((float) StrictMath.asin(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.asin(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void ASINHalffloat512VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ASIN).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::ASIN, Halffloat512VectorTests::strictASIN);
 +    }
 +
 +    static short ACOS(short a) {
-         return Halffloat.valueOf((float) Math.acos(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.acos(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictACOS(short a) {
-         return Halffloat.valueOf((float) StrictMath.acos(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.acos(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void ACOSHalffloat512VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ACOS).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::ACOS, Halffloat512VectorTests::strictACOS);
 +    }
 +
 +    static short ATAN(short a) {
-         return Halffloat.valueOf((float) Math.atan(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.atan(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictATAN(short a) {
-         return Halffloat.valueOf((float) StrictMath.atan(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.atan(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void ATANHalffloat512VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ATAN).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::ATAN, Halffloat512VectorTests::strictATAN);
 +    }
 +
 +    static short CBRT(short a) {
-         return Halffloat.valueOf((float) Math.cbrt(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.cbrt(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictCBRT(short a) {
-         return Halffloat.valueOf((float) StrictMath.cbrt(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.cbrt(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void CBRTHalffloat512VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.CBRT).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::CBRT, Halffloat512VectorTests::strictCBRT);
 +    }
 +
 +    static short HYPOT(short a, short b) {
-         return Halffloat.valueOf((float) Math.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)));
 +    }
 +
 +    static short strictHYPOT(short a, short b) {
-         return Halffloat.valueOf((float) StrictMath.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b))));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void HYPOTHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat512VectorTests::HYPOT, Halffloat512VectorTests::strictHYPOT);
 +    }
 +
 +    static short POW(short a, short b) {
-         return Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));
 +    }
 +
 +    static short strictPOW(short a, short b) {
-         return Halffloat.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b))));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void POWHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat512VectorTests::POW, Halffloat512VectorTests::strictPOW);
 +    }
 +
 +    static short pow(short a, short b) {
-         return Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));
 +    }
 +
 +    static short strictpow(short a, short b) {
-         return Halffloat.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b))));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void powHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.pow(bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat512VectorTests::pow, Halffloat512VectorTests::strictpow);
 +    }
 +
 +    static short ATAN2(short a, short b) {
-         return Halffloat.valueOf((float) Math.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)));
 +    }
 +
 +    static short strictATAN2(short a, short b) {
-         return Halffloat.valueOf((float) StrictMath.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b))));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void ATAN2Halffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat512VectorTests::ATAN2, Halffloat512VectorTests::strictATAN2);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void POWHalffloat512VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            av.lanewise(VectorOperators.POW, b[i]).intoArray(r, i);
 +        }
 +
 +        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat512VectorTests::POW, Halffloat512VectorTests::strictPOW);
 +    }
 +
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void powHalffloat512VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            av.pow(b[i]).intoArray(r, i);
 +        }
 +
 +        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat512VectorTests::pow, Halffloat512VectorTests::strictpow);
 +    }
 +
 +
 +    static short blend(short a, short b, boolean mask) {
 +        return mask ? b : a;
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void blendHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.blend(bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::blend);
 +    }
 +
 +    @Test(dataProvider = "shortCompareOpProvider")
 +    static void ltHalffloat512VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
-             VectorMask<Halffloat> mv = av.lt(b[i]);
++            VectorMask<Float16> mv = av.lt(b[i]);
 +
 +            // Check results as part of computation.
 +            for (int j = 0; j < SPECIES.length(); j++) {
 +                Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortCompareOpProvider")
 +    static void eqHalffloat512VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
-             VectorMask<Halffloat> mv = av.eq(b[i]);
++            VectorMask<Float16> mv = av.eq(b[i]);
 +
 +            // Check results as part of computation.
 +            for (int j = 0; j < SPECIES.length(); j++) {
 +                Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shorttoIntUnaryOpProvider")
 +    static void toIntArrayHalffloat512VectorTestsSmokeTest(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            int[] r = av.toIntArray();
 +            assertArraysEquals(r, a, i);
 +        }
 +    }
 +
 +    @Test(dataProvider = "shorttoLongUnaryOpProvider")
 +    static void toLongArrayHalffloat512VectorTestsSmokeTest(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            long[] r = av.toLongArray();
 +            assertArraysEquals(r, a, i);
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void toDoubleArrayHalffloat512VectorTestsSmokeTest(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            double[] r = av.toDoubleArray();
 +            assertArraysEquals(r, a, i);
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void toStringHalffloat512VectorTestsSmokeTest(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            String str = av.toString();
 +
 +            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());
 +            Assert.assertTrue(str.equals(Arrays.toString(subarr)), "at index " + i + ", string should be = " + Arrays.toString(subarr) + ", but is = " + str);
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void hashCodeHalffloat512VectorTestsSmokeTest(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            int hash = av.hashCode();
 +
 +            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());
 +            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));
 +            Assert.assertTrue(hash == expectedHash, "at index " + i + ", hash should be = " + expectedHash + ", but is = " + hash);
 +        }
 +    }
 +
 +
 +    static long ADDReduceLong(short[] a, int idx) {
 +        short res = 0;
 +        for (int i = idx; i < (idx + SPECIES.length()); i++) {
 +            res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));
 +        }
 +
 +        return (long)res;
 +    }
 +
 +    static long ADDReduceAllLong(short[] a) {
 +        long res = 0;
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            res += ADDReduceLong(a, i);
 +        }
 +
 +        return res;
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void ADDReduceLongHalffloat512VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        long[] r = lfr.apply(SPECIES.length());
 +        long ra = 0;
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            r[i] = av.reduceLanesToLong(VectorOperators.ADD);
 +        }
 +
 +        ra = 0;
 +        for (int i = 0; i < a.length; i ++) {
 +            ra += r[i];
 +        }
 +
 +        assertReductionLongArraysEquals(r, ra, a,
 +                Halffloat512VectorTests::ADDReduceLong, Halffloat512VectorTests::ADDReduceAllLong);
 +    }
 +
 +    static long ADDReduceLongMasked(short[] a, int idx, boolean[] mask) {
 +        short res = 0;
 +        for (int i = idx; i < (idx + SPECIES.length()); i++) {
 +            if(mask[i % SPECIES.length()])
 +                res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));
 +        }
 +
 +        return (long)res;
 +    }
 +
 +    static long ADDReduceAllLongMasked(short[] a, boolean[] mask) {
 +        long res = 0;
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            res += ADDReduceLongMasked(a, i, mask);
 +        }
 +
 +        return res;
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpMaskProvider")
 +    static void ADDReduceLongHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        long[] r = lfr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +        long ra = 0;
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            r[i] = av.reduceLanesToLong(VectorOperators.ADD, vmask);
 +        }
 +
 +        ra = 0;
 +        for (int i = 0; i < a.length; i ++) {
 +            ra += r[i];
 +        }
 +
 +        assertReductionLongArraysEqualsMasked(r, ra, a, mask,
 +                Halffloat512VectorTests::ADDReduceLongMasked, Halffloat512VectorTests::ADDReduceAllLongMasked);
 +    }
 +
 +    @Test(dataProvider = "shorttoLongUnaryOpProvider")
 +    static void BroadcastLongHalffloat512VectorTestsSmokeTest(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = new short[a.length];
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);
 +        }
 +        assertBroadcastArraysEquals(r, a);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void blendHalffloat512VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.blend((long)b[i], vmask).intoArray(r, i);
 +            }
 +        }
 +        assertBroadcastLongArraysEquals(r, a, b, mask, Halffloat512VectorTests::blend);
 +    }
 +
 +
 +    @Test(dataProvider = "shortUnaryOpSelectFromProvider")
 +    static void SelectFromHalffloat512VectorTests(IntFunction<short[]> fa,
 +                                           BiFunction<Integer,Integer,short[]> fs) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] order = fs.apply(a.length, SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);
 +            bv.selectFrom(av).intoArray(r, i);
 +        }
 +
 +        assertSelectFromArraysEquals(r, a, order, SPECIES.length());
 +    }
 +
++    @Test(dataProvider = "shortSelectFromTwoVectorOpProvider")
++    static void SelectFromTwoVectorHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] b = fb.apply(SPECIES.length());
++        short[] idx = fc.apply(SPECIES.length());
++        short[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < idx.length; i += SPECIES.length()) {
++                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
++                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
++                HalffloatVector idxv = HalffloatVector.fromArray(SPECIES, idx, i);
++                idxv.selectFrom(av, bv).intoArray(r, i);
++            }
++        }
++        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());
++    }
++
 +    @Test(dataProvider = "shortUnaryOpSelectFromMaskProvider")
 +    static void SelectFromHalffloat512VectorTestsMaskedSmokeTest(IntFunction<short[]> fa,
 +                                                           BiFunction<Integer,Integer,short[]> fs,
 +                                                           IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] order = fs.apply(a.length, SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);
 +            bv.selectFrom(av, vmask).intoArray(r, i);
 +        }
 +
 +        assertSelectFromArraysEquals(r, a, order, mask, SPECIES.length());
 +    }
 +
 +    @Test(dataProvider = "shuffleProvider")
 +    static void shuffleMiscellaneousHalffloat512VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {
 +        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);
 +            int hash = shuffle.hashCode();
 +            int length = shuffle.length();
 +
 +            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());
 +            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));
 +            Assert.assertTrue(hash == expectedHash, "at index " + i + ", hash should be = " + expectedHash + ", but is = " + hash);
 +            Assert.assertEquals(length, SPECIES.length());
 +        }
 +    }
 +
 +    @Test(dataProvider = "shuffleProvider")
 +    static void shuffleToStringHalffloat512VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {
 +        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);
 +            String str = shuffle.toString();
 +
 +            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());
 +            Assert.assertTrue(str.equals("Shuffle" + Arrays.toString(subarr)), "at index " +
 +                i + ", string should be = " + Arrays.toString(subarr) + ", but is = " + str);
 +        }
 +    }
 +
 +    @Test(dataProvider = "shuffleCompareOpProvider")
 +    static void shuffleEqualsHalffloat512VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {
 +        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());
 +        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var av = VectorShuffle.fromArray(SPECIES, a, i);
 +            var bv = VectorShuffle.fromArray(SPECIES, b, i);
 +            boolean eq = av.equals(bv);
 +            int to = i + SPECIES.length();
 +            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));
 +        }
 +    }
 +
 +    @Test(dataProvider = "maskCompareOpProvider")
 +    static void maskEqualsHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        boolean[] b = fb.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var av = SPECIES.loadMask(a, i);
 +            var bv = SPECIES.loadMask(b, i);
 +            boolean equals = av.equals(bv);
 +            int to = i + SPECIES.length();
 +            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));
 +        }
 +    }
 +
 +    static boolean band(boolean a, boolean b) {
 +        return a & b;
 +    }
 +
 +    @Test(dataProvider = "maskCompareOpProvider")
 +    static void maskAndHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        boolean[] b = fb.apply(SPECIES.length());
 +        boolean[] r = new boolean[a.length];
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var av = SPECIES.loadMask(a, i);
 +            var bv = SPECIES.loadMask(b, i);
 +            var cv = av.and(bv);
 +            cv.intoArray(r, i);
 +        }
 +        assertArraysEquals(r, a, b, Halffloat512VectorTests::band);
 +    }
 +
 +    static boolean bor(boolean a, boolean b) {
 +        return a | b;
 +    }
 +
 +    @Test(dataProvider = "maskCompareOpProvider")
 +    static void maskOrHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        boolean[] b = fb.apply(SPECIES.length());
 +        boolean[] r = new boolean[a.length];
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var av = SPECIES.loadMask(a, i);
 +            var bv = SPECIES.loadMask(b, i);
 +            var cv = av.or(bv);
 +            cv.intoArray(r, i);
 +        }
 +        assertArraysEquals(r, a, b, Halffloat512VectorTests::bor);
 +    }
 +
 +    static boolean bxor(boolean a, boolean b) {
 +        return a != b;
 +    }
 +
 +    @Test(dataProvider = "maskCompareOpProvider")
 +    static void maskXorHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        boolean[] b = fb.apply(SPECIES.length());
 +        boolean[] r = new boolean[a.length];
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var av = SPECIES.loadMask(a, i);
 +            var bv = SPECIES.loadMask(b, i);
 +            var cv = av.xor(bv);
 +            cv.intoArray(r, i);
 +        }
 +        assertArraysEquals(r, a, b, Halffloat512VectorTests::bxor);
 +    }
 +
 +    static boolean bandNot(boolean a, boolean b) {
 +        return a & !b;
 +    }
 +
 +    @Test(dataProvider = "maskCompareOpProvider")
 +    static void maskAndNotHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        boolean[] b = fb.apply(SPECIES.length());
 +        boolean[] r = new boolean[a.length];
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var av = SPECIES.loadMask(a, i);
 +            var bv = SPECIES.loadMask(b, i);
 +            var cv = av.andNot(bv);
 +            cv.intoArray(r, i);
 +        }
 +        assertArraysEquals(r, a, b, Halffloat512VectorTests::bandNot);
 +    }
 +
 +    static boolean beq(boolean a, boolean b) {
 +        return (a == b);
 +    }
 +
 +    @Test(dataProvider = "maskCompareOpProvider")
 +    static void maskEqHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        boolean[] b = fb.apply(SPECIES.length());
 +        boolean[] r = new boolean[a.length];
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var av = SPECIES.loadMask(a, i);
 +            var bv = SPECIES.loadMask(b, i);
 +            var cv = av.eq(bv);
 +            cv.intoArray(r, i);
 +        }
 +        assertArraysEquals(r, a, b, Halffloat512VectorTests::beq);
 +    }
 +
 +    @Test(dataProvider = "maskProvider")
 +    static void maskHashCodeHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var vmask = SPECIES.loadMask(a, i);
 +            int hash = vmask.hashCode();
 +
 +            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());
 +            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));
 +            Assert.assertTrue(hash == expectedHash, "at index " + i + ", hash should be = " + expectedHash + ", but is = " + hash);
 +        }
 +    }
 +
 +    static int maskTrueCount(boolean[] a, int idx) {
 +        int trueCount = 0;
 +        for (int i = idx; i < idx + SPECIES.length(); i++) {
 +            trueCount += a[i] ? 1 : 0;
 +        }
 +        return trueCount;
 +    }
 +
 +    @Test(dataProvider = "maskProvider")
 +    static void maskTrueCountHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        int[] r = new int[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                var vmask = SPECIES.loadMask(a, i);
 +                r[i] = vmask.trueCount();
 +            }
 +        }
 +
 +        assertMaskReductionArraysEquals(r, a, Halffloat512VectorTests::maskTrueCount);
 +    }
 +
 +    static int maskLastTrue(boolean[] a, int idx) {
 +        int i = idx + SPECIES.length() - 1;
 +        for (; i >= idx; i--) {
 +            if (a[i]) {
 +                break;
 +            }
 +        }
 +        return i - idx;
 +    }
 +
 +    @Test(dataProvider = "maskProvider")
 +    static void maskLastTrueHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        int[] r = new int[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                var vmask = SPECIES.loadMask(a, i);
 +                r[i] = vmask.lastTrue();
 +            }
 +        }
 +
 +        assertMaskReductionArraysEquals(r, a, Halffloat512VectorTests::maskLastTrue);
 +    }
 +
 +    static int maskFirstTrue(boolean[] a, int idx) {
 +        int i = idx;
 +        for (; i < idx + SPECIES.length(); i++) {
 +            if (a[i]) {
 +                break;
 +            }
 +        }
 +        return i - idx;
 +    }
 +
 +    @Test(dataProvider = "maskProvider")
 +    static void maskFirstTrueHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        int[] r = new int[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                var vmask = SPECIES.loadMask(a, i);
 +                r[i] = vmask.firstTrue();
 +            }
 +        }
 +
 +        assertMaskReductionArraysEquals(r, a, Halffloat512VectorTests::maskFirstTrue);
 +    }
 +
 +    @Test(dataProvider = "maskProvider")
 +    static void maskCompressHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
 +        int trueCount = 0;
 +        boolean[] a = fa.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                var vmask = SPECIES.loadMask(a, i);
 +                trueCount = vmask.trueCount();
 +                var rmask = vmask.compress();
 +                for (int j = 0; j < SPECIES.length(); j++)  {
 +                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
 +                }
 +            }
 +        }
 +    }
 +
 +    @DataProvider
 +    public static Object[][] longMaskProvider() {
 +        return new Object[][]{
 +                {0xFFFFFFFFFFFFFFFFL},
 +                {0x0000000000000000L},
 +                {0x5555555555555555L},
 +                {0x0123456789abcdefL},
 +        };
 +    }
 +
 +    @Test(dataProvider = "longMaskProvider")
 +    static void maskFromToLongHalffloat512VectorTestsSmokeTest(long inputLong) {
 +        var vmask = VectorMask.fromLong(SPECIES, inputLong);
 +        long outputLong = vmask.toLong();
 +        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));
 +    }
 +
 +    @DataProvider
 +    public static Object[][] offsetProvider() {
 +        return new Object[][]{
 +                {0},
 +                {-1},
 +                {+1},
 +                {+2},
 +                {-2},
 +        };
 +    }
 +
 +    @Test(dataProvider = "offsetProvider")
 +    static void indexInRangeHalffloat512VectorTestsSmokeTest(int offset) {
 +        int limit = SPECIES.length() * BUFFER_REPS;
 +        for (int i = 0; i < limit; i += SPECIES.length()) {
 +            var actualMask = SPECIES.indexInRange(i + offset, limit);
 +            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);
 +            assert(actualMask.equals(expectedMask));
 +            for (int j = 0; j < SPECIES.length(); j++)  {
 +                int index = i + j + offset;
 +                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "offsetProvider")
 +    static void indexInRangeLongHalffloat512VectorTestsSmokeTest(int offset) {
 +        long limit = SPECIES.length() * BUFFER_REPS;
 +        for (long i = 0; i < limit; i += SPECIES.length()) {
 +            var actualMask = SPECIES.indexInRange(i + offset, limit);
 +            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);
 +            assert(actualMask.equals(expectedMask));
 +            for (int j = 0; j < SPECIES.length(); j++)  {
 +                long index = i + j + offset;
 +                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);
 +            }
 +        }
 +    }
 +
 +    @DataProvider
 +    public static Object[][] lengthProvider() {
 +        return new Object[][]{
 +                {0},
 +                {1},
 +                {32},
 +                {37},
 +                {1024},
 +                {1024+1},
 +                {1024+5},
 +        };
 +    }
 +
 +    @Test(dataProvider = "lengthProvider")
 +    static void loopBoundHalffloat512VectorTestsSmokeTest(int length) {
 +        int actualLoopBound = SPECIES.loopBound(length);
 +        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());
 +        Assert.assertEquals(actualLoopBound, expectedLoopBound);
 +    }
 +
 +    @Test(dataProvider = "lengthProvider")
 +    static void loopBoundLongHalffloat512VectorTestsSmokeTest(int _length) {
 +        long length = _length;
 +        long actualLoopBound = SPECIES.loopBound(length);
 +        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());
 +        Assert.assertEquals(actualLoopBound, expectedLoopBound);
 +    }
 +
 +    @Test
 +    static void ElementSizeHalffloat512VectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
 +        int elsize = av.elementSize();
-         Assert.assertEquals(elsize, Halffloat.SIZE);
++        Assert.assertEquals(elsize, Float16.SIZE);
 +    }
 +
 +    @Test
 +    static void VectorShapeHalffloat512VectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
 +        VectorShape vsh = av.shape();
 +        assert(vsh.equals(VectorShape.S_512_BIT));
 +    }
 +
 +    @Test
 +    static void ShapeWithLanesHalffloat512VectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
 +        VectorShape vsh = av.shape();
-         VectorSpecies species = vsh.withLanes(Halffloat.class);
++        VectorSpecies species = vsh.withLanes(Float16.class);
 +        assert(species.equals(SPECIES));
 +    }
 +
 +    @Test
 +    static void ElementTypeHalffloat512VectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
-         assert(av.species().elementType() == Halffloat.class);
++        assert(av.species().elementType() == Float16.class);
 +    }
 +
 +    @Test
 +    static void SpeciesElementSizeHalffloat512VectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
-         assert(av.species().elementSize() == Halffloat.SIZE);
++        assert(av.species().elementSize() == Float16.SIZE);
 +    }
 +
 +    @Test
 +    static void VectorTypeHalffloat512VectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
 +        assert(av.species().vectorType() == av.getClass());
 +    }
 +
 +    @Test
 +    static void WithLanesHalffloat512VectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
-         VectorSpecies species = av.species().withLanes(Halffloat.class);
++        VectorSpecies species = av.species().withLanes(Float16.class);
 +        assert(species.equals(SPECIES));
 +    }
 +
 +    @Test
 +    static void WithShapeHalffloat512VectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
 +        VectorShape vsh = av.shape();
 +        VectorSpecies species = av.species().withShape(vsh);
 +        assert(species.equals(SPECIES));
 +    }
 +
 +    @Test
 +    static void MaskAllTrueHalffloat512VectorTestsSmokeTest() {
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));
 +        }
 +    }
 +}
diff --cc test/jdk/jdk/incubator/vector/Halffloat64VectorLoadStoreTests.java
index 4f697e7ce9d,00000000000..231894f280f
mode 100644,000000..100644
--- a/test/jdk/jdk/incubator/vector/Halffloat64VectorLoadStoreTests.java
+++ b/test/jdk/jdk/incubator/vector/Halffloat64VectorLoadStoreTests.java
@@@ -1,849 -1,0 +1,1014 @@@
 +/*
-  * Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2018, 2025, Oracle and/or its affiliates. All rights reserved.
 + * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 + *
 + * This code is free software; you can redistribute it and/or modify it
 + * under the terms of the GNU General Public License version 2 only, as
 + * published by the Free Software Foundation.
 + *
 + * This code is distributed in the hope that it will be useful, but WITHOUT
 + * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 + * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 + * version 2 for more details (a copy is included in the LICENSE file that
 + * accompanied this code).
 + *
 + * You should have received a copy of the GNU General Public License version
 + * 2 along with this work; if not, write to the Free Software Foundation,
 + * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 + *
 + * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 + * or visit www.oracle.com if you need additional information or have any
 + * questions.
 + */
 +
 +/*
 + * @test
-  * @enablePreview
++ * @key randomness
++ *
++ * @library /test/lib
 + * @modules jdk.incubator.vector java.base/jdk.internal.vm.annotation
 + * @run testng/othervm -XX:-TieredCompilation Halffloat64VectorLoadStoreTests
 + *
 + */
 +
 +// -- This file was mechanically generated: Do not edit! -- //
 +
 +import java.lang.foreign.MemorySegment;
- import java.lang.foreign.SegmentScope;
++import java.lang.foreign.Arena;
 +import java.lang.foreign.ValueLayout;
- import jdk.incubator.vector.Halffloat;
- import jdk.incubator.vector.HalffloatVector;
 +import jdk.incubator.vector.HalffloatVector;
 +import jdk.incubator.vector.VectorMask;
 +import jdk.incubator.vector.VectorSpecies;
 +import jdk.incubator.vector.VectorShuffle;
 +import jdk.internal.vm.annotation.DontInline;
 +import org.testng.Assert;
 +import org.testng.annotations.DataProvider;
 +import org.testng.annotations.Test;
 +
 +import java.nio.ByteOrder;
 +import java.util.List;
 +import java.util.function.*;
 +
 +@Test
 +public class Halffloat64VectorLoadStoreTests extends AbstractVectorLoadStoreTest {
-     static final VectorSpecies<Halffloat> SPECIES =
++    static final VectorSpecies<Float16> SPECIES =
 +                HalffloatVector.SPECIES_64;
 +
 +    static final int INVOC_COUNT = Integer.getInteger("jdk.incubator.vector.test.loop-iterations", 100);
 +
-     static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withBitAlignment(8);
++    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withByteAlignment(1);
 +
 +
 +    static final int BUFFER_REPS = Integer.getInteger("jdk.incubator.vector.test.buffer-vectors", 25000 / 64);
 +
 +    static void assertArraysEquals(short[] r, short[] a, boolean[] mask) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0);
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0, "at index #" + i);
 +        }
 +    }
 +
 +    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(
 +            withToString("short[i * 5]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (short)(i * 5));
 +            }),
 +            withToString("short[i + 1]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));
 +            })
 +    );
 +
 +    // Relative to array.length
 +    static final List<IntFunction<Integer>> INDEX_GENERATORS = List.of(
 +            withToString("-1", (int l) -> {
 +                return -1;
 +            }),
 +            withToString("l", (int l) -> {
 +                return l;
 +            }),
 +            withToString("l - 1", (int l) -> {
 +                return l - 1;
 +            }),
 +            withToString("l + 1", (int l) -> {
 +                return l + 1;
 +            }),
 +            withToString("l - speciesl + 1", (int l) -> {
 +                return l - SPECIES.length() + 1;
 +            }),
 +            withToString("l + speciesl - 1", (int l) -> {
 +                return l + SPECIES.length() - 1;
 +            }),
 +            withToString("l + speciesl", (int l) -> {
 +                return l + SPECIES.length();
 +            }),
 +            withToString("l + speciesl + 1", (int l) -> {
 +                return l + SPECIES.length() + 1;
 +            })
 +    );
 +
 +    // Relative to byte[] array.length or MemorySegment.byteSize()
 +    static final List<IntFunction<Integer>> BYTE_INDEX_GENERATORS = List.of(
 +            withToString("-1", (int l) -> {
 +                return -1;
 +            }),
 +            withToString("l", (int l) -> {
 +                return l;
 +            }),
 +            withToString("l - 1", (int l) -> {
 +                return l - 1;
 +            }),
 +            withToString("l + 1", (int l) -> {
 +                return l + 1;
 +            }),
 +            withToString("l - speciesl*ebsize + 1", (int l) -> {
 +                return l - SPECIES.vectorByteSize() + 1;
 +            }),
 +            withToString("l + speciesl*ebsize - 1", (int l) -> {
 +                return l + SPECIES.vectorByteSize() - 1;
 +            }),
 +            withToString("l + speciesl*ebsize", (int l) -> {
 +                return l + SPECIES.vectorByteSize();
 +            }),
 +            withToString("l + speciesl*ebsize + 1", (int l) -> {
 +                return l + SPECIES.vectorByteSize() + 1;
 +            })
 +    );
 +
 +    @DataProvider
 +    public Object[][] shortProvider() {
 +        return HALFFLOAT_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] maskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortProviderForIOOBE() {
 +        var f = HALFFLOAT_GENERATORS.get(0);
 +        return INDEX_GENERATORS.stream().map(fi -> {
 +                    return new Object[] {f, fi};
 +                }).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                    return new Object[] {fa, fm};
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortMaskProviderForIOOBE() {
 +        var f = HALFFLOAT_GENERATORS.get(0);
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {
 +                    return new Object[] {f, fi, fm};
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortMemorySegmentProvider() {
 +        return HALFFLOAT_GENERATORS.stream().
 +                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().
 +                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {
 +                            return new Object[]{fa, fb, bo};
 +                        }))).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortMemorySegmentMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_GENERATORS.stream().
 +                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().
 +                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {
 +                            return new Object[]{fa, fb, fm, bo};
 +                        })))).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortByteProviderForIOOBE() {
 +        var f = HALFFLOAT_GENERATORS.get(0);
 +        return BYTE_INDEX_GENERATORS.stream().map(fi -> {
 +                    return new Object[] {f, fi};
 +                }).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortByteMaskProviderForIOOBE() {
 +        var f = HALFFLOAT_GENERATORS.get(0);
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> BYTE_INDEX_GENERATORS.stream().map(fi -> {
 +                    return new Object[] {f, fi, fm};
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {
 +        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() / 8);
 +        for (int i = 0; i < a.length; i++) {
 +            ms.set(ELEMENT_LAYOUT, i * SPECIES.elementSize() / 8 , a[i]);
 +        }
 +        return ms;
 +    }
 +
 +    static short[] segmentToArray(MemorySegment ms) {
 +        return ms.toArray(ELEMENT_LAYOUT);
 +    }
 +
 +
 +    interface ToHalffloatF {
 +        short apply(int i);
 +    }
 +
 +    static short[] fill(int s , ToHalffloatF f) {
 +        return fill(new short[s], f);
 +    }
 +
 +    static short[] fill(short[] a, ToHalffloatF f) {
 +        for (int i = 0; i < a.length; i++) {
 +            a[i] = f.apply(i);
 +        }
 +        return a;
 +    }
 +
++    @DontInline
++    static VectorShuffle<Float16> shuffleFromArray(int[] a, int i) {
++        return SPECIES.shuffleFromArray(a, i);
++    }
++
++    @DontInline
++    static void shuffleIntoArray(VectorShuffle<Float16> s, int[] a, int i) {
++        s.intoArray(a, i);
++    }
++
++    @DontInline
++    static VectorShuffle<Float16> shuffleFromMemorySegment(MemorySegment mem, int i, ByteOrder bo) {
++        return VectorShuffle.fromMemorySegment(SPECIES, mem, i, bo);
++    }
++
++    @DontInline
++    static void shuffleIntoMemorySegment(VectorShuffle<Float16> s, MemorySegment mem, int i, ByteOrder bo) {
++        s.intoMemorySegment(mem, i, bo);
++    }
++
 +    @DontInline
 +    static HalffloatVector fromArray(short[] a, int i) {
-         return HalffloatVector.fromArray(SPECIES, a, i);
++        // Tests the species method and the equivalent vector method it defers to
++        return (HalffloatVector) SPECIES.fromArray(a, i);
 +    }
 +
 +    @DontInline
-     static HalffloatVector fromArray(short[] a, int i, VectorMask<Halffloat> m) {
++    static HalffloatVector fromArray(short[] a, int i, VectorMask<Float16> m) {
 +        return HalffloatVector.fromArray(SPECIES, a, i, m);
 +    }
 +
 +    @DontInline
 +    static void intoArray(HalffloatVector v, short[] a, int i) {
 +        v.intoArray(a, i);
 +    }
 +
 +    @DontInline
-     static void intoArray(HalffloatVector v, short[] a, int i, VectorMask<Halffloat> m) {
++    static void intoArray(HalffloatVector v, short[] a, int i, VectorMask<Float16> m) {
 +        v.intoArray(a, i, m);
 +    }
 +
 +    @DontInline
 +    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {
-         return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);
++        // Tests the species method and the equivalent vector method it defers to
++        return (HalffloatVector) SPECIES.fromMemorySegment(a, i, bo);
 +    }
 +
 +    @DontInline
-     static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Halffloat> m) {
++    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Float16> m) {
 +        return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, m);
 +    }
 +
 +    @DontInline
 +    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo) {
 +        v.intoMemorySegment(a, i, bo);
 +    }
 +
 +    @DontInline
-     static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Halffloat> m) {
++    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Float16> m) {
 +        v.intoMemorySegment(a, i, bo, m);
 +    }
 +
 +    @Test(dataProvider = "shortProvider")
 +    static void loadStoreArray(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = new short[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.intoArray(r, i);
 +            }
 +        }
 +        Assert.assertEquals(r, a);
 +    }
 +
 +    @Test(dataProvider = "shortProviderForIOOBE")
 +    static void loadArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = new short[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = fromArray(a, i);
 +                av.intoArray(r, i);
 +            }
 +        }
 +
 +        int index = fi.apply(a.length);
 +        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);
 +        try {
 +            fromArray(a, index);
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortProviderForIOOBE")
 +    static void storeArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = new short[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                intoArray(av, r, i);
 +            }
 +        }
 +
 +        int index = fi.apply(a.length);
 +        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);
 +        try {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);
 +            intoArray(av, r, index);
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +
 +    @Test(dataProvider = "shortMaskProvider")
 +    static void loadStoreMaskArray(IntFunction<short[]> fa,
 +                                   IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = new short[a.length];
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);
++        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, vmask);
 +                av.intoArray(r, i);
 +            }
 +        }
 +        assertArraysEquals(r, a, mask);
 +
 +
 +        r = new short[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.intoArray(r, i, vmask);
 +            }
 +        }
 +        assertArraysEquals(r, a, mask);
 +    }
 +
 +    @Test(dataProvider = "shortMaskProviderForIOOBE")
 +    static void loadArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = new short[a.length];
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);
++        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = fromArray(a, i, vmask);
 +                av.intoArray(r, i);
 +            }
 +        }
 +
 +        int index = fi.apply(a.length);
 +        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);
 +        try {
 +            fromArray(a, index, vmask);
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortMaskProviderForIOOBE")
 +    static void storeArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = new short[a.length];
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);
++        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                intoArray(av, r, i, vmask);
 +            }
 +        }
 +
 +        int index = fi.apply(a.length);
 +        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);
 +        try {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);
 +            intoArray(av, a, index, vmask);
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +
 +    @Test(dataProvider = "shortMaskProvider")
 +    static void loadStoreMask(IntFunction<short[]> fa,
 +                              IntFunction<boolean[]> fm) {
 +        boolean[] mask = fm.apply(SPECIES.length());
 +        boolean[] r = new boolean[mask.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < mask.length; i += SPECIES.length()) {
-                 VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, i);
++                VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, i);
 +                vmask.intoArray(r, i);
 +            }
 +        }
 +        Assert.assertEquals(r, mask);
 +    }
 +
 +
 +    @Test(dataProvider = "shortMemorySegmentProvider")
 +    static void loadStoreMemorySegment(IntFunction<short[]> fa,
 +                                       IntFunction<MemorySegment> fb,
 +                                       ByteOrder bo) {
 +        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);
 +        MemorySegment r = fb.apply((int) a.byteSize());
 +
 +        int l = (int) a.byteSize();
 +        int s = SPECIES.vectorByteSize();
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < l; i += s) {
 +                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);
 +                av.intoMemorySegment(r, i, bo);
 +            }
 +        }
 +        long m = r.mismatch(a);
 +        Assert.assertEquals(m, -1, "Segments not equal");
 +    }
 +
 +    @Test(dataProvider = "shortByteProviderForIOOBE")
 +    static void loadMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {
-         MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));
-         MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());
++        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));
++        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);
 +
 +        int l = (int) a.byteSize();
 +        int s = SPECIES.vectorByteSize();
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < l; i += s) {
 +                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());
 +                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());
 +            }
 +        }
 +
 +        int index = fi.apply((int) a.byteSize());
 +        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());
 +        try {
 +            fromMemorySegment(a, index, ByteOrder.nativeOrder());
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortByteProviderForIOOBE")
 +    static void storeMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {
-         MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));
-         MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());
++        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));
++        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);
 +
 +        int l = (int) a.byteSize();
 +        int s = SPECIES.vectorByteSize();
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < l; i += s) {
 +                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());
 +                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());
 +            }
 +        }
 +
 +        int index = fi.apply((int) a.byteSize());
 +        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());
 +        try {
 +            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());
 +            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortMemorySegmentMaskProvider")
 +    static void loadStoreMemorySegmentMask(IntFunction<short[]> fa,
 +                                           IntFunction<MemorySegment> fb,
 +                                           IntFunction<boolean[]> fm,
 +                                           ByteOrder bo) {
 +        short[] _a = fa.apply(SPECIES.length());
 +        MemorySegment a = toSegment(_a, fb);
 +        MemorySegment r = fb.apply((int) a.byteSize());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);
++        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);
 +
 +        int l = (int) a.byteSize();
 +        int s = SPECIES.vectorByteSize();
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < l; i += s) {
 +                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, vmask);
 +                av.intoMemorySegment(r, i, bo);
 +            }
 +        }
 +        assertArraysEquals(segmentToArray(r), _a, mask);
 +
 +
 +        r = fb.apply((int) a.byteSize());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < l; i += s) {
 +                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);
 +                av.intoMemorySegment(r, i, bo, vmask);
 +            }
 +        }
 +        assertArraysEquals(segmentToArray(r), _a, mask);
 +    }
 +
 +    @Test(dataProvider = "shortByteMaskProviderForIOOBE")
 +    static void loadMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {
-         MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));
-         MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());
++        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));
++        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);
++        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);
 +
 +        int l = (int) a.byteSize();
 +        int s = SPECIES.vectorByteSize();
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < l; i += s) {
 +                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);
 +                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());
 +            }
 +        }
 +
 +        int index = fi.apply((int) a.byteSize());
 +        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() / 8);
 +        try {
 +            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortByteMaskProviderForIOOBE")
 +    static void storeMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {
-         MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));
-         MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());
++        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));
++        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);
++        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);
 +
 +        int l = (int) a.byteSize();
 +        int s = SPECIES.vectorByteSize();
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < l; i += s) {
 +                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());
 +                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);
 +            }
 +        }
 +
 +        int index = fi.apply((int) a.byteSize());
 +        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() / 8);
 +        try {
 +            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());
 +            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortMemorySegmentProvider")
 +    static void loadStoreReadonlyMemorySegment(IntFunction<short[]> fa,
 +                                               IntFunction<MemorySegment> fb,
 +                                               ByteOrder bo) {
 +        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();
 +
 +        Assert.assertThrows(
 +                UnsupportedOperationException.class,
 +                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)
 +        );
 +
 +        Assert.assertThrows(
 +                UnsupportedOperationException.class,
 +                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))
 +        );
 +
 +        Assert.assertThrows(
 +                UnsupportedOperationException.class,
 +                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))
 +        );
 +
-         VectorMask<Halffloat> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)
++        VectorMask<Float16> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)
 +                .laneIsValid();
 +        Assert.assertThrows(
 +                UnsupportedOperationException.class,
 +                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)
 +        );
 +    }
 +
 +
 +    @Test(dataProvider = "maskProvider")
 +    static void loadStoreMask(IntFunction<boolean[]> fm) {
 +        boolean[] a = fm.apply(SPECIES.length());
 +        boolean[] r = new boolean[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                 VectorMask<Halffloat> vmask = SPECIES.loadMask(a, i);
++                VectorMask<Float16> vmask = SPECIES.loadMask(a, i);
 +                vmask.intoArray(r, i);
 +            }
 +        }
 +        Assert.assertEquals(r, a);
 +    }
 +
 +
-     @Test
-     static void loadStoreShuffle() {
-         IntUnaryOperator fn = a -> a + 5;
-         for (int ic = 0; ic < INVOC_COUNT; ic++) {
-             var shuffle = VectorShuffle.fromOp(SPECIES, fn);
-             int [] r = shuffle.toArray();
++   @Test(dataProvider = "shuffleIntProvider")
++   static void loadStoreShuffleArray(IntFunction<int[]> fa) {
++       int[] a = fa.apply(SPECIES.length());
++       int[] r = new int[a.length];
 +
-             int [] a = expectedShuffle(SPECIES.length(), fn);
-             Assert.assertEquals(r, a);
++       for (int ic = 0; ic < INVOC_COUNT; ic++) {
++           for (int i = 0; i < a.length; i += SPECIES.length()) {
++               VectorShuffle<Float16> shuffle = VectorShuffle.fromArray(SPECIES, a, i);
++               shuffle.intoArray(r, i);
++           }
 +       }
-     }
 +
++       for (int i = 0; i < a.length; i++) {
++          Assert.assertEquals(testPartiallyWrapIndex(SPECIES, a[i]), r[i]);
++       }
++
++   }
++
++   @Test(dataProvider = "shuffleIntProviderForIOOBE")
++   static void storeShuffleArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {
++       int[] a = fa.apply(SPECIES.length());
++       int[] r = new int[a.length];
++
++       for (int ic = 0; ic < INVOC_COUNT; ic++) {
++           for (int i = 0; i < a.length; i += SPECIES.length()) {
++               VectorShuffle<Float16> shuffle = shuffleFromArray(a, i);
++               shuffleIntoArray(shuffle, r, i);
++           }
++       }
++
++       int index = fi.apply(a.length);
++       boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);
++       try {
++           VectorShuffle<Float16> shuffle = shuffleFromArray(a, index);
++           shuffleIntoArray(shuffle, r, index);
++           if (shouldFail) {
++               Assert.fail("Failed to throw IndexOutOfBoundsException");
++           }
++       } catch (IndexOutOfBoundsException e) {
++           if (!shouldFail) {
++               Assert.fail("Unexpected IndexOutOfBoundsException");
++           }
++       }
++   }
++
++   @Test(dataProvider = "shuffleIntProviderForIOOBE")
++   static void loadShuffleArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {
++       int[] a = fa.apply(SPECIES.length());
++       int[] r = new int[a.length];
++
++       for (int ic = 0; ic < INVOC_COUNT; ic++) {
++           for (int i = 0; i < a.length; i += SPECIES.length()) {
++               VectorShuffle<Float16> shuffle = shuffleFromArray(a, i);
++               shuffle.intoArray(r, i);
++           }
++       }
++
++       int index = fi.apply(a.length);
++       boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);
++       try {
++           shuffleFromArray(a, index);
++           if (shouldFail) {
++               Assert.fail("Failed to throw IndexOutOfBoundsException");
++           }
++       } catch (IndexOutOfBoundsException e) {
++           if (!shouldFail) {
++               Assert.fail("Unexpected IndexOutOfBoundsException");
++           }
++       }
++   }
++
++   @Test(dataProvider = "shuffleIntMemorySegmentProvider")
++   static void loadStoreShuffleMemorySegment(IntFunction<int[]> fa,
++                                      IntFunction<MemorySegment> fb,
++                                      ByteOrder bo) {
++       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), fb);
++       MemorySegment r = fb.apply((int) a.byteSize());
++
++       int l = (int) a.byteSize();
++       int s = SPECIES.length() * 4; //An integer for every lane is read out. So 4 bytes per lane
++
++       for (int ic = 0; ic < INVOC_COUNT; ic++) {
++           for (int i = 0; i < l; i += s) {
++               VectorShuffle<Float16> shuffle = VectorShuffle.fromMemorySegment(SPECIES, a, i, bo);
++               shuffle.intoMemorySegment(r, i, bo);
++           }
++       }
++
++       for (int i = 0; i < l / 4; i++) {
++           int ai = a.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED.withOrder(bo), i);
++           int ri = r.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED.withOrder(bo), i);
++           Assert.assertEquals(testPartiallyWrapIndex(SPECIES, ai), ri);
++       }
++   }
++
++   @Test(dataProvider = "shuffleIntByteProviderForIOOBE")
++   static void shuffleLoadMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {
++       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i));
++       MemorySegment r = Arena.ofAuto().allocate(a.byteSize());
++
++       int l = (int) a.byteSize();
++       int s = SPECIES.length() * 4;
++
++       for (int ic = 0; ic < INVOC_COUNT; ic++) {
++           for (int i = 0; i < l; i += s) {
++               VectorShuffle<Float16> shuffle = shuffleFromMemorySegment(a, i, ByteOrder.nativeOrder());
++               shuffle.intoMemorySegment(r, i, ByteOrder.nativeOrder());
++           }
++       }
++
++       int index = fi.apply((int) a.byteSize());
++       boolean shouldFail = isIndexOutOfBounds(s, index, (int) a.byteSize());
++       try {
++           shuffleFromMemorySegment(a, index, ByteOrder.nativeOrder());
++           if (shouldFail) {
++               Assert.fail("Failed to throw IndexOutOfBoundsException");
++           }
++       } catch (IndexOutOfBoundsException e) {
++           if (!shouldFail) {
++               Assert.fail("Unexpected IndexOutOfBoundsException");
++           }
++       }
++   }
++
++   @Test(dataProvider = "shuffleIntByteProviderForIOOBE")
++   static void shuffleStoreMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {
++       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i));
++       MemorySegment r = Arena.ofAuto().allocate(a.byteSize());
++
++       int l = (int) a.byteSize();
++       int s = SPECIES.length() * 4;
++
++       for (int ic = 0; ic < INVOC_COUNT; ic++) {
++           for (int i = 0; i < l; i += s) {
++               VectorShuffle<Float16> shuffle =
++                       VectorShuffle.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());
++               shuffleIntoMemorySegment(shuffle, r, i, ByteOrder.nativeOrder());
++           }
++       }
++
++       int index = fi.apply((int) a.byteSize());
++       boolean shouldFail = isIndexOutOfBounds(s, index, (int) a.byteSize());
++       try {
++           VectorShuffle<Float16> shuffle =
++                   VectorShuffle.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());
++           shuffleIntoMemorySegment(shuffle, r, index, ByteOrder.nativeOrder());
++           if (shouldFail) {
++               Assert.fail("Failed to throw IndexOutOfBoundsException");
++           }
++       } catch (IndexOutOfBoundsException e) {
++           if (!shouldFail) {
++               Assert.fail("Unexpected IndexOutOfBoundsException");
++           }
++       }
++   }
 +
 +
 +
 +
 +    // Gather/Scatter load/store tests
 +
 +    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {
 +        int i = 0;
 +        int j = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                j = i;
 +                for (; j < i + SPECIES.length(); j++) {
 +                    Assert.assertEquals(r[j], a[i + indexMap[j]]);
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[j], a[i + indexMap[j]], "at index #" + j);
 +        }
 +    }
 +
 +    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {
 +        int i = 0;
 +        int j = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                j = i;
 +                for (; j < i + SPECIES.length(); j++) {
 +                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, "at index #" + j);
 +        }
 +    }
 +
 +    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {
 +        short[] expected = new short[r.length];
 +
 +        // Store before checking, since the same location may be stored to more than once
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            for (int j = i; j < i + SPECIES.length(); j++) {
 +                if (mask[j % SPECIES.length()]) {
 +                    expected[i + indexMap[j]] = a[j];
 +                }
 +            }
 +        }
 +
 +        Assert.assertEquals(r, expected);
 +    }
 +
 +    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {
 +        short[] expected = new short[r.length];
 +
 +        // Store before checking, since the same location may be stored to more than once
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            for (int j = i; j < i + SPECIES.length(); j++) {
 +                expected[i + indexMap[j]] = a[j];
 +            }
 +        }
 +
 +        Assert.assertEquals(r, expected);
 +    }
 +
 +    @DataProvider
 +    public Object[][] gatherScatterProvider() {
 +        return INT_INDEX_GENERATORS.stream().
 +                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                    return new Object[] {fa, fs};
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] gatherScatterMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->
 +            HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                    return new Object[] {fa, fm, fs};
 +            }))).
 +            toArray(Object[][]::new);
 +    }
 +
 +
 +    @Test(dataProvider = "gatherScatterProvider")
 +    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {
 +        short[] a = fa.apply(SPECIES.length());
 +        int[] b = fs.apply(a.length, SPECIES.length());
 +        short[] r = new short[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i);
 +                av.intoArray(r, i);
 +            }
 +        }
 +
 +        assertGatherArraysEquals(r, a, b);
 +    }
 +
 +    @Test(dataProvider = "gatherScatterMaskProvider")
 +    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        int[] b = fs.apply(a.length, SPECIES.length());
 +        short[] r = new short[a.length];
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i, vmask);
 +                av.intoArray(r, i);
 +            }
 +        }
 +
 +        assertGatherArraysEquals(r, a, b, mask);
 +    }
 +
 +    @Test(dataProvider = "gatherScatterProvider")
 +    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {
 +        short[] a = fa.apply(SPECIES.length());
 +        int[] b = fs.apply(a.length, SPECIES.length());
 +        short[] r = new short[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.intoArray(r, i, b, i);
 +            }
 +        }
 +
 +        assertScatterArraysEquals(r, a, b);
 +    }
 +
 +    @Test(dataProvider = "gatherScatterMaskProvider")
 +    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        int[] b = fs.apply(a.length, SPECIES.length());
 +        short[] r = new short[a.length];
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.intoArray(r, i, b, i, vmask);
 +            }
 +        }
 +
 +        assertScatterArraysEquals(r, a, b, mask);
 +    }
 +
 +
 +
 +}
diff --cc test/jdk/jdk/incubator/vector/Halffloat64VectorTests.java
index 13ba6f5bbb7,00000000000..d3a2305b6fe
mode 100644,000000..100644
--- a/test/jdk/jdk/incubator/vector/Halffloat64VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Halffloat64VectorTests.java
@@@ -1,3134 -1,0 +1,3256 @@@
 +/*
-  * Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
 + * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 + *
 + * This code is free software; you can redistribute it and/or modify it
 + * under the terms of the GNU General Public License version 2 only, as
 + * published by the Free Software Foundation.
 + *
 + * This code is distributed in the hope that it will be useful, but WITHOUT
 + * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 + * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 + * version 2 for more details (a copy is included in the LICENSE file that
 + * accompanied this code).
 + *
 + * You should have received a copy of the GNU General Public License version
 + * 2 along with this work; if not, write to the Free Software Foundation,
 + * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 + *
 + * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 + * or visit www.oracle.com if you need additional information or have any
 + * questions.
 + */
 +
 +/*
 + * @test
++ * @key randomness
++ *
++ * @library /test/lib
 + * @modules jdk.incubator.vector
-  * @run testng/othervm -ea -esa -Xbatch -XX:-TieredCompilation Halffloat64VectorTests
++ * @run testng/othervm/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Halffloat64VectorTests
 + */
 +
 +// -- This file was mechanically generated: Do not edit! -- //
 +
 +import jdk.incubator.vector.VectorShape;
 +import jdk.incubator.vector.VectorSpecies;
 +import jdk.incubator.vector.VectorShuffle;
 +import jdk.incubator.vector.VectorMask;
 +import jdk.incubator.vector.VectorOperators;
 +import jdk.incubator.vector.Vector;
 +
- import jdk.incubator.vector.Halffloat;
++import jdk.incubator.vector.Float16;
 +import jdk.incubator.vector.HalffloatVector;
 +
 +import org.testng.Assert;
 +import org.testng.annotations.DataProvider;
 +import org.testng.annotations.Test;
 +
 +import java.lang.Integer;
 +import java.util.List;
 +import java.util.Arrays;
 +import java.util.function.BiFunction;
 +import java.util.function.IntFunction;
 +import java.util.Objects;
 +import java.util.stream.Collectors;
 +import java.util.stream.Stream;
 +
 +@Test
 +public class Halffloat64VectorTests extends AbstractVectorTest {
 +
-     static final VectorSpecies<Halffloat> SPECIES =
++    static final VectorSpecies<Float16> SPECIES =
 +                HalffloatVector.SPECIES_64;
 +
 +    static final int INVOC_COUNT = Integer.getInteger("jdk.incubator.vector.test.loop-iterations", 100);
 +
 +
++    // for floating point addition reduction ops that may introduce rounding errors
++    private static final short RELATIVE_ROUNDING_ERROR_FACTOR_ADD = (short)10.0;
++
++    // for floating point multiplication reduction ops that may introduce rounding errors
++    private static final short RELATIVE_ROUNDING_ERROR_FACTOR_MUL = (short)50.0;
 +
 +    static final int BUFFER_REPS = Integer.getInteger("jdk.incubator.vector.test.buffer-vectors", 25000 / 64);
 +
++    static void assertArraysStrictlyEquals(short[] r, short[] a) {
++        for (int i = 0; i < a.length; i++) {
++            short ir = Float16.shortToRawShortBits(r[i]);
++            short ia = Float16.shortToRawShortBits(a[i]);
++            if (ir != ia) {
++                Assert.fail(String.format("at index #%d, expected = %016X, actual = %016X", i, ia, ir));
++            }
++        }
++    }
++
 +    interface FUnOp {
 +        short apply(short a);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, FUnOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i]), "at index #" + i + ", input = " + a[i]);
 +        }
 +    }
 +
 +    interface FUnArrayOp {
 +        short[] apply(short a);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, FUnArrayOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a[i]));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a[i]);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref, "(ref: " + Arrays.toString(ref)
 +              + ", res: " + Arrays.toString(res)
 +              + "), at index #" + i);
 +        }
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, boolean[] mask, FUnOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], "at index #" + i + ", input = " + a[i] + ", mask = " + mask[i % SPECIES.length()]);
 +        }
 +    }
 +
 +    interface FReductionOp {
 +        short apply(short[] a, int idx);
 +    }
 +
 +    interface FReductionAllOp {
 +        short apply(short[] a);
 +    }
 +
 +    static void assertReductionArraysEquals(short[] r, short rc, short[] a,
 +                                            FReductionOp f, FReductionAllOp fa) {
++        assertReductionArraysEquals(r, rc, a, f, fa, (short)0.0);
++    }
++
++    static void assertReductionArraysEquals(short[] r, short rc, short[] a,
++                                            FReductionOp f, FReductionAllOp fa,
++                                            short relativeErrorFactor) {
 +        int i = 0;
 +        try {
-             Assert.assertEquals(rc, fa.apply(a));
++            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor);
 +            for (; i < a.length; i += SPECIES.length()) {
-                 Assert.assertEquals(r[i], f.apply(a, i));
++                Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor);
 +            }
 +        } catch (AssertionError e) {
-             Assert.assertEquals(rc, fa.apply(a), "Final result is incorrect!");
-             Assert.assertEquals(r[i], f.apply(a, i), "at index #" + i);
++            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor, "Final result is incorrect!");
++            Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor, "at index #" + i);
 +        }
 +    }
 +
 +    interface FReductionMaskedOp {
 +        short apply(short[] a, int idx, boolean[] mask);
 +    }
 +
 +    interface FReductionAllMaskedOp {
 +        short apply(short[] a, boolean[] mask);
 +    }
 +
 +    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,
 +                                            FReductionMaskedOp f, FReductionAllMaskedOp fa) {
++        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, (short)0.0);
++    }
++
++    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,
++                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,
++                                            short relativeError) {
 +        int i = 0;
 +        try {
-             Assert.assertEquals(rc, fa.apply(a, mask));
++            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));
 +            for (; i < a.length; i += SPECIES.length()) {
-                 Assert.assertEquals(r[i], f.apply(a, i, mask));
++                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *
++relativeError));
 +            }
 +        } catch (AssertionError e) {
-             Assert.assertEquals(rc, fa.apply(a, mask), "Final result is incorrect!");
-             Assert.assertEquals(r[i], f.apply(a, i, mask), "at index #" + i);
++            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), "Final result is incorrect!");
++            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), "at index #" + i);
 +        }
 +    }
 +
 +    interface FReductionOpLong {
 +        long apply(short[] a, int idx);
 +    }
 +
 +    interface FReductionAllOpLong {
 +        long apply(short[] a);
 +    }
 +
 +    static void assertReductionLongArraysEquals(long[] r, long rc, short[] a,
 +                                            FReductionOpLong f, FReductionAllOpLong fa) {
 +        int i = 0;
 +        try {
 +            Assert.assertEquals(rc, fa.apply(a));
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(r[i], f.apply(a, i));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(rc, fa.apply(a), "Final result is incorrect!");
 +            Assert.assertEquals(r[i], f.apply(a, i), "at index #" + i);
 +        }
 +    }
 +
 +    interface FReductionMaskedOpLong {
 +        long apply(short[] a, int idx, boolean[] mask);
 +    }
 +
 +    interface FReductionAllMaskedOpLong {
 +        long apply(short[] a, boolean[] mask);
 +    }
 +
 +    static void assertReductionLongArraysEqualsMasked(long[] r, long rc, short[] a, boolean[] mask,
 +                                            FReductionMaskedOpLong f, FReductionAllMaskedOpLong fa) {
 +        int i = 0;
 +        try {
 +            Assert.assertEquals(rc, fa.apply(a, mask));
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(r[i], f.apply(a, i, mask));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(rc, fa.apply(a, mask), "Final result is incorrect!");
 +            Assert.assertEquals(r[i], f.apply(a, i, mask), "at index #" + i);
 +        }
 +    }
 +
 +    interface FBoolReductionOp {
 +        boolean apply(boolean[] a, int idx);
 +    }
 +
 +    static void assertReductionBoolArraysEquals(boolean[] r, boolean[] a, FBoolReductionOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(r[i], f.apply(a, i));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a, i), "at index #" + i);
 +        }
 +    }
 +
 +    interface FMaskReductionOp {
 +        int apply(boolean[] a, int idx);
 +    }
 +
 +    static void assertMaskReductionArraysEquals(int[] r, boolean[] a, FMaskReductionOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(r[i], f.apply(a, i));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a, i), "at index #" + i);
 +        }
 +    }
 +
-     static void assertInsertArraysEquals(short[] r, short[] a, short element, int index, int start, int end) {
-         int i = start;
-         try {
-             for (; i < end; i += 1) {
-                 if(i%SPECIES.length() == index) {
-                     Assert.assertEquals(r[i], element);
-                 } else {
-                     Assert.assertEquals(r[i], a[i]);
-                 }
-             }
-         } catch (AssertionError e) {
-             if (i%SPECIES.length() == index) {
-                 Assert.assertEquals(r[i], element, "at index #" + i);
-             } else {
-                 Assert.assertEquals(r[i], a[i], "at index #" + i);
-             }
-         }
-     }
- 
 +    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, int vector_len) {
 +        int i = 0, j = 0;
 +        try {
 +            for (; i < a.length; i += vector_len) {
 +                for (j = 0; j < vector_len; j++) {
 +                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            int idx = i + j;
 +            Assert.assertEquals(r[i+j], a[i+order[i+j]], "at index #" + idx + ", input = " + a[i+order[i+j]]);
 +        }
 +    }
 +
 +    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {
 +        int i = 0, j = 0, k = 0;
 +        try {
 +            for (; i < a.length; i += vector_len) {
 +                k = 0;
 +                for (j = 0; j < vector_len; j++) {
 +                    if (m[(i + j) % SPECIES.length()]) {
 +                        Assert.assertEquals(r[i + k], a[i + j]);
 +                        k++;
 +                    }
 +                }
 +                for (; k < vector_len; k++) {
 +                    Assert.assertEquals(r[i + k], (short)0);
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            int idx = i + k;
 +            if (m[(i + j) % SPECIES.length()]) {
 +                Assert.assertEquals(r[idx], a[i + j], "at index #" + idx);
 +            } else {
 +                Assert.assertEquals(r[idx], (short)0, "at index #" + idx);
 +            }
 +        }
 +    }
 +
 +    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {
 +        int i = 0, j = 0, k = 0;
 +        try {
 +            for (; i < a.length; i += vector_len) {
 +                k = 0;
 +                for (j = 0; j < vector_len; j++) {
 +                    if (m[(i + j) % SPECIES.length()]) {
 +                        Assert.assertEquals(r[i + j], a[i + k]);
 +                        k++;
 +                    } else {
 +                        Assert.assertEquals(r[i + j], (short)0);
 +                    }
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            int idx = i + j;
 +            if (m[idx % SPECIES.length()]) {
 +                Assert.assertEquals(r[idx], a[i + k], "at index #" + idx);
 +            } else {
 +                Assert.assertEquals(r[idx], (short)0, "at index #" + idx);
 +            }
 +        }
 +    }
 +
++    static void assertSelectFromTwoVectorEquals(short[] r, short[] order, short[] a, short[] b, int vector_len) {
++        int i = 0, j = 0;
++        boolean is_exceptional_idx = false;
++        int idx = 0, wrapped_index = 0, oidx = 0;
++        try {
++            for (; i < a.length; i += vector_len) {
++                for (j = 0; j < vector_len; j++) {
++                    idx = i + j;
++                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);
++                    is_exceptional_idx = wrapped_index >= vector_len;
++                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;
++                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));
++                }
++            }
++        } catch (AssertionError e) {
++            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), "at index #" + idx + ", order = " + order[idx] + ", a = " + a[i + oidx] + ", b = " + b[i + oidx]);
++        }
++    }
++
 +    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, int vector_len) {
 +        int i = 0, j = 0;
 +        try {
 +            for (; i < a.length; i += vector_len) {
 +                for (j = 0; j < vector_len; j++) {
 +                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            int idx = i + j;
 +            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], "at index #" + idx + ", input = " + a[i+(int)order[i+j]]);
 +        }
 +    }
 +
 +    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, boolean[] mask, int vector_len) {
 +        int i = 0, j = 0;
 +        try {
 +            for (; i < a.length; i += vector_len) {
 +                for (j = 0; j < vector_len; j++) {
 +                    if (mask[j % SPECIES.length()])
 +                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);
 +                    else
 +                         Assert.assertEquals(r[i+j], (short)0);
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            int idx = i + j;
 +            if (mask[j % SPECIES.length()])
 +                Assert.assertEquals(r[i+j], a[i+order[i+j]], "at index #" + idx + ", input = " + a[i+order[i+j]] + ", mask = " + mask[j % SPECIES.length()]);
 +            else
 +                Assert.assertEquals(r[i+j], (short)0, "at index #" + idx + ", input = " + a[i+order[i+j]] + ", mask = " + mask[j % SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, boolean[] mask, int vector_len) {
 +        int i = 0, j = 0;
 +        try {
 +            for (; i < a.length; i += vector_len) {
 +                for (j = 0; j < vector_len; j++) {
 +                    if (mask[j % SPECIES.length()])
 +                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);
 +                    else
 +                         Assert.assertEquals(r[i+j], (short)0);
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            int idx = i + j;
 +            if (mask[j % SPECIES.length()])
 +                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], "at index #" + idx + ", input = " + a[i+(int)order[i+j]] + ", mask = " + mask[j % SPECIES.length()]);
 +            else
 +                Assert.assertEquals(r[i+j], (short)0, "at index #" + idx + ", input = " + a[i+(int)order[i+j]] + ", mask = " + mask[j % SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertBroadcastArraysEquals(short[] r, short[] a) {
 +        int i = 0;
 +        for (; i < a.length; i += SPECIES.length()) {
 +            int idx = i;
 +            for (int j = idx; j < (idx + SPECIES.length()); j++)
 +                a[j]=a[idx];
 +        }
 +
 +        try {
 +            for (i = 0; i < a.length; i++) {
 +                Assert.assertEquals(r[i], a[i]);
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], a[i], "at index #" + i + ", input = " + a[i]);
 +        }
 +    }
 +
 +    interface FBinOp {
 +        short apply(short a, short b);
 +    }
 +
 +    interface FBinMaskOp {
 +        short apply(short a, short b, boolean m);
 +
 +        static FBinMaskOp lift(FBinOp f) {
 +            return (a, b, m) -> m ? f.apply(a, b) : a;
 +        }
 +    }
 +
++    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, FBinOp f) {
++        int i = 0;
++        try {
++            for (; i < a.length; i++) {
++                //Left associative
++                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));
++
++                //Right associative
++                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));
++
++                //Results equal sanity check
++                Assert.assertEquals(rl[i], rr[i]);
++            }
++        } catch (AssertionError e) {
++            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), "left associative test at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", input3 = " + c[i]);
++            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), "right associative test at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", input3 = " + c[i]);
++            Assert.assertEquals(rl[i], rr[i], "Result checks not equal at index #" + i + "leftRes = " + rl[i] + ", rightRes = " + rr[i]);
++        }
++    }
++
++   static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinOp f) {
++       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));
++   }
++
++    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinMaskOp f) {
++        int i = 0;
++        boolean mask_bit = false;
++        try {
++            for (; i < a.length; i++) {
++                mask_bit = mask[i % SPECIES.length()];
++                //Left associative
++                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));
++
++                //Right associative
++                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));
++
++                //Results equal sanity check
++                Assert.assertEquals(rl[i], rr[i]);
++            }
++        } catch (AssertionError e) {
++            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), "left associative masked test at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", input3 = " + c[i] + ", mask = " + mask_bit);
++            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), "right associative masked test at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", input3 = " + c[i] + ", mask = " + mask_bit);
++            Assert.assertEquals(rl[i], rr[i], "Result checks not equal at index #" + i + "leftRes = " + rl[i] + ", rightRes = " + rr[i]);
++        }
++    }
++
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[i]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[i]), "(" + a[i] + ", " + b[i] + ") at index #" + i);
 +        }
 +    }
 +
++    static void assertArraysEquals(short[] r, short[] a, short b, FBinOp f) {
++        int i = 0;
++        try {
++            for (; i < a.length; i++) {
++                Assert.assertEquals(r[i], f.apply(a[i], b));
++            }
++        } catch (AssertionError e) {
++            Assert.assertEquals(r[i], f.apply(a[i], b), "(" + a[i] + ", " + b + ") at index #" + i);
++        }
++    }
++
 +    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()]),
 +                                "(" + a[i] + ", " + b[(i / SPECIES.length()) * SPECIES.length()] + ") at index #" + i);
 +        }
 +    }
 +
 +    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i / SPECIES.length()) * SPECIES.length()])));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i / SPECIES.length()) * SPECIES.length()])),
 +                                "(" + a[i] + ", " + b[(i / SPECIES.length()) * SPECIES.length()] + ") at index #" + i);
 +        }
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {
 +        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), "at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", mask = " + mask[i % SPECIES.length()]);
 +        }
 +    }
 +
++    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinOp f) {
++        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));
++    }
++
++    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinMaskOp f) {
++        int i = 0;
++        try {
++            for (; i < a.length; i++) {
++                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));
++            }
++        } catch (AssertionError err) {
++            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), "at index #" + i + ", input1 = " + a[i] + ", input2 = " + b + ", mask = " + mask[i % SPECIES.length()]);
++        }
++    }
++
 +    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {
 +        assertBroadcastArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));
 +    }
 +
 +    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()],
 +                                mask[i % SPECIES.length()]), "at index #" + i + ", input1 = " + a[i] +
 +                                ", input2 = " + b[(i / SPECIES.length()) * SPECIES.length()] + ", mask = " +
 +                                mask[i % SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {
 +        assertBroadcastLongArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));
 +    }
 +
 +    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i / SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i / SPECIES.length()) * SPECIES.length()]),
 +                                mask[i % SPECIES.length()]), "at index #" + i + ", input1 = " + a[i] +
 +                                ", input2 = " + b[(i / SPECIES.length()) * SPECIES.length()] + ", mask = " +
 +                                mask[i % SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {
 +        int i = 0;
 +        int j = 0;
 +        try {
 +            for (; j < a.length; j += SPECIES.length()) {
 +                for (i = 0; i < SPECIES.length(); i++) {
 +                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), "at index #" + i + ", " + j);
 +        }
 +    }
 +
 +    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {
 +        assertShiftArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));
 +    }
 +
 +    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {
 +        int i = 0;
 +        int j = 0;
 +        try {
 +            for (; j < a.length; j += SPECIES.length()) {
 +                for (i = 0; i < SPECIES.length(); i++) {
 +                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));
 +                }
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), "at index #" + i + ", input1 = " + a[i+j] + ", input2 = " + b[j] + ", mask = " + mask[i]);
 +        }
 +    }
 +
 +    interface FBinConstOp {
 +        short apply(short a);
 +    }
 +
 +    interface FBinConstMaskOp {
 +        short apply(short a, boolean m);
 +
 +        static FBinConstMaskOp lift(FBinConstOp f) {
 +            return (a, m) -> m ? f.apply(a) : a;
 +        }
 +    }
 +
 +    static void assertShiftConstEquals(short[] r, short[] a, FBinConstOp f) {
 +        int i = 0;
 +        int j = 0;
 +        try {
 +            for (; j < a.length; j += SPECIES.length()) {
 +                for (i = 0; i < SPECIES.length(); i++) {
 +                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i+j], f.apply(a[i+j]), "at index #" + i + ", " + j);
 +        }
 +    }
 +
 +    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstOp f) {
 +        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));
 +    }
 +
 +    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstMaskOp f) {
 +        int i = 0;
 +        int j = 0;
 +        try {
 +            for (; j < a.length; j += SPECIES.length()) {
 +                for (i = 0; i < SPECIES.length(); i++) {
 +                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));
 +                }
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), "at index #" + i + ", input1 = " + a[i+j] + ", mask = " + mask[i]);
 +        }
 +    }
 +
 +    interface FTernOp {
 +        short apply(short a, short b, short c);
 +    }
 +
 +    interface FTernMaskOp {
 +        short apply(short a, short b, short c, boolean m);
 +
 +        static FTernMaskOp lift(FTernOp f) {
 +            return (a, b, c, m) -> m ? f.apply(a, b, c) : a;
 +        }
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), "at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", input3 = " + c[i]);
 +        }
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernOp f) {
 +        assertArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernMaskOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), "at index #" + i + ", input1 = " + a[i] + ", input2 = "
 +              + b[i] + ", input3 = " + c[i] + ", mask = " + mask[i % SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i / SPECIES.length()) * SPECIES.length()]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i / SPECIES.length()) * SPECIES.length()]), "at index #" +
 +                                i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", input3 = " +
 +                                c[(i / SPECIES.length()) * SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()], c[i]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()], c[i]), "at index #" +
 +                                i + ", input1 = " + a[i] + ", input2 = " +
 +                                b[(i / SPECIES.length()) * SPECIES.length()] + ",  input3 = " + c[i]);
 +        }
 +    }
 +
 +    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,
 +                                            FTernOp f) {
 +        assertBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));
 +    }
 +
 +    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,
 +                                            FTernMaskOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i / SPECIES.length()) * SPECIES.length()],
 +                                    mask[i % SPECIES.length()]));
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i / SPECIES.length()) * SPECIES.length()],
 +                                mask[i % SPECIES.length()]), "at index #" + i + ", input1 = " + a[i] + ", input2 = " +
 +                                b[i] + ", input3 = " + c[(i / SPECIES.length()) * SPECIES.length()] + ", mask = " +
 +                                mask[i % SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,
 +                                            FTernOp f) {
 +        assertAltBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));
 +    }
 +
 +    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,
 +                                            FTernMaskOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()], c[i],
 +                                    mask[i % SPECIES.length()]));
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()], c[i],
 +                                mask[i % SPECIES.length()]), "at index #" + i + ", input1 = " + a[i] +
 +                                ", input2 = " + b[(i / SPECIES.length()) * SPECIES.length()] +
 +                                ", input3 = " + c[i] + ", mask = " + mask[i % SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()],
 +                                    c[(i / SPECIES.length()) * SPECIES.length()]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()],
 +                                c[(i / SPECIES.length()) * SPECIES.length()]), "at index #" + i + ", input1 = " + a[i]
 +                                + ", input2 = " + b[(i / SPECIES.length()) * SPECIES.length()] + ", input3 = " +
 +                                c[(i / SPECIES.length()) * SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,
 +                                                  FTernOp f) {
 +        assertDoubleBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));
 +    }
 +
 +    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,
 +                                                  FTernMaskOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()],
 +                                    c[(i / SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()],
 +                                c[(i / SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]), "at index #"
 +                                + i + ", input1 = " + a[i] + ", input2 = " + b[(i / SPECIES.length()) * SPECIES.length()] +
 +                                ", input3 = " + c[(i / SPECIES.length()) * SPECIES.length()] + ", mask = " +
 +                                mask[i % SPECIES.length()]);
 +        }
 +    }
 +
 +
 +    static boolean isWithin1Ulp(short actual, short expected) {
 +        float act = Float.float16ToFloat(actual);
 +        float exp = Float.float16ToFloat(expected);
 +        if (Float.isNaN(exp) && !Float.isNaN(act)) {
 +            return false;
 +        } else if (!Float.isNaN(exp) && Float.isNaN(act)) {
 +             return false;
 +        }
 +
 +        float low = Math.nextDown(exp);
 +        float high = Math.nextUp(exp);
 +
 +        if (Float.compare(low, exp) > 0) {
 +            return false;
 +        }
 +
 +        if (Float.compare(high, exp) < 0) {
 +            return false;
 +        }
 +
 +        return true;
 +    }
 +
 +    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, FUnOp mathf, FUnOp strictmathf) {
 +        int i = 0;
 +        try {
 +            // Check that result is within 1 ulp of strict math or equivalent to math implementation.
 +            for (; i < a.length; i++) {
 +                Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i])) == 0 ||
 +                                    isWithin1Ulp(r[i], strictmathf.apply(a[i])));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i])) == 0, "at index #" + i + ", input = " + a[i] + ", actual = " + r[i] + ", expected = " + mathf.apply(a[i]));
 +            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i])), "at index #" + i + ", input = " + a[i] + ", actual = " + r[i] + ", expected (within 1 ulp) = " + strictmathf.apply(a[i]));
 +        }
 +    }
 +
 +    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b, FBinOp mathf, FBinOp strictmathf) {
 +        int i = 0;
 +        try {
 +            // Check that result is within 1 ulp of strict math or equivalent to math implementation.
 +            for (; i < a.length; i++) {
 +                Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i], b[i])) == 0 ||
 +                                    isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i], b[i])) == 0, "at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", actual = " + r[i] + ", expected = " + mathf.apply(a[i], b[i]));
 +            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])), "at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", actual = " + r[i] + ", expected (within 1 ulp) = " + strictmathf.apply(a[i], b[i]));
 +        }
 +    }
 +
 +    static void assertBroadcastArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b,
 +                                                        FBinOp mathf, FBinOp strictmathf) {
 +        int i = 0;
 +        try {
 +            // Check that result is within 1 ulp of strict math or equivalent to math implementation.
 +            for (; i < a.length; i++) {
 +                Assert.assertTrue(Halffloat.compare(r[i],
 +                                  mathf.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()])) == 0 ||
 +                                  isWithin1Ulp(r[i],
 +                                  strictmathf.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()])));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertTrue(Halffloat.compare(r[i],
 +                              mathf.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()])) == 0,
 +                              "at index #" + i + ", input1 = " + a[i] + ", input2 = " +
 +                              b[(i / SPECIES.length()) * SPECIES.length()] + ", actual = " + r[i] +
 +                              ", expected = " + mathf.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()]));
 +            Assert.assertTrue(isWithin1Ulp(r[i],
 +                              strictmathf.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()])),
 +                             "at index #" + i + ", input1 = " + a[i] + ", input2 = " +
 +                             b[(i / SPECIES.length()) * SPECIES.length()] + ", actual = " + r[i] +
 +                             ", expected (within 1 ulp) = " + strictmathf.apply(a[i],
 +                             b[(i / SPECIES.length()) * SPECIES.length()]));
 +        }
 +    }
 +
-     interface FBinArrayOp {
-         short apply(short[] a, int b);
-     }
- 
-     static void assertArraysEquals(short[] r, short[] a, FBinArrayOp f) {
-         int i = 0;
-         try {
-             for (; i < a.length; i++) {
-                 Assert.assertEquals(r[i], f.apply(a, i));
-             }
-         } catch (AssertionError e) {
-             Assert.assertEquals(r[i], f.apply(a,i), "at index #" + i);
-         }
-     }
- 
 +    interface FGatherScatterOp {
 +        short[] apply(short[] a, int ix, int[] b, int iy);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, int[] b, FGatherScatterOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a, i, b, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a, i, b, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref,
 +              "(ref: " + Arrays.toString(ref) + ", res: " + Arrays.toString(res) + ", a: "
 +              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))
 +              + ", b: "
 +              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))
 +              + " at index #" + i);
 +        }
 +    }
 +
 +    interface FGatherMaskedOp {
 +        short[] apply(short[] a, int ix, boolean[] mask, int[] b, int iy);
 +    }
 +
 +    interface FScatterMaskedOp {
 +        short[] apply(short[] r, short[] a, int ix, boolean[] mask, int[] b, int iy);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FGatherMaskedOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a, i, mask, b, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a, i, mask, b, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref,
 +              "(ref: " + Arrays.toString(ref) + ", res: " + Arrays.toString(res) + ", a: "
 +              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))
 +              + ", b: "
 +              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))
 +              + ", mask: "
 +              + Arrays.toString(mask)
 +              + " at index #" + i);
 +        }
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FScatterMaskedOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(r, a, i, mask, b, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(r, a, i, mask, b, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref,
 +              "(ref: " + Arrays.toString(ref) + ", res: " + Arrays.toString(res) + ", a: "
 +              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))
 +              + ", b: "
 +              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))
 +              + ", r: "
 +              + Arrays.toString(Arrays.copyOfRange(r, i, i+SPECIES.length()))
 +              + ", mask: "
 +              + Arrays.toString(mask)
 +              + " at index #" + i);
 +        }
 +    }
 +
 +    interface FLaneOp {
 +        short[] apply(short[] a, int origin, int idx);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, int origin, FLaneOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a, origin, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a, origin, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref, "(ref: " + Arrays.toString(ref)
 +              + ", res: " + Arrays.toString(res)
 +              + "), at index #" + i);
 +        }
 +    }
 +
 +    interface FLaneBop {
 +        short[] apply(short[] a, short[] b, int origin, int idx);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, FLaneBop f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a, b, origin, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a, b, origin, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref, "(ref: " + Arrays.toString(ref)
 +              + ", res: " + Arrays.toString(res)
 +              + "), at index #" + i
 +              + ", at origin #" + origin);
 +        }
 +    }
 +
 +    interface FLaneMaskedBop {
 +        short[] apply(short[] a, short[] b, int origin, boolean[] mask, int idx);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, boolean[] mask, FLaneMaskedBop f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a, b, origin, mask, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a, b, origin, mask, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref, "(ref: " + Arrays.toString(ref)
 +              + ", res: " + Arrays.toString(res)
 +              + "), at index #" + i
 +              + ", at origin #" + origin);
 +        }
 +    }
 +
 +    interface FLanePartBop {
 +        short[] apply(short[] a, short[] b, int origin, int part, int idx);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, FLanePartBop f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a, b, origin, part, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a, b, origin, part, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref, "(ref: " + Arrays.toString(ref)
 +              + ", res: " + Arrays.toString(res)
 +              + "), at index #" + i
 +              + ", at origin #" + origin
 +              + ", with part #" + part);
 +        }
 +    }
 +
 +    interface FLanePartMaskedBop {
 +        short[] apply(short[] a, short[] b, int origin, int part, boolean[] mask, int idx);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, boolean[] mask, FLanePartMaskedBop f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a, b, origin, part, mask, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a, b, origin, part, mask, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref, "(ref: " + Arrays.toString(ref)
 +              + ", res: " + Arrays.toString(res)
 +              + "), at index #" + i
 +              + ", at origin #" + origin
 +              + ", with part #" + part);
 +        }
 +    }
 +
 +    static short genValue(int i) {
-         return (short) Halffloat.valueOf(i);
++        return Float16.float16ToRawShortBits(Float16.valueOf(i));
 +    }
 +
 +    static int intCornerCaseValue(int i) {
 +        switch(i % 5) {
 +            case 0:
 +                return Integer.MAX_VALUE;
 +            case 1:
 +                return Integer.MIN_VALUE;
 +            case 2:
 +                return Integer.MIN_VALUE;
 +            case 3:
 +                return Integer.MAX_VALUE;
 +            default:
 +                return (int)0;
 +        }
 +    }
 +
 +    static final List<IntFunction<short[]>> INT_HALFFLOAT_GENERATORS = List.of(
-             withToString("Halffloat[-i * 5]", (int s) -> {
++            withToString("Float16[-i * 5]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> genValue(-i * 5));
 +            }),
-             withToString("Halffloat[i * 5]", (int s) -> {
++            withToString("Float16[i * 5]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> genValue(i * 5));
 +            }),
-             withToString("Halffloat[i + 1]", (int s) -> {
++            withToString("Float16[i + 1]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
 +            }),
-             withToString("Halffloat[intCornerCaseValue(i)]", (int s) -> {
++            withToString("Float16[intCornerCaseValue(i)]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (short)intCornerCaseValue(i));
 +            })
 +    );
 +
 +    static void assertArraysEquals(int[] r, short[] a, int offs) {
 +        int i = 0;
 +        try {
 +            for (; i < r.length; i++) {
 +                Assert.assertEquals(r[i], (int)Float.float16ToFloat(a[i+offs]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], (int)(a[i+offs]), "at index #" + i + ", input = " + a[i+offs]);
 +        }
 +    }
 +
 +    static long longCornerCaseValue(int i) {
 +        switch(i % 5) {
 +            case 0:
 +                return Long.MAX_VALUE;
 +            case 1:
 +                return Long.MIN_VALUE;
 +            case 2:
 +                return Long.MIN_VALUE;
 +            case 3:
 +                return Long.MAX_VALUE;
 +            default:
 +                return (long)0;
 +        }
 +    }
 +
 +    static short genValue(long i) {
-         return (short) Halffloat.valueOf(i);
++        return Float16.float16ToRawShortBits(Float16.valueOf(i));
 +    }
 +
 +    static final List<IntFunction<short[]>> LONG_HALFFLOAT_GENERATORS = List.of(
-             withToString("Halffloat[-i * 5]", (int s) -> {
++            withToString("Float16[-i * 5]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> genValue(-i * 5));
 +            }),
-             withToString("Halffloat[i * 5]", (int s) -> {
++            withToString("Float16[i * 5]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> genValue(i * 5));
 +            }),
-             withToString("Halffloat[i + 1]", (int s) -> {
++            withToString("Float16[i + 1]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
 +            }),
-             withToString("Halffloat[cornerCaseValue(i)]", (int s) -> {
++            withToString("Float16[cornerCaseValue(i)]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (short)longCornerCaseValue(i));
 +            })
 +    );
 +
 +
 +    static void assertArraysEquals(long[] r, short[] a, int offs) {
 +        int i = 0;
 +        try {
 +            for (; i < r.length; i++) {
 +                Assert.assertEquals(r[i], (long)Float.float16ToFloat(a[i+offs]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], (long)(a[i+offs]), "at index #" + i + ", input = " + a[i+offs]);
 +        }
 +    }
 +
 +    static void assertArraysEquals(double[] r, short[] a, int offs) {
 +        int i = 0;
 +        try {
 +            for (; i < r.length; i++) {
 +                Assert.assertEquals(r[i], (double)Float.float16ToFloat(a[i+offs]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], (double)(a[i+offs]), "at index #" + i + ", input = " + a[i+offs]);
 +        }
 +    }
 +
 +    static short bits(short e) {
-         return  Halffloat.shortToShortBits(e);
++        return  Float16.shortToShortBits(e);
 +    }
 +
 +    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(
-             withToString("Halffloat[-i * 5]", (int s) -> {
++            withToString("Float16[-i * 5]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> genValue(-i * 5));
 +            }),
-             withToString("Halffloat[i * 5]", (int s) -> {
++            withToString("Float16[i * 5]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> genValue(i * 5));
 +            }),
-             withToString("Halffloat[i + 1]", (int s) -> {
++            withToString("Float16[i + 1]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
 +            }),
-             withToString("Halffloat[cornerCaseValue(i)]", (int s) -> {
++            withToString("short[0.01 + (i / (i + 1))]", (int s) -> {
++                return fill(s * BUFFER_REPS,
++                            i -> (short)0.01 + ((short)i / (i + 1)));
++            }),
++            withToString("short[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i / (i + 1))]", (int s) -> {
++                return fill(s * BUFFER_REPS,
++                            i -> i % 17 == 0 ? cornerCaseValue(i) : (short)0.01 + ((short)i / (i + 1)));
++            }),
++            withToString("short[cornerCaseValue(i)]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> cornerCaseValue(i));
 +            })
 +    );
 +
 +    // Create combinations of pairs
 +    // @@@ Might be sensitive to order e.g. div by 0
 +    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_PAIRS =
 +        Stream.of(HALFFLOAT_GENERATORS.get(0)).
 +                flatMap(fa -> HALFFLOAT_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).
 +                collect(Collectors.toList());
 +
 +    @DataProvider
 +    public Object[][] boolUnaryOpProvider() {
 +        return BOOL_ARRAY_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_TRIPLES =
 +        HALFFLOAT_GENERATOR_PAIRS.stream().
 +                flatMap(pair -> HALFFLOAT_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).
 +                collect(Collectors.toList());
 +
++    static final List<IntFunction<short[]>> SELECT_FROM_INDEX_GENERATORS = List.of(
++            withToString("short[0..VECLEN*2)", (int s) -> {
++                return fill(s * BUFFER_REPS,
++                            i -> (short)(RAND.nextInt()));
++            })
++    );
++
++    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_SELECT_FROM_TRIPLES =
++        HALFFLOAT_GENERATOR_PAIRS.stream().
++                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).
++                collect(Collectors.toList());
++
 +    @DataProvider
 +    public Object[][] shortBinaryOpProvider() {
 +        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortIndexedOpProvider() {
 +        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortBinaryOpMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_GENERATOR_PAIRS.stream().map(lfa -> {
 +                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortTernaryOpProvider() {
 +        return HALFFLOAT_GENERATOR_TRIPLES.stream().map(List::toArray).
 +                toArray(Object[][]::new);
 +    }
 +
++    @DataProvider
++    public Object[][] shortSelectFromTwoVectorOpProvider() {
++        return HALFFLOAT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).
++                toArray(Object[][]::new);
++    }
++
 +    @DataProvider
 +    public Object[][] shortTernaryOpMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_GENERATOR_TRIPLES.stream().map(lfa -> {
 +                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortUnaryOpProvider() {
 +        return HALFFLOAT_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortUnaryOpMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                    return new Object[] {fa, fm};
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shorttoIntUnaryOpProvider() {
 +        return INT_HALFFLOAT_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shorttoLongUnaryOpProvider() {
 +        return LONG_HALFFLOAT_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] maskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] maskCompareOpProvider() {
 +        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shuffleProvider() {
 +        return INT_SHUFFLE_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shuffleCompareOpProvider() {
 +        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortUnaryOpShuffleProvider() {
 +        return INT_SHUFFLE_GENERATORS.stream().
 +                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                    return new Object[] {fa, fs};
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortUnaryOpShuffleMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> INT_SHUFFLE_GENERATORS.stream().
 +                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                        return new Object[] {fa, fs, fm};
 +                }))).
 +                toArray(Object[][]::new);
 +    }
 +
 +    static final List<BiFunction<Integer,Integer,short[]>> HALFFLOAT_SHUFFLE_GENERATORS = List.of(
 +            withToStringBi("shuffle[random]", (Integer l, Integer m) -> {
 +                short[] a = new short[l];
 +                int upper = m;
 +                for (int i = 0; i < 1; i++) {
 +                    a[i] = (short)RAND.nextInt(upper);
 +                }
 +                return a;
 +            })
 +    );
 +
 +    @DataProvider
 +    public Object[][] shortUnaryOpSelectFromProvider() {
 +        return HALFFLOAT_SHUFFLE_GENERATORS.stream().
 +                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                    return new Object[] {fa, fs};
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortUnaryOpSelectFromMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_SHUFFLE_GENERATORS.stream().
 +                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                        return new Object[] {fa, fs, fm};
 +                }))).
 +                toArray(Object[][]::new);
 +    }
 +
 +    static final List<IntFunction<short[]>> HALFFLOAT_COMPARE_GENERATORS = List.of(
 +            withToString("short[i]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (short)i);
 +            }),
 +            withToString("short[i - length / 2]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (short)(i - (s * BUFFER_REPS / 2)));
 +            }),
 +            withToString("short[i + 1]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (short)(i + 1));
 +            }),
 +            withToString("short[i - 2]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (short)(i - 2));
 +            }),
 +            withToString("short[zigZag(i)]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> i%3 == 0 ? (short)i : (i%3 == 1 ? (short)(i + 1) : (short)(i - 2)));
 +            }),
 +            withToString("short[cornerCaseValue(i)]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> cornerCaseValue(i));
 +            })
 +    );
 +
 +    static final List<List<IntFunction<short[]>>> HALFFLOAT_TEST_GENERATOR_ARGS =
 +        HALFFLOAT_COMPARE_GENERATORS.stream().
 +                map(fa -> List.of(fa)).
 +                collect(Collectors.toList());
 +
 +    @DataProvider
 +    public Object[][] shortTestOpProvider() {
 +        return HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(List::toArray).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortTestOpMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(lfa -> {
 +                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    static final List<List<IntFunction<short[]>>> HALFFLOAT_COMPARE_GENERATOR_PAIRS =
 +        HALFFLOAT_COMPARE_GENERATORS.stream().
 +                flatMap(fa -> HALFFLOAT_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).
 +                collect(Collectors.toList());
 +
 +    @DataProvider
 +    public Object[][] shortCompareOpProvider() {
 +        return HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortCompareOpMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {
 +                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    interface ToHalffloatF {
 +        short apply(int i);
 +    }
 +
 +    static short[] fill(int s , ToHalffloatF f) {
 +        return fill(new short[s], f);
 +    }
 +
 +    static short[] fill(short[] a, ToHalffloatF f) {
 +        for (int i = 0; i < a.length; i++) {
 +            a[i] = f.apply(i);
 +        }
 +        return a;
 +    }
 +
 +    static short cornerCaseValue(int i) {
-         switch(i % 7) {
-             case 0:
-                 return Halffloat.MAX_VALUE;
-             case 1:
-                 return Halffloat.MIN_VALUE;
-             case 2:
-                 return Halffloat.NEGATIVE_INFINITY;
-             case 3:
-                 return Halffloat.POSITIVE_INFINITY;
-             case 4:
-                 return Halffloat.NaN;
-             case 5:
-                 return (short)0.0;
-             default:
-                 return Short.MIN_VALUE;
-         }
-     }
- 
-     static short get(short[] a, int i) {
-         return (short) a[i];
++        return switch(i % 8) {
++            case 0  -> Float16.MAX_VALUE;
++            case 1  -> Float16.MIN_VALUE;
++            case 2  -> Float16.NEGATIVE_INFINITY;
++            case 3  -> Float16.POSITIVE_INFINITY;
++            case 4  -> Float16.NaN;
++            case 5  -> Double.longBitsToDouble(0x7FF123456789ABCDL);
++            case 6  -> (short)0.0;
++            default -> (short)-0.0;
++        };
 +    }
 +
 +    static final IntFunction<short[]> fr = (vl) -> {
 +        int length = BUFFER_REPS * vl;
 +        return new short[length];
 +    };
 +
 +    static final IntFunction<boolean[]> fmr = (vl) -> {
 +        int length = BUFFER_REPS * vl;
 +        return new boolean[length];
 +    };
 +
 +    static final IntFunction<long[]> lfr = (vl) -> {
 +        int length = BUFFER_REPS * vl;
 +        return new long[length];
 +    };
 +
 +    static boolean eq(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() == bt.floatValue();
 +    }
 +
 +    static boolean neq(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() != bt.floatValue();
 +    }
 +
 +    static boolean lt(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() < bt.floatValue();
 +    }
 +
 +    static boolean le(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() <= bt.floatValue();
 +    }
 +
 +    static boolean gt(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() > bt.floatValue();
 +    }
 +
 +    static boolean ge(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() >= bt.floatValue();
 +    }
 +
 +    static short firstNonZero(short a, short b) {
 +        return Short.compare(a, (short) 0) != 0 ? a : b;
 +    }
 +
 +    @Test
 +    static void smokeTest1() {
-         HalffloatVector three = HalffloatVector.broadcast(SPECIES, Halffloat.valueOf(-3));
-         HalffloatVector three2 = (HalffloatVector) SPECIES.broadcast(Halffloat.valueOf(-3));
++        HalffloatVector three = HalffloatVector.broadcast(SPECIES, Float16.float16ToRawShortBits(Float16.valueOf(-3)));
++        HalffloatVector three2 = (HalffloatVector) SPECIES.broadcast(Float16.float16ToRawShortBits(Float16.valueOf(-3)));
 +        assert(three.eq(three2).allTrue());
-         HalffloatVector three3 = three2.broadcast(Halffloat.valueOf(1)).broadcast(Halffloat.valueOf(-3));
++        HalffloatVector three3 = three2.broadcast(Float16.float16ToRawShortBits(Float16.valueOf(1))).broadcast(Float16.float16ToRawShortBits(Float16.valueOf(-3)));
 +        assert(three.eq(three3).allTrue());
 +        int scale = 2;
 +        HalffloatVector higher = three.addIndex(scale);
-         VectorMask<Halffloat> m = three.compare(VectorOperators.LE, higher);
++        VectorMask<Float16> m = three.compare(VectorOperators.LE, higher);
 +        assert(m.allTrue());
-         m = higher.min((Halffloat.valueOf(-1))).test(VectorOperators.IS_NEGATIVE);
++        m = higher.min((Float16.float16ToRawShortBits(Float16.valueOf(-1)))).test(VectorOperators.IS_NEGATIVE);
 +        assert(m.allTrue());
 +        m = higher.test(VectorOperators.IS_FINITE);
 +        assert(m.allTrue());
 +        short max = higher.reduceLanes(VectorOperators.MAX);
 +        assert((short) Float.float16ToFloat(max) == -3 + scale * (SPECIES.length()-1));
 +    }
 +
 +    private static short[]
 +    bothToArray(HalffloatVector a, HalffloatVector b) {
 +        short[] r = new short[a.length() + b.length()];
 +        a.intoArray(r, 0);
 +        b.intoArray(r, a.length());
 +        return r;
 +    }
 +
 +    @Test
 +    static void smokeTest2() {
 +        // Do some zipping and shuffling.
 +        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);
 +        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES,0,1,false).toVector();
 +        Assert.assertEquals(io, io2);
 +        HalffloatVector a = io.add((short)1); //[1,2]
 +        HalffloatVector b = a.neg();  //[-1,-2]
 +        short[] abValues = bothToArray(a,b); //[1,2,-1,-2]
-         VectorShuffle<Halffloat> zip0 = VectorShuffle.makeZip(SPECIES, 0);
-         VectorShuffle<Halffloat> zip1 = VectorShuffle.makeZip(SPECIES, 1);
++        VectorShuffle<Float16> zip0 = VectorShuffle.makeZip(SPECIES, 0);
++        VectorShuffle<Float16> zip1 = VectorShuffle.makeZip(SPECIES, 1);
 +        HalffloatVector zab0 = a.rearrange(zip0,b); //[1,-1]
 +        HalffloatVector zab1 = a.rearrange(zip1,b); //[2,-2]
 +        short[] zabValues = bothToArray(zab0, zab1); //[1,-1,2,-2]
 +        // manually zip
 +        short[] manual = new short[zabValues.length];
 +        for (int i = 0; i < manual.length; i += 2) {
 +            manual[i+0] = abValues[i/2];
 +            manual[i+1] = abValues[a.length() + i/2];
 +        }
 +        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));
-         VectorShuffle<Halffloat> unz0 = VectorShuffle.makeUnzip(SPECIES, 0);
-         VectorShuffle<Halffloat> unz1 = VectorShuffle.makeUnzip(SPECIES, 1);
++        VectorShuffle<Float16> unz0 = VectorShuffle.makeUnzip(SPECIES, 0);
++        VectorShuffle<Float16> unz1 = VectorShuffle.makeUnzip(SPECIES, 1);
 +        HalffloatVector uab0 = zab0.rearrange(unz0,zab1);
 +        HalffloatVector uab1 = zab0.rearrange(unz1,zab1);
 +        short[] abValues1 = bothToArray(uab0, uab1);
 +        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));
 +    }
 +
 +    static void iotaShuffle() {
 +        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);
 +        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES, 0 , 1, false).toVector();
 +        Assert.assertEquals(io, io2);
 +    }
 +
 +    @Test
 +    // Test all shuffle related operations.
 +    static void shuffleTest() {
 +        // To test backend instructions, make sure that C2 is used.
 +        for (int loop = 0; loop < INVOC_COUNT * INVOC_COUNT; loop++) {
 +            iotaShuffle();
 +        }
 +    }
 +
 +    @Test
 +    void viewAsIntegeralLanesTest() {
 +        Vector<?> asIntegral = SPECIES.zero().viewAsIntegralLanes();
 +        VectorSpecies<?> asIntegralSpecies = asIntegral.species();
 +        Assert.assertNotEquals(asIntegralSpecies.elementType(), SPECIES.elementType());
 +        Assert.assertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());
 +        Assert.assertEquals(asIntegralSpecies.length(), SPECIES.length());
 +        Assert.assertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);
 +    }
 +
 +    @Test
 +    void viewAsFloatingLanesTest() {
 +        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();
 +        Assert.assertEquals(asFloating.species(), SPECIES);
 +    }
 +
 +    static short ADD(short a, short b) {
 +        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b)));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void ADDHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, Halffloat64VectorTests::ADD);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void ADDHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::ADD);
 +    }
 +
 +    static short SUB(short a, short b) {
 +        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b)));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void SUBHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, Halffloat64VectorTests::SUB);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void SUBHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::SUB);
 +    }
 +
 +    static short MUL(short a, short b) {
 +        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) * Float.float16ToFloat(b)));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void MULHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, Halffloat64VectorTests::MUL);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void MULHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::MUL);
 +    }
 +
 +    static short DIV(short a, short b) {
 +        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) / Float.float16ToFloat(b)));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void DIVHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, Halffloat64VectorTests::DIV);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void DIVHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::DIV);
 +    }
 +
 +    static short MAX(short a, short b) {
 +        return (short)(Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b))));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void MAXHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, Halffloat64VectorTests::MAX);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void MAXHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::MAX);
 +    }
 +
 +    static short MIN(short a, short b) {
-         return (short)(Halffloat.valueOf(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));
++        return (short)(Float.floatToFloat16(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void MINHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, Halffloat64VectorTests::MIN);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void MINHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::MIN);
 +    }
 +
 +    static short ABS(short a) {
 +        return (short)(Math.abs(a));
 +    }
 +
 +    static short abs(short a) {
 +        return (short)(Math.abs(a));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void ABSHalffloat64VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ABS).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, Halffloat64VectorTests::ABS);
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void absHalffloat64VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.abs().intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, Halffloat64VectorTests::abs);
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpMaskProvider")
 +    static void ABSMaskedHalffloat64VectorTests(IntFunction<short[]> fa,
 +                                                IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, mask, Halffloat64VectorTests::ABS);
 +    }
 +
 +    static short NEG(short a) {
 +        return (short)(-a);
 +    }
 +
 +    static short neg(short a) {
 +        return (short)(-a);
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void NEGHalffloat64VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.NEG).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, Halffloat64VectorTests::NEG);
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void negHalffloat64VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.neg().intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, Halffloat64VectorTests::neg);
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpMaskProvider")
 +    static void NEGMaskedHalffloat64VectorTests(IntFunction<short[]> fa,
 +                                                IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, mask, Halffloat64VectorTests::NEG);
 +    }
 +
 +    static short FMA(short a, short b, short c) {
 +        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));
 +    }
 +
 +    static short fma(short a, short b, short c) {
 +        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));
 +    }
 +
 +    @Test(dataProvider = "shortTernaryOpProvider")
 +    static void FMAHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] c = fc.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);
 +                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, c, Halffloat64VectorTests::FMA);
 +    }
 +
 +    @Test(dataProvider = "shortTernaryOpProvider")
 +    static void fmaHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] c = fc.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +            HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);
 +            av.fma(bv, cv).intoArray(r, i);
 +        }
 +
 +        assertArraysEquals(r, a, b, c, Halffloat64VectorTests::fma);
 +    }
 +
 +    @Test(dataProvider = "shortTernaryOpMaskProvider")
 +    static void FMAHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] c = fc.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);
 +                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, c, mask, Halffloat64VectorTests::FMA);
 +    }
 +
 +    static short SQRT(short a) {
-         return (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));
++        return (short)(Float.floatToFloat16((float) Math.sqrt(Float.float16ToFloat(a))));
 +    }
 +
 +    static short sqrt(short a) {
-         return (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));
++        return (short)(Float.floatToFloat16((float) Math.sqrt(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void SQRTHalffloat64VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SQRT).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, Halffloat64VectorTests::SQRT);
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void sqrtHalffloat64VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.sqrt().intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, Halffloat64VectorTests::sqrt);
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpMaskProvider")
 +    static void SQRTMaskedHalffloat64VectorTests(IntFunction<short[]> fa,
 +                                                IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, mask, Halffloat64VectorTests::SQRT);
 +    }
 +
 +    static short SIN(short a) {
-         return Halffloat.valueOf((float) Math.sin(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.sin(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictSIN(short a) {
-         return Halffloat.valueOf((float) StrictMath.sin(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.sin(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void SINHalffloat64VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SIN).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::SIN, Halffloat64VectorTests::strictSIN);
 +    }
 +
 +    static short EXP(short a) {
-         return Halffloat.valueOf((float) Math.exp(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.exp(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictEXP(short a) {
-         return Halffloat.valueOf((float) StrictMath.exp(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.exp(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void EXPHalffloat64VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.EXP).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::EXP, Halffloat64VectorTests::strictEXP);
 +    }
 +
 +    static short LOG1P(short a) {
-         return Halffloat.valueOf((float) Math.log1p(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.log1p(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictLOG1P(short a) {
-         return Halffloat.valueOf((float) StrictMath.log1p(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.log1p(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void LOG1PHalffloat64VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::LOG1P, Halffloat64VectorTests::strictLOG1P);
 +    }
 +
 +    static short LOG(short a) {
-         return Halffloat.valueOf((float) Math.log(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.log(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictLOG(short a) {
-         return Halffloat.valueOf((float) StrictMath.log(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.log(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void LOGHalffloat64VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.LOG).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::LOG, Halffloat64VectorTests::strictLOG);
 +    }
 +
 +    static short LOG10(short a) {
-         return Halffloat.valueOf((float) Math.log10(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.log10(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictLOG10(short a) {
-         return Halffloat.valueOf((float) StrictMath.log10(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.log10(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void LOG10Halffloat64VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.LOG10).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::LOG10, Halffloat64VectorTests::strictLOG10);
 +    }
 +
 +    static short EXPM1(short a) {
-         return Halffloat.valueOf((float) Math.expm1(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.expm1(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictEXPM1(short a) {
-         return Halffloat.valueOf((float) StrictMath.expm1(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.expm1(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void EXPM1Halffloat64VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::EXPM1, Halffloat64VectorTests::strictEXPM1);
 +    }
 +
 +    static short COS(short a) {
-         return Halffloat.valueOf((float) Math.cos(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.cos(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictCOS(short a) {
-         return Halffloat.valueOf((float) StrictMath.cos(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.cos(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void COSHalffloat64VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.COS).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::COS, Halffloat64VectorTests::strictCOS);
 +    }
 +
 +    static short TAN(short a) {
-         return Halffloat.valueOf((float) Math.tan(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.tan(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictTAN(short a) {
-         return Halffloat.valueOf((float) StrictMath.tan(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.tan(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void TANHalffloat64VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.TAN).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::TAN, Halffloat64VectorTests::strictTAN);
 +    }
 +
 +    static short SINH(short a) {
-         return Halffloat.valueOf((float) Math.sinh(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.sinh(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictSINH(short a) {
-         return Halffloat.valueOf((float) StrictMath.sinh(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.sinh(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void SINHHalffloat64VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SINH).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::SINH, Halffloat64VectorTests::strictSINH);
 +    }
 +
 +    static short COSH(short a) {
-         return Halffloat.valueOf((float) Math.cosh(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.cosh(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictCOSH(short a) {
-         return Halffloat.valueOf((float) StrictMath.cosh(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.cosh(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void COSHHalffloat64VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.COSH).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::COSH, Halffloat64VectorTests::strictCOSH);
 +    }
 +
 +    static short TANH(short a) {
-         return Halffloat.valueOf((float) Math.tanh(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.tanh(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictTANH(short a) {
-         return Halffloat.valueOf((float) StrictMath.tanh(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.tanh(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void TANHHalffloat64VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.TANH).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::TANH, Halffloat64VectorTests::strictTANH);
 +    }
 +
 +    static short ASIN(short a) {
-         return Halffloat.valueOf((float) Math.asin(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.asin(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictASIN(short a) {
-         return Halffloat.valueOf((float) StrictMath.asin(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.asin(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void ASINHalffloat64VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ASIN).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::ASIN, Halffloat64VectorTests::strictASIN);
 +    }
 +
 +    static short ACOS(short a) {
-         return Halffloat.valueOf((float) Math.acos(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.acos(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictACOS(short a) {
-         return Halffloat.valueOf((float) StrictMath.acos(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.acos(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void ACOSHalffloat64VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ACOS).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::ACOS, Halffloat64VectorTests::strictACOS);
 +    }
 +
 +    static short ATAN(short a) {
-         return Halffloat.valueOf((float) Math.atan(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.atan(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictATAN(short a) {
-         return Halffloat.valueOf((float) StrictMath.atan(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.atan(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void ATANHalffloat64VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ATAN).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::ATAN, Halffloat64VectorTests::strictATAN);
 +    }
 +
 +    static short CBRT(short a) {
-         return Halffloat.valueOf((float) Math.cbrt(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.cbrt(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictCBRT(short a) {
-         return Halffloat.valueOf((float) StrictMath.cbrt(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.cbrt(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void CBRTHalffloat64VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.CBRT).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::CBRT, Halffloat64VectorTests::strictCBRT);
 +    }
 +
 +    static short HYPOT(short a, short b) {
-         return Halffloat.valueOf((float) Math.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)));
 +    }
 +
 +    static short strictHYPOT(short a, short b) {
-         return Halffloat.valueOf((float) StrictMath.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b))));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void HYPOTHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat64VectorTests::HYPOT, Halffloat64VectorTests::strictHYPOT);
 +    }
 +
 +    static short POW(short a, short b) {
-         return Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));
 +    }
 +
 +    static short strictPOW(short a, short b) {
-         return Halffloat.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b))));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void POWHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat64VectorTests::POW, Halffloat64VectorTests::strictPOW);
 +    }
 +
 +    static short pow(short a, short b) {
-         return Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));
 +    }
 +
 +    static short strictpow(short a, short b) {
-         return Halffloat.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b))));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void powHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.pow(bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat64VectorTests::pow, Halffloat64VectorTests::strictpow);
 +    }
 +
 +    static short ATAN2(short a, short b) {
-         return Halffloat.valueOf((float) Math.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)));
 +    }
 +
 +    static short strictATAN2(short a, short b) {
-         return Halffloat.valueOf((float) StrictMath.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b))));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void ATAN2Halffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat64VectorTests::ATAN2, Halffloat64VectorTests::strictATAN2);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void POWHalffloat64VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            av.lanewise(VectorOperators.POW, b[i]).intoArray(r, i);
 +        }
 +
 +        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat64VectorTests::POW, Halffloat64VectorTests::strictPOW);
 +    }
 +
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void powHalffloat64VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            av.pow(b[i]).intoArray(r, i);
 +        }
 +
 +        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat64VectorTests::pow, Halffloat64VectorTests::strictpow);
 +    }
 +
 +
 +    static short blend(short a, short b, boolean mask) {
 +        return mask ? b : a;
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void blendHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.blend(bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::blend);
 +    }
 +
 +    @Test(dataProvider = "shortCompareOpProvider")
 +    static void ltHalffloat64VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
-             VectorMask<Halffloat> mv = av.lt(b[i]);
++            VectorMask<Float16> mv = av.lt(b[i]);
 +
 +            // Check results as part of computation.
 +            for (int j = 0; j < SPECIES.length(); j++) {
 +                Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortCompareOpProvider")
 +    static void eqHalffloat64VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
-             VectorMask<Halffloat> mv = av.eq(b[i]);
++            VectorMask<Float16> mv = av.eq(b[i]);
 +
 +            // Check results as part of computation.
 +            for (int j = 0; j < SPECIES.length(); j++) {
 +                Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shorttoIntUnaryOpProvider")
 +    static void toIntArrayHalffloat64VectorTestsSmokeTest(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            int[] r = av.toIntArray();
 +            assertArraysEquals(r, a, i);
 +        }
 +    }
 +
 +    @Test(dataProvider = "shorttoLongUnaryOpProvider")
 +    static void toLongArrayHalffloat64VectorTestsSmokeTest(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            long[] r = av.toLongArray();
 +            assertArraysEquals(r, a, i);
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void toDoubleArrayHalffloat64VectorTestsSmokeTest(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            double[] r = av.toDoubleArray();
 +            assertArraysEquals(r, a, i);
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void toStringHalffloat64VectorTestsSmokeTest(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            String str = av.toString();
 +
 +            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());
 +            Assert.assertTrue(str.equals(Arrays.toString(subarr)), "at index " + i + ", string should be = " + Arrays.toString(subarr) + ", but is = " + str);
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void hashCodeHalffloat64VectorTestsSmokeTest(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            int hash = av.hashCode();
 +
 +            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());
 +            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));
 +            Assert.assertTrue(hash == expectedHash, "at index " + i + ", hash should be = " + expectedHash + ", but is = " + hash);
 +        }
 +    }
 +
 +
 +    static long ADDReduceLong(short[] a, int idx) {
 +        short res = 0;
 +        for (int i = idx; i < (idx + SPECIES.length()); i++) {
 +            res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));
 +        }
 +
 +        return (long)res;
 +    }
 +
 +    static long ADDReduceAllLong(short[] a) {
 +        long res = 0;
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            res += ADDReduceLong(a, i);
 +        }
 +
 +        return res;
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void ADDReduceLongHalffloat64VectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        long[] r = lfr.apply(SPECIES.length());
 +        long ra = 0;
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            r[i] = av.reduceLanesToLong(VectorOperators.ADD);
 +        }
 +
 +        ra = 0;
 +        for (int i = 0; i < a.length; i ++) {
 +            ra += r[i];
 +        }
 +
 +        assertReductionLongArraysEquals(r, ra, a,
 +                Halffloat64VectorTests::ADDReduceLong, Halffloat64VectorTests::ADDReduceAllLong);
 +    }
 +
 +    static long ADDReduceLongMasked(short[] a, int idx, boolean[] mask) {
 +        short res = 0;
 +        for (int i = idx; i < (idx + SPECIES.length()); i++) {
 +            if(mask[i % SPECIES.length()])
 +                res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));
 +        }
 +
 +        return (long)res;
 +    }
 +
 +    static long ADDReduceAllLongMasked(short[] a, boolean[] mask) {
 +        long res = 0;
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            res += ADDReduceLongMasked(a, i, mask);
 +        }
 +
 +        return res;
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpMaskProvider")
 +    static void ADDReduceLongHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        long[] r = lfr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +        long ra = 0;
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            r[i] = av.reduceLanesToLong(VectorOperators.ADD, vmask);
 +        }
 +
 +        ra = 0;
 +        for (int i = 0; i < a.length; i ++) {
 +            ra += r[i];
 +        }
 +
 +        assertReductionLongArraysEqualsMasked(r, ra, a, mask,
 +                Halffloat64VectorTests::ADDReduceLongMasked, Halffloat64VectorTests::ADDReduceAllLongMasked);
 +    }
 +
 +    @Test(dataProvider = "shorttoLongUnaryOpProvider")
 +    static void BroadcastLongHalffloat64VectorTestsSmokeTest(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = new short[a.length];
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);
 +        }
 +        assertBroadcastArraysEquals(r, a);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void blendHalffloat64VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.blend((long)b[i], vmask).intoArray(r, i);
 +            }
 +        }
 +        assertBroadcastLongArraysEquals(r, a, b, mask, Halffloat64VectorTests::blend);
 +    }
 +
 +
 +    @Test(dataProvider = "shortUnaryOpSelectFromProvider")
 +    static void SelectFromHalffloat64VectorTests(IntFunction<short[]> fa,
 +                                           BiFunction<Integer,Integer,short[]> fs) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] order = fs.apply(a.length, SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);
 +            bv.selectFrom(av).intoArray(r, i);
 +        }
 +
 +        assertSelectFromArraysEquals(r, a, order, SPECIES.length());
 +    }
 +
++    @Test(dataProvider = "shortSelectFromTwoVectorOpProvider")
++    static void SelectFromTwoVectorHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] b = fb.apply(SPECIES.length());
++        short[] idx = fc.apply(SPECIES.length());
++        short[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < idx.length; i += SPECIES.length()) {
++                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
++                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
++                HalffloatVector idxv = HalffloatVector.fromArray(SPECIES, idx, i);
++                idxv.selectFrom(av, bv).intoArray(r, i);
++            }
++        }
++        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());
++    }
++
 +    @Test(dataProvider = "shortUnaryOpSelectFromMaskProvider")
 +    static void SelectFromHalffloat64VectorTestsMaskedSmokeTest(IntFunction<short[]> fa,
 +                                                           BiFunction<Integer,Integer,short[]> fs,
 +                                                           IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] order = fs.apply(a.length, SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);
 +            bv.selectFrom(av, vmask).intoArray(r, i);
 +        }
 +
 +        assertSelectFromArraysEquals(r, a, order, mask, SPECIES.length());
 +    }
 +
 +    @Test(dataProvider = "shuffleProvider")
 +    static void shuffleMiscellaneousHalffloat64VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {
 +        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);
 +            int hash = shuffle.hashCode();
 +            int length = shuffle.length();
 +
 +            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());
 +            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));
 +            Assert.assertTrue(hash == expectedHash, "at index " + i + ", hash should be = " + expectedHash + ", but is = " + hash);
 +            Assert.assertEquals(length, SPECIES.length());
 +        }
 +    }
 +
 +    @Test(dataProvider = "shuffleProvider")
 +    static void shuffleToStringHalffloat64VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {
 +        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);
 +            String str = shuffle.toString();
 +
 +            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());
 +            Assert.assertTrue(str.equals("Shuffle" + Arrays.toString(subarr)), "at index " +
 +                i + ", string should be = " + Arrays.toString(subarr) + ", but is = " + str);
 +        }
 +    }
 +
 +    @Test(dataProvider = "shuffleCompareOpProvider")
 +    static void shuffleEqualsHalffloat64VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {
 +        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());
 +        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var av = VectorShuffle.fromArray(SPECIES, a, i);
 +            var bv = VectorShuffle.fromArray(SPECIES, b, i);
 +            boolean eq = av.equals(bv);
 +            int to = i + SPECIES.length();
 +            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));
 +        }
 +    }
 +
 +    @Test(dataProvider = "maskCompareOpProvider")
 +    static void maskEqualsHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        boolean[] b = fb.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var av = SPECIES.loadMask(a, i);
 +            var bv = SPECIES.loadMask(b, i);
 +            boolean equals = av.equals(bv);
 +            int to = i + SPECIES.length();
 +            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));
 +        }
 +    }
 +
 +    static boolean band(boolean a, boolean b) {
 +        return a & b;
 +    }
 +
 +    @Test(dataProvider = "maskCompareOpProvider")
 +    static void maskAndHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        boolean[] b = fb.apply(SPECIES.length());
 +        boolean[] r = new boolean[a.length];
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var av = SPECIES.loadMask(a, i);
 +            var bv = SPECIES.loadMask(b, i);
 +            var cv = av.and(bv);
 +            cv.intoArray(r, i);
 +        }
 +        assertArraysEquals(r, a, b, Halffloat64VectorTests::band);
 +    }
 +
 +    static boolean bor(boolean a, boolean b) {
 +        return a | b;
 +    }
 +
 +    @Test(dataProvider = "maskCompareOpProvider")
 +    static void maskOrHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        boolean[] b = fb.apply(SPECIES.length());
 +        boolean[] r = new boolean[a.length];
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var av = SPECIES.loadMask(a, i);
 +            var bv = SPECIES.loadMask(b, i);
 +            var cv = av.or(bv);
 +            cv.intoArray(r, i);
 +        }
 +        assertArraysEquals(r, a, b, Halffloat64VectorTests::bor);
 +    }
 +
 +    static boolean bxor(boolean a, boolean b) {
 +        return a != b;
 +    }
 +
 +    @Test(dataProvider = "maskCompareOpProvider")
 +    static void maskXorHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        boolean[] b = fb.apply(SPECIES.length());
 +        boolean[] r = new boolean[a.length];
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var av = SPECIES.loadMask(a, i);
 +            var bv = SPECIES.loadMask(b, i);
 +            var cv = av.xor(bv);
 +            cv.intoArray(r, i);
 +        }
 +        assertArraysEquals(r, a, b, Halffloat64VectorTests::bxor);
 +    }
 +
 +    static boolean bandNot(boolean a, boolean b) {
 +        return a & !b;
 +    }
 +
 +    @Test(dataProvider = "maskCompareOpProvider")
 +    static void maskAndNotHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        boolean[] b = fb.apply(SPECIES.length());
 +        boolean[] r = new boolean[a.length];
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var av = SPECIES.loadMask(a, i);
 +            var bv = SPECIES.loadMask(b, i);
 +            var cv = av.andNot(bv);
 +            cv.intoArray(r, i);
 +        }
 +        assertArraysEquals(r, a, b, Halffloat64VectorTests::bandNot);
 +    }
 +
 +    static boolean beq(boolean a, boolean b) {
 +        return (a == b);
 +    }
 +
 +    @Test(dataProvider = "maskCompareOpProvider")
 +    static void maskEqHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        boolean[] b = fb.apply(SPECIES.length());
 +        boolean[] r = new boolean[a.length];
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var av = SPECIES.loadMask(a, i);
 +            var bv = SPECIES.loadMask(b, i);
 +            var cv = av.eq(bv);
 +            cv.intoArray(r, i);
 +        }
 +        assertArraysEquals(r, a, b, Halffloat64VectorTests::beq);
 +    }
 +
 +    @Test(dataProvider = "maskProvider")
 +    static void maskHashCodeHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var vmask = SPECIES.loadMask(a, i);
 +            int hash = vmask.hashCode();
 +
 +            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());
 +            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));
 +            Assert.assertTrue(hash == expectedHash, "at index " + i + ", hash should be = " + expectedHash + ", but is = " + hash);
 +        }
 +    }
 +
 +    static int maskTrueCount(boolean[] a, int idx) {
 +        int trueCount = 0;
 +        for (int i = idx; i < idx + SPECIES.length(); i++) {
 +            trueCount += a[i] ? 1 : 0;
 +        }
 +        return trueCount;
 +    }
 +
 +    @Test(dataProvider = "maskProvider")
 +    static void maskTrueCountHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        int[] r = new int[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                var vmask = SPECIES.loadMask(a, i);
 +                r[i] = vmask.trueCount();
 +            }
 +        }
 +
 +        assertMaskReductionArraysEquals(r, a, Halffloat64VectorTests::maskTrueCount);
 +    }
 +
 +    static int maskLastTrue(boolean[] a, int idx) {
 +        int i = idx + SPECIES.length() - 1;
 +        for (; i >= idx; i--) {
 +            if (a[i]) {
 +                break;
 +            }
 +        }
 +        return i - idx;
 +    }
 +
 +    @Test(dataProvider = "maskProvider")
 +    static void maskLastTrueHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        int[] r = new int[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                var vmask = SPECIES.loadMask(a, i);
 +                r[i] = vmask.lastTrue();
 +            }
 +        }
 +
 +        assertMaskReductionArraysEquals(r, a, Halffloat64VectorTests::maskLastTrue);
 +    }
 +
 +    static int maskFirstTrue(boolean[] a, int idx) {
 +        int i = idx;
 +        for (; i < idx + SPECIES.length(); i++) {
 +            if (a[i]) {
 +                break;
 +            }
 +        }
 +        return i - idx;
 +    }
 +
 +    @Test(dataProvider = "maskProvider")
 +    static void maskFirstTrueHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        int[] r = new int[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                var vmask = SPECIES.loadMask(a, i);
 +                r[i] = vmask.firstTrue();
 +            }
 +        }
 +
 +        assertMaskReductionArraysEquals(r, a, Halffloat64VectorTests::maskFirstTrue);
 +    }
 +
 +    @Test(dataProvider = "maskProvider")
 +    static void maskCompressHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
 +        int trueCount = 0;
 +        boolean[] a = fa.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                var vmask = SPECIES.loadMask(a, i);
 +                trueCount = vmask.trueCount();
 +                var rmask = vmask.compress();
 +                for (int j = 0; j < SPECIES.length(); j++)  {
 +                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
 +                }
 +            }
 +        }
 +    }
 +
 +    @DataProvider
 +    public static Object[][] longMaskProvider() {
 +        return new Object[][]{
 +                {0xFFFFFFFFFFFFFFFFL},
 +                {0x0000000000000000L},
 +                {0x5555555555555555L},
 +                {0x0123456789abcdefL},
 +        };
 +    }
 +
 +    @Test(dataProvider = "longMaskProvider")
 +    static void maskFromToLongHalffloat64VectorTestsSmokeTest(long inputLong) {
 +        var vmask = VectorMask.fromLong(SPECIES, inputLong);
 +        long outputLong = vmask.toLong();
 +        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));
 +    }
 +
 +    @DataProvider
 +    public static Object[][] offsetProvider() {
 +        return new Object[][]{
 +                {0},
 +                {-1},
 +                {+1},
 +                {+2},
 +                {-2},
 +        };
 +    }
 +
 +    @Test(dataProvider = "offsetProvider")
 +    static void indexInRangeHalffloat64VectorTestsSmokeTest(int offset) {
 +        int limit = SPECIES.length() * BUFFER_REPS;
 +        for (int i = 0; i < limit; i += SPECIES.length()) {
 +            var actualMask = SPECIES.indexInRange(i + offset, limit);
 +            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);
 +            assert(actualMask.equals(expectedMask));
 +            for (int j = 0; j < SPECIES.length(); j++)  {
 +                int index = i + j + offset;
 +                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "offsetProvider")
 +    static void indexInRangeLongHalffloat64VectorTestsSmokeTest(int offset) {
 +        long limit = SPECIES.length() * BUFFER_REPS;
 +        for (long i = 0; i < limit; i += SPECIES.length()) {
 +            var actualMask = SPECIES.indexInRange(i + offset, limit);
 +            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);
 +            assert(actualMask.equals(expectedMask));
 +            for (int j = 0; j < SPECIES.length(); j++)  {
 +                long index = i + j + offset;
 +                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);
 +            }
 +        }
 +    }
 +
 +    @DataProvider
 +    public static Object[][] lengthProvider() {
 +        return new Object[][]{
 +                {0},
 +                {1},
 +                {32},
 +                {37},
 +                {1024},
 +                {1024+1},
 +                {1024+5},
 +        };
 +    }
 +
 +    @Test(dataProvider = "lengthProvider")
 +    static void loopBoundHalffloat64VectorTestsSmokeTest(int length) {
 +        int actualLoopBound = SPECIES.loopBound(length);
 +        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());
 +        Assert.assertEquals(actualLoopBound, expectedLoopBound);
 +    }
 +
 +    @Test(dataProvider = "lengthProvider")
 +    static void loopBoundLongHalffloat64VectorTestsSmokeTest(int _length) {
 +        long length = _length;
 +        long actualLoopBound = SPECIES.loopBound(length);
 +        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());
 +        Assert.assertEquals(actualLoopBound, expectedLoopBound);
 +    }
 +
 +    @Test
 +    static void ElementSizeHalffloat64VectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
 +        int elsize = av.elementSize();
-         Assert.assertEquals(elsize, Halffloat.SIZE);
++        Assert.assertEquals(elsize, Float16.SIZE);
 +    }
 +
 +    @Test
 +    static void VectorShapeHalffloat64VectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
 +        VectorShape vsh = av.shape();
 +        assert(vsh.equals(VectorShape.S_64_BIT));
 +    }
 +
 +    @Test
 +    static void ShapeWithLanesHalffloat64VectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
 +        VectorShape vsh = av.shape();
-         VectorSpecies species = vsh.withLanes(Halffloat.class);
++        VectorSpecies species = vsh.withLanes(Float16.class);
 +        assert(species.equals(SPECIES));
 +    }
 +
 +    @Test
 +    static void ElementTypeHalffloat64VectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
-         assert(av.species().elementType() == Halffloat.class);
++        assert(av.species().elementType() == Float16.class);
 +    }
 +
 +    @Test
 +    static void SpeciesElementSizeHalffloat64VectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
-         assert(av.species().elementSize() == Halffloat.SIZE);
++        assert(av.species().elementSize() == Float16.SIZE);
 +    }
 +
 +    @Test
 +    static void VectorTypeHalffloat64VectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
 +        assert(av.species().vectorType() == av.getClass());
 +    }
 +
 +    @Test
 +    static void WithLanesHalffloat64VectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
-         VectorSpecies species = av.species().withLanes(Halffloat.class);
++        VectorSpecies species = av.species().withLanes(Float16.class);
 +        assert(species.equals(SPECIES));
 +    }
 +
 +    @Test
 +    static void WithShapeHalffloat64VectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
 +        VectorShape vsh = av.shape();
 +        VectorSpecies species = av.species().withShape(vsh);
 +        assert(species.equals(SPECIES));
 +    }
 +
 +    @Test
 +    static void MaskAllTrueHalffloat64VectorTestsSmokeTest() {
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));
 +        }
 +    }
 +}
diff --cc test/jdk/jdk/incubator/vector/HalffloatMaxVectorLoadStoreTests.java
index e07b75656c0,00000000000..4fb9327ce38
mode 100644,000000..100644
--- a/test/jdk/jdk/incubator/vector/HalffloatMaxVectorLoadStoreTests.java
+++ b/test/jdk/jdk/incubator/vector/HalffloatMaxVectorLoadStoreTests.java
@@@ -1,856 -1,0 +1,1021 @@@
 +/*
-  * Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2018, 2025, Oracle and/or its affiliates. All rights reserved.
 + * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 + *
 + * This code is free software; you can redistribute it and/or modify it
 + * under the terms of the GNU General Public License version 2 only, as
 + * published by the Free Software Foundation.
 + *
 + * This code is distributed in the hope that it will be useful, but WITHOUT
 + * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 + * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 + * version 2 for more details (a copy is included in the LICENSE file that
 + * accompanied this code).
 + *
 + * You should have received a copy of the GNU General Public License version
 + * 2 along with this work; if not, write to the Free Software Foundation,
 + * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 + *
 + * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 + * or visit www.oracle.com if you need additional information or have any
 + * questions.
 + */
 +
 +/*
 + * @test
-  * @enablePreview
++ * @key randomness
++ *
++ * @library /test/lib
 + * @modules jdk.incubator.vector java.base/jdk.internal.vm.annotation
 + * @run testng/othervm --add-opens jdk.incubator.vector/jdk.incubator.vector=ALL-UNNAMED
 + *      -XX:-TieredCompilation HalffloatMaxVectorLoadStoreTests
 + *
 + */
 +
 +// -- This file was mechanically generated: Do not edit! -- //
 +
 +import java.lang.foreign.MemorySegment;
- import java.lang.foreign.SegmentScope;
++import java.lang.foreign.Arena;
 +import java.lang.foreign.ValueLayout;
- import jdk.incubator.vector.Halffloat;
- import jdk.incubator.vector.HalffloatVector;
 +import jdk.incubator.vector.HalffloatVector;
 +import jdk.incubator.vector.VectorMask;
 +import jdk.incubator.vector.VectorShape;
 +import jdk.incubator.vector.VectorSpecies;
 +import jdk.incubator.vector.VectorShuffle;
 +import jdk.internal.vm.annotation.DontInline;
 +import org.testng.Assert;
 +import org.testng.annotations.DataProvider;
 +import org.testng.annotations.Test;
 +
 +import java.nio.ByteOrder;
 +import java.util.List;
 +import java.util.function.*;
 +
 +@Test
 +public class HalffloatMaxVectorLoadStoreTests extends AbstractVectorLoadStoreTest {
-     static final VectorSpecies<Halffloat> SPECIES =
++    static final VectorSpecies<Float16> SPECIES =
 +                HalffloatVector.SPECIES_MAX;
 +
 +    static final int INVOC_COUNT = Integer.getInteger("jdk.incubator.vector.test.loop-iterations", 100);
 +
-     static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withBitAlignment(8);
++    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withByteAlignment(1);
 +
 +    static VectorShape getMaxBit() {
 +        return VectorShape.S_Max_BIT;
 +    }
 +
 +    private static final int Max = 256;  // juts so we can do N/Max
 +
 +    static final int BUFFER_REPS = Integer.getInteger("jdk.incubator.vector.test.buffer-vectors", 25000 / Max);
 +
 +    static void assertArraysEquals(short[] r, short[] a, boolean[] mask) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0);
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0, "at index #" + i);
 +        }
 +    }
 +
 +    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(
 +            withToString("short[i * 5]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (short)(i * 5));
 +            }),
 +            withToString("short[i + 1]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));
 +            })
 +    );
 +
 +    // Relative to array.length
 +    static final List<IntFunction<Integer>> INDEX_GENERATORS = List.of(
 +            withToString("-1", (int l) -> {
 +                return -1;
 +            }),
 +            withToString("l", (int l) -> {
 +                return l;
 +            }),
 +            withToString("l - 1", (int l) -> {
 +                return l - 1;
 +            }),
 +            withToString("l + 1", (int l) -> {
 +                return l + 1;
 +            }),
 +            withToString("l - speciesl + 1", (int l) -> {
 +                return l - SPECIES.length() + 1;
 +            }),
 +            withToString("l + speciesl - 1", (int l) -> {
 +                return l + SPECIES.length() - 1;
 +            }),
 +            withToString("l + speciesl", (int l) -> {
 +                return l + SPECIES.length();
 +            }),
 +            withToString("l + speciesl + 1", (int l) -> {
 +                return l + SPECIES.length() + 1;
 +            })
 +    );
 +
 +    // Relative to byte[] array.length or MemorySegment.byteSize()
 +    static final List<IntFunction<Integer>> BYTE_INDEX_GENERATORS = List.of(
 +            withToString("-1", (int l) -> {
 +                return -1;
 +            }),
 +            withToString("l", (int l) -> {
 +                return l;
 +            }),
 +            withToString("l - 1", (int l) -> {
 +                return l - 1;
 +            }),
 +            withToString("l + 1", (int l) -> {
 +                return l + 1;
 +            }),
 +            withToString("l - speciesl*ebsize + 1", (int l) -> {
 +                return l - SPECIES.vectorByteSize() + 1;
 +            }),
 +            withToString("l + speciesl*ebsize - 1", (int l) -> {
 +                return l + SPECIES.vectorByteSize() - 1;
 +            }),
 +            withToString("l + speciesl*ebsize", (int l) -> {
 +                return l + SPECIES.vectorByteSize();
 +            }),
 +            withToString("l + speciesl*ebsize + 1", (int l) -> {
 +                return l + SPECIES.vectorByteSize() + 1;
 +            })
 +    );
 +
 +    @DataProvider
 +    public Object[][] shortProvider() {
 +        return HALFFLOAT_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] maskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortProviderForIOOBE() {
 +        var f = HALFFLOAT_GENERATORS.get(0);
 +        return INDEX_GENERATORS.stream().map(fi -> {
 +                    return new Object[] {f, fi};
 +                }).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                    return new Object[] {fa, fm};
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortMaskProviderForIOOBE() {
 +        var f = HALFFLOAT_GENERATORS.get(0);
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {
 +                    return new Object[] {f, fi, fm};
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortMemorySegmentProvider() {
 +        return HALFFLOAT_GENERATORS.stream().
 +                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().
 +                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {
 +                            return new Object[]{fa, fb, bo};
 +                        }))).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortMemorySegmentMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_GENERATORS.stream().
 +                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().
 +                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {
 +                            return new Object[]{fa, fb, fm, bo};
 +                        })))).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortByteProviderForIOOBE() {
 +        var f = HALFFLOAT_GENERATORS.get(0);
 +        return BYTE_INDEX_GENERATORS.stream().map(fi -> {
 +                    return new Object[] {f, fi};
 +                }).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortByteMaskProviderForIOOBE() {
 +        var f = HALFFLOAT_GENERATORS.get(0);
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> BYTE_INDEX_GENERATORS.stream().map(fi -> {
 +                    return new Object[] {f, fi, fm};
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {
 +        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() / 8);
 +        for (int i = 0; i < a.length; i++) {
 +            ms.set(ELEMENT_LAYOUT, i * SPECIES.elementSize() / 8 , a[i]);
 +        }
 +        return ms;
 +    }
 +
 +    static short[] segmentToArray(MemorySegment ms) {
 +        return ms.toArray(ELEMENT_LAYOUT);
 +    }
 +
 +
 +    interface ToHalffloatF {
 +        short apply(int i);
 +    }
 +
 +    static short[] fill(int s , ToHalffloatF f) {
 +        return fill(new short[s], f);
 +    }
 +
 +    static short[] fill(short[] a, ToHalffloatF f) {
 +        for (int i = 0; i < a.length; i++) {
 +            a[i] = f.apply(i);
 +        }
 +        return a;
 +    }
 +
++    @DontInline
++    static VectorShuffle<Float16> shuffleFromArray(int[] a, int i) {
++        return SPECIES.shuffleFromArray(a, i);
++    }
++
++    @DontInline
++    static void shuffleIntoArray(VectorShuffle<Float16> s, int[] a, int i) {
++        s.intoArray(a, i);
++    }
++
++    @DontInline
++    static VectorShuffle<Float16> shuffleFromMemorySegment(MemorySegment mem, int i, ByteOrder bo) {
++        return VectorShuffle.fromMemorySegment(SPECIES, mem, i, bo);
++    }
++
++    @DontInline
++    static void shuffleIntoMemorySegment(VectorShuffle<Float16> s, MemorySegment mem, int i, ByteOrder bo) {
++        s.intoMemorySegment(mem, i, bo);
++    }
++
 +    @DontInline
 +    static HalffloatVector fromArray(short[] a, int i) {
-         return HalffloatVector.fromArray(SPECIES, a, i);
++        // Tests the species method and the equivalent vector method it defers to
++        return (HalffloatVector) SPECIES.fromArray(a, i);
 +    }
 +
 +    @DontInline
-     static HalffloatVector fromArray(short[] a, int i, VectorMask<Halffloat> m) {
++    static HalffloatVector fromArray(short[] a, int i, VectorMask<Float16> m) {
 +        return HalffloatVector.fromArray(SPECIES, a, i, m);
 +    }
 +
 +    @DontInline
 +    static void intoArray(HalffloatVector v, short[] a, int i) {
 +        v.intoArray(a, i);
 +    }
 +
 +    @DontInline
-     static void intoArray(HalffloatVector v, short[] a, int i, VectorMask<Halffloat> m) {
++    static void intoArray(HalffloatVector v, short[] a, int i, VectorMask<Float16> m) {
 +        v.intoArray(a, i, m);
 +    }
 +
 +    @DontInline
 +    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {
-         return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);
++        // Tests the species method and the equivalent vector method it defers to
++        return (HalffloatVector) SPECIES.fromMemorySegment(a, i, bo);
 +    }
 +
 +    @DontInline
-     static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Halffloat> m) {
++    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Float16> m) {
 +        return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, m);
 +    }
 +
 +    @DontInline
 +    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo) {
 +        v.intoMemorySegment(a, i, bo);
 +    }
 +
 +    @DontInline
-     static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Halffloat> m) {
++    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Float16> m) {
 +        v.intoMemorySegment(a, i, bo, m);
 +    }
 +
 +    @Test(dataProvider = "shortProvider")
 +    static void loadStoreArray(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = new short[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.intoArray(r, i);
 +            }
 +        }
 +        Assert.assertEquals(r, a);
 +    }
 +
 +    @Test(dataProvider = "shortProviderForIOOBE")
 +    static void loadArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = new short[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = fromArray(a, i);
 +                av.intoArray(r, i);
 +            }
 +        }
 +
 +        int index = fi.apply(a.length);
 +        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);
 +        try {
 +            fromArray(a, index);
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortProviderForIOOBE")
 +    static void storeArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = new short[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                intoArray(av, r, i);
 +            }
 +        }
 +
 +        int index = fi.apply(a.length);
 +        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);
 +        try {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);
 +            intoArray(av, r, index);
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +
 +    @Test(dataProvider = "shortMaskProvider")
 +    static void loadStoreMaskArray(IntFunction<short[]> fa,
 +                                   IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = new short[a.length];
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);
++        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, vmask);
 +                av.intoArray(r, i);
 +            }
 +        }
 +        assertArraysEquals(r, a, mask);
 +
 +
 +        r = new short[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.intoArray(r, i, vmask);
 +            }
 +        }
 +        assertArraysEquals(r, a, mask);
 +    }
 +
 +    @Test(dataProvider = "shortMaskProviderForIOOBE")
 +    static void loadArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = new short[a.length];
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);
++        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = fromArray(a, i, vmask);
 +                av.intoArray(r, i);
 +            }
 +        }
 +
 +        int index = fi.apply(a.length);
 +        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);
 +        try {
 +            fromArray(a, index, vmask);
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortMaskProviderForIOOBE")
 +    static void storeArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = new short[a.length];
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);
++        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                intoArray(av, r, i, vmask);
 +            }
 +        }
 +
 +        int index = fi.apply(a.length);
 +        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);
 +        try {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);
 +            intoArray(av, a, index, vmask);
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +
 +    @Test(dataProvider = "shortMaskProvider")
 +    static void loadStoreMask(IntFunction<short[]> fa,
 +                              IntFunction<boolean[]> fm) {
 +        boolean[] mask = fm.apply(SPECIES.length());
 +        boolean[] r = new boolean[mask.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < mask.length; i += SPECIES.length()) {
-                 VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, i);
++                VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, i);
 +                vmask.intoArray(r, i);
 +            }
 +        }
 +        Assert.assertEquals(r, mask);
 +    }
 +
 +
 +    @Test(dataProvider = "shortMemorySegmentProvider")
 +    static void loadStoreMemorySegment(IntFunction<short[]> fa,
 +                                       IntFunction<MemorySegment> fb,
 +                                       ByteOrder bo) {
 +        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);
 +        MemorySegment r = fb.apply((int) a.byteSize());
 +
 +        int l = (int) a.byteSize();
 +        int s = SPECIES.vectorByteSize();
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < l; i += s) {
 +                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);
 +                av.intoMemorySegment(r, i, bo);
 +            }
 +        }
 +        long m = r.mismatch(a);
 +        Assert.assertEquals(m, -1, "Segments not equal");
 +    }
 +
 +    @Test(dataProvider = "shortByteProviderForIOOBE")
 +    static void loadMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {
-         MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));
-         MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());
++        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));
++        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);
 +
 +        int l = (int) a.byteSize();
 +        int s = SPECIES.vectorByteSize();
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < l; i += s) {
 +                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());
 +                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());
 +            }
 +        }
 +
 +        int index = fi.apply((int) a.byteSize());
 +        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());
 +        try {
 +            fromMemorySegment(a, index, ByteOrder.nativeOrder());
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortByteProviderForIOOBE")
 +    static void storeMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {
-         MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));
-         MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());
++        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));
++        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);
 +
 +        int l = (int) a.byteSize();
 +        int s = SPECIES.vectorByteSize();
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < l; i += s) {
 +                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());
 +                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());
 +            }
 +        }
 +
 +        int index = fi.apply((int) a.byteSize());
 +        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());
 +        try {
 +            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());
 +            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortMemorySegmentMaskProvider")
 +    static void loadStoreMemorySegmentMask(IntFunction<short[]> fa,
 +                                           IntFunction<MemorySegment> fb,
 +                                           IntFunction<boolean[]> fm,
 +                                           ByteOrder bo) {
 +        short[] _a = fa.apply(SPECIES.length());
 +        MemorySegment a = toSegment(_a, fb);
 +        MemorySegment r = fb.apply((int) a.byteSize());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);
++        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);
 +
 +        int l = (int) a.byteSize();
 +        int s = SPECIES.vectorByteSize();
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < l; i += s) {
 +                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, vmask);
 +                av.intoMemorySegment(r, i, bo);
 +            }
 +        }
 +        assertArraysEquals(segmentToArray(r), _a, mask);
 +
 +
 +        r = fb.apply((int) a.byteSize());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < l; i += s) {
 +                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);
 +                av.intoMemorySegment(r, i, bo, vmask);
 +            }
 +        }
 +        assertArraysEquals(segmentToArray(r), _a, mask);
 +    }
 +
 +    @Test(dataProvider = "shortByteMaskProviderForIOOBE")
 +    static void loadMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {
-         MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));
-         MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());
++        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));
++        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);
++        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);
 +
 +        int l = (int) a.byteSize();
 +        int s = SPECIES.vectorByteSize();
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < l; i += s) {
 +                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);
 +                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());
 +            }
 +        }
 +
 +        int index = fi.apply((int) a.byteSize());
 +        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() / 8);
 +        try {
 +            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortByteMaskProviderForIOOBE")
 +    static void storeMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {
-         MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));
-         MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());
++        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));
++        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);
++        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);
 +
 +        int l = (int) a.byteSize();
 +        int s = SPECIES.vectorByteSize();
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < l; i += s) {
 +                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());
 +                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);
 +            }
 +        }
 +
 +        int index = fi.apply((int) a.byteSize());
 +        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() / 8);
 +        try {
 +            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());
 +            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);
 +            if (shouldFail) {
 +                Assert.fail("Failed to throw IndexOutOfBoundsException");
 +            }
 +        } catch (IndexOutOfBoundsException e) {
 +            if (!shouldFail) {
 +                Assert.fail("Unexpected IndexOutOfBoundsException");
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortMemorySegmentProvider")
 +    static void loadStoreReadonlyMemorySegment(IntFunction<short[]> fa,
 +                                               IntFunction<MemorySegment> fb,
 +                                               ByteOrder bo) {
 +        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();
 +
 +        Assert.assertThrows(
 +                UnsupportedOperationException.class,
 +                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)
 +        );
 +
 +        Assert.assertThrows(
 +                UnsupportedOperationException.class,
 +                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))
 +        );
 +
 +        Assert.assertThrows(
 +                UnsupportedOperationException.class,
 +                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))
 +        );
 +
-         VectorMask<Halffloat> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)
++        VectorMask<Float16> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)
 +                .laneIsValid();
 +        Assert.assertThrows(
 +                UnsupportedOperationException.class,
 +                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)
 +        );
 +    }
 +
 +
 +    @Test(dataProvider = "maskProvider")
 +    static void loadStoreMask(IntFunction<boolean[]> fm) {
 +        boolean[] a = fm.apply(SPECIES.length());
 +        boolean[] r = new boolean[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                 VectorMask<Halffloat> vmask = SPECIES.loadMask(a, i);
++                VectorMask<Float16> vmask = SPECIES.loadMask(a, i);
 +                vmask.intoArray(r, i);
 +            }
 +        }
 +        Assert.assertEquals(r, a);
 +    }
 +
 +
-     @Test
-     static void loadStoreShuffle() {
-         IntUnaryOperator fn = a -> a + 5;
-         for (int ic = 0; ic < INVOC_COUNT; ic++) {
-             var shuffle = VectorShuffle.fromOp(SPECIES, fn);
-             int [] r = shuffle.toArray();
++   @Test(dataProvider = "shuffleIntProvider")
++   static void loadStoreShuffleArray(IntFunction<int[]> fa) {
++       int[] a = fa.apply(SPECIES.length());
++       int[] r = new int[a.length];
 +
-             int [] a = expectedShuffle(SPECIES.length(), fn);
-             Assert.assertEquals(r, a);
++       for (int ic = 0; ic < INVOC_COUNT; ic++) {
++           for (int i = 0; i < a.length; i += SPECIES.length()) {
++               VectorShuffle<Float16> shuffle = VectorShuffle.fromArray(SPECIES, a, i);
++               shuffle.intoArray(r, i);
++           }
 +       }
-     }
 +
++       for (int i = 0; i < a.length; i++) {
++          Assert.assertEquals(testPartiallyWrapIndex(SPECIES, a[i]), r[i]);
++       }
++
++   }
++
++   @Test(dataProvider = "shuffleIntProviderForIOOBE")
++   static void storeShuffleArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {
++       int[] a = fa.apply(SPECIES.length());
++       int[] r = new int[a.length];
++
++       for (int ic = 0; ic < INVOC_COUNT; ic++) {
++           for (int i = 0; i < a.length; i += SPECIES.length()) {
++               VectorShuffle<Float16> shuffle = shuffleFromArray(a, i);
++               shuffleIntoArray(shuffle, r, i);
++           }
++       }
++
++       int index = fi.apply(a.length);
++       boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);
++       try {
++           VectorShuffle<Float16> shuffle = shuffleFromArray(a, index);
++           shuffleIntoArray(shuffle, r, index);
++           if (shouldFail) {
++               Assert.fail("Failed to throw IndexOutOfBoundsException");
++           }
++       } catch (IndexOutOfBoundsException e) {
++           if (!shouldFail) {
++               Assert.fail("Unexpected IndexOutOfBoundsException");
++           }
++       }
++   }
++
++   @Test(dataProvider = "shuffleIntProviderForIOOBE")
++   static void loadShuffleArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {
++       int[] a = fa.apply(SPECIES.length());
++       int[] r = new int[a.length];
++
++       for (int ic = 0; ic < INVOC_COUNT; ic++) {
++           for (int i = 0; i < a.length; i += SPECIES.length()) {
++               VectorShuffle<Float16> shuffle = shuffleFromArray(a, i);
++               shuffle.intoArray(r, i);
++           }
++       }
++
++       int index = fi.apply(a.length);
++       boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);
++       try {
++           shuffleFromArray(a, index);
++           if (shouldFail) {
++               Assert.fail("Failed to throw IndexOutOfBoundsException");
++           }
++       } catch (IndexOutOfBoundsException e) {
++           if (!shouldFail) {
++               Assert.fail("Unexpected IndexOutOfBoundsException");
++           }
++       }
++   }
++
++   @Test(dataProvider = "shuffleIntMemorySegmentProvider")
++   static void loadStoreShuffleMemorySegment(IntFunction<int[]> fa,
++                                      IntFunction<MemorySegment> fb,
++                                      ByteOrder bo) {
++       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), fb);
++       MemorySegment r = fb.apply((int) a.byteSize());
++
++       int l = (int) a.byteSize();
++       int s = SPECIES.length() * 4; //An integer for every lane is read out. So 4 bytes per lane
++
++       for (int ic = 0; ic < INVOC_COUNT; ic++) {
++           for (int i = 0; i < l; i += s) {
++               VectorShuffle<Float16> shuffle = VectorShuffle.fromMemorySegment(SPECIES, a, i, bo);
++               shuffle.intoMemorySegment(r, i, bo);
++           }
++       }
++
++       for (int i = 0; i < l / 4; i++) {
++           int ai = a.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED.withOrder(bo), i);
++           int ri = r.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED.withOrder(bo), i);
++           Assert.assertEquals(testPartiallyWrapIndex(SPECIES, ai), ri);
++       }
++   }
++
++   @Test(dataProvider = "shuffleIntByteProviderForIOOBE")
++   static void shuffleLoadMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {
++       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i));
++       MemorySegment r = Arena.ofAuto().allocate(a.byteSize());
++
++       int l = (int) a.byteSize();
++       int s = SPECIES.length() * 4;
++
++       for (int ic = 0; ic < INVOC_COUNT; ic++) {
++           for (int i = 0; i < l; i += s) {
++               VectorShuffle<Float16> shuffle = shuffleFromMemorySegment(a, i, ByteOrder.nativeOrder());
++               shuffle.intoMemorySegment(r, i, ByteOrder.nativeOrder());
++           }
++       }
++
++       int index = fi.apply((int) a.byteSize());
++       boolean shouldFail = isIndexOutOfBounds(s, index, (int) a.byteSize());
++       try {
++           shuffleFromMemorySegment(a, index, ByteOrder.nativeOrder());
++           if (shouldFail) {
++               Assert.fail("Failed to throw IndexOutOfBoundsException");
++           }
++       } catch (IndexOutOfBoundsException e) {
++           if (!shouldFail) {
++               Assert.fail("Unexpected IndexOutOfBoundsException");
++           }
++       }
++   }
++
++   @Test(dataProvider = "shuffleIntByteProviderForIOOBE")
++   static void shuffleStoreMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {
++       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i));
++       MemorySegment r = Arena.ofAuto().allocate(a.byteSize());
++
++       int l = (int) a.byteSize();
++       int s = SPECIES.length() * 4;
++
++       for (int ic = 0; ic < INVOC_COUNT; ic++) {
++           for (int i = 0; i < l; i += s) {
++               VectorShuffle<Float16> shuffle =
++                       VectorShuffle.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());
++               shuffleIntoMemorySegment(shuffle, r, i, ByteOrder.nativeOrder());
++           }
++       }
++
++       int index = fi.apply((int) a.byteSize());
++       boolean shouldFail = isIndexOutOfBounds(s, index, (int) a.byteSize());
++       try {
++           VectorShuffle<Float16> shuffle =
++                   VectorShuffle.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());
++           shuffleIntoMemorySegment(shuffle, r, index, ByteOrder.nativeOrder());
++           if (shouldFail) {
++               Assert.fail("Failed to throw IndexOutOfBoundsException");
++           }
++       } catch (IndexOutOfBoundsException e) {
++           if (!shouldFail) {
++               Assert.fail("Unexpected IndexOutOfBoundsException");
++           }
++       }
++   }
 +
 +
 +
 +
 +    // Gather/Scatter load/store tests
 +
 +    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {
 +        int i = 0;
 +        int j = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                j = i;
 +                for (; j < i + SPECIES.length(); j++) {
 +                    Assert.assertEquals(r[j], a[i + indexMap[j]]);
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[j], a[i + indexMap[j]], "at index #" + j);
 +        }
 +    }
 +
 +    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {
 +        int i = 0;
 +        int j = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                j = i;
 +                for (; j < i + SPECIES.length(); j++) {
 +                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, "at index #" + j);
 +        }
 +    }
 +
 +    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {
 +        short[] expected = new short[r.length];
 +
 +        // Store before checking, since the same location may be stored to more than once
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            for (int j = i; j < i + SPECIES.length(); j++) {
 +                if (mask[j % SPECIES.length()]) {
 +                    expected[i + indexMap[j]] = a[j];
 +                }
 +            }
 +        }
 +
 +        Assert.assertEquals(r, expected);
 +    }
 +
 +    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {
 +        short[] expected = new short[r.length];
 +
 +        // Store before checking, since the same location may be stored to more than once
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            for (int j = i; j < i + SPECIES.length(); j++) {
 +                expected[i + indexMap[j]] = a[j];
 +            }
 +        }
 +
 +        Assert.assertEquals(r, expected);
 +    }
 +
 +    @DataProvider
 +    public Object[][] gatherScatterProvider() {
 +        return INT_INDEX_GENERATORS.stream().
 +                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                    return new Object[] {fa, fs};
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] gatherScatterMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->
 +            HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                    return new Object[] {fa, fm, fs};
 +            }))).
 +            toArray(Object[][]::new);
 +    }
 +
 +
 +    @Test(dataProvider = "gatherScatterProvider")
 +    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {
 +        short[] a = fa.apply(SPECIES.length());
 +        int[] b = fs.apply(a.length, SPECIES.length());
 +        short[] r = new short[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i);
 +                av.intoArray(r, i);
 +            }
 +        }
 +
 +        assertGatherArraysEquals(r, a, b);
 +    }
 +
 +    @Test(dataProvider = "gatherScatterMaskProvider")
 +    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        int[] b = fs.apply(a.length, SPECIES.length());
 +        short[] r = new short[a.length];
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i, vmask);
 +                av.intoArray(r, i);
 +            }
 +        }
 +
 +        assertGatherArraysEquals(r, a, b, mask);
 +    }
 +
 +    @Test(dataProvider = "gatherScatterProvider")
 +    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {
 +        short[] a = fa.apply(SPECIES.length());
 +        int[] b = fs.apply(a.length, SPECIES.length());
 +        short[] r = new short[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.intoArray(r, i, b, i);
 +            }
 +        }
 +
 +        assertScatterArraysEquals(r, a, b);
 +    }
 +
 +    @Test(dataProvider = "gatherScatterMaskProvider")
 +    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        int[] b = fs.apply(a.length, SPECIES.length());
 +        short[] r = new short[a.length];
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.intoArray(r, i, b, i, vmask);
 +            }
 +        }
 +
 +        assertScatterArraysEquals(r, a, b, mask);
 +    }
 +
 +
 +
 +}
diff --cc test/jdk/jdk/incubator/vector/HalffloatMaxVectorTests.java
index fc1ca6fa5bc,00000000000..68e1e46ecb7
mode 100644,000000..100644
--- a/test/jdk/jdk/incubator/vector/HalffloatMaxVectorTests.java
+++ b/test/jdk/jdk/incubator/vector/HalffloatMaxVectorTests.java
@@@ -1,3123 -1,0 +1,3245 @@@
 +/*
-  * Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
 + * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 + *
 + * This code is free software; you can redistribute it and/or modify it
 + * under the terms of the GNU General Public License version 2 only, as
 + * published by the Free Software Foundation.
 + *
 + * This code is distributed in the hope that it will be useful, but WITHOUT
 + * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 + * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 + * version 2 for more details (a copy is included in the LICENSE file that
 + * accompanied this code).
 + *
 + * You should have received a copy of the GNU General Public License version
 + * 2 along with this work; if not, write to the Free Software Foundation,
 + * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 + *
 + * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 + * or visit www.oracle.com if you need additional information or have any
 + * questions.
 + */
 +
 +/*
 + * @test
++ * @key randomness
++ *
++ * @library /test/lib
 + * @modules jdk.incubator.vector
-  * @run testng/othervm -ea -esa -Xbatch -XX:-TieredCompilation HalffloatMaxVectorTests
++ * @run testng/othervm/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation HalffloatMaxVectorTests
 + */
 +
 +// -- This file was mechanically generated: Do not edit! -- //
 +
 +import jdk.incubator.vector.VectorShape;
 +import jdk.incubator.vector.VectorSpecies;
 +import jdk.incubator.vector.VectorShuffle;
 +import jdk.incubator.vector.VectorMask;
 +import jdk.incubator.vector.VectorOperators;
 +import jdk.incubator.vector.Vector;
 +
- import jdk.incubator.vector.Halffloat;
++import jdk.incubator.vector.Float16;
 +import jdk.incubator.vector.HalffloatVector;
 +
 +import org.testng.Assert;
 +import org.testng.annotations.DataProvider;
 +import org.testng.annotations.Test;
 +
 +import java.lang.Integer;
 +import java.util.List;
 +import java.util.Arrays;
 +import java.util.function.BiFunction;
 +import java.util.function.IntFunction;
 +import java.util.Objects;
 +import java.util.stream.Collectors;
 +import java.util.stream.Stream;
 +
 +@Test
 +public class HalffloatMaxVectorTests extends AbstractVectorTest {
 +
-     static final VectorSpecies<Halffloat> SPECIES =
++    static final VectorSpecies<Float16> SPECIES =
 +                HalffloatVector.SPECIES_MAX;
 +
 +    static final int INVOC_COUNT = Integer.getInteger("jdk.incubator.vector.test.loop-iterations", 100);
 +
 +    static VectorShape getMaxBit() {
 +        return VectorShape.S_Max_BIT;
 +    }
 +
 +    private static final int Max = 256;  // juts so we can do N/Max
 +
++    // for floating point addition reduction ops that may introduce rounding errors
++    private static final short RELATIVE_ROUNDING_ERROR_FACTOR_ADD = (short)10.0;
++
++    // for floating point multiplication reduction ops that may introduce rounding errors
++    private static final short RELATIVE_ROUNDING_ERROR_FACTOR_MUL = (short)50.0;
 +
 +    static final int BUFFER_REPS = Integer.getInteger("jdk.incubator.vector.test.buffer-vectors", 25000 / Max);
 +
++    static void assertArraysStrictlyEquals(short[] r, short[] a) {
++        for (int i = 0; i < a.length; i++) {
++            short ir = Float16.shortToRawShortBits(r[i]);
++            short ia = Float16.shortToRawShortBits(a[i]);
++            if (ir != ia) {
++                Assert.fail(String.format("at index #%d, expected = %016X, actual = %016X", i, ia, ir));
++            }
++        }
++    }
++
 +    interface FUnOp {
 +        short apply(short a);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, FUnOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i]), "at index #" + i + ", input = " + a[i]);
 +        }
 +    }
 +
 +    interface FUnArrayOp {
 +        short[] apply(short a);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, FUnArrayOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a[i]));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a[i]);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref, "(ref: " + Arrays.toString(ref)
 +              + ", res: " + Arrays.toString(res)
 +              + "), at index #" + i);
 +        }
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, boolean[] mask, FUnOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], "at index #" + i + ", input = " + a[i] + ", mask = " + mask[i % SPECIES.length()]);
 +        }
 +    }
 +
 +    interface FReductionOp {
 +        short apply(short[] a, int idx);
 +    }
 +
 +    interface FReductionAllOp {
 +        short apply(short[] a);
 +    }
 +
 +    static void assertReductionArraysEquals(short[] r, short rc, short[] a,
 +                                            FReductionOp f, FReductionAllOp fa) {
++        assertReductionArraysEquals(r, rc, a, f, fa, (short)0.0);
++    }
++
++    static void assertReductionArraysEquals(short[] r, short rc, short[] a,
++                                            FReductionOp f, FReductionAllOp fa,
++                                            short relativeErrorFactor) {
 +        int i = 0;
 +        try {
-             Assert.assertEquals(rc, fa.apply(a));
++            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor);
 +            for (; i < a.length; i += SPECIES.length()) {
-                 Assert.assertEquals(r[i], f.apply(a, i));
++                Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor);
 +            }
 +        } catch (AssertionError e) {
-             Assert.assertEquals(rc, fa.apply(a), "Final result is incorrect!");
-             Assert.assertEquals(r[i], f.apply(a, i), "at index #" + i);
++            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor, "Final result is incorrect!");
++            Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor, "at index #" + i);
 +        }
 +    }
 +
 +    interface FReductionMaskedOp {
 +        short apply(short[] a, int idx, boolean[] mask);
 +    }
 +
 +    interface FReductionAllMaskedOp {
 +        short apply(short[] a, boolean[] mask);
 +    }
 +
 +    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,
 +                                            FReductionMaskedOp f, FReductionAllMaskedOp fa) {
++        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, (short)0.0);
++    }
++
++    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,
++                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,
++                                            short relativeError) {
 +        int i = 0;
 +        try {
-             Assert.assertEquals(rc, fa.apply(a, mask));
++            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));
 +            for (; i < a.length; i += SPECIES.length()) {
-                 Assert.assertEquals(r[i], f.apply(a, i, mask));
++                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *
++relativeError));
 +            }
 +        } catch (AssertionError e) {
-             Assert.assertEquals(rc, fa.apply(a, mask), "Final result is incorrect!");
-             Assert.assertEquals(r[i], f.apply(a, i, mask), "at index #" + i);
++            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), "Final result is incorrect!");
++            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), "at index #" + i);
 +        }
 +    }
 +
 +    interface FReductionOpLong {
 +        long apply(short[] a, int idx);
 +    }
 +
 +    interface FReductionAllOpLong {
 +        long apply(short[] a);
 +    }
 +
 +    static void assertReductionLongArraysEquals(long[] r, long rc, short[] a,
 +                                            FReductionOpLong f, FReductionAllOpLong fa) {
 +        int i = 0;
 +        try {
 +            Assert.assertEquals(rc, fa.apply(a));
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(r[i], f.apply(a, i));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(rc, fa.apply(a), "Final result is incorrect!");
 +            Assert.assertEquals(r[i], f.apply(a, i), "at index #" + i);
 +        }
 +    }
 +
 +    interface FReductionMaskedOpLong {
 +        long apply(short[] a, int idx, boolean[] mask);
 +    }
 +
 +    interface FReductionAllMaskedOpLong {
 +        long apply(short[] a, boolean[] mask);
 +    }
 +
 +    static void assertReductionLongArraysEqualsMasked(long[] r, long rc, short[] a, boolean[] mask,
 +                                            FReductionMaskedOpLong f, FReductionAllMaskedOpLong fa) {
 +        int i = 0;
 +        try {
 +            Assert.assertEquals(rc, fa.apply(a, mask));
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(r[i], f.apply(a, i, mask));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(rc, fa.apply(a, mask), "Final result is incorrect!");
 +            Assert.assertEquals(r[i], f.apply(a, i, mask), "at index #" + i);
 +        }
 +    }
 +
 +    interface FBoolReductionOp {
 +        boolean apply(boolean[] a, int idx);
 +    }
 +
 +    static void assertReductionBoolArraysEquals(boolean[] r, boolean[] a, FBoolReductionOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(r[i], f.apply(a, i));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a, i), "at index #" + i);
 +        }
 +    }
 +
 +    interface FMaskReductionOp {
 +        int apply(boolean[] a, int idx);
 +    }
 +
 +    static void assertMaskReductionArraysEquals(int[] r, boolean[] a, FMaskReductionOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(r[i], f.apply(a, i));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a, i), "at index #" + i);
 +        }
 +    }
 +
-     static void assertInsertArraysEquals(short[] r, short[] a, short element, int index, int start, int end) {
-         int i = start;
-         try {
-             for (; i < end; i += 1) {
-                 if(i%SPECIES.length() == index) {
-                     Assert.assertEquals(r[i], element);
-                 } else {
-                     Assert.assertEquals(r[i], a[i]);
-                 }
-             }
-         } catch (AssertionError e) {
-             if (i%SPECIES.length() == index) {
-                 Assert.assertEquals(r[i], element, "at index #" + i);
-             } else {
-                 Assert.assertEquals(r[i], a[i], "at index #" + i);
-             }
-         }
-     }
- 
 +    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, int vector_len) {
 +        int i = 0, j = 0;
 +        try {
 +            for (; i < a.length; i += vector_len) {
 +                for (j = 0; j < vector_len; j++) {
 +                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            int idx = i + j;
 +            Assert.assertEquals(r[i+j], a[i+order[i+j]], "at index #" + idx + ", input = " + a[i+order[i+j]]);
 +        }
 +    }
 +
 +    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {
 +        int i = 0, j = 0, k = 0;
 +        try {
 +            for (; i < a.length; i += vector_len) {
 +                k = 0;
 +                for (j = 0; j < vector_len; j++) {
 +                    if (m[(i + j) % SPECIES.length()]) {
 +                        Assert.assertEquals(r[i + k], a[i + j]);
 +                        k++;
 +                    }
 +                }
 +                for (; k < vector_len; k++) {
 +                    Assert.assertEquals(r[i + k], (short)0);
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            int idx = i + k;
 +            if (m[(i + j) % SPECIES.length()]) {
 +                Assert.assertEquals(r[idx], a[i + j], "at index #" + idx);
 +            } else {
 +                Assert.assertEquals(r[idx], (short)0, "at index #" + idx);
 +            }
 +        }
 +    }
 +
 +    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {
 +        int i = 0, j = 0, k = 0;
 +        try {
 +            for (; i < a.length; i += vector_len) {
 +                k = 0;
 +                for (j = 0; j < vector_len; j++) {
 +                    if (m[(i + j) % SPECIES.length()]) {
 +                        Assert.assertEquals(r[i + j], a[i + k]);
 +                        k++;
 +                    } else {
 +                        Assert.assertEquals(r[i + j], (short)0);
 +                    }
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            int idx = i + j;
 +            if (m[idx % SPECIES.length()]) {
 +                Assert.assertEquals(r[idx], a[i + k], "at index #" + idx);
 +            } else {
 +                Assert.assertEquals(r[idx], (short)0, "at index #" + idx);
 +            }
 +        }
 +    }
 +
++    static void assertSelectFromTwoVectorEquals(short[] r, short[] order, short[] a, short[] b, int vector_len) {
++        int i = 0, j = 0;
++        boolean is_exceptional_idx = false;
++        int idx = 0, wrapped_index = 0, oidx = 0;
++        try {
++            for (; i < a.length; i += vector_len) {
++                for (j = 0; j < vector_len; j++) {
++                    idx = i + j;
++                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);
++                    is_exceptional_idx = wrapped_index >= vector_len;
++                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;
++                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));
++                }
++            }
++        } catch (AssertionError e) {
++            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), "at index #" + idx + ", order = " + order[idx] + ", a = " + a[i + oidx] + ", b = " + b[i + oidx]);
++        }
++    }
++
 +    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, int vector_len) {
 +        int i = 0, j = 0;
 +        try {
 +            for (; i < a.length; i += vector_len) {
 +                for (j = 0; j < vector_len; j++) {
 +                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            int idx = i + j;
 +            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], "at index #" + idx + ", input = " + a[i+(int)order[i+j]]);
 +        }
 +    }
 +
 +    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, boolean[] mask, int vector_len) {
 +        int i = 0, j = 0;
 +        try {
 +            for (; i < a.length; i += vector_len) {
 +                for (j = 0; j < vector_len; j++) {
 +                    if (mask[j % SPECIES.length()])
 +                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);
 +                    else
 +                         Assert.assertEquals(r[i+j], (short)0);
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            int idx = i + j;
 +            if (mask[j % SPECIES.length()])
 +                Assert.assertEquals(r[i+j], a[i+order[i+j]], "at index #" + idx + ", input = " + a[i+order[i+j]] + ", mask = " + mask[j % SPECIES.length()]);
 +            else
 +                Assert.assertEquals(r[i+j], (short)0, "at index #" + idx + ", input = " + a[i+order[i+j]] + ", mask = " + mask[j % SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, boolean[] mask, int vector_len) {
 +        int i = 0, j = 0;
 +        try {
 +            for (; i < a.length; i += vector_len) {
 +                for (j = 0; j < vector_len; j++) {
 +                    if (mask[j % SPECIES.length()])
 +                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);
 +                    else
 +                         Assert.assertEquals(r[i+j], (short)0);
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            int idx = i + j;
 +            if (mask[j % SPECIES.length()])
 +                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], "at index #" + idx + ", input = " + a[i+(int)order[i+j]] + ", mask = " + mask[j % SPECIES.length()]);
 +            else
 +                Assert.assertEquals(r[i+j], (short)0, "at index #" + idx + ", input = " + a[i+(int)order[i+j]] + ", mask = " + mask[j % SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertBroadcastArraysEquals(short[] r, short[] a) {
 +        int i = 0;
 +        for (; i < a.length; i += SPECIES.length()) {
 +            int idx = i;
 +            for (int j = idx; j < (idx + SPECIES.length()); j++)
 +                a[j]=a[idx];
 +        }
 +
 +        try {
 +            for (i = 0; i < a.length; i++) {
 +                Assert.assertEquals(r[i], a[i]);
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], a[i], "at index #" + i + ", input = " + a[i]);
 +        }
 +    }
 +
 +    interface FBinOp {
 +        short apply(short a, short b);
 +    }
 +
 +    interface FBinMaskOp {
 +        short apply(short a, short b, boolean m);
 +
 +        static FBinMaskOp lift(FBinOp f) {
 +            return (a, b, m) -> m ? f.apply(a, b) : a;
 +        }
 +    }
 +
++    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, FBinOp f) {
++        int i = 0;
++        try {
++            for (; i < a.length; i++) {
++                //Left associative
++                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));
++
++                //Right associative
++                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));
++
++                //Results equal sanity check
++                Assert.assertEquals(rl[i], rr[i]);
++            }
++        } catch (AssertionError e) {
++            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), "left associative test at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", input3 = " + c[i]);
++            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), "right associative test at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", input3 = " + c[i]);
++            Assert.assertEquals(rl[i], rr[i], "Result checks not equal at index #" + i + "leftRes = " + rl[i] + ", rightRes = " + rr[i]);
++        }
++    }
++
++   static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinOp f) {
++       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));
++   }
++
++    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinMaskOp f) {
++        int i = 0;
++        boolean mask_bit = false;
++        try {
++            for (; i < a.length; i++) {
++                mask_bit = mask[i % SPECIES.length()];
++                //Left associative
++                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));
++
++                //Right associative
++                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));
++
++                //Results equal sanity check
++                Assert.assertEquals(rl[i], rr[i]);
++            }
++        } catch (AssertionError e) {
++            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), "left associative masked test at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", input3 = " + c[i] + ", mask = " + mask_bit);
++            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), "right associative masked test at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", input3 = " + c[i] + ", mask = " + mask_bit);
++            Assert.assertEquals(rl[i], rr[i], "Result checks not equal at index #" + i + "leftRes = " + rl[i] + ", rightRes = " + rr[i]);
++        }
++    }
++
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[i]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[i]), "(" + a[i] + ", " + b[i] + ") at index #" + i);
 +        }
 +    }
 +
++    static void assertArraysEquals(short[] r, short[] a, short b, FBinOp f) {
++        int i = 0;
++        try {
++            for (; i < a.length; i++) {
++                Assert.assertEquals(r[i], f.apply(a[i], b));
++            }
++        } catch (AssertionError e) {
++            Assert.assertEquals(r[i], f.apply(a[i], b), "(" + a[i] + ", " + b + ") at index #" + i);
++        }
++    }
++
 +    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()]),
 +                                "(" + a[i] + ", " + b[(i / SPECIES.length()) * SPECIES.length()] + ") at index #" + i);
 +        }
 +    }
 +
 +    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i / SPECIES.length()) * SPECIES.length()])));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i / SPECIES.length()) * SPECIES.length()])),
 +                                "(" + a[i] + ", " + b[(i / SPECIES.length()) * SPECIES.length()] + ") at index #" + i);
 +        }
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {
 +        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), "at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", mask = " + mask[i % SPECIES.length()]);
 +        }
 +    }
 +
++    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinOp f) {
++        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));
++    }
++
++    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinMaskOp f) {
++        int i = 0;
++        try {
++            for (; i < a.length; i++) {
++                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));
++            }
++        } catch (AssertionError err) {
++            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), "at index #" + i + ", input1 = " + a[i] + ", input2 = " + b + ", mask = " + mask[i % SPECIES.length()]);
++        }
++    }
++
 +    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {
 +        assertBroadcastArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));
 +    }
 +
 +    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()],
 +                                mask[i % SPECIES.length()]), "at index #" + i + ", input1 = " + a[i] +
 +                                ", input2 = " + b[(i / SPECIES.length()) * SPECIES.length()] + ", mask = " +
 +                                mask[i % SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {
 +        assertBroadcastLongArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));
 +    }
 +
 +    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i / SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i / SPECIES.length()) * SPECIES.length()]),
 +                                mask[i % SPECIES.length()]), "at index #" + i + ", input1 = " + a[i] +
 +                                ", input2 = " + b[(i / SPECIES.length()) * SPECIES.length()] + ", mask = " +
 +                                mask[i % SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {
 +        int i = 0;
 +        int j = 0;
 +        try {
 +            for (; j < a.length; j += SPECIES.length()) {
 +                for (i = 0; i < SPECIES.length(); i++) {
 +                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), "at index #" + i + ", " + j);
 +        }
 +    }
 +
 +    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {
 +        assertShiftArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));
 +    }
 +
 +    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {
 +        int i = 0;
 +        int j = 0;
 +        try {
 +            for (; j < a.length; j += SPECIES.length()) {
 +                for (i = 0; i < SPECIES.length(); i++) {
 +                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));
 +                }
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), "at index #" + i + ", input1 = " + a[i+j] + ", input2 = " + b[j] + ", mask = " + mask[i]);
 +        }
 +    }
 +
 +    interface FBinConstOp {
 +        short apply(short a);
 +    }
 +
 +    interface FBinConstMaskOp {
 +        short apply(short a, boolean m);
 +
 +        static FBinConstMaskOp lift(FBinConstOp f) {
 +            return (a, m) -> m ? f.apply(a) : a;
 +        }
 +    }
 +
 +    static void assertShiftConstEquals(short[] r, short[] a, FBinConstOp f) {
 +        int i = 0;
 +        int j = 0;
 +        try {
 +            for (; j < a.length; j += SPECIES.length()) {
 +                for (i = 0; i < SPECIES.length(); i++) {
 +                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));
 +                }
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i+j], f.apply(a[i+j]), "at index #" + i + ", " + j);
 +        }
 +    }
 +
 +    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstOp f) {
 +        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));
 +    }
 +
 +    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstMaskOp f) {
 +        int i = 0;
 +        int j = 0;
 +        try {
 +            for (; j < a.length; j += SPECIES.length()) {
 +                for (i = 0; i < SPECIES.length(); i++) {
 +                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));
 +                }
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), "at index #" + i + ", input1 = " + a[i+j] + ", mask = " + mask[i]);
 +        }
 +    }
 +
 +    interface FTernOp {
 +        short apply(short a, short b, short c);
 +    }
 +
 +    interface FTernMaskOp {
 +        short apply(short a, short b, short c, boolean m);
 +
 +        static FTernMaskOp lift(FTernOp f) {
 +            return (a, b, c, m) -> m ? f.apply(a, b, c) : a;
 +        }
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), "at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", input3 = " + c[i]);
 +        }
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernOp f) {
 +        assertArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernMaskOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), "at index #" + i + ", input1 = " + a[i] + ", input2 = "
 +              + b[i] + ", input3 = " + c[i] + ", mask = " + mask[i % SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i / SPECIES.length()) * SPECIES.length()]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i / SPECIES.length()) * SPECIES.length()]), "at index #" +
 +                                i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", input3 = " +
 +                                c[(i / SPECIES.length()) * SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()], c[i]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()], c[i]), "at index #" +
 +                                i + ", input1 = " + a[i] + ", input2 = " +
 +                                b[(i / SPECIES.length()) * SPECIES.length()] + ",  input3 = " + c[i]);
 +        }
 +    }
 +
 +    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,
 +                                            FTernOp f) {
 +        assertBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));
 +    }
 +
 +    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,
 +                                            FTernMaskOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i / SPECIES.length()) * SPECIES.length()],
 +                                    mask[i % SPECIES.length()]));
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i / SPECIES.length()) * SPECIES.length()],
 +                                mask[i % SPECIES.length()]), "at index #" + i + ", input1 = " + a[i] + ", input2 = " +
 +                                b[i] + ", input3 = " + c[(i / SPECIES.length()) * SPECIES.length()] + ", mask = " +
 +                                mask[i % SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,
 +                                            FTernOp f) {
 +        assertAltBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));
 +    }
 +
 +    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,
 +                                            FTernMaskOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()], c[i],
 +                                    mask[i % SPECIES.length()]));
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()], c[i],
 +                                mask[i % SPECIES.length()]), "at index #" + i + ", input1 = " + a[i] +
 +                                ", input2 = " + b[(i / SPECIES.length()) * SPECIES.length()] +
 +                                ", input3 = " + c[i] + ", mask = " + mask[i % SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()],
 +                                    c[(i / SPECIES.length()) * SPECIES.length()]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()],
 +                                c[(i / SPECIES.length()) * SPECIES.length()]), "at index #" + i + ", input1 = " + a[i]
 +                                + ", input2 = " + b[(i / SPECIES.length()) * SPECIES.length()] + ", input3 = " +
 +                                c[(i / SPECIES.length()) * SPECIES.length()]);
 +        }
 +    }
 +
 +    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,
 +                                                  FTernOp f) {
 +        assertDoubleBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));
 +    }
 +
 +    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,
 +                                                  FTernMaskOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i++) {
 +                Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()],
 +                                    c[(i / SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));
 +            }
 +        } catch (AssertionError err) {
 +            Assert.assertEquals(r[i], f.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()],
 +                                c[(i / SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]), "at index #"
 +                                + i + ", input1 = " + a[i] + ", input2 = " + b[(i / SPECIES.length()) * SPECIES.length()] +
 +                                ", input3 = " + c[(i / SPECIES.length()) * SPECIES.length()] + ", mask = " +
 +                                mask[i % SPECIES.length()]);
 +        }
 +    }
 +
 +
 +    static boolean isWithin1Ulp(short actual, short expected) {
 +        float act = Float.float16ToFloat(actual);
 +        float exp = Float.float16ToFloat(expected);
 +        if (Float.isNaN(exp) && !Float.isNaN(act)) {
 +            return false;
 +        } else if (!Float.isNaN(exp) && Float.isNaN(act)) {
 +             return false;
 +        }
 +
 +        float low = Math.nextDown(exp);
 +        float high = Math.nextUp(exp);
 +
 +        if (Float.compare(low, exp) > 0) {
 +            return false;
 +        }
 +
 +        if (Float.compare(high, exp) < 0) {
 +            return false;
 +        }
 +
 +        return true;
 +    }
 +
 +    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, FUnOp mathf, FUnOp strictmathf) {
 +        int i = 0;
 +        try {
 +            // Check that result is within 1 ulp of strict math or equivalent to math implementation.
 +            for (; i < a.length; i++) {
 +                Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i])) == 0 ||
 +                                    isWithin1Ulp(r[i], strictmathf.apply(a[i])));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i])) == 0, "at index #" + i + ", input = " + a[i] + ", actual = " + r[i] + ", expected = " + mathf.apply(a[i]));
 +            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i])), "at index #" + i + ", input = " + a[i] + ", actual = " + r[i] + ", expected (within 1 ulp) = " + strictmathf.apply(a[i]));
 +        }
 +    }
 +
 +    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b, FBinOp mathf, FBinOp strictmathf) {
 +        int i = 0;
 +        try {
 +            // Check that result is within 1 ulp of strict math or equivalent to math implementation.
 +            for (; i < a.length; i++) {
 +                Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i], b[i])) == 0 ||
 +                                    isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i], b[i])) == 0, "at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", actual = " + r[i] + ", expected = " + mathf.apply(a[i], b[i]));
 +            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])), "at index #" + i + ", input1 = " + a[i] + ", input2 = " + b[i] + ", actual = " + r[i] + ", expected (within 1 ulp) = " + strictmathf.apply(a[i], b[i]));
 +        }
 +    }
 +
 +    static void assertBroadcastArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b,
 +                                                        FBinOp mathf, FBinOp strictmathf) {
 +        int i = 0;
 +        try {
 +            // Check that result is within 1 ulp of strict math or equivalent to math implementation.
 +            for (; i < a.length; i++) {
 +                Assert.assertTrue(Halffloat.compare(r[i],
 +                                  mathf.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()])) == 0 ||
 +                                  isWithin1Ulp(r[i],
 +                                  strictmathf.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()])));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertTrue(Halffloat.compare(r[i],
 +                              mathf.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()])) == 0,
 +                              "at index #" + i + ", input1 = " + a[i] + ", input2 = " +
 +                              b[(i / SPECIES.length()) * SPECIES.length()] + ", actual = " + r[i] +
 +                              ", expected = " + mathf.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()]));
 +            Assert.assertTrue(isWithin1Ulp(r[i],
 +                              strictmathf.apply(a[i], b[(i / SPECIES.length()) * SPECIES.length()])),
 +                             "at index #" + i + ", input1 = " + a[i] + ", input2 = " +
 +                             b[(i / SPECIES.length()) * SPECIES.length()] + ", actual = " + r[i] +
 +                             ", expected (within 1 ulp) = " + strictmathf.apply(a[i],
 +                             b[(i / SPECIES.length()) * SPECIES.length()]));
 +        }
 +    }
 +
-     interface FBinArrayOp {
-         short apply(short[] a, int b);
-     }
- 
-     static void assertArraysEquals(short[] r, short[] a, FBinArrayOp f) {
-         int i = 0;
-         try {
-             for (; i < a.length; i++) {
-                 Assert.assertEquals(r[i], f.apply(a, i));
-             }
-         } catch (AssertionError e) {
-             Assert.assertEquals(r[i], f.apply(a,i), "at index #" + i);
-         }
-     }
- 
 +    interface FGatherScatterOp {
 +        short[] apply(short[] a, int ix, int[] b, int iy);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, int[] b, FGatherScatterOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a, i, b, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a, i, b, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref,
 +              "(ref: " + Arrays.toString(ref) + ", res: " + Arrays.toString(res) + ", a: "
 +              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))
 +              + ", b: "
 +              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))
 +              + " at index #" + i);
 +        }
 +    }
 +
 +    interface FGatherMaskedOp {
 +        short[] apply(short[] a, int ix, boolean[] mask, int[] b, int iy);
 +    }
 +
 +    interface FScatterMaskedOp {
 +        short[] apply(short[] r, short[] a, int ix, boolean[] mask, int[] b, int iy);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FGatherMaskedOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a, i, mask, b, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a, i, mask, b, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref,
 +              "(ref: " + Arrays.toString(ref) + ", res: " + Arrays.toString(res) + ", a: "
 +              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))
 +              + ", b: "
 +              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))
 +              + ", mask: "
 +              + Arrays.toString(mask)
 +              + " at index #" + i);
 +        }
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FScatterMaskedOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(r, a, i, mask, b, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(r, a, i, mask, b, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref,
 +              "(ref: " + Arrays.toString(ref) + ", res: " + Arrays.toString(res) + ", a: "
 +              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))
 +              + ", b: "
 +              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))
 +              + ", r: "
 +              + Arrays.toString(Arrays.copyOfRange(r, i, i+SPECIES.length()))
 +              + ", mask: "
 +              + Arrays.toString(mask)
 +              + " at index #" + i);
 +        }
 +    }
 +
 +    interface FLaneOp {
 +        short[] apply(short[] a, int origin, int idx);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, int origin, FLaneOp f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a, origin, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a, origin, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref, "(ref: " + Arrays.toString(ref)
 +              + ", res: " + Arrays.toString(res)
 +              + "), at index #" + i);
 +        }
 +    }
 +
 +    interface FLaneBop {
 +        short[] apply(short[] a, short[] b, int origin, int idx);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, FLaneBop f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a, b, origin, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a, b, origin, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref, "(ref: " + Arrays.toString(ref)
 +              + ", res: " + Arrays.toString(res)
 +              + "), at index #" + i
 +              + ", at origin #" + origin);
 +        }
 +    }
 +
 +    interface FLaneMaskedBop {
 +        short[] apply(short[] a, short[] b, int origin, boolean[] mask, int idx);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, boolean[] mask, FLaneMaskedBop f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a, b, origin, mask, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a, b, origin, mask, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref, "(ref: " + Arrays.toString(ref)
 +              + ", res: " + Arrays.toString(res)
 +              + "), at index #" + i
 +              + ", at origin #" + origin);
 +        }
 +    }
 +
 +    interface FLanePartBop {
 +        short[] apply(short[] a, short[] b, int origin, int part, int idx);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, FLanePartBop f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a, b, origin, part, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a, b, origin, part, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref, "(ref: " + Arrays.toString(ref)
 +              + ", res: " + Arrays.toString(res)
 +              + "), at index #" + i
 +              + ", at origin #" + origin
 +              + ", with part #" + part);
 +        }
 +    }
 +
 +    interface FLanePartMaskedBop {
 +        short[] apply(short[] a, short[] b, int origin, int part, boolean[] mask, int idx);
 +    }
 +
 +    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, boolean[] mask, FLanePartMaskedBop f) {
 +        int i = 0;
 +        try {
 +            for (; i < a.length; i += SPECIES.length()) {
 +                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),
 +                  f.apply(a, b, origin, part, mask, i));
 +            }
 +        } catch (AssertionError e) {
 +            short[] ref = f.apply(a, b, origin, part, mask, i);
 +            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());
 +            Assert.assertEquals(res, ref, "(ref: " + Arrays.toString(ref)
 +              + ", res: " + Arrays.toString(res)
 +              + "), at index #" + i
 +              + ", at origin #" + origin
 +              + ", with part #" + part);
 +        }
 +    }
 +
 +    static short genValue(int i) {
-         return (short) Halffloat.valueOf(i);
++        return Float16.float16ToRawShortBits(Float16.valueOf(i));
 +    }
 +
 +    static int intCornerCaseValue(int i) {
 +        switch(i % 5) {
 +            case 0:
 +                return Integer.MAX_VALUE;
 +            case 1:
 +                return Integer.MIN_VALUE;
 +            case 2:
 +                return Integer.MIN_VALUE;
 +            case 3:
 +                return Integer.MAX_VALUE;
 +            default:
 +                return (int)0;
 +        }
 +    }
 +
 +    static final List<IntFunction<short[]>> INT_HALFFLOAT_GENERATORS = List.of(
-             withToString("Halffloat[-i * 5]", (int s) -> {
++            withToString("Float16[-i * 5]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> genValue(-i * 5));
 +            }),
-             withToString("Halffloat[i * 5]", (int s) -> {
++            withToString("Float16[i * 5]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> genValue(i * 5));
 +            }),
-             withToString("Halffloat[i + 1]", (int s) -> {
++            withToString("Float16[i + 1]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
 +            }),
-             withToString("Halffloat[intCornerCaseValue(i)]", (int s) -> {
++            withToString("Float16[intCornerCaseValue(i)]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (short)intCornerCaseValue(i));
 +            })
 +    );
 +
 +    static void assertArraysEquals(int[] r, short[] a, int offs) {
 +        int i = 0;
 +        try {
 +            for (; i < r.length; i++) {
 +                Assert.assertEquals(r[i], (int)Float.float16ToFloat(a[i+offs]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], (int)(a[i+offs]), "at index #" + i + ", input = " + a[i+offs]);
 +        }
 +    }
 +
 +    static long longCornerCaseValue(int i) {
 +        switch(i % 5) {
 +            case 0:
 +                return Long.MAX_VALUE;
 +            case 1:
 +                return Long.MIN_VALUE;
 +            case 2:
 +                return Long.MIN_VALUE;
 +            case 3:
 +                return Long.MAX_VALUE;
 +            default:
 +                return (long)0;
 +        }
 +    }
 +
 +    static short genValue(long i) {
-         return (short) Halffloat.valueOf(i);
++        return Float16.float16ToRawShortBits(Float16.valueOf(i));
 +    }
 +
 +    static final List<IntFunction<short[]>> LONG_HALFFLOAT_GENERATORS = List.of(
-             withToString("Halffloat[-i * 5]", (int s) -> {
++            withToString("Float16[-i * 5]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> genValue(-i * 5));
 +            }),
-             withToString("Halffloat[i * 5]", (int s) -> {
++            withToString("Float16[i * 5]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> genValue(i * 5));
 +            }),
-             withToString("Halffloat[i + 1]", (int s) -> {
++            withToString("Float16[i + 1]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
 +            }),
-             withToString("Halffloat[cornerCaseValue(i)]", (int s) -> {
++            withToString("Float16[cornerCaseValue(i)]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (short)longCornerCaseValue(i));
 +            })
 +    );
 +
 +
 +    static void assertArraysEquals(long[] r, short[] a, int offs) {
 +        int i = 0;
 +        try {
 +            for (; i < r.length; i++) {
 +                Assert.assertEquals(r[i], (long)Float.float16ToFloat(a[i+offs]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], (long)(a[i+offs]), "at index #" + i + ", input = " + a[i+offs]);
 +        }
 +    }
 +
 +    static void assertArraysEquals(double[] r, short[] a, int offs) {
 +        int i = 0;
 +        try {
 +            for (; i < r.length; i++) {
 +                Assert.assertEquals(r[i], (double)Float.float16ToFloat(a[i+offs]));
 +            }
 +        } catch (AssertionError e) {
 +            Assert.assertEquals(r[i], (double)(a[i+offs]), "at index #" + i + ", input = " + a[i+offs]);
 +        }
 +    }
 +
 +    static short bits(short e) {
-         return  Halffloat.shortToShortBits(e);
++        return  Float16.shortToShortBits(e);
 +    }
 +
 +    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(
-             withToString("Halffloat[-i * 5]", (int s) -> {
++            withToString("Float16[-i * 5]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> genValue(-i * 5));
 +            }),
-             withToString("Halffloat[i * 5]", (int s) -> {
++            withToString("Float16[i * 5]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> genValue(i * 5));
 +            }),
-             withToString("Halffloat[i + 1]", (int s) -> {
++            withToString("Float16[i + 1]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
 +            }),
-             withToString("Halffloat[cornerCaseValue(i)]", (int s) -> {
++            withToString("short[0.01 + (i / (i + 1))]", (int s) -> {
++                return fill(s * BUFFER_REPS,
++                            i -> (short)0.01 + ((short)i / (i + 1)));
++            }),
++            withToString("short[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i / (i + 1))]", (int s) -> {
++                return fill(s * BUFFER_REPS,
++                            i -> i % 17 == 0 ? cornerCaseValue(i) : (short)0.01 + ((short)i / (i + 1)));
++            }),
++            withToString("short[cornerCaseValue(i)]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> cornerCaseValue(i));
 +            })
 +    );
 +
 +    // Create combinations of pairs
 +    // @@@ Might be sensitive to order e.g. div by 0
 +    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_PAIRS =
 +        Stream.of(HALFFLOAT_GENERATORS.get(0)).
 +                flatMap(fa -> HALFFLOAT_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).
 +                collect(Collectors.toList());
 +
 +    @DataProvider
 +    public Object[][] boolUnaryOpProvider() {
 +        return BOOL_ARRAY_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_TRIPLES =
 +        HALFFLOAT_GENERATOR_PAIRS.stream().
 +                flatMap(pair -> HALFFLOAT_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).
 +                collect(Collectors.toList());
 +
++    static final List<IntFunction<short[]>> SELECT_FROM_INDEX_GENERATORS = List.of(
++            withToString("short[0..VECLEN*2)", (int s) -> {
++                return fill(s * BUFFER_REPS,
++                            i -> (short)(RAND.nextInt()));
++            })
++    );
++
++    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_SELECT_FROM_TRIPLES =
++        HALFFLOAT_GENERATOR_PAIRS.stream().
++                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).
++                collect(Collectors.toList());
++
 +    @DataProvider
 +    public Object[][] shortBinaryOpProvider() {
 +        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortIndexedOpProvider() {
 +        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortBinaryOpMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_GENERATOR_PAIRS.stream().map(lfa -> {
 +                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortTernaryOpProvider() {
 +        return HALFFLOAT_GENERATOR_TRIPLES.stream().map(List::toArray).
 +                toArray(Object[][]::new);
 +    }
 +
++    @DataProvider
++    public Object[][] shortSelectFromTwoVectorOpProvider() {
++        return HALFFLOAT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).
++                toArray(Object[][]::new);
++    }
++
 +    @DataProvider
 +    public Object[][] shortTernaryOpMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_GENERATOR_TRIPLES.stream().map(lfa -> {
 +                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortUnaryOpProvider() {
 +        return HALFFLOAT_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortUnaryOpMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                    return new Object[] {fa, fm};
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shorttoIntUnaryOpProvider() {
 +        return INT_HALFFLOAT_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shorttoLongUnaryOpProvider() {
 +        return LONG_HALFFLOAT_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] maskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] maskCompareOpProvider() {
 +        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shuffleProvider() {
 +        return INT_SHUFFLE_GENERATORS.stream().
 +                map(f -> new Object[]{f}).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shuffleCompareOpProvider() {
 +        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortUnaryOpShuffleProvider() {
 +        return INT_SHUFFLE_GENERATORS.stream().
 +                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                    return new Object[] {fa, fs};
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortUnaryOpShuffleMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> INT_SHUFFLE_GENERATORS.stream().
 +                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                        return new Object[] {fa, fs, fm};
 +                }))).
 +                toArray(Object[][]::new);
 +    }
 +
 +    static final List<BiFunction<Integer,Integer,short[]>> HALFFLOAT_SHUFFLE_GENERATORS = List.of(
 +            withToStringBi("shuffle[random]", (Integer l, Integer m) -> {
 +                short[] a = new short[l];
 +                int upper = m;
 +                for (int i = 0; i < 1; i++) {
 +                    a[i] = (short)RAND.nextInt(upper);
 +                }
 +                return a;
 +            })
 +    );
 +
 +    @DataProvider
 +    public Object[][] shortUnaryOpSelectFromProvider() {
 +        return HALFFLOAT_SHUFFLE_GENERATORS.stream().
 +                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                    return new Object[] {fa, fs};
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortUnaryOpSelectFromMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_SHUFFLE_GENERATORS.stream().
 +                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {
 +                        return new Object[] {fa, fs, fm};
 +                }))).
 +                toArray(Object[][]::new);
 +    }
 +
 +    static final List<IntFunction<short[]>> HALFFLOAT_COMPARE_GENERATORS = List.of(
 +            withToString("short[i]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (short)i);
 +            }),
 +            withToString("short[i - length / 2]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (short)(i - (s * BUFFER_REPS / 2)));
 +            }),
 +            withToString("short[i + 1]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (short)(i + 1));
 +            }),
 +            withToString("short[i - 2]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> (short)(i - 2));
 +            }),
 +            withToString("short[zigZag(i)]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> i%3 == 0 ? (short)i : (i%3 == 1 ? (short)(i + 1) : (short)(i - 2)));
 +            }),
 +            withToString("short[cornerCaseValue(i)]", (int s) -> {
 +                return fill(s * BUFFER_REPS,
 +                            i -> cornerCaseValue(i));
 +            })
 +    );
 +
 +    static final List<List<IntFunction<short[]>>> HALFFLOAT_TEST_GENERATOR_ARGS =
 +        HALFFLOAT_COMPARE_GENERATORS.stream().
 +                map(fa -> List.of(fa)).
 +                collect(Collectors.toList());
 +
 +    @DataProvider
 +    public Object[][] shortTestOpProvider() {
 +        return HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(List::toArray).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortTestOpMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(lfa -> {
 +                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    static final List<List<IntFunction<short[]>>> HALFFLOAT_COMPARE_GENERATOR_PAIRS =
 +        HALFFLOAT_COMPARE_GENERATORS.stream().
 +                flatMap(fa -> HALFFLOAT_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).
 +                collect(Collectors.toList());
 +
 +    @DataProvider
 +    public Object[][] shortCompareOpProvider() {
 +        return HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).
 +                toArray(Object[][]::new);
 +    }
 +
 +    @DataProvider
 +    public Object[][] shortCompareOpMaskProvider() {
 +        return BOOLEAN_MASK_GENERATORS.stream().
 +                flatMap(fm -> HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {
 +                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();
 +                })).
 +                toArray(Object[][]::new);
 +    }
 +
 +    interface ToHalffloatF {
 +        short apply(int i);
 +    }
 +
 +    static short[] fill(int s , ToHalffloatF f) {
 +        return fill(new short[s], f);
 +    }
 +
 +    static short[] fill(short[] a, ToHalffloatF f) {
 +        for (int i = 0; i < a.length; i++) {
 +            a[i] = f.apply(i);
 +        }
 +        return a;
 +    }
 +
 +    static short cornerCaseValue(int i) {
-         switch(i % 7) {
-             case 0:
-                 return Halffloat.MAX_VALUE;
-             case 1:
-                 return Halffloat.MIN_VALUE;
-             case 2:
-                 return Halffloat.NEGATIVE_INFINITY;
-             case 3:
-                 return Halffloat.POSITIVE_INFINITY;
-             case 4:
-                 return Halffloat.NaN;
-             case 5:
-                 return (short)0.0;
-             default:
-                 return Short.MIN_VALUE;
-         }
-     }
- 
-     static short get(short[] a, int i) {
-         return (short) a[i];
++        return switch(i % 8) {
++            case 0  -> Float16.MAX_VALUE;
++            case 1  -> Float16.MIN_VALUE;
++            case 2  -> Float16.NEGATIVE_INFINITY;
++            case 3  -> Float16.POSITIVE_INFINITY;
++            case 4  -> Float16.NaN;
++            case 5  -> Double.longBitsToDouble(0x7FF123456789ABCDL);
++            case 6  -> (short)0.0;
++            default -> (short)-0.0;
++        };
 +    }
 +
 +    static final IntFunction<short[]> fr = (vl) -> {
 +        int length = BUFFER_REPS * vl;
 +        return new short[length];
 +    };
 +
 +    static final IntFunction<boolean[]> fmr = (vl) -> {
 +        int length = BUFFER_REPS * vl;
 +        return new boolean[length];
 +    };
 +
 +    static final IntFunction<long[]> lfr = (vl) -> {
 +        int length = BUFFER_REPS * vl;
 +        return new long[length];
 +    };
 +
 +    static boolean eq(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() == bt.floatValue();
 +    }
 +
 +    static boolean neq(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() != bt.floatValue();
 +    }
 +
 +    static boolean lt(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() < bt.floatValue();
 +    }
 +
 +    static boolean le(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() <= bt.floatValue();
 +    }
 +
 +    static boolean gt(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() > bt.floatValue();
 +    }
 +
 +    static boolean ge(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() >= bt.floatValue();
 +    }
 +
 +    static short firstNonZero(short a, short b) {
 +        return Short.compare(a, (short) 0) != 0 ? a : b;
 +    }
 +
 +    @Test
 +    static void smokeTest1() {
-         HalffloatVector three = HalffloatVector.broadcast(SPECIES, Halffloat.valueOf(-3));
-         HalffloatVector three2 = (HalffloatVector) SPECIES.broadcast(Halffloat.valueOf(-3));
++        HalffloatVector three = HalffloatVector.broadcast(SPECIES, Float16.float16ToRawShortBits(Float16.valueOf(-3)));
++        HalffloatVector three2 = (HalffloatVector) SPECIES.broadcast(Float16.float16ToRawShortBits(Float16.valueOf(-3)));
 +        assert(three.eq(three2).allTrue());
-         HalffloatVector three3 = three2.broadcast(Halffloat.valueOf(1)).broadcast(Halffloat.valueOf(-3));
++        HalffloatVector three3 = three2.broadcast(Float16.float16ToRawShortBits(Float16.valueOf(1))).broadcast(Float16.float16ToRawShortBits(Float16.valueOf(-3)));
 +        assert(three.eq(three3).allTrue());
 +        int scale = 2;
 +        HalffloatVector higher = three.addIndex(scale);
-         VectorMask<Halffloat> m = three.compare(VectorOperators.LE, higher);
++        VectorMask<Float16> m = three.compare(VectorOperators.LE, higher);
 +        assert(m.allTrue());
-         m = higher.min((Halffloat.valueOf(-1))).test(VectorOperators.IS_NEGATIVE);
++        m = higher.min((Float16.float16ToRawShortBits(Float16.valueOf(-1)))).test(VectorOperators.IS_NEGATIVE);
 +        assert(m.allTrue());
 +        m = higher.test(VectorOperators.IS_FINITE);
 +        assert(m.allTrue());
 +        short max = higher.reduceLanes(VectorOperators.MAX);
 +        assert((short) Float.float16ToFloat(max) == -3 + scale * (SPECIES.length()-1));
 +    }
 +
 +    private static short[]
 +    bothToArray(HalffloatVector a, HalffloatVector b) {
 +        short[] r = new short[a.length() + b.length()];
 +        a.intoArray(r, 0);
 +        b.intoArray(r, a.length());
 +        return r;
 +    }
 +
 +    @Test
 +    static void smokeTest2() {
 +        // Do some zipping and shuffling.
 +        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);
 +        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES,0,1,false).toVector();
 +        Assert.assertEquals(io, io2);
 +        HalffloatVector a = io.add((short)1); //[1,2]
 +        HalffloatVector b = a.neg();  //[-1,-2]
 +        short[] abValues = bothToArray(a,b); //[1,2,-1,-2]
-         VectorShuffle<Halffloat> zip0 = VectorShuffle.makeZip(SPECIES, 0);
-         VectorShuffle<Halffloat> zip1 = VectorShuffle.makeZip(SPECIES, 1);
++        VectorShuffle<Float16> zip0 = VectorShuffle.makeZip(SPECIES, 0);
++        VectorShuffle<Float16> zip1 = VectorShuffle.makeZip(SPECIES, 1);
 +        HalffloatVector zab0 = a.rearrange(zip0,b); //[1,-1]
 +        HalffloatVector zab1 = a.rearrange(zip1,b); //[2,-2]
 +        short[] zabValues = bothToArray(zab0, zab1); //[1,-1,2,-2]
 +        // manually zip
 +        short[] manual = new short[zabValues.length];
 +        for (int i = 0; i < manual.length; i += 2) {
 +            manual[i+0] = abValues[i/2];
 +            manual[i+1] = abValues[a.length() + i/2];
 +        }
 +        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));
-         VectorShuffle<Halffloat> unz0 = VectorShuffle.makeUnzip(SPECIES, 0);
-         VectorShuffle<Halffloat> unz1 = VectorShuffle.makeUnzip(SPECIES, 1);
++        VectorShuffle<Float16> unz0 = VectorShuffle.makeUnzip(SPECIES, 0);
++        VectorShuffle<Float16> unz1 = VectorShuffle.makeUnzip(SPECIES, 1);
 +        HalffloatVector uab0 = zab0.rearrange(unz0,zab1);
 +        HalffloatVector uab1 = zab0.rearrange(unz1,zab1);
 +        short[] abValues1 = bothToArray(uab0, uab1);
 +        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));
 +    }
 +
 +    static void iotaShuffle() {
 +        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);
 +        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES, 0 , 1, false).toVector();
 +        Assert.assertEquals(io, io2);
 +    }
 +
 +    @Test
 +    // Test all shuffle related operations.
 +    static void shuffleTest() {
 +        // To test backend instructions, make sure that C2 is used.
 +        for (int loop = 0; loop < INVOC_COUNT * INVOC_COUNT; loop++) {
 +            iotaShuffle();
 +        }
 +    }
 +
 +    @Test
 +    void viewAsIntegeralLanesTest() {
 +        Vector<?> asIntegral = SPECIES.zero().viewAsIntegralLanes();
 +        VectorSpecies<?> asIntegralSpecies = asIntegral.species();
 +        Assert.assertNotEquals(asIntegralSpecies.elementType(), SPECIES.elementType());
 +        Assert.assertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());
 +        Assert.assertEquals(asIntegralSpecies.length(), SPECIES.length());
 +        Assert.assertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);
 +    }
 +
 +    @Test
 +    void viewAsFloatingLanesTest() {
 +        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();
 +        Assert.assertEquals(asFloating.species(), SPECIES);
 +    }
 +
 +    static short ADD(short a, short b) {
 +        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b)));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void ADDHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::ADD);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void ADDHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::ADD);
 +    }
 +
 +    static short SUB(short a, short b) {
 +        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b)));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void SUBHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::SUB);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void SUBHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::SUB);
 +    }
 +
 +    static short MUL(short a, short b) {
 +        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) * Float.float16ToFloat(b)));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void MULHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::MUL);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void MULHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::MUL);
 +    }
 +
 +    static short DIV(short a, short b) {
 +        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) / Float.float16ToFloat(b)));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void DIVHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::DIV);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void DIVHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::DIV);
 +    }
 +
 +    static short MAX(short a, short b) {
 +        return (short)(Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b))));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void MAXHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::MAX);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void MAXHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::MAX);
 +    }
 +
 +    static short MIN(short a, short b) {
-         return (short)(Halffloat.valueOf(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));
++        return (short)(Float.floatToFloat16(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void MINHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::MIN);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void MINHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::MIN);
 +    }
 +
 +    static short ABS(short a) {
 +        return (short)(Math.abs(a));
 +    }
 +
 +    static short abs(short a) {
 +        return (short)(Math.abs(a));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void ABSHalffloatMaxVectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ABS).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, HalffloatMaxVectorTests::ABS);
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void absHalffloatMaxVectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.abs().intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, HalffloatMaxVectorTests::abs);
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpMaskProvider")
 +    static void ABSMaskedHalffloatMaxVectorTests(IntFunction<short[]> fa,
 +                                                IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, mask, HalffloatMaxVectorTests::ABS);
 +    }
 +
 +    static short NEG(short a) {
 +        return (short)(-a);
 +    }
 +
 +    static short neg(short a) {
 +        return (short)(-a);
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void NEGHalffloatMaxVectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.NEG).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, HalffloatMaxVectorTests::NEG);
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void negHalffloatMaxVectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.neg().intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, HalffloatMaxVectorTests::neg);
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpMaskProvider")
 +    static void NEGMaskedHalffloatMaxVectorTests(IntFunction<short[]> fa,
 +                                                IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, mask, HalffloatMaxVectorTests::NEG);
 +    }
 +
 +    static short FMA(short a, short b, short c) {
 +        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));
 +    }
 +
 +    static short fma(short a, short b, short c) {
 +        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));
 +    }
 +
 +    @Test(dataProvider = "shortTernaryOpProvider")
 +    static void FMAHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] c = fc.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);
 +                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, c, HalffloatMaxVectorTests::FMA);
 +    }
 +
 +    @Test(dataProvider = "shortTernaryOpProvider")
 +    static void fmaHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] c = fc.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +            HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);
 +            av.fma(bv, cv).intoArray(r, i);
 +        }
 +
 +        assertArraysEquals(r, a, b, c, HalffloatMaxVectorTests::fma);
 +    }
 +
 +    @Test(dataProvider = "shortTernaryOpMaskProvider")
 +    static void FMAHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] c = fc.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);
 +                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, c, mask, HalffloatMaxVectorTests::FMA);
 +    }
 +
 +    static short SQRT(short a) {
-         return (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));
++        return (short)(Float.floatToFloat16((float) Math.sqrt(Float.float16ToFloat(a))));
 +    }
 +
 +    static short sqrt(short a) {
-         return (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));
++        return (short)(Float.floatToFloat16((float) Math.sqrt(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void SQRTHalffloatMaxVectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SQRT).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, HalffloatMaxVectorTests::SQRT);
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void sqrtHalffloatMaxVectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.sqrt().intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, HalffloatMaxVectorTests::sqrt);
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpMaskProvider")
 +    static void SQRTMaskedHalffloatMaxVectorTests(IntFunction<short[]> fa,
 +                                                IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, mask, HalffloatMaxVectorTests::SQRT);
 +    }
 +
 +    static short SIN(short a) {
-         return Halffloat.valueOf((float) Math.sin(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.sin(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictSIN(short a) {
-         return Halffloat.valueOf((float) StrictMath.sin(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.sin(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void SINHalffloatMaxVectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SIN).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::SIN, HalffloatMaxVectorTests::strictSIN);
 +    }
 +
 +    static short EXP(short a) {
-         return Halffloat.valueOf((float) Math.exp(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.exp(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictEXP(short a) {
-         return Halffloat.valueOf((float) StrictMath.exp(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.exp(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void EXPHalffloatMaxVectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.EXP).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::EXP, HalffloatMaxVectorTests::strictEXP);
 +    }
 +
 +    static short LOG1P(short a) {
-         return Halffloat.valueOf((float) Math.log1p(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.log1p(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictLOG1P(short a) {
-         return Halffloat.valueOf((float) StrictMath.log1p(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.log1p(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void LOG1PHalffloatMaxVectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::LOG1P, HalffloatMaxVectorTests::strictLOG1P);
 +    }
 +
 +    static short LOG(short a) {
-         return Halffloat.valueOf((float) Math.log(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.log(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictLOG(short a) {
-         return Halffloat.valueOf((float) StrictMath.log(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.log(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void LOGHalffloatMaxVectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.LOG).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::LOG, HalffloatMaxVectorTests::strictLOG);
 +    }
 +
 +    static short LOG10(short a) {
-         return Halffloat.valueOf((float) Math.log10(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.log10(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictLOG10(short a) {
-         return Halffloat.valueOf((float) StrictMath.log10(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.log10(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void LOG10HalffloatMaxVectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.LOG10).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::LOG10, HalffloatMaxVectorTests::strictLOG10);
 +    }
 +
 +    static short EXPM1(short a) {
-         return Halffloat.valueOf((float) Math.expm1(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.expm1(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictEXPM1(short a) {
-         return Halffloat.valueOf((float) StrictMath.expm1(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.expm1(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void EXPM1HalffloatMaxVectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::EXPM1, HalffloatMaxVectorTests::strictEXPM1);
 +    }
 +
 +    static short COS(short a) {
-         return Halffloat.valueOf((float) Math.cos(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.cos(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictCOS(short a) {
-         return Halffloat.valueOf((float) StrictMath.cos(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.cos(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void COSHalffloatMaxVectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.COS).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::COS, HalffloatMaxVectorTests::strictCOS);
 +    }
 +
 +    static short TAN(short a) {
-         return Halffloat.valueOf((float) Math.tan(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.tan(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictTAN(short a) {
-         return Halffloat.valueOf((float) StrictMath.tan(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.tan(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void TANHalffloatMaxVectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.TAN).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::TAN, HalffloatMaxVectorTests::strictTAN);
 +    }
 +
 +    static short SINH(short a) {
-         return Halffloat.valueOf((float) Math.sinh(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.sinh(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictSINH(short a) {
-         return Halffloat.valueOf((float) StrictMath.sinh(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.sinh(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void SINHHalffloatMaxVectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SINH).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::SINH, HalffloatMaxVectorTests::strictSINH);
 +    }
 +
 +    static short COSH(short a) {
-         return Halffloat.valueOf((float) Math.cosh(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.cosh(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictCOSH(short a) {
-         return Halffloat.valueOf((float) StrictMath.cosh(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.cosh(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void COSHHalffloatMaxVectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.COSH).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::COSH, HalffloatMaxVectorTests::strictCOSH);
 +    }
 +
 +    static short TANH(short a) {
-         return Halffloat.valueOf((float) Math.tanh(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.tanh(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictTANH(short a) {
-         return Halffloat.valueOf((float) StrictMath.tanh(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.tanh(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void TANHHalffloatMaxVectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.TANH).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::TANH, HalffloatMaxVectorTests::strictTANH);
 +    }
 +
 +    static short ASIN(short a) {
-         return Halffloat.valueOf((float) Math.asin(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.asin(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictASIN(short a) {
-         return Halffloat.valueOf((float) StrictMath.asin(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.asin(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void ASINHalffloatMaxVectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ASIN).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::ASIN, HalffloatMaxVectorTests::strictASIN);
 +    }
 +
 +    static short ACOS(short a) {
-         return Halffloat.valueOf((float) Math.acos(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.acos(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictACOS(short a) {
-         return Halffloat.valueOf((float) StrictMath.acos(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.acos(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void ACOSHalffloatMaxVectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ACOS).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::ACOS, HalffloatMaxVectorTests::strictACOS);
 +    }
 +
 +    static short ATAN(short a) {
-         return Halffloat.valueOf((float) Math.atan(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.atan(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictATAN(short a) {
-         return Halffloat.valueOf((float) StrictMath.atan(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.atan(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void ATANHalffloatMaxVectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ATAN).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::ATAN, HalffloatMaxVectorTests::strictATAN);
 +    }
 +
 +    static short CBRT(short a) {
-         return Halffloat.valueOf((float) Math.cbrt(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.cbrt(Float.float16ToFloat(a))));
 +    }
 +
 +    static short strictCBRT(short a) {
-         return Halffloat.valueOf((float) StrictMath.cbrt(Float.float16ToFloat(a)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.cbrt(Float.float16ToFloat(a))));
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void CBRTHalffloatMaxVectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.CBRT).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::CBRT, HalffloatMaxVectorTests::strictCBRT);
 +    }
 +
 +    static short HYPOT(short a, short b) {
-         return Halffloat.valueOf((float) Math.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)));
 +    }
 +
 +    static short strictHYPOT(short a, short b) {
-         return Halffloat.valueOf((float) StrictMath.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b))));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void HYPOTHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, b, HalffloatMaxVectorTests::HYPOT, HalffloatMaxVectorTests::strictHYPOT);
 +    }
 +
 +    static short POW(short a, short b) {
-         return Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));
 +    }
 +
 +    static short strictPOW(short a, short b) {
-         return Halffloat.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b))));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void POWHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, b, HalffloatMaxVectorTests::POW, HalffloatMaxVectorTests::strictPOW);
 +    }
 +
 +    static short pow(short a, short b) {
-         return Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));
 +    }
 +
 +    static short strictpow(short a, short b) {
-         return Halffloat.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b))));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void powHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.pow(bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, b, HalffloatMaxVectorTests::pow, HalffloatMaxVectorTests::strictpow);
 +    }
 +
 +    static short ATAN2(short a, short b) {
-         return Halffloat.valueOf((float) Math.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)));
 +    }
 +
 +    static short strictATAN2(short a, short b) {
-         return Halffloat.valueOf((float) StrictMath.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)));
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b))));
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void ATAN2HalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEqualsWithinOneUlp(r, a, b, HalffloatMaxVectorTests::ATAN2, HalffloatMaxVectorTests::strictATAN2);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void POWHalffloatMaxVectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            av.lanewise(VectorOperators.POW, b[i]).intoArray(r, i);
 +        }
 +
 +        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, HalffloatMaxVectorTests::POW, HalffloatMaxVectorTests::strictPOW);
 +    }
 +
 +
 +    @Test(dataProvider = "shortBinaryOpProvider")
 +    static void powHalffloatMaxVectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            av.pow(b[i]).intoArray(r, i);
 +        }
 +
 +        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, HalffloatMaxVectorTests::pow, HalffloatMaxVectorTests::strictpow);
 +    }
 +
 +
 +    static short blend(short a, short b, boolean mask) {
 +        return mask ? b : a;
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void blendHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.blend(bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::blend);
 +    }
 +
 +    @Test(dataProvider = "shortCompareOpProvider")
 +    static void ltHalffloatMaxVectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
-             VectorMask<Halffloat> mv = av.lt(b[i]);
++            VectorMask<Float16> mv = av.lt(b[i]);
 +
 +            // Check results as part of computation.
 +            for (int j = 0; j < SPECIES.length(); j++) {
 +                Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortCompareOpProvider")
 +    static void eqHalffloatMaxVectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
-             VectorMask<Halffloat> mv = av.eq(b[i]);
++            VectorMask<Float16> mv = av.eq(b[i]);
 +
 +            // Check results as part of computation.
 +            for (int j = 0; j < SPECIES.length(); j++) {
 +                Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "shorttoIntUnaryOpProvider")
 +    static void toIntArrayHalffloatMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            int[] r = av.toIntArray();
 +            assertArraysEquals(r, a, i);
 +        }
 +    }
 +
 +    @Test(dataProvider = "shorttoLongUnaryOpProvider")
 +    static void toLongArrayHalffloatMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            long[] r = av.toLongArray();
 +            assertArraysEquals(r, a, i);
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void toDoubleArrayHalffloatMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            double[] r = av.toDoubleArray();
 +            assertArraysEquals(r, a, i);
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void toStringHalffloatMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            String str = av.toString();
 +
 +            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());
 +            Assert.assertTrue(str.equals(Arrays.toString(subarr)), "at index " + i + ", string should be = " + Arrays.toString(subarr) + ", but is = " + str);
 +        }
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void hashCodeHalffloatMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            int hash = av.hashCode();
 +
 +            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());
 +            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));
 +            Assert.assertTrue(hash == expectedHash, "at index " + i + ", hash should be = " + expectedHash + ", but is = " + hash);
 +        }
 +    }
 +
 +
 +    static long ADDReduceLong(short[] a, int idx) {
 +        short res = 0;
 +        for (int i = idx; i < (idx + SPECIES.length()); i++) {
 +            res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));
 +        }
 +
 +        return (long)res;
 +    }
 +
 +    static long ADDReduceAllLong(short[] a) {
 +        long res = 0;
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            res += ADDReduceLong(a, i);
 +        }
 +
 +        return res;
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpProvider")
 +    static void ADDReduceLongHalffloatMaxVectorTests(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        long[] r = lfr.apply(SPECIES.length());
 +        long ra = 0;
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            r[i] = av.reduceLanesToLong(VectorOperators.ADD);
 +        }
 +
 +        ra = 0;
 +        for (int i = 0; i < a.length; i ++) {
 +            ra += r[i];
 +        }
 +
 +        assertReductionLongArraysEquals(r, ra, a,
 +                HalffloatMaxVectorTests::ADDReduceLong, HalffloatMaxVectorTests::ADDReduceAllLong);
 +    }
 +
 +    static long ADDReduceLongMasked(short[] a, int idx, boolean[] mask) {
 +        short res = 0;
 +        for (int i = idx; i < (idx + SPECIES.length()); i++) {
 +            if(mask[i % SPECIES.length()])
 +                res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));
 +        }
 +
 +        return (long)res;
 +    }
 +
 +    static long ADDReduceAllLongMasked(short[] a, boolean[] mask) {
 +        long res = 0;
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            res += ADDReduceLongMasked(a, i, mask);
 +        }
 +
 +        return res;
 +    }
 +
 +    @Test(dataProvider = "shortUnaryOpMaskProvider")
 +    static void ADDReduceLongHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        long[] r = lfr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +        long ra = 0;
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            r[i] = av.reduceLanesToLong(VectorOperators.ADD, vmask);
 +        }
 +
 +        ra = 0;
 +        for (int i = 0; i < a.length; i ++) {
 +            ra += r[i];
 +        }
 +
 +        assertReductionLongArraysEqualsMasked(r, ra, a, mask,
 +                HalffloatMaxVectorTests::ADDReduceLongMasked, HalffloatMaxVectorTests::ADDReduceAllLongMasked);
 +    }
 +
 +    @Test(dataProvider = "shorttoLongUnaryOpProvider")
 +    static void BroadcastLongHalffloatMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = new short[a.length];
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);
 +        }
 +        assertBroadcastArraysEquals(r, a);
 +    }
 +
 +    @Test(dataProvider = "shortBinaryOpMaskProvider")
 +    static void blendHalffloatMaxVectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,
 +                                          IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.blend((long)b[i], vmask).intoArray(r, i);
 +            }
 +        }
 +        assertBroadcastLongArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::blend);
 +    }
 +
 +
 +    @Test(dataProvider = "shortUnaryOpSelectFromProvider")
 +    static void SelectFromHalffloatMaxVectorTests(IntFunction<short[]> fa,
 +                                           BiFunction<Integer,Integer,short[]> fs) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] order = fs.apply(a.length, SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);
 +            bv.selectFrom(av).intoArray(r, i);
 +        }
 +
 +        assertSelectFromArraysEquals(r, a, order, SPECIES.length());
 +    }
 +
++    @Test(dataProvider = "shortSelectFromTwoVectorOpProvider")
++    static void SelectFromTwoVectorHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] b = fb.apply(SPECIES.length());
++        short[] idx = fc.apply(SPECIES.length());
++        short[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < idx.length; i += SPECIES.length()) {
++                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
++                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
++                HalffloatVector idxv = HalffloatVector.fromArray(SPECIES, idx, i);
++                idxv.selectFrom(av, bv).intoArray(r, i);
++            }
++        }
++        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());
++    }
++
 +    @Test(dataProvider = "shortUnaryOpSelectFromMaskProvider")
 +    static void SelectFromHalffloatMaxVectorTestsMaskedSmokeTest(IntFunction<short[]> fa,
 +                                                           BiFunction<Integer,Integer,short[]> fs,
 +                                                           IntFunction<boolean[]> fm) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] order = fs.apply(a.length, SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);
 +            bv.selectFrom(av, vmask).intoArray(r, i);
 +        }
 +
 +        assertSelectFromArraysEquals(r, a, order, mask, SPECIES.length());
 +    }
 +
 +    @Test(dataProvider = "shuffleProvider")
 +    static void shuffleMiscellaneousHalffloatMaxVectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {
 +        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);
 +            int hash = shuffle.hashCode();
 +            int length = shuffle.length();
 +
 +            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());
 +            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));
 +            Assert.assertTrue(hash == expectedHash, "at index " + i + ", hash should be = " + expectedHash + ", but is = " + hash);
 +            Assert.assertEquals(length, SPECIES.length());
 +        }
 +    }
 +
 +    @Test(dataProvider = "shuffleProvider")
 +    static void shuffleToStringHalffloatMaxVectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {
 +        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);
 +            String str = shuffle.toString();
 +
 +            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());
 +            Assert.assertTrue(str.equals("Shuffle" + Arrays.toString(subarr)), "at index " +
 +                i + ", string should be = " + Arrays.toString(subarr) + ", but is = " + str);
 +        }
 +    }
 +
 +    @Test(dataProvider = "shuffleCompareOpProvider")
 +    static void shuffleEqualsHalffloatMaxVectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {
 +        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());
 +        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var av = VectorShuffle.fromArray(SPECIES, a, i);
 +            var bv = VectorShuffle.fromArray(SPECIES, b, i);
 +            boolean eq = av.equals(bv);
 +            int to = i + SPECIES.length();
 +            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));
 +        }
 +    }
 +
 +    @Test(dataProvider = "maskCompareOpProvider")
 +    static void maskEqualsHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        boolean[] b = fb.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var av = SPECIES.loadMask(a, i);
 +            var bv = SPECIES.loadMask(b, i);
 +            boolean equals = av.equals(bv);
 +            int to = i + SPECIES.length();
 +            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));
 +        }
 +    }
 +
 +    static boolean band(boolean a, boolean b) {
 +        return a & b;
 +    }
 +
 +    @Test(dataProvider = "maskCompareOpProvider")
 +    static void maskAndHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        boolean[] b = fb.apply(SPECIES.length());
 +        boolean[] r = new boolean[a.length];
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var av = SPECIES.loadMask(a, i);
 +            var bv = SPECIES.loadMask(b, i);
 +            var cv = av.and(bv);
 +            cv.intoArray(r, i);
 +        }
 +        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::band);
 +    }
 +
 +    static boolean bor(boolean a, boolean b) {
 +        return a | b;
 +    }
 +
 +    @Test(dataProvider = "maskCompareOpProvider")
 +    static void maskOrHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        boolean[] b = fb.apply(SPECIES.length());
 +        boolean[] r = new boolean[a.length];
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var av = SPECIES.loadMask(a, i);
 +            var bv = SPECIES.loadMask(b, i);
 +            var cv = av.or(bv);
 +            cv.intoArray(r, i);
 +        }
 +        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::bor);
 +    }
 +
 +    static boolean bxor(boolean a, boolean b) {
 +        return a != b;
 +    }
 +
 +    @Test(dataProvider = "maskCompareOpProvider")
 +    static void maskXorHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        boolean[] b = fb.apply(SPECIES.length());
 +        boolean[] r = new boolean[a.length];
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var av = SPECIES.loadMask(a, i);
 +            var bv = SPECIES.loadMask(b, i);
 +            var cv = av.xor(bv);
 +            cv.intoArray(r, i);
 +        }
 +        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::bxor);
 +    }
 +
 +    static boolean bandNot(boolean a, boolean b) {
 +        return a & !b;
 +    }
 +
 +    @Test(dataProvider = "maskCompareOpProvider")
 +    static void maskAndNotHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        boolean[] b = fb.apply(SPECIES.length());
 +        boolean[] r = new boolean[a.length];
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var av = SPECIES.loadMask(a, i);
 +            var bv = SPECIES.loadMask(b, i);
 +            var cv = av.andNot(bv);
 +            cv.intoArray(r, i);
 +        }
 +        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::bandNot);
 +    }
 +
 +    static boolean beq(boolean a, boolean b) {
 +        return (a == b);
 +    }
 +
 +    @Test(dataProvider = "maskCompareOpProvider")
 +    static void maskEqHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        boolean[] b = fb.apply(SPECIES.length());
 +        boolean[] r = new boolean[a.length];
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var av = SPECIES.loadMask(a, i);
 +            var bv = SPECIES.loadMask(b, i);
 +            var cv = av.eq(bv);
 +            cv.intoArray(r, i);
 +        }
 +        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::beq);
 +    }
 +
 +    @Test(dataProvider = "maskProvider")
 +    static void maskHashCodeHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +
 +        for (int i = 0; i < a.length; i += SPECIES.length()) {
 +            var vmask = SPECIES.loadMask(a, i);
 +            int hash = vmask.hashCode();
 +
 +            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());
 +            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));
 +            Assert.assertTrue(hash == expectedHash, "at index " + i + ", hash should be = " + expectedHash + ", but is = " + hash);
 +        }
 +    }
 +
 +    static int maskTrueCount(boolean[] a, int idx) {
 +        int trueCount = 0;
 +        for (int i = idx; i < idx + SPECIES.length(); i++) {
 +            trueCount += a[i] ? 1 : 0;
 +        }
 +        return trueCount;
 +    }
 +
 +    @Test(dataProvider = "maskProvider")
 +    static void maskTrueCountHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        int[] r = new int[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                var vmask = SPECIES.loadMask(a, i);
 +                r[i] = vmask.trueCount();
 +            }
 +        }
 +
 +        assertMaskReductionArraysEquals(r, a, HalffloatMaxVectorTests::maskTrueCount);
 +    }
 +
 +    static int maskLastTrue(boolean[] a, int idx) {
 +        int i = idx + SPECIES.length() - 1;
 +        for (; i >= idx; i--) {
 +            if (a[i]) {
 +                break;
 +            }
 +        }
 +        return i - idx;
 +    }
 +
 +    @Test(dataProvider = "maskProvider")
 +    static void maskLastTrueHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        int[] r = new int[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                var vmask = SPECIES.loadMask(a, i);
 +                r[i] = vmask.lastTrue();
 +            }
 +        }
 +
 +        assertMaskReductionArraysEquals(r, a, HalffloatMaxVectorTests::maskLastTrue);
 +    }
 +
 +    static int maskFirstTrue(boolean[] a, int idx) {
 +        int i = idx;
 +        for (; i < idx + SPECIES.length(); i++) {
 +            if (a[i]) {
 +                break;
 +            }
 +        }
 +        return i - idx;
 +    }
 +
 +    @Test(dataProvider = "maskProvider")
 +    static void maskFirstTrueHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {
 +        boolean[] a = fa.apply(SPECIES.length());
 +        int[] r = new int[a.length];
 +
 +        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                var vmask = SPECIES.loadMask(a, i);
 +                r[i] = vmask.firstTrue();
 +            }
 +        }
 +
 +        assertMaskReductionArraysEquals(r, a, HalffloatMaxVectorTests::maskFirstTrue);
 +    }
 +
 +    @Test(dataProvider = "maskProvider")
 +    static void maskCompressHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {
 +        int trueCount = 0;
 +        boolean[] a = fa.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                var vmask = SPECIES.loadMask(a, i);
 +                trueCount = vmask.trueCount();
 +                var rmask = vmask.compress();
 +                for (int j = 0; j < SPECIES.length(); j++)  {
 +                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
 +                }
 +            }
 +        }
 +    }
 +
 +
 +    @DataProvider
 +    public static Object[][] offsetProvider() {
 +        return new Object[][]{
 +                {0},
 +                {-1},
 +                {+1},
 +                {+2},
 +                {-2},
 +        };
 +    }
 +
 +    @Test(dataProvider = "offsetProvider")
 +    static void indexInRangeHalffloatMaxVectorTestsSmokeTest(int offset) {
 +        int limit = SPECIES.length() * BUFFER_REPS;
 +        for (int i = 0; i < limit; i += SPECIES.length()) {
 +            var actualMask = SPECIES.indexInRange(i + offset, limit);
 +            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);
 +            assert(actualMask.equals(expectedMask));
 +            for (int j = 0; j < SPECIES.length(); j++)  {
 +                int index = i + j + offset;
 +                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);
 +            }
 +        }
 +    }
 +
 +    @Test(dataProvider = "offsetProvider")
 +    static void indexInRangeLongHalffloatMaxVectorTestsSmokeTest(int offset) {
 +        long limit = SPECIES.length() * BUFFER_REPS;
 +        for (long i = 0; i < limit; i += SPECIES.length()) {
 +            var actualMask = SPECIES.indexInRange(i + offset, limit);
 +            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);
 +            assert(actualMask.equals(expectedMask));
 +            for (int j = 0; j < SPECIES.length(); j++)  {
 +                long index = i + j + offset;
 +                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);
 +            }
 +        }
 +    }
 +
 +    @DataProvider
 +    public static Object[][] lengthProvider() {
 +        return new Object[][]{
 +                {0},
 +                {1},
 +                {32},
 +                {37},
 +                {1024},
 +                {1024+1},
 +                {1024+5},
 +        };
 +    }
 +
 +    @Test(dataProvider = "lengthProvider")
 +    static void loopBoundHalffloatMaxVectorTestsSmokeTest(int length) {
 +        int actualLoopBound = SPECIES.loopBound(length);
 +        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());
 +        Assert.assertEquals(actualLoopBound, expectedLoopBound);
 +    }
 +
 +    @Test(dataProvider = "lengthProvider")
 +    static void loopBoundLongHalffloatMaxVectorTestsSmokeTest(int _length) {
 +        long length = _length;
 +        long actualLoopBound = SPECIES.loopBound(length);
 +        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());
 +        Assert.assertEquals(actualLoopBound, expectedLoopBound);
 +    }
 +
 +    @Test
 +    static void ElementSizeHalffloatMaxVectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
 +        int elsize = av.elementSize();
-         Assert.assertEquals(elsize, Halffloat.SIZE);
++        Assert.assertEquals(elsize, Float16.SIZE);
 +    }
 +
 +    @Test
 +    static void VectorShapeHalffloatMaxVectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
 +        VectorShape vsh = av.shape();
 +        assert(vsh.equals(VectorShape.S_Max_BIT));
 +    }
 +
 +    @Test
 +    static void ShapeWithLanesHalffloatMaxVectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
 +        VectorShape vsh = av.shape();
-         VectorSpecies species = vsh.withLanes(Halffloat.class);
++        VectorSpecies species = vsh.withLanes(Float16.class);
 +        assert(species.equals(SPECIES));
 +    }
 +
 +    @Test
 +    static void ElementTypeHalffloatMaxVectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
-         assert(av.species().elementType() == Halffloat.class);
++        assert(av.species().elementType() == Float16.class);
 +    }
 +
 +    @Test
 +    static void SpeciesElementSizeHalffloatMaxVectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
-         assert(av.species().elementSize() == Halffloat.SIZE);
++        assert(av.species().elementSize() == Float16.SIZE);
 +    }
 +
 +    @Test
 +    static void VectorTypeHalffloatMaxVectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
 +        assert(av.species().vectorType() == av.getClass());
 +    }
 +
 +    @Test
 +    static void WithLanesHalffloatMaxVectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
-         VectorSpecies species = av.species().withLanes(Halffloat.class);
++        VectorSpecies species = av.species().withLanes(Float16.class);
 +        assert(species.equals(SPECIES));
 +    }
 +
 +    @Test
 +    static void WithShapeHalffloatMaxVectorTestsSmokeTest() {
 +        HalffloatVector av = HalffloatVector.zero(SPECIES);
 +        VectorShape vsh = av.shape();
 +        VectorSpecies species = av.species().withShape(vsh);
 +        assert(species.equals(SPECIES));
 +    }
 +
 +    @Test
 +    static void MaskAllTrueHalffloatMaxVectorTestsSmokeTest() {
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));
 +        }
 +    }
 +}
diff --cc test/jdk/jdk/incubator/vector/Int128VectorTests.java
index bde53c70d10,d6bca96ea6e..fa5de30fd88
--- a/test/jdk/jdk/incubator/vector/Int128VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Int128VectorTests.java
@@@ -1,5 -1,5 +1,5 @@@
  /*
-  * Copyright (c) 2018, 2022, Oracle and/or its affiliates. All rights reserved.
 - * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
diff --cc test/jdk/jdk/incubator/vector/Int256VectorTests.java
index eb8da73c9c9,ac98217b714..fececdc1212
--- a/test/jdk/jdk/incubator/vector/Int256VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Int256VectorTests.java
@@@ -1,5 -1,5 +1,5 @@@
  /*
-  * Copyright (c) 2018, 2022, Oracle and/or its affiliates. All rights reserved.
 - * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
diff --cc test/jdk/jdk/incubator/vector/Int512VectorTests.java
index 1ba1d59badb,b56236db322..ac87b4b5cf6
--- a/test/jdk/jdk/incubator/vector/Int512VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Int512VectorTests.java
@@@ -1,5 -1,5 +1,5 @@@
  /*
-  * Copyright (c) 2018, 2022, Oracle and/or its affiliates. All rights reserved.
 - * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
diff --cc test/jdk/jdk/incubator/vector/Int64VectorTests.java
index a42a5bacdc6,f87a0eb458c..9b1af12b48d
--- a/test/jdk/jdk/incubator/vector/Int64VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Int64VectorTests.java
@@@ -1,5 -1,5 +1,5 @@@
  /*
-  * Copyright (c) 2018, 2022, Oracle and/or its affiliates. All rights reserved.
 - * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
diff --cc test/jdk/jdk/incubator/vector/IntMaxVectorTests.java
index fd97893ed8c,c61aab0013e..8aaa1f30940
--- a/test/jdk/jdk/incubator/vector/IntMaxVectorTests.java
+++ b/test/jdk/jdk/incubator/vector/IntMaxVectorTests.java
@@@ -1,5 -1,5 +1,5 @@@
  /*
-  * Copyright (c) 2018, 2022, Oracle and/or its affiliates. All rights reserved.
 - * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
diff --cc test/jdk/jdk/incubator/vector/Long128VectorTests.java
index 6d6f29a5321,a8cf38c003a..610d04f654b
--- a/test/jdk/jdk/incubator/vector/Long128VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Long128VectorTests.java
@@@ -1,5 -1,5 +1,5 @@@
  /*
-  * Copyright (c) 2018, 2022, Oracle and/or its affiliates. All rights reserved.
 - * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
diff --cc test/jdk/jdk/incubator/vector/Long256VectorTests.java
index 3f54d5a5178,a394a59699f..6c9c99518f9
--- a/test/jdk/jdk/incubator/vector/Long256VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Long256VectorTests.java
@@@ -1,5 -1,5 +1,5 @@@
  /*
-  * Copyright (c) 2018, 2022, Oracle and/or its affiliates. All rights reserved.
 - * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
diff --cc test/jdk/jdk/incubator/vector/Long512VectorTests.java
index baec0bd5e82,2f12ea98399..ff56eb44fb0
--- a/test/jdk/jdk/incubator/vector/Long512VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Long512VectorTests.java
@@@ -1,5 -1,5 +1,5 @@@
  /*
-  * Copyright (c) 2018, 2022, Oracle and/or its affiliates. All rights reserved.
 - * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
diff --cc test/jdk/jdk/incubator/vector/Long64VectorTests.java
index e46f0d95c94,0fda0abed58..1cd51f6430a
--- a/test/jdk/jdk/incubator/vector/Long64VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Long64VectorTests.java
@@@ -1,5 -1,5 +1,5 @@@
  /*
-  * Copyright (c) 2018, 2022, Oracle and/or its affiliates. All rights reserved.
 - * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
diff --cc test/jdk/jdk/incubator/vector/LongMaxVectorTests.java
index 38130cef3b3,7aa2bc4c510..c8fad682f59
--- a/test/jdk/jdk/incubator/vector/LongMaxVectorTests.java
+++ b/test/jdk/jdk/incubator/vector/LongMaxVectorTests.java
@@@ -1,5 -1,5 +1,5 @@@
  /*
-  * Copyright (c) 2018, 2022, Oracle and/or its affiliates. All rights reserved.
 - * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
diff --cc test/jdk/jdk/incubator/vector/Short128VectorTests.java
index 820785db9ac,5f4c54bb708..85a368348a2
--- a/test/jdk/jdk/incubator/vector/Short128VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Short128VectorTests.java
@@@ -1,5 -1,5 +1,5 @@@
  /*
-  * Copyright (c) 2018, 2022, Oracle and/or its affiliates. All rights reserved.
 - * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
diff --cc test/jdk/jdk/incubator/vector/Short256VectorTests.java
index 3a75cef69f9,88986575f60..dde4b306fe0
--- a/test/jdk/jdk/incubator/vector/Short256VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Short256VectorTests.java
@@@ -1,5 -1,5 +1,5 @@@
  /*
-  * Copyright (c) 2018, 2022, Oracle and/or its affiliates. All rights reserved.
 - * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
diff --cc test/jdk/jdk/incubator/vector/Short512VectorTests.java
index 5a480a986b8,0f474375a47..637960646cc
--- a/test/jdk/jdk/incubator/vector/Short512VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Short512VectorTests.java
@@@ -1,5 -1,5 +1,5 @@@
  /*
-  * Copyright (c) 2018, 2022, Oracle and/or its affiliates. All rights reserved.
 - * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
diff --cc test/jdk/jdk/incubator/vector/Short64VectorTests.java
index 1d2a136edb6,4b99ed6d84c..f45d1121b86
--- a/test/jdk/jdk/incubator/vector/Short64VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Short64VectorTests.java
@@@ -1,5 -1,5 +1,5 @@@
  /*
-  * Copyright (c) 2018, 2022, Oracle and/or its affiliates. All rights reserved.
 - * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
diff --cc test/jdk/jdk/incubator/vector/ShortMaxVectorTests.java
index dd3b6817d56,2bb3b9c1557..02b7a12627e
--- a/test/jdk/jdk/incubator/vector/ShortMaxVectorTests.java
+++ b/test/jdk/jdk/incubator/vector/ShortMaxVectorTests.java
@@@ -1,5 -1,5 +1,5 @@@
  /*
-  * Copyright (c) 2018, 2022, Oracle and/or its affiliates. All rights reserved.
 - * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
diff --cc test/jdk/jdk/incubator/vector/gen-template.sh
index 5100c1fa2bf,a6f794a5559..25a0a9cbb8c
--- a/test/jdk/jdk/incubator/vector/gen-template.sh
+++ b/test/jdk/jdk/incubator/vector/gen-template.sh
@@@ -62,12 -66,11 +66,14 @@@ reduction_op="Reduction-op
  reduction_op_func="Reduction-op-func"
  reduction_op_masked="Reduction-Masked-op"
  reduction_op_masked_func="Reduction-Masked-op-func"
+ reduction_saturating_op="SaturatingReduction-op"
+ reduction_saturating_op_masked="SaturatingReduction-Masked-op"
  unary_math_template="Unary-op-math"
 +unary_math_hf_template="Unary-op-hf-math"
  binary_math_template="Binary-op-math"
 +binary_math_hf_template="Binary-op-hf-math"
  binary_math_broadcast_template="Binary-Broadcast-op-math"
 +binary_math_hf_broadcast_template="Binary-Broadcast-op-hf-math"
  bool_reduction_scalar="BoolReduction-Scalar-op"
  bool_reduction_template="BoolReduction-op"
  with_op_template="With-Op"
@@@ -401,220 -428,202 +431,235 @@@ if [ $generate_perf_tests == true ]; th
    gen_perf_scalar_header $perf_scalar_output
  fi
  
 -# ALU binary ops.
 -# Here "ADD+add+withMask" says VectorOperator name is "ADD", and we have a dedicate method too named 'add', and add() is also available with mask variant.
 -gen_binary_alu_op "ADD+add+withMask" "a + b"
 -gen_binary_alu_op "SUB+sub+withMask" "a - b"
 -gen_binary_alu_op "MUL+mul+withMask" "a \* b"
 -gen_binary_alu_op "DIV+div+withMask" "a \/ b" "FP"
 -gen_op_tmpl "Binary-op_bitwise-div" "DIV+div+withMask" "a \/ b" "BITWISE"
 -gen_op_tmpl "Binary-Masked-op_bitwise-div" "DIV+div+withMask" "a \/ b" "BITWISE"
 -gen_binary_alu_op "FIRST_NONZERO" "{#if[FP]?Double.doubleToLongBits}(a)!=0?a:b"
 -gen_binary_alu_op "AND+and"   "a \& b"  "BITWISE"
 -gen_binary_alu_op "AND_NOT" "a \& ~b" "BITWISE"
 -gen_binary_alu_op "OR+or"    "a | b"   "BITWISE"
 -# Missing:        "OR_UNCHECKED"
 -gen_binary_alu_op "XOR"   "a ^ b"   "BITWISE"
 -gen_binary_alu_op "COMPRESS_BITS" "\$Boxtype\$.compress(a, b)" "intOrLong"
 -gen_binary_alu_op "EXPAND_BITS" "\$Boxtype\$.expand(a, b)" "intOrLong"
 -# Generate the broadcast versions
 -gen_binary_alu_bcst_op "add+withMask" "a + b"
 -gen_binary_alu_bcst_op "sub+withMask" "a - b"
 -gen_binary_alu_bcst_op "mul+withMask" "a \* b"
 -gen_binary_alu_bcst_op "div+withMask" "a \/ b" "FP"
 -gen_op_tmpl "Binary-Broadcast-op_bitwise-div" "div+withMask" "a \/ b" "BITWISE"
 -gen_op_tmpl "Binary-Broadcast-Masked-op_bitwise-div" "div+withMask" "a \/ b" "BITWISE"
 -gen_binary_alu_bcst_op "OR+or"    "a | b"   "BITWISE"
 -gen_binary_alu_bcst_op "AND+and"    "a \& b"   "BITWISE"
 -gen_binary_alu_bcst_long_op "OR"     "a | b"   "BITWISE"
 -gen_binary_alu_bcst_long_op "ADD"    "a + b"
 -
 -# Shifts
 -gen_binary_alu_op "LSHL" "(a << b)" "intOrLong"
 -gen_binary_alu_op "LSHL" "(a << (b \& 0x7))" "byte"
 -gen_binary_alu_op "LSHL" "(a << (b \& 0xF))" "short"
 -gen_binary_alu_op "ASHR" "(a >> b)" "intOrLong"
 -gen_binary_alu_op "ASHR" "(a >> (b \& 0x7))" "byte"
 -gen_binary_alu_op "ASHR" "(a >> (b \& 0xF))" "short"
 -gen_binary_alu_op "LSHR" "(a >>> b)" "intOrLong"
 -gen_binary_alu_op "LSHR" "((a \& 0xFF) >>> (b \& 0x7))" "byte"
 -gen_binary_alu_op "LSHR" "((a \& 0xFFFF) >>> (b \& 0xF))" "short"
 -gen_shift_op  "LSHL" "(a << b)" "intOrLong"
 -gen_shift_op  "LSHL" "(a << (b \& 7))" "byte"
 -gen_shift_op  "LSHL" "(a << (b \& 15))" "short"
 -gen_shift_op  "LSHR" "(a >>> b)" "intOrLong"
 -gen_shift_op  "LSHR" "((a \& 0xFF) >>> (b \& 7))" "byte"
 -gen_shift_op  "LSHR" "((a \& 0xFFFF) >>> (b \& 15))" "short"
 -gen_shift_op  "ASHR" "(a >> b)" "intOrLong"
 -gen_shift_op  "ASHR" "(a >> (b \& 7))" "byte"
 -gen_shift_op  "ASHR" "(a >> (b \& 15))" "short"
 -gen_binary_alu_op "ROR" "ROR_scalar(a,b)" "BITWISE"
 -gen_binary_alu_op "ROL" "ROL_scalar(a,b)" "BITWISE"
 -gen_shift_op  "ROR" "ROR_scalar(a, b)" "BITWISE"
 -gen_shift_op  "ROL" "ROL_scalar(a, b)" "BITWISE"
 -
 -# Constant Shifts
 -gen_shift_cst_op  "LSHR" "(a >>> CONST_SHIFT)" "intOrLong"
 -gen_shift_cst_op  "LSHR" "((a \& 0xFF) >>> CONST_SHIFT)" "byte"
 -gen_shift_cst_op  "LSHR" "((a \& 0xFFFF) >>> CONST_SHIFT)" "short"
 -gen_shift_cst_op  "LSHL" "(a << CONST_SHIFT)" "BITWISE"
 -gen_shift_cst_op  "ASHR" "(a >> CONST_SHIFT)" "BITWISE"
 -gen_shift_cst_op  "ROR" "ROR_scalar(a, CONST_SHIFT)" "BITWISE"
 -gen_shift_cst_op  "ROL" "ROL_scalar(a, CONST_SHIFT)" "BITWISE"
 -
 -# Binary operation with one memory operand
 -gen_binary_alu_mem_op "MIN+min+withMask", "Math.min(a, b)"
 -gen_binary_alu_mem_op "MAX+max+withMask", "Math.max(a, b)"
 -
 -# Masked reductions.
 -gen_binary_op_no_masked "MIN+min" "Math.min(a, b)"
 -gen_binary_op_no_masked "MAX+max" "Math.max(a, b)"
 -gen_binary_op "UMIN" "VectorMath.minUnsigned(a, b)" "BITWISE"
 -gen_binary_op "UMAX" "VectorMath.maxUnsigned(a, b)" "BITWISE"
 -gen_saturating_binary_op "SADD" "VectorMath.addSaturating(a, b)" "BITWISE"
 -gen_saturating_binary_op "SSUB" "VectorMath.subSaturating(a, b)" "BITWISE"
 -gen_saturating_binary_op "SUADD" "VectorMath.addSaturatingUnsigned(a, b)" "BITWISE"
 -gen_saturating_binary_op "SUSUB" "VectorMath.subSaturatingUnsigned(a, b)" "BITWISE"
 -gen_binary_bcst_op_no_masked "MIN+min" "Math.min(a, b)"
 -gen_binary_bcst_op_no_masked "MAX+max" "Math.max(a, b)"
 -gen_saturating_binary_op_associative "SUADD" "VectorMath.addSaturatingUnsigned(a, b)" "BITWISE"
 -
 -# Reductions.
 -gen_reduction_op "AND" "\&" "BITWISE" "-1"
 -gen_reduction_op "OR" "|" "BITWISE" "0"
 -gen_reduction_op "XOR" "^" "BITWISE" "0"
 -gen_reduction_op "ADD" "+" "" "0"
 -gen_reduction_op "MUL" "*" "" "1"
 -gen_reduction_op_func "MIN" "(\$type\$) Math.min" "" "\$Wideboxtype\$.\$MaxValue\$"
 -gen_reduction_op_func "MAX" "(\$type\$) Math.max" "" "\$Wideboxtype\$.\$MinValue\$"
 -gen_reduction_op_func "UMIN" "(\$type\$) VectorMath.minUnsigned" "BITWISE" "\$Wideboxtype\$.\$MaxValue\$"
 -gen_reduction_op_func "UMAX" "(\$type\$) VectorMath.maxUnsigned" "BITWISE" "\$Wideboxtype\$.\$MinValue\$"
 -gen_reduction_op_func "FIRST_NONZERO" "firstNonZero" "" "(\$type\$) 0"
 -
 -# Boolean reductions.
 -gen_bool_reduction_op "anyTrue" "|" "BITWISE" "false"
 -gen_bool_reduction_op "allTrue" "\&" "BITWISE" "true"
 -
 -# Saturating reductions.
 -gen_saturating_reduction_op "SUADD" "(\$type\$) VectorMath.addSaturatingUnsigned" "BITWISE" "0"
 -
 -#Insert
 -gen_with_op "withLane" "" "" ""
 -
 -# Tests
 -gen_op_tmpl $test_template "IS_DEFAULT" "bits(a)==0"
 -gen_op_tmpl $test_template "IS_NEGATIVE" "bits(a)<0"
 -gen_op_tmpl $test_template "IS_FINITE" "\$Boxtype\$.isFinite(a)" "FP"
 -gen_op_tmpl $test_template "IS_NAN" "\$Boxtype\$.isNaN(a)" "FP"
 -gen_op_tmpl $test_template "IS_INFINITE" "\$Boxtype\$.isInfinite(a)" "FP"
 -
 -# Compares
 -gen_compare_op "LT+lt" "lt"
 -gen_compare_op "GT" "gt"
 -gen_compare_op "EQ+eq" "eq"
 -gen_compare_op "NE" "neq"
 -gen_compare_op "LE" "le"
 -gen_compare_op "GE" "ge"
 -
 -gen_compare_op "ULT" "ult" "BITWISE"
 -gen_compare_op "UGT" "ugt" "BITWISE"
 -gen_compare_op "ULE" "ule" "BITWISE"
 -gen_compare_op "UGE" "uge" "BITWISE"
 -
 -
 -gen_compare_bcst_op "LT" "<"
 -gen_compare_bcst_op "EQ" "=="
 -
 -# Blend.
 -gen_op_tmpl $blend "blend" ""
 -
 -# Rearrange
 -gen_op_tmpl $rearrange_template "rearrange" ""
 -
 -# Compress/Expand
 -gen_op_tmpl $compressexpand_template "compress_expand" ""
 -
 -# Get
 -gen_get_op "lane" ""
 -
 -# Broadcast
 -gen_op_tmpl $broadcast_template "broadcast" ""
 -
 -# Zero
 -gen_op_tmpl $zero_template "zero" ""
 -
 -# Slice
 -gen_op_tmpl $slice_template "sliceUnary" ""
 -gen_op_tmpl $slice1_template "sliceBinary" ""
 -gen_op_tmpl $slice1_masked_template "slice" ""
 -
 -# Unslice
 -gen_op_tmpl $unslice_template "unsliceUnary" ""
 -gen_op_tmpl $unslice1_template "unsliceBinary" ""
 -gen_op_tmpl $unslice1_masked_template "unslice" ""
 -
 -# Math
 -gen_op_tmpl $unary_math_template "SIN" "Math.sin((double)a)" "FP"
 -gen_op_tmpl $unary_math_template "EXP" "Math.exp((double)a)" "FP"
 -gen_op_tmpl $unary_math_template "LOG1P" "Math.log1p((double)a)" "FP"
 -gen_op_tmpl $unary_math_template "LOG" "Math.log((double)a)" "FP"
 -gen_op_tmpl $unary_math_template "LOG10" "Math.log10((double)a)" "FP"
 -gen_op_tmpl $unary_math_template "EXPM1" "Math.expm1((double)a)" "FP"
 -gen_op_tmpl $unary_math_template "COS" "Math.cos((double)a)" "FP"
 -gen_op_tmpl $unary_math_template "TAN" "Math.tan((double)a)" "FP"
 -gen_op_tmpl $unary_math_template "SINH" "Math.sinh((double)a)" "FP"
 -gen_op_tmpl $unary_math_template "COSH" "Math.cosh((double)a)" "FP"
 -gen_op_tmpl $unary_math_template "TANH" "Math.tanh((double)a)" "FP"
 -gen_op_tmpl $unary_math_template "ASIN" "Math.asin((double)a)" "FP"
 -gen_op_tmpl $unary_math_template "ACOS" "Math.acos((double)a)" "FP"
 -gen_op_tmpl $unary_math_template "ATAN" "Math.atan((double)a)" "FP"
 -gen_op_tmpl $unary_math_template "CBRT" "Math.cbrt((double)a)" "FP"
 -gen_op_tmpl $binary_math_template "HYPOT" "Math.hypot((double)a, (double)b)" "FP"
 -gen_op_tmpl $binary_math_template "POW+pow" "Math.pow((double)a, (double)b)" "FP"
 -gen_op_tmpl $binary_math_template "ATAN2" "Math.atan2((double)a, (double)b)" "FP"
 -gen_op_tmpl $binary_math_broadcast_template "POW+pow" "Math.pow((double)a, (double)b)" "FP"
 -
 -# Ternary operations.
 -gen_ternary_alu_op "FMA+fma" "Math.fma(a, b, c)" "FP"
 -gen_ternary_alu_op "BITWISE_BLEND+bitwiseBlend" "(a\&~(c))|(b\&c)" "BITWISE"
 -gen_ternary_alu_bcst_op "FMA" "Math.fma(a, b, c)" "FP"
 -gen_ternary_alu_bcst_op "BITWISE_BLEND+bitwiseBlend" "(a\&~(c))|(b\&c)" "BITWISE"
 -gen_ternary_alu_double_bcst_op "FMA+fma" "Math.fma(a, b, c)" "FP"
 -gen_ternary_alu_double_bcst_op "BITWISE_BLEND+bitwiseBlend" "(a\&~(c))|(b\&c)" "BITWISE"
 -
 -# Unary operations.
 -gen_unary_alu_op "NEG+neg" "-((\$type\$)a)"
 -gen_unary_alu_op "ABS+abs" "Math.abs((\$type\$)a)"
 -gen_unary_alu_op "NOT+not" "~((\$type\$)a)" "BITWISE"
 -gen_unary_alu_op "ZOMO" "(a==0?0:-1)" "BITWISE"
 -gen_unary_alu_op "SQRT+sqrt" "Math.sqrt((double)a)" "FP"
 -gen_unary_alu_op "BIT_COUNT" "\$Boxtype\$.bitCount(a)" "intOrLong"
 -gen_unary_alu_op "BIT_COUNT" "Integer.bitCount((int)a \& 0xFF)" "byte"
 -gen_unary_alu_op "BIT_COUNT" "Integer.bitCount((int)a \& 0xFFFF)" "short"
 -gen_unary_alu_op "TRAILING_ZEROS_COUNT" "TRAILING_ZEROS_COUNT_scalar(a)" "BITWISE"
 -gen_unary_alu_op "LEADING_ZEROS_COUNT" "LEADING_ZEROS_COUNT_scalar(a)" "BITWISE"
 -gen_unary_alu_op "REVERSE" "REVERSE_scalar(a)" "BITWISE"
 -gen_unary_alu_op "REVERSE_BYTES" "\$Boxtype\$.reverseBytes(a)" "intOrLong"
 -gen_unary_alu_op "REVERSE_BYTES" "\$Boxtype\$.reverseBytes(a)" "short"
 -gen_unary_alu_op "REVERSE_BYTES" "a" "byte"
 +if [ "$1" == "ALL_PRIM_TYPES" ]; then
 +  # ALU binary ops.
 +  # Here "ADD+add+withMask" says VectorOperator name is "ADD", and we have a dedicate method too named 'add', and add() is also available with mask variant.
 +  gen_binary_alu_op "ADD+add+withMask" "a + b"
 +  gen_binary_alu_op "SUB+sub+withMask" "a - b"
 +  gen_binary_alu_op "MUL+mul+withMask" "a \* b"
 +  gen_binary_alu_op "DIV+div+withMask" "a \/ b" "FP"
 +  gen_op_tmpl "Binary-op_bitwise-div" "DIV+div+withMask" "a \/ b" "BITWISE"
 +  gen_op_tmpl "Binary-Masked-op_bitwise-div" "DIV+div+withMask" "a \/ b" "BITWISE"
 +  gen_binary_alu_op "FIRST_NONZERO" "{#if[FP]?Double.doubleToLongBits}(a)!=0?a:b"
 +  gen_binary_alu_op "AND+and"   "a \& b"  "BITWISE"
 +  gen_binary_alu_op "AND_NOT" "a \& ~b" "BITWISE"
 +  gen_binary_alu_op "OR+or"    "a | b"   "BITWISE"
 +  # Missing:        "OR_UNCHECKED"
 +  gen_binary_alu_op "XOR"   "a ^ b"   "BITWISE"
 +  gen_binary_alu_op "COMPRESS_BITS" "\$Boxtype\$.compress(a, b)" "intOrLong"
 +  gen_binary_alu_op "EXPAND_BITS" "\$Boxtype\$.expand(a, b)" "intOrLong"
 +  # Generate the broadcast versions
 +  gen_binary_alu_bcst_op "add+withMask" "a + b"
 +  gen_binary_alu_bcst_op "sub+withMask" "a - b"
 +  gen_binary_alu_bcst_op "mul+withMask" "a \* b"
 +  gen_binary_alu_bcst_op "div+withMask" "a \/ b" "FP"
 +  gen_op_tmpl "Binary-Broadcast-op_bitwise-div" "div+withMask" "a \/ b" "BITWISE"
 +  gen_op_tmpl "Binary-Broadcast-Masked-op_bitwise-div" "div+withMask" "a \/ b" "BITWISE"
 +  gen_binary_alu_bcst_op "OR+or"    "a | b"   "BITWISE"
 +  gen_binary_alu_bcst_op "AND+and"    "a \& b"   "BITWISE"
 +  gen_binary_alu_bcst_long_op "OR"     "a | b"   "BITWISE"
 +  gen_binary_alu_bcst_long_op "ADD"    "a + b"
 +
 +  # Shifts
 +  gen_binary_alu_op "LSHL" "(a << b)" "intOrLong"
 +  gen_binary_alu_op "LSHL" "(a << (b \& 0x7))" "byte"
 +  gen_binary_alu_op "LSHL" "(a << (b \& 0xF))" "short"
 +  gen_binary_alu_op "ASHR" "(a >> b)" "intOrLong"
 +  gen_binary_alu_op "ASHR" "(a >> (b \& 0x7))" "byte"
 +  gen_binary_alu_op "ASHR" "(a >> (b \& 0xF))" "short"
 +  gen_binary_alu_op "LSHR" "(a >>> b)" "intOrLong"
 +  gen_binary_alu_op "LSHR" "((a \& 0xFF) >>> (b \& 0x7))" "byte"
 +  gen_binary_alu_op "LSHR" "((a \& 0xFFFF) >>> (b \& 0xF))" "short"
 +  gen_shift_op  "LSHL" "(a << b)" "intOrLong"
 +  gen_shift_op  "LSHL" "(a << (b \& 7))" "byte"
 +  gen_shift_op  "LSHL" "(a << (b \& 15))" "short"
 +  gen_shift_op  "LSHR" "(a >>> b)" "intOrLong"
 +  gen_shift_op  "LSHR" "((a \& 0xFF) >>> (b \& 7))" "byte"
 +  gen_shift_op  "LSHR" "((a \& 0xFFFF) >>> (b \& 15))" "short"
 +  gen_shift_op  "ASHR" "(a >> b)" "intOrLong"
 +  gen_shift_op  "ASHR" "(a >> (b \& 7))" "byte"
 +  gen_shift_op  "ASHR" "(a >> (b \& 15))" "short"
 +  gen_binary_alu_op "ROR" "ROR_scalar(a,b)" "BITWISE"
 +  gen_binary_alu_op "ROL" "ROL_scalar(a,b)" "BITWISE"
 +  gen_shift_op  "ROR" "ROR_scalar(a, b)" "BITWISE"
 +  gen_shift_op  "ROL" "ROL_scalar(a, b)" "BITWISE"
 +
 +  # Constant Shifts
 +  gen_shift_cst_op  "LSHR" "(a >>> CONST_SHIFT)" "intOrLong"
 +  gen_shift_cst_op  "LSHR" "((a \& 0xFF) >>> CONST_SHIFT)" "byte"
 +  gen_shift_cst_op  "LSHR" "((a \& 0xFFFF) >>> CONST_SHIFT)" "short"
 +  gen_shift_cst_op  "LSHL" "(a << CONST_SHIFT)" "BITWISE"
 +  gen_shift_cst_op  "ASHR" "(a >> CONST_SHIFT)" "BITWISE"
 +  gen_shift_cst_op  "ROR" "ROR_scalar(a, CONST_SHIFT)" "BITWISE"
 +  gen_shift_cst_op  "ROL" "ROL_scalar(a, CONST_SHIFT)" "BITWISE"
 +
++  # Binary operation with one memory operand
++  gen_binary_alu_mem_op "MIN+min+withMask", "Math.min(a, b)"
++  gen_binary_alu_mem_op "MAX+max+withMask", "Math.max(a, b)"
++  
 +  # Masked reductions.
 +  gen_binary_op_no_masked "MIN+min" "Math.min(a, b)"
 +  gen_binary_op_no_masked "MAX+max" "Math.max(a, b)"
++  gen_binary_op "UMIN" "VectorMath.minUnsigned(a, b)" "BITWISE"
++  gen_binary_op "UMAX" "VectorMath.maxUnsigned(a, b)" "BITWISE"
++  gen_saturating_binary_op "SADD" "VectorMath.addSaturating(a, b)" "BITWISE"
++  gen_saturating_binary_op "SSUB" "VectorMath.subSaturating(a, b)" "BITWISE"
++  gen_saturating_binary_op "SUADD" "VectorMath.addSaturatingUnsigned(a, b)" "BITWISE"
++  gen_saturating_binary_op "SUSUB" "VectorMath.subSaturatingUnsigned(a, b)" "BITWISE"
 +  gen_binary_bcst_op_no_masked "MIN+min" "Math.min(a, b)"
 +  gen_binary_bcst_op_no_masked "MAX+max" "Math.max(a, b)"
- 
++  gen_saturating_binary_op_associative "SUADD" "VectorMath.addSaturatingUnsigned(a, b)" "BITWISE"
++  
 +  # Reductions.
 +  gen_reduction_op "AND" "\&" "BITWISE" "-1"
 +  gen_reduction_op "OR" "|" "BITWISE" "0"
 +  gen_reduction_op "XOR" "^" "BITWISE" "0"
 +  gen_reduction_op "ADD" "+" "" "0"
 +  gen_reduction_op "MUL" "*" "" "1"
 +  gen_reduction_op_func "MIN" "(\$type\$) Math.min" "" "\$Wideboxtype\$.\$MaxValue\$"
 +  gen_reduction_op_func "MAX" "(\$type\$) Math.max" "" "\$Wideboxtype\$.\$MinValue\$"
++  gen_reduction_op_func "UMIN" "(\$type\$) VectorMath.minUnsigned" "BITWISE" "\$Wideboxtype\$.\$MaxValue\$"
++  gen_reduction_op_func "UMAX" "(\$type\$) VectorMath.maxUnsigned" "BITWISE" "\$Wideboxtype\$.\$MinValue\$"
 +  gen_reduction_op_func "FIRST_NONZERO" "firstNonZero" "" "(\$type\$) 0"
 +
 +  # Boolean reductions.
 +  gen_bool_reduction_op "anyTrue" "|" "BITWISE" "false"
 +  gen_bool_reduction_op "allTrue" "\&" "BITWISE" "true"
 +
++  # Saturating reductions.
++  gen_saturating_reduction_op "SUADD" "(\$type\$) VectorMath.addSaturatingUnsigned" "BITWISE" "0"
++  
 +  #Insert
 +  gen_with_op "withLane" "" "" ""
 +
 +  # Tests
 +  gen_op_tmpl $test_template "IS_DEFAULT" "bits(a)==0"
 +  gen_op_tmpl $test_template "IS_NEGATIVE" "bits(a)<0"
 +  gen_op_tmpl $test_template "IS_FINITE" "\$Boxtype\$.isFinite(a)" "FP"
 +  gen_op_tmpl $test_template "IS_NAN" "\$Boxtype\$.isNaN(a)" "FP"
 +  gen_op_tmpl $test_template "IS_INFINITE" "\$Boxtype\$.isInfinite(a)" "FP"
 +
 +  # Compares
 +  gen_compare_op "LT+lt" "lt"
 +  gen_compare_op "GT" "gt"
 +  gen_compare_op "EQ+eq" "eq"
 +  gen_compare_op "NE" "neq"
 +  gen_compare_op "LE" "le"
 +  gen_compare_op "GE" "ge"
 +
-   gen_compare_op "UNSIGNED_LT" "ult" "BITWISE"
-   gen_compare_op "UNSIGNED_GT" "ugt" "BITWISE"
-   gen_compare_op "UNSIGNED_LE" "ule" "BITWISE"
-   gen_compare_op "UNSIGNED_GE" "uge" "BITWISE"
- 
- 
++  gen_compare_op "ULT" "ult" "BITWISE"
++  gen_compare_op "UGT" "ugt" "BITWISE"
++  gen_compare_op "ULE" "ule" "BITWISE"
++  gen_compare_op "UGE" "uge" "BITWISE"
++  
 +  gen_compare_bcst_op "LT" "<"
 +  gen_compare_bcst_op "EQ" "=="
 +
 +  # Blend.
 +  gen_op_tmpl $blend "blend" ""
 +
 +  # Rearrange
 +  gen_op_tmpl $rearrange_template "rearrange" ""
 +
 +  # Compress/Expand
 +  gen_op_tmpl $compressexpand_template "compress_expand" ""
 +
 +  # Get
 +  gen_get_op "lane" ""
 +
 +  # Broadcast
 +  gen_op_tmpl $broadcast_template "broadcast" ""
 +
 +  # Zero
 +  gen_op_tmpl $zero_template "zero" ""
 +
 +  # Slice
 +  gen_op_tmpl $slice_template "sliceUnary" ""
 +  gen_op_tmpl $slice1_template "sliceBinary" ""
 +  gen_op_tmpl $slice1_masked_template "slice" ""
 +
 +  # Unslice
 +  gen_op_tmpl $unslice_template "unsliceUnary" ""
 +  gen_op_tmpl $unslice1_template "unsliceBinary" ""
 +  gen_op_tmpl $unslice1_masked_template "unslice" ""
 +
 +  # Math
 +  gen_op_tmpl $unary_math_template "SIN" "Math.sin((double)a)" "FP"
 +  gen_op_tmpl $unary_math_template "EXP" "Math.exp((double)a)" "FP"
 +  gen_op_tmpl $unary_math_template "LOG1P" "Math.log1p((double)a)" "FP"
 +  gen_op_tmpl $unary_math_template "LOG" "Math.log((double)a)" "FP"
 +  gen_op_tmpl $unary_math_template "LOG10" "Math.log10((double)a)" "FP"
 +  gen_op_tmpl $unary_math_template "EXPM1" "Math.expm1((double)a)" "FP"
 +  gen_op_tmpl $unary_math_template "COS" "Math.cos((double)a)" "FP"
 +  gen_op_tmpl $unary_math_template "TAN" "Math.tan((double)a)" "FP"
 +  gen_op_tmpl $unary_math_template "SINH" "Math.sinh((double)a)" "FP"
 +  gen_op_tmpl $unary_math_template "COSH" "Math.cosh((double)a)" "FP"
 +  gen_op_tmpl $unary_math_template "TANH" "Math.tanh((double)a)" "FP"
 +  gen_op_tmpl $unary_math_template "ASIN" "Math.asin((double)a)" "FP"
 +  gen_op_tmpl $unary_math_template "ACOS" "Math.acos((double)a)" "FP"
 +  gen_op_tmpl $unary_math_template "ATAN" "Math.atan((double)a)" "FP"
 +  gen_op_tmpl $unary_math_template "CBRT" "Math.cbrt((double)a)" "FP"
 +  gen_op_tmpl $binary_math_template "HYPOT" "Math.hypot((double)a, (double)b)" "FP"
 +  gen_op_tmpl $binary_math_template "POW+pow" "Math.pow((double)a, (double)b)" "FP"
 +  gen_op_tmpl $binary_math_template "ATAN2" "Math.atan2((double)a, (double)b)" "FP"
 +  gen_op_tmpl $binary_math_broadcast_template "POW+pow" "Math.pow((double)a, (double)b)" "FP"
 +
 +  # Ternary operations.
 +  gen_ternary_alu_op "FMA+fma" "Math.fma(a, b, c)" "FP"
 +  gen_ternary_alu_op "BITWISE_BLEND+bitwiseBlend" "(a\&~(c))|(b\&c)" "BITWISE"
 +  gen_ternary_alu_bcst_op "FMA" "Math.fma(a, b, c)" "FP"
 +  gen_ternary_alu_bcst_op "BITWISE_BLEND+bitwiseBlend" "(a\&~(c))|(b\&c)" "BITWISE"
 +  gen_ternary_alu_double_bcst_op "FMA+fma" "Math.fma(a, b, c)" "FP"
 +  gen_ternary_alu_double_bcst_op "BITWISE_BLEND+bitwiseBlend" "(a\&~(c))|(b\&c)" "BITWISE"
 +
 +  # Unary operations.
 +  gen_unary_alu_op "NEG+neg" "-((\$type\$)a)"
 +  gen_unary_alu_op "ABS+abs" "Math.abs((\$type\$)a)"
 +  gen_unary_alu_op "NOT+not" "~((\$type\$)a)" "BITWISE"
 +  gen_unary_alu_op "ZOMO" "(a==0?0:-1)" "BITWISE"
 +  gen_unary_alu_op "SQRT+sqrt" "Math.sqrt((double)a)" "FP"
 +  gen_unary_alu_op "BIT_COUNT" "\$Boxtype\$.bitCount(a)" "intOrLong"
 +  gen_unary_alu_op "BIT_COUNT" "Integer.bitCount((int)a \& 0xFF)" "byte"
 +  gen_unary_alu_op "BIT_COUNT" "Integer.bitCount((int)a \& 0xFFFF)" "short"
 +  gen_unary_alu_op "TRAILING_ZEROS_COUNT" "TRAILING_ZEROS_COUNT_scalar(a)" "BITWISE"
 +  gen_unary_alu_op "LEADING_ZEROS_COUNT" "LEADING_ZEROS_COUNT_scalar(a)" "BITWISE"
 +  gen_unary_alu_op "REVERSE" "REVERSE_scalar(a)" "BITWISE"
 +  gen_unary_alu_op "REVERSE_BYTES" "\$Boxtype\$.reverseBytes(a)" "intOrLong"
 +  gen_unary_alu_op "REVERSE_BYTES" "\$Boxtype\$.reverseBytes(a)" "short"
 +  gen_unary_alu_op "REVERSE_BYTES" "a" "byte"
 +
 +elif [ "$1" == "HALF_FLOAT_TYPE" ]; then
 +  gen_binary_alu_op "ADD" "Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b))" "Halffloat"
 +  gen_binary_alu_op "SUB" "Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b))" "Halffloat"
 +  gen_binary_alu_op "MUL" "Float.floatToFloat16(Float.float16ToFloat(a) \* Float.float16ToFloat(b))" "Halffloat"
 +  gen_binary_alu_op "DIV" "Float.floatToFloat16(Float.float16ToFloat(a) \/ Float.float16ToFloat(b))" "Halffloat"
 +  gen_binary_alu_op "MAX" "Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b)))" "Halffloat"
-   gen_binary_alu_op "MIN" "Halffloat.valueOf(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b)))" "Halffloat"
++  gen_binary_alu_op "MIN" "Float.floatToFloat16(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b)))" "Halffloat"
 +  gen_unary_alu_op "ABS+abs" "Math.abs(a)" "Halffloat"
 +  gen_unary_alu_op "NEG+neg" "-a" "Halffloat"
 +  gen_ternary_alu_op "FMA+fma" "Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c)))" "Halffloat"
-   gen_unary_alu_op "SQRT+sqrt" "Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a)))" "Halffloat"
++  gen_unary_alu_op "SQRT+sqrt" "Float.floatToFloat16((float) Math.sqrt(Float.float16ToFloat(a)))" "Halffloat"
 +  gen_op_tmpl $unary_math_hf_template "SIN" "Math.sin(Float.float16ToFloat(a))" "Halffloat"
 +  gen_op_tmpl $unary_math_hf_template "EXP" "Math.exp(Float.float16ToFloat(a))" "Halffloat"
 +  gen_op_tmpl $unary_math_hf_template "LOG1P" "Math.log1p(Float.float16ToFloat(a))" "Halffloat"
 +  gen_op_tmpl $unary_math_hf_template "LOG" "Math.log(Float.float16ToFloat(a))" "Halffloat"
 +  gen_op_tmpl $unary_math_hf_template "LOG10" "Math.log10(Float.float16ToFloat(a))" "Halffloat"
 +  gen_op_tmpl $unary_math_hf_template "EXPM1" "Math.expm1(Float.float16ToFloat(a))" "Halffloat"
 +  gen_op_tmpl $unary_math_hf_template "COS" "Math.cos(Float.float16ToFloat(a))" "Halffloat"
 +  gen_op_tmpl $unary_math_hf_template "TAN" "Math.tan(Float.float16ToFloat(a))" "Halffloat"
 +  gen_op_tmpl $unary_math_hf_template "SINH" "Math.sinh(Float.float16ToFloat(a))" "Halffloat"
 +  gen_op_tmpl $unary_math_hf_template "COSH" "Math.cosh(Float.float16ToFloat(a))" "Halffloat"
 +  gen_op_tmpl $unary_math_hf_template "TANH" "Math.tanh(Float.float16ToFloat(a))" "Halffloat"
 +  gen_op_tmpl $unary_math_hf_template "ASIN" "Math.asin(Float.float16ToFloat(a))" "Halffloat"
 +  gen_op_tmpl $unary_math_hf_template "ACOS" "Math.acos(Float.float16ToFloat(a))" "Halffloat"
 +  gen_op_tmpl $unary_math_hf_template "ATAN" "Math.atan(Float.float16ToFloat(a))" "Halffloat"
 +  gen_op_tmpl $unary_math_hf_template "CBRT" "Math.cbrt(Float.float16ToFloat(a))" "Halffloat"
 +  gen_op_tmpl $binary_math_hf_template "HYPOT" "Math.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b))" "Halffloat"
 +  gen_op_tmpl $binary_math_hf_template "POW+pow" "Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b))" "Halffloat"
 +  gen_op_tmpl $binary_math_hf_template "ATAN2" "Math.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b))" "Halffloat"
 +  gen_op_tmpl $binary_math_broadcast_template "POW+pow" "Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b))" "Halffloat"
 +  gen_op_tmpl $blend "blend" "Halffloat"
 +fi
  
  # Miscellaneous Smoke Tests
  gen_op_tmpl $miscellaneous_template "MISC" "" ""
diff --cc test/jdk/jdk/incubator/vector/gen-tests.sh
index 2a16fc97dd5,8b87d9d9efb..c19c10fb94b
--- a/test/jdk/jdk/incubator/vector/gen-tests.sh
+++ b/test/jdk/jdk/incubator/vector/gen-tests.sh
@@@ -28,179 -26,157 +26,180 @@@
  # You can regenerate the source files,
  # and you can clean them up.
  # FIXME: Move this script under $REPO/make/gensrc/
 -case $* in
 -'')             CLASS_FILTER='*';;
 ---generate*)    CLASS_FILTER=${2-'*'};;
 ---help|*)       echo "Usage: $0 [--generate [file]]"; exit 1;;
 -esac
 +generate_test_cases() {
 +  Log false "Generating Vector API tests, $(date)\n"
  
 -. config.sh
 +  # Compile SPP
 +  Log true "Compiling SPP... "
 +  compilation=$(${JAVAC} -d . "${JDK_SRC_HOME}/make/jdk/src/classes/build/tools/spp/Spp.java")
 +  Log false "$compilation\n"
 +  Log true "done\n"
  
 -# Detect whether to generate the performance tests
 -generate_perf_tests=false
 -if [ -d "$PERF_DEST" ]; then
 -  generate_perf_tests=true
 -fi
 +  array=()
 +  if [ $1 == "ALL_PRIM_TYPES" ]; then
 +    array=("byte" "short" "int" "long" "float" "double")
 +  elif [ $1 == "HALF_FLOAT_TYPE" ]; then
 +    array=("halffloat")
 +  fi
  
 -# First, generate the template file.
 -bash ./gen-template.sh $generate_perf_tests
 -
 -Log false "Generating Vector API tests, $(date)\n"
 -
 -# Compile SPP
 -Log true "Compiling SPP... "
 -compilation=$(${JAVAC} -d . "${JDK_SRC_HOME}/make/jdk/src/classes/build/tools/spp/Spp.java")
 -Log false "$compilation\n"
 -Log true "done\n"
 -
 -# For each type
 -for type in byte short int long float double
 -do
 -  Type="$(tr '[:lower:]' '[:upper:]' <<< ${type:0:1})${type:1}"
 -  TYPE="$(tr '[:lower:]' '[:upper:]' <<< ${type})"
 -  args="-K$type -Dtype=$type -DType=$Type -DTYPE=$TYPE"
 -
 -  Boxtype=$Type
 -  Wideboxtype=$Boxtype
 -  MaxValue=MAX_VALUE
 -  MinValue=MIN_VALUE
 -
 -  kind=BITWISE
 -
 -  bitstype=$type
 -  Bitstype=$Type
 -  Boxbitstype=$Boxtype
 -
 -  fptype=$type
 -  Fptype=$Type
 -  Boxfptype=$Boxtype
 -
 -  case $type in
 -    byte)
 -      Wideboxtype=Byte
 -      args="$args -KbyteOrShort"
 -      ;;
 -    short)
 -      Wideboxtype=Short
 -      args="$args -KbyteOrShort"
 -      ;;
 -    int)
 -      Boxtype=Integer
 -      Wideboxtype=Integer
 -      fptype=float
 -      Fptype=Float
 -      Boxfptype=Float
 -      args="$args -KintOrLong"
 -      ;;
 -    long)
 -      Wideboxtype=Long
 -      fptype=double
 -      Fptype=Double
 -      Boxfptype=Double
 -      args="$args -KintOrLong"
 -      ;;
 -    float)
 -      kind=FP
 -      bitstype=int
 -      Bitstype=Int
 -      Boxbitstype=Integer
 -      Wideboxtype=Float
 -      MaxValue=POSITIVE_INFINITY
 -      MinValue=NEGATIVE_INFINITY
 -      ;;
 -    double)
 -      kind=FP
 -      bitstype=long
 -      Bitstype=Long
 -      Boxbitstype=Long
 -      Wideboxtype=Double
 -      MaxValue=POSITIVE_INFINITY
 -      MinValue=NEGATIVE_INFINITY
 -      ;;
 -  esac
 -
 -  args="$args -K$kind -K$Type -DBoxtype=$Boxtype -DWideboxtype=$Wideboxtype -DMaxValue=$MaxValue -DMinValue=$MinValue"
 -  args="$args -Dbitstype=$bitstype -DBitstype=$Bitstype -DBoxbitstype=$Boxbitstype"
 -  args="$args -Dfptype=$fptype -DFptype=$Fptype -DBoxfptype=$Boxfptype"
 -
 -  abstractvectortype=${typeprefix}${Type}Vector
 -  abstractvectorteststype=${typeprefix}${Type}VectorTests
 -  abstractbitsvectortype=${typeprefix}${Bitstype}Vector
 -  abstractfpvectortype=${typeprefix}${Fptype}Vector
 -  args="$args -Dabstractvectortype=$abstractvectortype -Dabstractvectorteststype=$abstractvectorteststype -Dabstractbitsvectortype=$abstractbitsvectortype -Dabstractfpvectortype=$abstractfpvectortype"
 -
 -  # Generate tests for operations
 -  # For each size
 -  Log true "${Type}:"
 -
 -  for bits in 64 128 256 512 Max
 +  # For each type
 +  for type in ${array[@]}
    do
 -    vectortype=${typeprefix}${Type}${bits}Vector
 -    vectorteststype=${typeprefix}${Type}${bits}VectorTests
 -    vectorbenchtype=${typeprefix}${Type}${bits}Vector
 -    masktype=${typeprefix}${Type}${bits}Mask
 -    bitsvectortype=${typeprefix}${Bitstype}${bits}Vector
 -    fpvectortype=${typeprefix}${Fptype}${bits}Vector
 -    shape=S${bits}Bit
 -    Shape=S_${bits}_BIT
 -    if [[ "${vectortype}" == "ByteMaxVector" ]]; then
 -      args="$args -KByteMax"
 -    fi
 -    bitargs="$args -Dbits=$bits -Dvectortype=$vectortype -Dvectorteststype=$vectorteststype -Dvectorbenchtype=$vectorbenchtype -Dmasktype=$masktype -Dbitsvectortype=$bitsvectortype -Dfpvectortype=$fpvectortype -Dshape=$shape -DShape=$Shape"
 -    if [ $bits == 'Max' ]; then
 -      bitargs="$bitargs -KMaxBit"
 -    fi
 -
 -    # Generate jtreg tests
 -    case $vectorteststype in
 -    $CLASS_FILTER)
 -      Log true " ${bits}_jtreg $vectorteststype.java"
 -      Log false "${JAVA} -cp . ${SPP_CLASSNAME} -nel $bitargs -i${TEMPLATE_FILE} -o$vectorteststype.java "
 -      TEST_DEST_FILE="${vectorteststype}.java"
 -      rm -f ${TEST_DEST_FILE}
 -      ${JAVA} -cp . ${SPP_CLASSNAME} -nel $bitargs \
 -        -i${TEMPLATE_FILE} \
 -        -o${TEST_DEST_FILE}
 -      if [ VAR_OS_ENV==windows.cygwin ]; then
 -        tr -d  '\r' < ${TEST_DEST_FILE} > temp
 -        mv temp ${TEST_DEST_FILE}
 +    Type="$(tr '[:lower:]' '[:upper:]' <<< ${type:0:1})${type:1}"
 +    TYPE="$(tr '[:lower:]' '[:upper:]' <<< ${type})"
 +    args="-K$type -Dtype=$type -DType=$Type -DTYPE=$TYPE"
 +
 +    Boxtype=$Type
 +    Wideboxtype=$Boxtype
 +    MaxValue=MAX_VALUE
 +    MinValue=MIN_VALUE
 +    ElementType=$Type
 +    kind=BITWISE
 +    VecEleType=$Type
 +    bitstype=$type
 +    Bitstype=$Type
 +    Boxbitstype=$Boxtype
 +    fptype=$type
 +    Fptype=$Type
 +    Boxfptype=$Boxtype
 +    ClassType=$type
 +
 +    case $type in
 +      byte)
 +        Wideboxtype=Byte
 +        args="$args -KbyteOrShort"
 +        ;;
 +      short)
 +        Wideboxtype=Short
 +        args="$args -KbyteOrShort"
 +        ;;
 +      int)
 +        ElementType=Int
 +        VecEleType=Integer
 +        Boxtype=Integer
 +        Wideboxtype=Integer
 +        fptype=float
 +        Fptype=Float
 +        Boxfptype=Float
 +        args="$args -KintOrLong"
 +        ;;
 +      long)
 +        Wideboxtype=Long
 +        fptype=double
 +        Fptype=Double
 +        Boxfptype=Double
 +        args="$args -KintOrLong"
 +        ;;
 +      float)
 +        kind=FP
 +        bitstype=int
 +        Bitstype=Int
 +        Boxbitstype=Integer
 +        Wideboxtype=Float
 +        MaxValue=POSITIVE_INFINITY
 +        MinValue=NEGATIVE_INFINITY
 +        ;;
 +      double)
 +        kind=FP
 +        bitstype=long
 +        Bitstype=Long
 +        Boxbitstype=Long
 +        Wideboxtype=Double
 +        MaxValue=POSITIVE_INFINITY
 +        MinValue=NEGATIVE_INFINITY
 +        ;;
 +      halffloat)
 +        VecEleType=Short
-         ClassType=Halffloat
++        ClassType=Float16
 +        kind=FP
 +        bitstype=short
 +        Bitstype=Short
++        Boxtype=Float16
 +        Boxbitstype=Short
-         Wideboxtype=Halffloat
++        Wideboxtype=Float16
 +        args="$args -Dtype=short -DType=Halffloat -DTYPE=HALFFLOAT -DElementType=Halffloat"
 +        ;;
 +      esac
 +
 +    args="$args -K$kind -K$Type -DBoxtype=$Boxtype -DWideboxtype=$Wideboxtype -DMaxValue=$MaxValue -DMinValue=$MinValue"
 +    args="$args -Dbitstype=$bitstype -DBitstype=$Bitstype -DBoxbitstype=$Boxbitstype -DElementType=$Type -DVecEleType=$VecEleType -DClassType=$ClassType"
 +    args="$args -Dfptype=$fptype -DFptype=$Fptype -DBoxfptype=$Boxfptype"
 +
 +    abstractvectortype=${typeprefix}${Type}Vector
 +    abstractvectorteststype=${typeprefix}${Type}VectorTests
 +    abstractbitsvectortype=${typeprefix}${Bitstype}Vector
 +    abstractfpvectortype=${typeprefix}${Fptype}Vector
 +    args="$args -Dabstractvectortype=$abstractvectortype -Dabstractvectorteststype=$abstractvectorteststype -Dabstractbitsvectortype=$abstractbitsvectortype -Dabstractfpvectortype=$abstractfpvectortype"
 +
 +    # Generate tests for operations
 +    # For each size
 +    Log true "${Type}:"
 +
 +    for bits in 64 128 256 512 Max
 +    do
 +      vectortype=${typeprefix}${Type}${bits}Vector
 +      vectorteststype=${typeprefix}${Type}${bits}VectorTests
 +      vectorbenchtype=${typeprefix}${Type}${bits}Vector
 +      masktype=${typeprefix}${Type}${bits}Mask
 +      bitsvectortype=${typeprefix}${Bitstype}${bits}Vector
 +      fpvectortype=${typeprefix}${Fptype}${bits}Vector
 +      shape=S${bits}Bit
 +      Shape=S_${bits}_BIT
 +      if [[ "${vectortype}" == "ByteMaxVector" ]]; then
 +        args="$args -KByteMax"
 +      fi
 +      bitargs="$args -Dbits=$bits -Dvectortype=$vectortype -Dvectorteststype=$vectorteststype -Dvectorbenchtype=$vectorbenchtype -Dmasktype=$masktype -Dbitsvectortype=$bitsvectortype -Dfpvectortype=$fpvectortype -Dshape=$shape -DShape=$Shape"
 +      if [ $bits == 'Max' ]; then
 +        bitargs="$bitargs -KMaxBit"
        fi
 -      ;;
 -    esac
  
 -    if [ $generate_perf_tests == true ]; then
 -      # Generate jmh performance tests
 -      case $vectorbenchtype in
 +      # Generate jtreg tests
 +      case $vectorteststype in
        $CLASS_FILTER)
 -        Log true " ${bits}_jmh $vectorbenchtype.java"
 -        Log false "${JAVA} -cp . ${SPP_CLASSNAME} -nel $bitargs -i${PERF_TEMPLATE_FILE} -o${vectorteststype}Perf.java "
 -        PERF_DEST_FILE="${PERF_DEST}/${vectorbenchtype}.java"
 -        rm -f ${PERF_DEST_FILE}
 +        Log true " ${bits}_jtreg $vectorteststype.java"
 +        Log false "${JAVA} -cp . ${SPP_CLASSNAME} -nel $bitargs -i${TEMPLATE_FILE} -o$vectorteststype.java "
 +        TEST_DEST_FILE="${vectorteststype}.java"
 +        rm -f ${TEST_DEST_FILE}
          ${JAVA} -cp . ${SPP_CLASSNAME} -nel $bitargs \
 +          -i${TEMPLATE_FILE} \
 +          -o${TEST_DEST_FILE}
 +        if [ VAR_OS_ENV==windows.cygwin ]; then
 +          tr -d  '\r' < ${TEST_DEST_FILE} > temp
 +          mv temp ${TEST_DEST_FILE}
 +        fi
 +        ;;
 +      esac
 +
 +        if [ $generate_perf_tests == true ]; then
 +          # Generate jmh performance tests
 +          case $vectorbenchtype in
 +          $CLASS_FILTER)
 +          Log true " ${bits}_jmh $vectorbenchtype.java"
 +          Log false "${JAVA} -cp . ${SPP_CLASSNAME} -nel $bitargs -i${PERF_TEMPLATE_FILE} -o${vectorteststype}Perf.java "
 +          PERF_DEST_FILE="${PERF_DEST}/${vectorbenchtype}.java"
 +          rm -f ${PERF_DEST_FILE}
 +          ${JAVA} -cp . ${SPP_CLASSNAME} -nel $bitargs \
            -i${PERF_TEMPLATE_FILE} \
            -o${PERF_DEST_FILE}
 +          if [ VAR_OS_ENV==windows.cygwin ]; then
 +            tr -d  '\r' < ${PERF_DEST_FILE} > temp
 +            mv temp ${PERF_DEST_FILE}
 +          fi
 +            ;;
 +          esac
 +        fi
 +    done
 +
 +      if [ $generate_perf_tests == true ]; then
 +        # Generate jmh performance tests
 +        case ${Type}Scalar in
 +        $CLASS_FILTER)
 +        Log true " scalar ${Type}Scalar.java"
 +        PERF_DEST_FILE="${PERF_DEST}/${Type}Scalar.java"
 +        rm -f ${PERF_DEST_FILE}
 +        ${JAVA} -cp . ${SPP_CLASSNAME} -nel $args \
 +        -i${PERF_SCALAR_TEMPLATE_FILE} \
 +        -o${PERF_DEST_FILE}
          if [ VAR_OS_ENV==windows.cygwin ]; then
            tr -d  '\r' < ${PERF_DEST_FILE} > temp
            mv temp ${PERF_DEST_FILE}
diff --cc test/jdk/jdk/incubator/vector/templates/Perf-Scalar-header.template
index fcf6d6cea68,27a3c3c74bd..96685ebc951
--- a/test/jdk/jdk/incubator/vector/templates/Perf-Scalar-header.template
+++ b/test/jdk/jdk/incubator/vector/templates/Perf-Scalar-header.template
@@@ -27,10 -27,8 +27,11 @@@ package org.openjdk.bench.jdk.incubator
  
  import java.util.concurrent.TimeUnit;
  import java.util.function.IntFunction;
+ import jdk.incubator.vector.VectorMath;
  
 +#if[Halffloat]
 +import jdk.incubator.vector.Halffloat;
 +#end[Halffloat]
  import org.openjdk.jmh.annotations.*;
  import org.openjdk.jmh.infra.Blackhole;
  
diff --cc test/jdk/jdk/incubator/vector/templates/Unit-Binary-op-hf-math.template
index fd52664a23c,00000000000..7755a4adb53
mode 100644,000000..100644
--- a/test/jdk/jdk/incubator/vector/templates/Unit-Binary-op-hf-math.template
+++ b/test/jdk/jdk/incubator/vector/templates/Unit-Binary-op-hf-math.template
@@@ -1,14 -1,0 +1,14 @@@
 +
 +    static $type$ [[TEST]]($type$ a, $type$ b) {
-         return Halffloat.valueOf((float) [[TEST_OP]]);
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) [[TEST_OP]]);
 +    }
 +
 +    static $type$ strict[[TEST]]($type$ a, $type$ b) {
-         return Halffloat.valueOf((float) Strict[[TEST_OP]]);
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Strict[[TEST_OP]]));
 +    }
 +
 +    @Test(dataProvider = "$type$BinaryOpProvider")
 +    static void [[TEST]]$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {
 +[[KERNEL]]
 +        assertArraysEqualsWithinOneUlp(r, a, b, $vectorteststype$::[[TEST]], $vectorteststype$::strict[[TEST]]);
 +    }
diff --cc test/jdk/jdk/incubator/vector/templates/Unit-Unary-op-hf-math.template
index 57b68297d06,00000000000..57239885979
mode 100644,000000..100644
--- a/test/jdk/jdk/incubator/vector/templates/Unit-Unary-op-hf-math.template
+++ b/test/jdk/jdk/incubator/vector/templates/Unit-Unary-op-hf-math.template
@@@ -1,14 -1,0 +1,14 @@@
 +
 +    static $type$ [[TEST]]($type$ a) {
-         return Halffloat.valueOf((float) [[TEST_OP]]);
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) [[TEST_OP]]));
 +    }
 +
 +    static $type$ strict[[TEST]]($type$ a) {
-         return Halffloat.valueOf((float) Strict[[TEST_OP]]);
++        return Float16.float16ToRawShortBits(Float16.valueOf((float) Strict[[TEST_OP]]));
 +    }
 +
 +    @Test(dataProvider = "$type$UnaryOpProvider")
 +    static void [[TEST]]$vectorteststype$(IntFunction<$type$[]> fa) {
 +[[KERNEL]]
 +        assertArraysEqualsWithinOneUlp(r, a, $vectorteststype$::[[TEST]], $vectorteststype$::strict[[TEST]]);
 +    }
diff --cc test/jdk/jdk/incubator/vector/templates/Unit-header.template
index 2302cad4b18,33c52f18c1c..97321a04482
--- a/test/jdk/jdk/incubator/vector/templates/Unit-header.template
+++ b/test/jdk/jdk/incubator/vector/templates/Unit-header.template
@@@ -1,9 -1,5 +1,5 @@@
  /*
- #if[Halffloat]
-  * Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved.
- #else[Halffloat]
-  * Copyright (c) 2018, 2022, Oracle and/or its affiliates. All rights reserved.
- #end[Halffloat]
 - * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2017, 2025, Oracle and/or its affiliates. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
@@@ -46,10 -48,6 +48,10 @@@ import jdk.incubator.vector.ByteVector
  #if[Float]
  import jdk.incubator.vector.FloatVector;
  #end[Float]
 +#if[Halffloat]
- import jdk.incubator.vector.Halffloat;
++import jdk.incubator.vector.Float16;
 +import jdk.incubator.vector.HalffloatVector;
 +#end[Halffloat]
  #if[Int]
  import jdk.incubator.vector.IntVector;
  #end[Int]
@@@ -1035,14 -1139,6 +1164,14 @@@ relativeError))
          }
      }
  
 +    static $type$ genValue(int i) {
 +#if[Halffloat]
-         return (short) Halffloat.valueOf(i);
++        return Float16.float16ToRawShortBits(Float16.valueOf(i));
 +#else[Halffloat]
 +        return ($type$) i;
 +#end[Halffloat]
 +    }
 +
  #if[!Int]
  #if[!byteOrShort]
      static int intCornerCaseValue(int i) {
@@@ -1113,28 -1205,20 +1242,28 @@@
          }
      }
  
 +    static $type$ genValue(long i) {
 +#if[Halffloat]
-         return (short) Halffloat.valueOf(i);
++        return Float16.float16ToRawShortBits(Float16.valueOf(i));
 +#else[Halffloat]
 +        return ($type$) i;
 +#end[Halffloat]
 +    }
 +
      static final List<IntFunction<$type$[]>> LONG_$TYPE$_GENERATORS = List.of(
 -            withToString("$type$[-i * 5]", (int s) -> {
 +            withToString("$ClassType$[-i * 5]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> ($type$)(-i * 5));
 +                            i -> genValue(-i * 5));
              }),
-             withToString("Halffloat[i * 5]", (int s) -> {
 -            withToString("$type$[i * 5]", (int s) -> {
++            withToString("$ClassType$[i * 5]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> ($type$)(i * 5));
 +                            i -> genValue(i * 5));
              }),
-             withToString("Halffloat[i + 1]", (int s) -> {
 -            withToString("$type$[i + 1]", (int s) -> {
++            withToString("$ClassType$[i + 1]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> ((($type$)(i + 1) == 0) ? 1 : ($type$)(i + 1)));
 +                            i -> ((($type$)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
              }),
-             withToString("Halffloat[cornerCaseValue(i)]", (int s) -> {
 -            withToString("$type$[cornerCaseValue(i)]", (int s) -> {
++            withToString("$ClassType$[cornerCaseValue(i)]", (int s) -> {
                  return fill(s * BUFFER_REPS,
                              i -> ($type$)longCornerCaseValue(i));
              })
@@@ -1192,19 -1268,29 +1321,29 @@@
      }
  
      static final List<IntFunction<$type$[]>> $TYPE$_GENERATORS = List.of(
 -            withToString("$type$[-i * 5]", (int s) -> {
 +            withToString("$ClassType$[-i * 5]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> ($type$)(-i * 5));
 +                            i -> genValue(-i * 5));
              }),
 -            withToString("$type$[i * 5]", (int s) -> {
 +            withToString("$ClassType$[i * 5]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> ($type$)(i * 5));
 +                            i -> genValue(i * 5));
              }),
 -            withToString("$type$[i + 1]", (int s) -> {
 +            withToString("$ClassType$[i + 1]", (int s) -> {
                  return fill(s * BUFFER_REPS,
 -                            i -> ((($type$)(i + 1) == 0) ? 1 : ($type$)(i + 1)));
 +                            i -> ((($type$)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));
              }),
-             withToString("$ClassType$[cornerCaseValue(i)]", (int s) -> {
+ #if[FP]
+             withToString("$type$[0.01 + (i / (i + 1))]", (int s) -> {
+                 return fill(s * BUFFER_REPS,
+                             i -> ($type$)0.01 + (($type$)i / (i + 1)));
+             }),
+             withToString("$type$[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i / (i + 1))]", (int s) -> {
+                 return fill(s * BUFFER_REPS,
+                             i -> i % 17 == 0 ? cornerCaseValue(i) : ($type$)0.01 + (($type$)i / (i + 1)));
+             }),
+ #end[FP]
+             withToString("$type$[cornerCaseValue(i)]", (int s) -> {
                  return fill(s * BUFFER_REPS,
                              i -> cornerCaseValue(i));
              })
@@@ -1607,44 -1809,6 +1862,44 @@@
  #end[intOrLong]
      }
  #end[BITWISE]
 +#if[Halffloat]
 +
 +    static boolean eq(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() == bt.floatValue();
 +    }
 +
 +    static boolean neq(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() != bt.floatValue();
 +    }
 +
 +    static boolean lt(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() < bt.floatValue();
 +    }
 +
 +    static boolean le(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() <= bt.floatValue();
 +    }
 +
 +    static boolean gt(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() > bt.floatValue();
 +    }
 +
 +    static boolean ge(short a, short b) {
-         Halffloat at = Halffloat.valueOf(a);
-         Halffloat bt = Halffloat.valueOf(b);
++        Float16 at = Float16.shortBitsToFloat16(a);
++        Float16 bt = Float16.shortBitsToFloat16(b);
 +        return at.floatValue() >= bt.floatValue();
 +    }
 +#else[Halffloat]
  
      static boolean eq($type$ a, $type$ b) {
          return a == b;
@@@ -1695,23 -1858,6 +1950,23 @@@
  
      @Test
      static void smokeTest1() {
 +#if[Halffloat]
-         $abstractvectortype$ three = $abstractvectortype$.broadcast(SPECIES, Halffloat.valueOf(-3));
-         $abstractvectortype$ three2 = ($abstractvectortype$) SPECIES.broadcast(Halffloat.valueOf(-3));
++        $abstractvectortype$ three = $abstractvectortype$.broadcast(SPECIES, Float16.float16ToRawShortBits(Float16.valueOf(-3)));
++        $abstractvectortype$ three2 = ($abstractvectortype$) SPECIES.broadcast(Float16.float16ToRawShortBits(Float16.valueOf(-3)));
 +        assert(three.eq(three2).allTrue());
-         $abstractvectortype$ three3 = three2.broadcast(Halffloat.valueOf(1)).broadcast(Halffloat.valueOf(-3));
++        $abstractvectortype$ three3 = three2.broadcast(Float16.float16ToRawShortBits(Float16.valueOf(1))).broadcast(Float16.float16ToRawShortBits(Float16.valueOf(-3)));
 +        assert(three.eq(three3).allTrue());
 +        int scale = 2;
 +        $abstractvectortype$ higher = three.addIndex(scale);
 +        VectorMask<$Boxtype$> m = three.compare(VectorOperators.LE, higher);
 +        assert(m.allTrue());
-         m = higher.min((Halffloat.valueOf(-1))).test(VectorOperators.IS_NEGATIVE);
++        m = higher.min((Float16.float16ToRawShortBits(Float16.valueOf(-1)))).test(VectorOperators.IS_NEGATIVE);
 +        assert(m.allTrue());
 +        m = higher.test(VectorOperators.IS_FINITE);
 +        assert(m.allTrue());
 +        $type$ max = higher.reduceLanes(VectorOperators.MAX);
 +        assert((short) Float.float16ToFloat(max) == -3 + scale * (SPECIES.length()-1));
 +#else[Halffloat]
          $abstractvectortype$ three = $abstractvectortype$.broadcast(SPECIES, (byte)-3);
          $abstractvectortype$ three2 = ($abstractvectortype$) SPECIES.broadcast(-3);
          assert(three.eq(three2).allTrue());
diff --cc test/jdk/jdk/incubator/vector/templates/X-LoadStoreTest.java.template
index f5123219b8a,a68103e1060..1e92799e628
--- a/test/jdk/jdk/incubator/vector/templates/X-LoadStoreTest.java.template
+++ b/test/jdk/jdk/incubator/vector/templates/X-LoadStoreTest.java.template
@@@ -41,12 -39,8 +39,12 @@@
  #warn This file is preprocessed before being compiled
  
  import java.lang.foreign.MemorySegment;
- import java.lang.foreign.SegmentScope;
+ import java.lang.foreign.Arena;
  import java.lang.foreign.ValueLayout;
- #if[Halffloat]
- import jdk.incubator.vector.Halffloat;
++#if[FP16]
++import jdk.incubator.vector.Float16;
 +import jdk.incubator.vector.HalffloatVector;
- #end[Halffloat]
++#end[FP16]
  import jdk.incubator.vector.$Type$Vector;
  import jdk.incubator.vector.VectorMask;
  #if[MaxBit]
@@@ -75,11 -69,7 +73,11 @@@ public class $vectorteststype$ extends 
  
      static final int INVOC_COUNT = Integer.getInteger("jdk.incubator.vector.test.loop-iterations", 100);
  
 +#if[Halffloat]
-     static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withBitAlignment(8);
++    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withByteAlignment(1);
 +#else[Halffloat]
-     static final ValueLayout.Of$Type$ ELEMENT_LAYOUT = ValueLayout.JAVA_$TYPE$.withBitAlignment(8);
+     static final ValueLayout.Of$Type$ ELEMENT_LAYOUT = ValueLayout.JAVA_$TYPE$.withByteAlignment(1);
 +#end[Halffloat]
  
  #if[MaxBit]
      static VectorShape getMaxBit() {
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Byte128Vector.java
index da8b476a77d,626c1c97648..08381a62a7d
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Byte128Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Byte128Vector.java
@@@ -954,6 -952,6 +954,70 @@@ public class Byte128Vector extends Abst
          bh.consume(r);
      }
  
++    @Benchmark
++    public void MIN(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MINMasked(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAX(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAXMasked(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void MIN(Blackhole bh) {
          byte[] a = fa.apply(SPECIES.length());
@@@ -988,6 -986,222 +1052,267 @@@
          bh.consume(r);
      }
  
+     @Benchmark
+     public void UMIN(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMINMasked(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAX(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAXMasked(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADD(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADDMasked(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUB(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUBMasked(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADD(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADDMasked(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUB(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUBMasked(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] b = fb.apply(SPECIES.length());
++        byte[] c = fc.apply(SPECIES.length());
++        byte[] rl = fr.apply(SPECIES.length());
++        byte[] rr = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
++                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] b = fb.apply(SPECIES.length());
++        byte[] c = fc.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        byte[] rl = fr.apply(SPECIES.length());
++        byte[] rr = fr.apply(SPECIES.length());
++
++        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
++                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void ANDLanes(Blackhole bh) {
          byte[] a = fa.apply(SPECIES.length());
@@@ -1212,6 -1426,6 +1537,70 @@@
          bh.consume(ra);
      }
  
++    @Benchmark
++    public void UMINLanes(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte ra = Byte.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Byte.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMINMaskedLanes(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        byte ra = Byte.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Byte.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXLanes(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte ra = Byte.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Byte.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXMaskedLanes(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        byte ra = Byte.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Byte.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
      @Benchmark
      public void FIRST_NONZEROLanes(Blackhole bh) {
          byte[] a = fa.apply(SPECIES.length());
@@@ -1274,6 -1488,6 +1663,56 @@@
          bh.consume(r);
      }
  
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] r = fr.apply(SPECIES.length());
++        byte ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ra = (byte) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        byte ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ra = (byte) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void withLane(Blackhole bh) {
          byte[] a = fa.apply(SPECIES.length());
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Byte256Vector.java
index dc130d9ea19,c84eceedec4..821c5ba44e2
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Byte256Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Byte256Vector.java
@@@ -954,6 -952,6 +954,70 @@@ public class Byte256Vector extends Abst
          bh.consume(r);
      }
  
++    @Benchmark
++    public void MIN(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MINMasked(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAX(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAXMasked(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void MIN(Blackhole bh) {
          byte[] a = fa.apply(SPECIES.length());
@@@ -988,6 -986,222 +1052,267 @@@
          bh.consume(r);
      }
  
+     @Benchmark
+     public void UMIN(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMINMasked(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAX(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAXMasked(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADD(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADDMasked(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUB(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUBMasked(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADD(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADDMasked(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUB(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUBMasked(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] b = fb.apply(SPECIES.length());
++        byte[] c = fc.apply(SPECIES.length());
++        byte[] rl = fr.apply(SPECIES.length());
++        byte[] rr = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
++                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] b = fb.apply(SPECIES.length());
++        byte[] c = fc.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        byte[] rl = fr.apply(SPECIES.length());
++        byte[] rr = fr.apply(SPECIES.length());
++
++        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
++                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void ANDLanes(Blackhole bh) {
          byte[] a = fa.apply(SPECIES.length());
@@@ -1212,6 -1426,6 +1537,70 @@@
          bh.consume(ra);
      }
  
++    @Benchmark
++    public void UMINLanes(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte ra = Byte.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Byte.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMINMaskedLanes(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        byte ra = Byte.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Byte.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXLanes(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte ra = Byte.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Byte.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXMaskedLanes(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        byte ra = Byte.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Byte.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
      @Benchmark
      public void FIRST_NONZEROLanes(Blackhole bh) {
          byte[] a = fa.apply(SPECIES.length());
@@@ -1274,6 -1488,6 +1663,56 @@@
          bh.consume(r);
      }
  
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] r = fr.apply(SPECIES.length());
++        byte ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ra = (byte) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        byte ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ra = (byte) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void withLane(Blackhole bh) {
          byte[] a = fa.apply(SPECIES.length());
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Byte512Vector.java
index 3fb674dc891,4c624fae4cb..f3b376b47a9
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Byte512Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Byte512Vector.java
@@@ -954,6 -952,6 +954,70 @@@ public class Byte512Vector extends Abst
          bh.consume(r);
      }
  
++    @Benchmark
++    public void MIN(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MINMasked(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAX(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAXMasked(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void MIN(Blackhole bh) {
          byte[] a = fa.apply(SPECIES.length());
@@@ -988,6 -986,222 +1052,267 @@@
          bh.consume(r);
      }
  
+     @Benchmark
+     public void UMIN(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMINMasked(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAX(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAXMasked(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADD(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADDMasked(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUB(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUBMasked(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADD(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADDMasked(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUB(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUBMasked(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] b = fb.apply(SPECIES.length());
++        byte[] c = fc.apply(SPECIES.length());
++        byte[] rl = fr.apply(SPECIES.length());
++        byte[] rr = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
++                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] b = fb.apply(SPECIES.length());
++        byte[] c = fc.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        byte[] rl = fr.apply(SPECIES.length());
++        byte[] rr = fr.apply(SPECIES.length());
++
++        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
++                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void ANDLanes(Blackhole bh) {
          byte[] a = fa.apply(SPECIES.length());
@@@ -1212,6 -1426,6 +1537,70 @@@
          bh.consume(ra);
      }
  
++    @Benchmark
++    public void UMINLanes(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte ra = Byte.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Byte.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMINMaskedLanes(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        byte ra = Byte.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Byte.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXLanes(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte ra = Byte.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Byte.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXMaskedLanes(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        byte ra = Byte.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Byte.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
      @Benchmark
      public void FIRST_NONZEROLanes(Blackhole bh) {
          byte[] a = fa.apply(SPECIES.length());
@@@ -1274,6 -1488,6 +1663,56 @@@
          bh.consume(r);
      }
  
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] r = fr.apply(SPECIES.length());
++        byte ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ra = (byte) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        byte ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ra = (byte) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void withLane(Blackhole bh) {
          byte[] a = fa.apply(SPECIES.length());
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Byte64Vector.java
index 213aa40ac04,2be789c7a42..60d50f1e478
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Byte64Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Byte64Vector.java
@@@ -954,6 -952,6 +954,70 @@@ public class Byte64Vector extends Abstr
          bh.consume(r);
      }
  
++    @Benchmark
++    public void MIN(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MINMasked(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAX(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAXMasked(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void MIN(Blackhole bh) {
          byte[] a = fa.apply(SPECIES.length());
@@@ -988,6 -986,222 +1052,267 @@@
          bh.consume(r);
      }
  
+     @Benchmark
+     public void UMIN(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMINMasked(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAX(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAXMasked(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADD(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADDMasked(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUB(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUBMasked(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADD(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADDMasked(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUB(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUBMasked(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] b = fb.apply(SPECIES.length());
++        byte[] c = fc.apply(SPECIES.length());
++        byte[] rl = fr.apply(SPECIES.length());
++        byte[] rr = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
++                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] b = fb.apply(SPECIES.length());
++        byte[] c = fc.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        byte[] rl = fr.apply(SPECIES.length());
++        byte[] rr = fr.apply(SPECIES.length());
++
++        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
++                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void ANDLanes(Blackhole bh) {
          byte[] a = fa.apply(SPECIES.length());
@@@ -1212,6 -1426,6 +1537,70 @@@
          bh.consume(ra);
      }
  
++    @Benchmark
++    public void UMINLanes(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte ra = Byte.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Byte.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMINMaskedLanes(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        byte ra = Byte.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Byte.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXLanes(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte ra = Byte.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Byte.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXMaskedLanes(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        byte ra = Byte.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Byte.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
      @Benchmark
      public void FIRST_NONZEROLanes(Blackhole bh) {
          byte[] a = fa.apply(SPECIES.length());
@@@ -1274,6 -1488,6 +1663,56 @@@
          bh.consume(r);
      }
  
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] r = fr.apply(SPECIES.length());
++        byte ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ra = (byte) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        byte ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ra = (byte) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void withLane(Blackhole bh) {
          byte[] a = fa.apply(SPECIES.length());
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/ByteMaxVector.java
index 55563604127,bf6fc82151c..1aa145f84d9
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/ByteMaxVector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/ByteMaxVector.java
@@@ -954,6 -952,6 +954,70 @@@ public class ByteMaxVector extends Abst
          bh.consume(r);
      }
  
++    @Benchmark
++    public void MIN(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MINMasked(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAX(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAXMasked(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void MIN(Blackhole bh) {
          byte[] a = fa.apply(SPECIES.length());
@@@ -988,6 -986,222 +1052,267 @@@
          bh.consume(r);
      }
  
+     @Benchmark
+     public void UMIN(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMINMasked(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAX(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAXMasked(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADD(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADDMasked(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUB(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUBMasked(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADD(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADDMasked(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUB(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUBMasked(Blackhole bh) {
+         byte[] a = fa.apply(SPECIES.length());
+         byte[] b = fb.apply(SPECIES.length());
+         byte[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                 ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] b = fb.apply(SPECIES.length());
++        byte[] c = fc.apply(SPECIES.length());
++        byte[] rl = fr.apply(SPECIES.length());
++        byte[] rr = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
++                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] b = fb.apply(SPECIES.length());
++        byte[] c = fc.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        byte[] rl = fr.apply(SPECIES.length());
++        byte[] rr = fr.apply(SPECIES.length());
++
++        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);
++                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void ANDLanes(Blackhole bh) {
          byte[] a = fa.apply(SPECIES.length());
@@@ -1212,6 -1426,6 +1537,70 @@@
          bh.consume(ra);
      }
  
++    @Benchmark
++    public void UMINLanes(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte ra = Byte.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Byte.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMINMaskedLanes(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        byte ra = Byte.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Byte.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXLanes(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte ra = Byte.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Byte.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXMaskedLanes(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        byte ra = Byte.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Byte.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
      @Benchmark
      public void FIRST_NONZEROLanes(Blackhole bh) {
          byte[] a = fa.apply(SPECIES.length());
@@@ -1274,6 -1488,6 +1663,56 @@@
          bh.consume(r);
      }
  
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] r = fr.apply(SPECIES.length());
++        byte ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ra = (byte) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        byte[] a = fa.apply(SPECIES.length());
++        byte[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        byte ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
++                ra = (byte) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void withLane(Blackhole bh) {
          byte[] a = fa.apply(SPECIES.length());
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Double128Vector.java
index 9f0e7e8add8,98aa9398fa6..b849142e29c
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Double128Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Double128Vector.java
@@@ -280,6 -278,6 +280,70 @@@ public class Double128Vector extends Ab
          bh.consume(r);
      }
  
++    @Benchmark
++    public void MIN(Blackhole bh) {
++        double[] a = fa.apply(SPECIES.length());
++        double[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MINMasked(Blackhole bh) {
++        double[] a = fa.apply(SPECIES.length());
++        double[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAX(Blackhole bh) {
++        double[] a = fa.apply(SPECIES.length());
++        double[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAXMasked(Blackhole bh) {
++        double[] a = fa.apply(SPECIES.length());
++        double[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void MIN(Blackhole bh) {
          double[] a = fa.apply(SPECIES.length());
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Double256Vector.java
index f590bb63cd8,743ee7be764..82de330fec3
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Double256Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Double256Vector.java
@@@ -280,6 -278,6 +280,70 @@@ public class Double256Vector extends Ab
          bh.consume(r);
      }
  
++    @Benchmark
++    public void MIN(Blackhole bh) {
++        double[] a = fa.apply(SPECIES.length());
++        double[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MINMasked(Blackhole bh) {
++        double[] a = fa.apply(SPECIES.length());
++        double[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAX(Blackhole bh) {
++        double[] a = fa.apply(SPECIES.length());
++        double[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAXMasked(Blackhole bh) {
++        double[] a = fa.apply(SPECIES.length());
++        double[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void MIN(Blackhole bh) {
          double[] a = fa.apply(SPECIES.length());
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Double512Vector.java
index 90c072c91c3,f2c70eed7c2..ddfee9bd7a6
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Double512Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Double512Vector.java
@@@ -280,6 -278,6 +280,70 @@@ public class Double512Vector extends Ab
          bh.consume(r);
      }
  
++    @Benchmark
++    public void MIN(Blackhole bh) {
++        double[] a = fa.apply(SPECIES.length());
++        double[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MINMasked(Blackhole bh) {
++        double[] a = fa.apply(SPECIES.length());
++        double[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAX(Blackhole bh) {
++        double[] a = fa.apply(SPECIES.length());
++        double[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAXMasked(Blackhole bh) {
++        double[] a = fa.apply(SPECIES.length());
++        double[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void MIN(Blackhole bh) {
          double[] a = fa.apply(SPECIES.length());
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Double64Vector.java
index e7f1ebaf494,a5243aa762a..93ea6601507
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Double64Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Double64Vector.java
@@@ -280,6 -278,6 +280,70 @@@ public class Double64Vector extends Abs
          bh.consume(r);
      }
  
++    @Benchmark
++    public void MIN(Blackhole bh) {
++        double[] a = fa.apply(SPECIES.length());
++        double[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MINMasked(Blackhole bh) {
++        double[] a = fa.apply(SPECIES.length());
++        double[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAX(Blackhole bh) {
++        double[] a = fa.apply(SPECIES.length());
++        double[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAXMasked(Blackhole bh) {
++        double[] a = fa.apply(SPECIES.length());
++        double[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void MIN(Blackhole bh) {
          double[] a = fa.apply(SPECIES.length());
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/DoubleMaxVector.java
index 666868a80de,37012ec098d..e00da409346
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/DoubleMaxVector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/DoubleMaxVector.java
@@@ -280,6 -278,6 +280,70 @@@ public class DoubleMaxVector extends Ab
          bh.consume(r);
      }
  
++    @Benchmark
++    public void MIN(Blackhole bh) {
++        double[] a = fa.apply(SPECIES.length());
++        double[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MINMasked(Blackhole bh) {
++        double[] a = fa.apply(SPECIES.length());
++        double[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAX(Blackhole bh) {
++        double[] a = fa.apply(SPECIES.length());
++        double[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAXMasked(Blackhole bh) {
++        double[] a = fa.apply(SPECIES.length());
++        double[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void MIN(Blackhole bh) {
          double[] a = fa.apply(SPECIES.length());
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Float128Vector.java
index 29bbb44c0d2,179a7b83ce5..fd5e25135cd
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Float128Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Float128Vector.java
@@@ -280,6 -278,6 +280,70 @@@ public class Float128Vector extends Abs
          bh.consume(r);
      }
  
++    @Benchmark
++    public void MIN(Blackhole bh) {
++        float[] a = fa.apply(SPECIES.length());
++        float[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                FloatVector av = FloatVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MINMasked(Blackhole bh) {
++        float[] a = fa.apply(SPECIES.length());
++        float[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                FloatVector av = FloatVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAX(Blackhole bh) {
++        float[] a = fa.apply(SPECIES.length());
++        float[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                FloatVector av = FloatVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAXMasked(Blackhole bh) {
++        float[] a = fa.apply(SPECIES.length());
++        float[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                FloatVector av = FloatVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void MIN(Blackhole bh) {
          float[] a = fa.apply(SPECIES.length());
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Float256Vector.java
index 2bb333864fc,177956f5422..946aa33f233
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Float256Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Float256Vector.java
@@@ -280,6 -278,6 +280,70 @@@ public class Float256Vector extends Abs
          bh.consume(r);
      }
  
++    @Benchmark
++    public void MIN(Blackhole bh) {
++        float[] a = fa.apply(SPECIES.length());
++        float[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                FloatVector av = FloatVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MINMasked(Blackhole bh) {
++        float[] a = fa.apply(SPECIES.length());
++        float[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                FloatVector av = FloatVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAX(Blackhole bh) {
++        float[] a = fa.apply(SPECIES.length());
++        float[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                FloatVector av = FloatVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAXMasked(Blackhole bh) {
++        float[] a = fa.apply(SPECIES.length());
++        float[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                FloatVector av = FloatVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void MIN(Blackhole bh) {
          float[] a = fa.apply(SPECIES.length());
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Float512Vector.java
index 01435b26432,7135da1f877..f85c428ab5a
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Float512Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Float512Vector.java
@@@ -280,6 -278,6 +280,70 @@@ public class Float512Vector extends Abs
          bh.consume(r);
      }
  
++    @Benchmark
++    public void MIN(Blackhole bh) {
++        float[] a = fa.apply(SPECIES.length());
++        float[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                FloatVector av = FloatVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MINMasked(Blackhole bh) {
++        float[] a = fa.apply(SPECIES.length());
++        float[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                FloatVector av = FloatVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAX(Blackhole bh) {
++        float[] a = fa.apply(SPECIES.length());
++        float[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                FloatVector av = FloatVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAXMasked(Blackhole bh) {
++        float[] a = fa.apply(SPECIES.length());
++        float[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                FloatVector av = FloatVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void MIN(Blackhole bh) {
          float[] a = fa.apply(SPECIES.length());
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Float64Vector.java
index 64981f5eedc,ce74c74b43d..bed4f61f774
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Float64Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Float64Vector.java
@@@ -280,6 -278,6 +280,70 @@@ public class Float64Vector extends Abst
          bh.consume(r);
      }
  
++    @Benchmark
++    public void MIN(Blackhole bh) {
++        float[] a = fa.apply(SPECIES.length());
++        float[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                FloatVector av = FloatVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MINMasked(Blackhole bh) {
++        float[] a = fa.apply(SPECIES.length());
++        float[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                FloatVector av = FloatVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAX(Blackhole bh) {
++        float[] a = fa.apply(SPECIES.length());
++        float[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                FloatVector av = FloatVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAXMasked(Blackhole bh) {
++        float[] a = fa.apply(SPECIES.length());
++        float[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                FloatVector av = FloatVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void MIN(Blackhole bh) {
          float[] a = fa.apply(SPECIES.length());
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/FloatMaxVector.java
index 20c8b96178b,251cd9e7828..0d2a7e70bd4
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/FloatMaxVector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/FloatMaxVector.java
@@@ -280,6 -278,6 +280,70 @@@ public class FloatMaxVector extends Abs
          bh.consume(r);
      }
  
++    @Benchmark
++    public void MIN(Blackhole bh) {
++        float[] a = fa.apply(SPECIES.length());
++        float[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                FloatVector av = FloatVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MINMasked(Blackhole bh) {
++        float[] a = fa.apply(SPECIES.length());
++        float[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                FloatVector av = FloatVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAX(Blackhole bh) {
++        float[] a = fa.apply(SPECIES.length());
++        float[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                FloatVector av = FloatVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAXMasked(Blackhole bh) {
++        float[] a = fa.apply(SPECIES.length());
++        float[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                FloatVector av = FloatVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void MIN(Blackhole bh) {
          float[] a = fa.apply(SPECIES.length());
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Halffloat128Vector.java
index 7e4b5dd56cb,00000000000..b38522829aa
mode 100644,000000..100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Halffloat128Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Halffloat128Vector.java
@@@ -1,750 -1,0 +1,750 @@@
 +/*
-  * Copyright (c) 2018, 2021, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
 + * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 + *
 + * This code is free software; you can redistribute it and/or modify it
 + * under the terms of the GNU General Public License version 2 only, as
 + * published by the Free Software Foundation.
 + *
 + * This code is distributed in the hope that it will be useful, but WITHOUT
 + * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 + * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 + * version 2 for more details (a copy is included in the LICENSE file that
 + * accompanied this code).
 + *
 + * You should have received a copy of the GNU General Public License version
 + * 2 along with this work; if not, write to the Free Software Foundation,
 + * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 + *
 + * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 + * or visit www.oracle.com if you need additional information or have any
 + * questions.
 + */
 +
 +package org.openjdk.bench.jdk.incubator.vector.operation;
 +
 +// -- This file was mechanically generated: Do not edit! -- //
 +
 +import jdk.incubator.vector.Vector;
 +import jdk.incubator.vector.VectorMask;
 +import jdk.incubator.vector.VectorOperators;
 +import jdk.incubator.vector.VectorShape;
 +import jdk.incubator.vector.VectorSpecies;
 +import jdk.incubator.vector.VectorShuffle;
 +import jdk.incubator.vector.HalffloatVector;
 +
 +import jdk.incubator.vector.Halffloat;
 +import java.util.concurrent.TimeUnit;
 +import java.util.function.BiFunction;
 +import java.util.function.IntFunction;
 +
 +import org.openjdk.jmh.annotations.*;
 +import org.openjdk.jmh.infra.Blackhole;
 +
 +@BenchmarkMode(Mode.Throughput)
 +@OutputTimeUnit(TimeUnit.MILLISECONDS)
 +@State(Scope.Benchmark)
 +@Warmup(iterations = 3, time = 1)
 +@Measurement(iterations = 5, time = 1)
 +@Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
 +public class Halffloat128Vector extends AbstractVectorBenchmark {
-     static final VectorSpecies<Halffloat> SPECIES = HalffloatVector.SPECIES_128;
++    static final VectorSpecies<Float16> SPECIES = HalffloatVector.SPECIES_128;
 +
 +    static final int INVOC_COUNT = 1; // get rid of outer loop
 +
 +
 +    static short firstNonZero(short a, short b) {
-         return Halffloat.compare(a, (short) 0) != 0 ? a : b;
++        return Float16.compare(a, (short) 0) != 0 ? a : b;
 +    }
 +
 +
 +    @Param("1024")
 +    int size;
 +
 +    short[] fill(IntFunction<Short> f) {
 +        short[] array = new short[size];
 +        for (int i = 0; i < array.length; i++) {
 +            array[i] = f.apply(i);
 +        }
 +        return array;
 +    }
 +
 +    short[] a, b, c, r;
 +    boolean[] m, mt, rm;
 +    int[] s;
 +
 +    static short genValue(int i) {
 +        return Halffloat.valueOf(i);
 +    }
 +
 +    @Setup
 +    public void init() {
 +        size += size % SPECIES.length(); // FIXME: add post-loops
 +        a = fill(i -> genValue(2*i));
 +        b = fill(i -> genValue(i+1));
 +        c = fill(i -> genValue(i+5));
 +        r = fill(i -> genValue(0));
 +        m = fillMask(size, i -> (i % 2) == 0);
 +        mt = fillMask(size, i -> true);
 +        rm = fillMask(size, i -> false);
 +
-         s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));
++        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));
 +    }
 +
 +    final IntFunction<short[]> fa = vl -> a;
 +    final IntFunction<short[]> fb = vl -> b;
 +    final IntFunction<short[]> fc = vl -> c;
 +    final IntFunction<short[]> fr = vl -> r;
 +    final IntFunction<boolean[]> fm = vl -> m;
 +    final IntFunction<boolean[]> fmt = vl -> mt;
 +    final IntFunction<boolean[]> fmr = vl -> rm;
 +    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;
 +
 +
 +    @Benchmark
 +    public void ADD(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void ADDMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void SUB(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void SUBMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void MUL(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void MULMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void DIV(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void DIVMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void MAX(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void MAXMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void MIN(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void MINMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void ABS(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ABS).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void ABSMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void NEG(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.NEG).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void NEGMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void FMA(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] c = fc.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);
 +                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void FMAMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] c = fc.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);
 +                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void SQRT(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SQRT).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void SQRTMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void SIN(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SIN).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void EXP(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.EXP).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void LOG1P(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void LOG(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.LOG).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void LOG10(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.LOG10).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void EXPM1(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void COS(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.COS).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void TAN(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.TAN).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void SINH(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SINH).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void COSH(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.COSH).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void TANH(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.TANH).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void ASIN(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ASIN).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void ACOS(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ACOS).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void ATAN(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ATAN).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void CBRT(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.CBRT).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void HYPOT(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void POW(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void ATAN2(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void blend(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.blend(bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +}
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Halffloat256Vector.java
index 5fa9cd8a0ec,00000000000..49a73e6d08e
mode 100644,000000..100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Halffloat256Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Halffloat256Vector.java
@@@ -1,750 -1,0 +1,750 @@@
 +/*
-  * Copyright (c) 2018, 2021, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
 + * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 + *
 + * This code is free software; you can redistribute it and/or modify it
 + * under the terms of the GNU General Public License version 2 only, as
 + * published by the Free Software Foundation.
 + *
 + * This code is distributed in the hope that it will be useful, but WITHOUT
 + * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 + * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 + * version 2 for more details (a copy is included in the LICENSE file that
 + * accompanied this code).
 + *
 + * You should have received a copy of the GNU General Public License version
 + * 2 along with this work; if not, write to the Free Software Foundation,
 + * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 + *
 + * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 + * or visit www.oracle.com if you need additional information or have any
 + * questions.
 + */
 +
 +package org.openjdk.bench.jdk.incubator.vector.operation;
 +
 +// -- This file was mechanically generated: Do not edit! -- //
 +
 +import jdk.incubator.vector.Vector;
 +import jdk.incubator.vector.VectorMask;
 +import jdk.incubator.vector.VectorOperators;
 +import jdk.incubator.vector.VectorShape;
 +import jdk.incubator.vector.VectorSpecies;
 +import jdk.incubator.vector.VectorShuffle;
 +import jdk.incubator.vector.HalffloatVector;
 +
 +import jdk.incubator.vector.Halffloat;
 +import java.util.concurrent.TimeUnit;
 +import java.util.function.BiFunction;
 +import java.util.function.IntFunction;
 +
 +import org.openjdk.jmh.annotations.*;
 +import org.openjdk.jmh.infra.Blackhole;
 +
 +@BenchmarkMode(Mode.Throughput)
 +@OutputTimeUnit(TimeUnit.MILLISECONDS)
 +@State(Scope.Benchmark)
 +@Warmup(iterations = 3, time = 1)
 +@Measurement(iterations = 5, time = 1)
 +@Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
 +public class Halffloat256Vector extends AbstractVectorBenchmark {
-     static final VectorSpecies<Halffloat> SPECIES = HalffloatVector.SPECIES_256;
++    static final VectorSpecies<Float16> SPECIES = HalffloatVector.SPECIES_256;
 +
 +    static final int INVOC_COUNT = 1; // get rid of outer loop
 +
 +
 +    static short firstNonZero(short a, short b) {
-         return Halffloat.compare(a, (short) 0) != 0 ? a : b;
++        return Float16.compare(a, (short) 0) != 0 ? a : b;
 +    }
 +
 +
 +    @Param("1024")
 +    int size;
 +
 +    short[] fill(IntFunction<Short> f) {
 +        short[] array = new short[size];
 +        for (int i = 0; i < array.length; i++) {
 +            array[i] = f.apply(i);
 +        }
 +        return array;
 +    }
 +
 +    short[] a, b, c, r;
 +    boolean[] m, mt, rm;
 +    int[] s;
 +
 +    static short genValue(int i) {
 +        return Halffloat.valueOf(i);
 +    }
 +
 +    @Setup
 +    public void init() {
 +        size += size % SPECIES.length(); // FIXME: add post-loops
 +        a = fill(i -> genValue(2*i));
 +        b = fill(i -> genValue(i+1));
 +        c = fill(i -> genValue(i+5));
 +        r = fill(i -> genValue(0));
 +        m = fillMask(size, i -> (i % 2) == 0);
 +        mt = fillMask(size, i -> true);
 +        rm = fillMask(size, i -> false);
 +
-         s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));
++        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));
 +    }
 +
 +    final IntFunction<short[]> fa = vl -> a;
 +    final IntFunction<short[]> fb = vl -> b;
 +    final IntFunction<short[]> fc = vl -> c;
 +    final IntFunction<short[]> fr = vl -> r;
 +    final IntFunction<boolean[]> fm = vl -> m;
 +    final IntFunction<boolean[]> fmt = vl -> mt;
 +    final IntFunction<boolean[]> fmr = vl -> rm;
 +    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;
 +
 +
 +    @Benchmark
 +    public void ADD(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void ADDMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void SUB(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void SUBMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void MUL(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void MULMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void DIV(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void DIVMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void MAX(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void MAXMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void MIN(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void MINMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void ABS(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ABS).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void ABSMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void NEG(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.NEG).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void NEGMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void FMA(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] c = fc.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);
 +                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void FMAMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] c = fc.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);
 +                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void SQRT(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SQRT).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void SQRTMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void SIN(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SIN).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void EXP(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.EXP).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void LOG1P(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void LOG(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.LOG).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void LOG10(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.LOG10).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void EXPM1(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void COS(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.COS).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void TAN(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.TAN).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void SINH(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SINH).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void COSH(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.COSH).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void TANH(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.TANH).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void ASIN(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ASIN).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void ACOS(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ACOS).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void ATAN(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ATAN).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void CBRT(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.CBRT).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void HYPOT(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void POW(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void ATAN2(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void blend(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.blend(bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +}
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Halffloat512Vector.java
index 2f3bd647440,00000000000..08934af4e51
mode 100644,000000..100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Halffloat512Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Halffloat512Vector.java
@@@ -1,750 -1,0 +1,750 @@@
 +/*
-  * Copyright (c) 2018, 2021, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
 + * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 + *
 + * This code is free software; you can redistribute it and/or modify it
 + * under the terms of the GNU General Public License version 2 only, as
 + * published by the Free Software Foundation.
 + *
 + * This code is distributed in the hope that it will be useful, but WITHOUT
 + * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 + * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 + * version 2 for more details (a copy is included in the LICENSE file that
 + * accompanied this code).
 + *
 + * You should have received a copy of the GNU General Public License version
 + * 2 along with this work; if not, write to the Free Software Foundation,
 + * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 + *
 + * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 + * or visit www.oracle.com if you need additional information or have any
 + * questions.
 + */
 +
 +package org.openjdk.bench.jdk.incubator.vector.operation;
 +
 +// -- This file was mechanically generated: Do not edit! -- //
 +
 +import jdk.incubator.vector.Vector;
 +import jdk.incubator.vector.VectorMask;
 +import jdk.incubator.vector.VectorOperators;
 +import jdk.incubator.vector.VectorShape;
 +import jdk.incubator.vector.VectorSpecies;
 +import jdk.incubator.vector.VectorShuffle;
 +import jdk.incubator.vector.HalffloatVector;
 +
 +import jdk.incubator.vector.Halffloat;
 +import java.util.concurrent.TimeUnit;
 +import java.util.function.BiFunction;
 +import java.util.function.IntFunction;
 +
 +import org.openjdk.jmh.annotations.*;
 +import org.openjdk.jmh.infra.Blackhole;
 +
 +@BenchmarkMode(Mode.Throughput)
 +@OutputTimeUnit(TimeUnit.MILLISECONDS)
 +@State(Scope.Benchmark)
 +@Warmup(iterations = 3, time = 1)
 +@Measurement(iterations = 5, time = 1)
 +@Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
 +public class Halffloat512Vector extends AbstractVectorBenchmark {
-     static final VectorSpecies<Halffloat> SPECIES = HalffloatVector.SPECIES_512;
++    static final VectorSpecies<Float16> SPECIES = HalffloatVector.SPECIES_512;
 +
 +    static final int INVOC_COUNT = 1; // get rid of outer loop
 +
 +
 +    static short firstNonZero(short a, short b) {
-         return Halffloat.compare(a, (short) 0) != 0 ? a : b;
++        return Float16.compare(a, (short) 0) != 0 ? a : b;
 +    }
 +
 +
 +    @Param("1024")
 +    int size;
 +
 +    short[] fill(IntFunction<Short> f) {
 +        short[] array = new short[size];
 +        for (int i = 0; i < array.length; i++) {
 +            array[i] = f.apply(i);
 +        }
 +        return array;
 +    }
 +
 +    short[] a, b, c, r;
 +    boolean[] m, mt, rm;
 +    int[] s;
 +
 +    static short genValue(int i) {
 +        return Halffloat.valueOf(i);
 +    }
 +
 +    @Setup
 +    public void init() {
 +        size += size % SPECIES.length(); // FIXME: add post-loops
 +        a = fill(i -> genValue(2*i));
 +        b = fill(i -> genValue(i+1));
 +        c = fill(i -> genValue(i+5));
 +        r = fill(i -> genValue(0));
 +        m = fillMask(size, i -> (i % 2) == 0);
 +        mt = fillMask(size, i -> true);
 +        rm = fillMask(size, i -> false);
 +
-         s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));
++        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));
 +    }
 +
 +    final IntFunction<short[]> fa = vl -> a;
 +    final IntFunction<short[]> fb = vl -> b;
 +    final IntFunction<short[]> fc = vl -> c;
 +    final IntFunction<short[]> fr = vl -> r;
 +    final IntFunction<boolean[]> fm = vl -> m;
 +    final IntFunction<boolean[]> fmt = vl -> mt;
 +    final IntFunction<boolean[]> fmr = vl -> rm;
 +    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;
 +
 +
 +    @Benchmark
 +    public void ADD(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void ADDMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void SUB(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void SUBMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void MUL(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void MULMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void DIV(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void DIVMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void MAX(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void MAXMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void MIN(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void MINMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void ABS(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ABS).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void ABSMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void NEG(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.NEG).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void NEGMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void FMA(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] c = fc.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);
 +                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void FMAMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] c = fc.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);
 +                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void SQRT(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SQRT).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void SQRTMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void SIN(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SIN).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void EXP(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.EXP).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void LOG1P(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void LOG(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.LOG).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void LOG10(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.LOG10).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void EXPM1(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void COS(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.COS).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void TAN(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.TAN).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void SINH(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SINH).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void COSH(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.COSH).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void TANH(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.TANH).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void ASIN(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ASIN).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void ACOS(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ACOS).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void ATAN(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ATAN).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void CBRT(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.CBRT).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void HYPOT(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void POW(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void ATAN2(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void blend(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.blend(bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +}
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Halffloat64Vector.java
index fdba36b3cc0,00000000000..11b5c67a260
mode 100644,000000..100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Halffloat64Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Halffloat64Vector.java
@@@ -1,750 -1,0 +1,750 @@@
 +/*
-  * Copyright (c) 2018, 2021, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
 + * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 + *
 + * This code is free software; you can redistribute it and/or modify it
 + * under the terms of the GNU General Public License version 2 only, as
 + * published by the Free Software Foundation.
 + *
 + * This code is distributed in the hope that it will be useful, but WITHOUT
 + * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 + * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 + * version 2 for more details (a copy is included in the LICENSE file that
 + * accompanied this code).
 + *
 + * You should have received a copy of the GNU General Public License version
 + * 2 along with this work; if not, write to the Free Software Foundation,
 + * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 + *
 + * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 + * or visit www.oracle.com if you need additional information or have any
 + * questions.
 + */
 +
 +package org.openjdk.bench.jdk.incubator.vector.operation;
 +
 +// -- This file was mechanically generated: Do not edit! -- //
 +
 +import jdk.incubator.vector.Vector;
 +import jdk.incubator.vector.VectorMask;
 +import jdk.incubator.vector.VectorOperators;
 +import jdk.incubator.vector.VectorShape;
 +import jdk.incubator.vector.VectorSpecies;
 +import jdk.incubator.vector.VectorShuffle;
 +import jdk.incubator.vector.HalffloatVector;
 +
 +import jdk.incubator.vector.Halffloat;
 +import java.util.concurrent.TimeUnit;
 +import java.util.function.BiFunction;
 +import java.util.function.IntFunction;
 +
 +import org.openjdk.jmh.annotations.*;
 +import org.openjdk.jmh.infra.Blackhole;
 +
 +@BenchmarkMode(Mode.Throughput)
 +@OutputTimeUnit(TimeUnit.MILLISECONDS)
 +@State(Scope.Benchmark)
 +@Warmup(iterations = 3, time = 1)
 +@Measurement(iterations = 5, time = 1)
 +@Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
 +public class Halffloat64Vector extends AbstractVectorBenchmark {
-     static final VectorSpecies<Halffloat> SPECIES = HalffloatVector.SPECIES_64;
++    static final VectorSpecies<Float16> SPECIES = HalffloatVector.SPECIES_64;
 +
 +    static final int INVOC_COUNT = 1; // get rid of outer loop
 +
 +
 +    static short firstNonZero(short a, short b) {
-         return Halffloat.compare(a, (short) 0) != 0 ? a : b;
++        return Float16.compare(a, (short) 0) != 0 ? a : b;
 +    }
 +
 +
 +    @Param("1024")
 +    int size;
 +
 +    short[] fill(IntFunction<Short> f) {
 +        short[] array = new short[size];
 +        for (int i = 0; i < array.length; i++) {
 +            array[i] = f.apply(i);
 +        }
 +        return array;
 +    }
 +
 +    short[] a, b, c, r;
 +    boolean[] m, mt, rm;
 +    int[] s;
 +
 +    static short genValue(int i) {
 +        return Halffloat.valueOf(i);
 +    }
 +
 +    @Setup
 +    public void init() {
 +        size += size % SPECIES.length(); // FIXME: add post-loops
 +        a = fill(i -> genValue(2*i));
 +        b = fill(i -> genValue(i+1));
 +        c = fill(i -> genValue(i+5));
 +        r = fill(i -> genValue(0));
 +        m = fillMask(size, i -> (i % 2) == 0);
 +        mt = fillMask(size, i -> true);
 +        rm = fillMask(size, i -> false);
 +
-         s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));
++        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));
 +    }
 +
 +    final IntFunction<short[]> fa = vl -> a;
 +    final IntFunction<short[]> fb = vl -> b;
 +    final IntFunction<short[]> fc = vl -> c;
 +    final IntFunction<short[]> fr = vl -> r;
 +    final IntFunction<boolean[]> fm = vl -> m;
 +    final IntFunction<boolean[]> fmt = vl -> mt;
 +    final IntFunction<boolean[]> fmr = vl -> rm;
 +    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;
 +
 +
 +    @Benchmark
 +    public void ADD(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void ADDMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void SUB(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void SUBMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void MUL(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void MULMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void DIV(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void DIVMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void MAX(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void MAXMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void MIN(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void MINMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void ABS(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ABS).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void ABSMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void NEG(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.NEG).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void NEGMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void FMA(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] c = fc.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);
 +                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void FMAMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] c = fc.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);
 +                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void SQRT(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SQRT).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void SQRTMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void SIN(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SIN).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void EXP(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.EXP).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void LOG1P(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void LOG(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.LOG).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void LOG10(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.LOG10).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void EXPM1(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void COS(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.COS).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void TAN(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.TAN).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void SINH(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SINH).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void COSH(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.COSH).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void TANH(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.TANH).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void ASIN(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ASIN).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void ACOS(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ACOS).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void ATAN(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ATAN).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void CBRT(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.CBRT).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void HYPOT(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void POW(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void ATAN2(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void blend(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.blend(bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +}
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/HalffloatMaxVector.java
index a2093e46d58,00000000000..099b4004f94
mode 100644,000000..100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/HalffloatMaxVector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/HalffloatMaxVector.java
@@@ -1,750 -1,0 +1,750 @@@
 +/*
-  * Copyright (c) 2018, 2021, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
 + * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 + *
 + * This code is free software; you can redistribute it and/or modify it
 + * under the terms of the GNU General Public License version 2 only, as
 + * published by the Free Software Foundation.
 + *
 + * This code is distributed in the hope that it will be useful, but WITHOUT
 + * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 + * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 + * version 2 for more details (a copy is included in the LICENSE file that
 + * accompanied this code).
 + *
 + * You should have received a copy of the GNU General Public License version
 + * 2 along with this work; if not, write to the Free Software Foundation,
 + * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 + *
 + * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 + * or visit www.oracle.com if you need additional information or have any
 + * questions.
 + */
 +
 +package org.openjdk.bench.jdk.incubator.vector.operation;
 +
 +// -- This file was mechanically generated: Do not edit! -- //
 +
 +import jdk.incubator.vector.Vector;
 +import jdk.incubator.vector.VectorMask;
 +import jdk.incubator.vector.VectorOperators;
 +import jdk.incubator.vector.VectorShape;
 +import jdk.incubator.vector.VectorSpecies;
 +import jdk.incubator.vector.VectorShuffle;
 +import jdk.incubator.vector.HalffloatVector;
 +
 +import jdk.incubator.vector.Halffloat;
 +import java.util.concurrent.TimeUnit;
 +import java.util.function.BiFunction;
 +import java.util.function.IntFunction;
 +
 +import org.openjdk.jmh.annotations.*;
 +import org.openjdk.jmh.infra.Blackhole;
 +
 +@BenchmarkMode(Mode.Throughput)
 +@OutputTimeUnit(TimeUnit.MILLISECONDS)
 +@State(Scope.Benchmark)
 +@Warmup(iterations = 3, time = 1)
 +@Measurement(iterations = 5, time = 1)
 +@Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
 +public class HalffloatMaxVector extends AbstractVectorBenchmark {
-     static final VectorSpecies<Halffloat> SPECIES = HalffloatVector.SPECIES_MAX;
++    static final VectorSpecies<Float16> SPECIES = HalffloatVector.SPECIES_MAX;
 +
 +    static final int INVOC_COUNT = 1; // get rid of outer loop
 +
 +
 +    static short firstNonZero(short a, short b) {
-         return Halffloat.compare(a, (short) 0) != 0 ? a : b;
++        return Float16.compare(a, (short) 0) != 0 ? a : b;
 +    }
 +
 +
 +    @Param("1024")
 +    int size;
 +
 +    short[] fill(IntFunction<Short> f) {
 +        short[] array = new short[size];
 +        for (int i = 0; i < array.length; i++) {
 +            array[i] = f.apply(i);
 +        }
 +        return array;
 +    }
 +
 +    short[] a, b, c, r;
 +    boolean[] m, mt, rm;
 +    int[] s;
 +
 +    static short genValue(int i) {
 +        return Halffloat.valueOf(i);
 +    }
 +
 +    @Setup
 +    public void init() {
 +        size += size % SPECIES.length(); // FIXME: add post-loops
 +        a = fill(i -> genValue(2*i));
 +        b = fill(i -> genValue(i+1));
 +        c = fill(i -> genValue(i+5));
 +        r = fill(i -> genValue(0));
 +        m = fillMask(size, i -> (i % 2) == 0);
 +        mt = fillMask(size, i -> true);
 +        rm = fillMask(size, i -> false);
 +
-         s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));
++        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));
 +    }
 +
 +    final IntFunction<short[]> fa = vl -> a;
 +    final IntFunction<short[]> fb = vl -> b;
 +    final IntFunction<short[]> fc = vl -> c;
 +    final IntFunction<short[]> fr = vl -> r;
 +    final IntFunction<boolean[]> fm = vl -> m;
 +    final IntFunction<boolean[]> fmt = vl -> mt;
 +    final IntFunction<boolean[]> fmr = vl -> rm;
 +    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;
 +
 +
 +    @Benchmark
 +    public void ADD(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void ADDMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void SUB(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void SUBMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void MUL(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void MULMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void DIV(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void DIVMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void MAX(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void MAXMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void MIN(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void MINMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void ABS(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ABS).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void ABSMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void NEG(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.NEG).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void NEGMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void FMA(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] c = fc.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);
 +                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void FMAMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] c = fc.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);
 +                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void SQRT(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SQRT).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void SQRTMasked(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void SIN(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SIN).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void EXP(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.EXP).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void LOG1P(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void LOG(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.LOG).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void LOG10(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.LOG10).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void EXPM1(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void COS(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.COS).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void TAN(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.TAN).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void SINH(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.SINH).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void COSH(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.COSH).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void TANH(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.TANH).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void ASIN(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ASIN).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void ACOS(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ACOS).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void ATAN(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.ATAN).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void CBRT(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                av.lanewise(VectorOperators.CBRT).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void HYPOT(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void POW(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void ATAN2(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +
 +    @Benchmark
 +    public void blend(Blackhole bh) {
 +        short[] a = fa.apply(SPECIES.length());
 +        short[] b = fb.apply(SPECIES.length());
 +        short[] r = fr.apply(SPECIES.length());
 +        boolean[] mask = fm.apply(SPECIES.length());
-         VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < a.length; i += SPECIES.length()) {
 +                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);
 +                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);
 +                av.blend(bv, vmask).intoArray(r, i);
 +            }
 +        }
 +
 +        bh.consume(r);
 +    }
 +}
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/HalffloatScalar.java
index 93c9d644959,00000000000..e347563419c
mode 100644,000000..100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/HalffloatScalar.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/HalffloatScalar.java
@@@ -1,497 -1,0 +1,498 @@@
 +/*
-  * Copyright (c) 2018, 2022, Oracle and/or its affiliates. All rights reserved.
++ * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
 + * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 + *
 + * This code is free software; you can redistribute it and/or modify it
 + * under the terms of the GNU General Public License version 2 only, as
 + * published by the Free Software Foundation.
 + *
 + * This code is distributed in the hope that it will be useful, but WITHOUT
 + * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 + * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 + * version 2 for more details (a copy is included in the LICENSE file that
 + * accompanied this code).
 + *
 + * You should have received a copy of the GNU General Public License version
 + * 2 along with this work; if not, write to the Free Software Foundation,
 + * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 + *
 + * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 + * or visit www.oracle.com if you need additional information or have any
 + * questions.
 + */
 +
 +package org.openjdk.bench.jdk.incubator.vector.operation;
 +
 +// -- This file was mechanically generated: Do not edit! -- //
 +
 +import java.util.concurrent.TimeUnit;
 +import java.util.function.IntFunction;
++import jdk.incubator.vector.VectorMath;
 +
 +import jdk.incubator.vector.Halffloat;
 +import org.openjdk.jmh.annotations.*;
 +import org.openjdk.jmh.infra.Blackhole;
 +
 +@BenchmarkMode(Mode.Throughput)
 +@OutputTimeUnit(TimeUnit.MILLISECONDS)
 +@State(Scope.Benchmark)
 +@Warmup(iterations = 3, time = 1)
 +@Measurement(iterations = 5, time = 1)
 +@Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
 +public class HalffloatScalar extends AbstractVectorBenchmark {
 +    static final int INVOC_COUNT = 1; // To align with vector benchmarks.
 +
 +
 +    @Param("1024")
 +    int size;
 +
 +    short[] fill(IntFunction<Short> f) {
 +        short[] array = new short[size];
 +        for (int i = 0; i < array.length; i++) {
 +            array[i] = f.apply(i);
 +        }
 +        return array;
 +    }
 +
 +    static short bits(short e) {
 +        return Halffloat.shortToShortBits(e);
 +    }
 +
 +    short[] as, bs, cs, rs;
 +    boolean[] ms, mt, rms;
 +    int[] ss;
 +
 +    static short genValue(int i) {
 +        return Halffloat.valueOf(i);
 +    }
 +
 +    @Setup
 +    public void init() {
 +        as = fill(i -> genValue(2*i));
 +        bs = fill(i -> genValue(i+1));
 +        cs = fill(i -> genValue(i+5));
 +        rs = fill(i -> genValue(0));
 +        ms = fillMask(size, i -> (i % 2) == 0);
 +        mt = fillMask(size, i -> true);
 +        rms = fillMask(size, i -> false);
 +
-         ss = fillInt(size, i -> RANDOM.nextInt(Math.max(i,1)));
++        ss = fillInt(size, i -> RAND.nextInt(Math.max(i,1)));
 +    }
 +
 +    final IntFunction<short[]> fa = vl -> as;
 +    final IntFunction<short[]> fb = vl -> bs;
 +    final IntFunction<short[]> fc = vl -> cs;
 +    final IntFunction<short[]> fr = vl -> rs;
 +    final IntFunction<boolean[]> fm = vl -> ms;
 +    final IntFunction<boolean[]> fmt = vl -> mt;
 +    final IntFunction<boolean[]> fmr = vl -> rms;
 +    final IntFunction<int[]> fs = vl -> ss;
 +
 +    static boolean eq(short a, short b) {
 +        return a == b;
 +    }
 +
 +    static boolean neq(short a, short b) {
 +        return a != b;
 +    }
 +
 +    static boolean lt(short a, short b) {
 +        return a < b;
 +    }
 +
 +    static boolean le(short a, short b) {
 +        return a <= b;
 +    }
 +
 +    static boolean gt(short a, short b) {
 +        return a > b;
 +    }
 +
 +    static boolean ge(short a, short b) {
 +        return a >= b;
 +    }
 +
 +
 +
 +    @Benchmark
 +    public void ADD(Blackhole bh) {
 +        short[] as = fa.apply(size);
 +        short[] bs = fb.apply(size);
 +        short[] rs = fr.apply(size);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < as.length; i++) {
 +                short a = as[i];
 +                short b = bs[i];
 +                rs[i] = (short)(Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b)));
 +            }
 +        }
 +
 +        bh.consume(rs);
 +    }
 +
 +    @Benchmark
 +    public void ADDMasked(Blackhole bh) {
 +        short[] as = fa.apply(size);
 +        short[] bs = fb.apply(size);
 +        short[] rs = fr.apply(size);
 +        boolean[] ms = fm.apply(size);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < as.length; i++) {
 +                short a = as[i];
 +                short b = bs[i];
 +                if (ms[i % ms.length]) {
 +                    rs[i] = (short)(Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b)));
 +                } else {
 +                    rs[i] = a;
 +                }
 +            }
 +        }
 +        bh.consume(rs);
 +    }
 +
 +    @Benchmark
 +    public void SUB(Blackhole bh) {
 +        short[] as = fa.apply(size);
 +        short[] bs = fb.apply(size);
 +        short[] rs = fr.apply(size);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < as.length; i++) {
 +                short a = as[i];
 +                short b = bs[i];
 +                rs[i] = (short)(Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b)));
 +            }
 +        }
 +
 +        bh.consume(rs);
 +    }
 +
 +    @Benchmark
 +    public void SUBMasked(Blackhole bh) {
 +        short[] as = fa.apply(size);
 +        short[] bs = fb.apply(size);
 +        short[] rs = fr.apply(size);
 +        boolean[] ms = fm.apply(size);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < as.length; i++) {
 +                short a = as[i];
 +                short b = bs[i];
 +                if (ms[i % ms.length]) {
 +                    rs[i] = (short)(Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b)));
 +                } else {
 +                    rs[i] = a;
 +                }
 +            }
 +        }
 +        bh.consume(rs);
 +    }
 +
 +    @Benchmark
 +    public void MUL(Blackhole bh) {
 +        short[] as = fa.apply(size);
 +        short[] bs = fb.apply(size);
 +        short[] rs = fr.apply(size);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < as.length; i++) {
 +                short a = as[i];
 +                short b = bs[i];
 +                rs[i] = (short)(Float.floatToFloat16(Float.float16ToFloat(a) * Float.float16ToFloat(b)));
 +            }
 +        }
 +
 +        bh.consume(rs);
 +    }
 +
 +    @Benchmark
 +    public void MULMasked(Blackhole bh) {
 +        short[] as = fa.apply(size);
 +        short[] bs = fb.apply(size);
 +        short[] rs = fr.apply(size);
 +        boolean[] ms = fm.apply(size);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < as.length; i++) {
 +                short a = as[i];
 +                short b = bs[i];
 +                if (ms[i % ms.length]) {
 +                    rs[i] = (short)(Float.floatToFloat16(Float.float16ToFloat(a) * Float.float16ToFloat(b)));
 +                } else {
 +                    rs[i] = a;
 +                }
 +            }
 +        }
 +        bh.consume(rs);
 +    }
 +
 +    @Benchmark
 +    public void DIV(Blackhole bh) {
 +        short[] as = fa.apply(size);
 +        short[] bs = fb.apply(size);
 +        short[] rs = fr.apply(size);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < as.length; i++) {
 +                short a = as[i];
 +                short b = bs[i];
 +                rs[i] = (short)(Float.floatToFloat16(Float.float16ToFloat(a) / Float.float16ToFloat(b)));
 +            }
 +        }
 +
 +        bh.consume(rs);
 +    }
 +
 +    @Benchmark
 +    public void DIVMasked(Blackhole bh) {
 +        short[] as = fa.apply(size);
 +        short[] bs = fb.apply(size);
 +        short[] rs = fr.apply(size);
 +        boolean[] ms = fm.apply(size);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < as.length; i++) {
 +                short a = as[i];
 +                short b = bs[i];
 +                if (ms[i % ms.length]) {
 +                    rs[i] = (short)(Float.floatToFloat16(Float.float16ToFloat(a) / Float.float16ToFloat(b)));
 +                } else {
 +                    rs[i] = a;
 +                }
 +            }
 +        }
 +        bh.consume(rs);
 +    }
 +
 +    @Benchmark
 +    public void MAX(Blackhole bh) {
 +        short[] as = fa.apply(size);
 +        short[] bs = fb.apply(size);
 +        short[] rs = fr.apply(size);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < as.length; i++) {
 +                short a = as[i];
 +                short b = bs[i];
 +                rs[i] = (short)(Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b))));
 +            }
 +        }
 +
 +        bh.consume(rs);
 +    }
 +
 +    @Benchmark
 +    public void MAXMasked(Blackhole bh) {
 +        short[] as = fa.apply(size);
 +        short[] bs = fb.apply(size);
 +        short[] rs = fr.apply(size);
 +        boolean[] ms = fm.apply(size);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < as.length; i++) {
 +                short a = as[i];
 +                short b = bs[i];
 +                if (ms[i % ms.length]) {
 +                    rs[i] = (short)(Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b))));
 +                } else {
 +                    rs[i] = a;
 +                }
 +            }
 +        }
 +        bh.consume(rs);
 +    }
 +
 +    @Benchmark
 +    public void MIN(Blackhole bh) {
 +        short[] as = fa.apply(size);
 +        short[] bs = fb.apply(size);
 +        short[] rs = fr.apply(size);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < as.length; i++) {
 +                short a = as[i];
 +                short b = bs[i];
-                 rs[i] = (short)(Halffloat.valueOf(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));
++                rs[i] = (short)(Float.floatToFloat16(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));
 +            }
 +        }
 +
 +        bh.consume(rs);
 +    }
 +
 +    @Benchmark
 +    public void MINMasked(Blackhole bh) {
 +        short[] as = fa.apply(size);
 +        short[] bs = fb.apply(size);
 +        short[] rs = fr.apply(size);
 +        boolean[] ms = fm.apply(size);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < as.length; i++) {
 +                short a = as[i];
 +                short b = bs[i];
 +                if (ms[i % ms.length]) {
-                     rs[i] = (short)(Halffloat.valueOf(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));
++                    rs[i] = (short)(Float.floatToFloat16(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));
 +                } else {
 +                    rs[i] = a;
 +                }
 +            }
 +        }
 +        bh.consume(rs);
 +    }
 +    @Benchmark
 +    public void ABS(Blackhole bh) {
 +        short[] as = fa.apply(size);
 +        short[] rs = fr.apply(size);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < as.length; i++) {
 +                short a = as[i];
 +                rs[i] = (short)(Math.abs(a));
 +            }
 +        }
 +
 +        bh.consume(rs);
 +    }
 +
 +    @Benchmark
 +    public void ABSMasked(Blackhole bh) {
 +        short[] as = fa.apply(size);
 +        short[] rs = fr.apply(size);
 +        boolean[] ms = fm.apply(size);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < as.length; i++) {
 +                short a = as[i];
 +                boolean m = ms[i % ms.length];
 +                rs[i] = (m ? (short)(Math.abs(a)) : a);
 +            }
 +        }
 +
 +        bh.consume(rs);
 +    }
 +    @Benchmark
 +    public void NEG(Blackhole bh) {
 +        short[] as = fa.apply(size);
 +        short[] rs = fr.apply(size);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < as.length; i++) {
 +                short a = as[i];
 +                rs[i] = (short)(-a);
 +            }
 +        }
 +
 +        bh.consume(rs);
 +    }
 +
 +    @Benchmark
 +    public void NEGMasked(Blackhole bh) {
 +        short[] as = fa.apply(size);
 +        short[] rs = fr.apply(size);
 +        boolean[] ms = fm.apply(size);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < as.length; i++) {
 +                short a = as[i];
 +                boolean m = ms[i % ms.length];
 +                rs[i] = (m ? (short)(-a) : a);
 +            }
 +        }
 +
 +        bh.consume(rs);
 +    }
 +
 +    @Benchmark
 +    public void FMA(Blackhole bh) {
 +        short[] as = fa.apply(size);
 +        short[] bs = fb.apply(size);
 +        short[] cs = fc.apply(size);
 +        short[] rs = fr.apply(size);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < as.length; i++) {
 +                short a = as[i];
 +                short b = bs[i];
 +                short c = cs[i];
 +                rs[i] = (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));
 +            }
 +        }
 +
 +        bh.consume(rs);
 +    }
 +
 +    @Benchmark
 +    public void FMAMasked(Blackhole bh) {
 +        short[] as = fa.apply(size);
 +        short[] bs = fb.apply(size);
 +        short[] cs = fc.apply(size);
 +        short[] rs = fr.apply(size);
 +        boolean[] ms = fm.apply(size);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < as.length; i++) {
 +                short a = as[i];
 +                short b = bs[i];
 +                short c = cs[i];
 +                if (ms[i % ms.length]) {
 +                    rs[i] = (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));
 +                } else {
 +                    rs[i] = a;
 +                }
 +            }
 +        }
 +        bh.consume(rs);
 +    }
 +    @Benchmark
 +    public void SQRT(Blackhole bh) {
 +        short[] as = fa.apply(size);
 +        short[] rs = fr.apply(size);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < as.length; i++) {
 +                short a = as[i];
-                 rs[i] = (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));
++                rs[i] = (short)(Float.floatToFloat16((float) Math.sqrt(Float.float16ToFloat(a))));
 +            }
 +        }
 +
 +        bh.consume(rs);
 +    }
 +
 +    @Benchmark
 +    public void SQRTMasked(Blackhole bh) {
 +        short[] as = fa.apply(size);
 +        short[] rs = fr.apply(size);
 +        boolean[] ms = fm.apply(size);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < as.length; i++) {
 +                short a = as[i];
 +                boolean m = ms[i % ms.length];
-                 rs[i] = (m ? (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a)))) : a);
++                rs[i] = (m ? (short)(Float.floatToFloat16((float) Math.sqrt(Float.float16ToFloat(a)))) : a);
 +            }
 +        }
 +
 +        bh.consume(rs);
 +    }
 +
 +    @Benchmark
 +    public void blend(Blackhole bh) {
 +        short[] as = fa.apply(size);
 +        short[] bs = fb.apply(size);
 +        short[] rs = fr.apply(size);
 +        boolean[] ms = fm.apply(size);
 +
 +        for (int ic = 0; ic < INVOC_COUNT; ic++) {
 +            for (int i = 0; i < as.length; i++) {
 +                short a = as[i];
 +                short b = bs[i];
 +                boolean m = ms[i % ms.length];
 +                rs[i] = (m ? b : a);
 +            }
 +        }
 +
 +        bh.consume(rs);
 +    }
 +}
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Int128Vector.java
index d44d32eae24,9801d6ea9ca..e17e8247251
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Int128Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Int128Vector.java
@@@ -1026,6 -1024,6 +1026,70 @@@ public class Int128Vector extends Abstr
          bh.consume(r);
      }
  
++    @Benchmark
++    public void MIN(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MINMasked(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAX(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAXMasked(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void MIN(Blackhole bh) {
          int[] a = fa.apply(SPECIES.length());
@@@ -1060,6 -1058,222 +1124,267 @@@
          bh.consume(r);
      }
  
+     @Benchmark
+     public void UMIN(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMINMasked(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAX(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAXMasked(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADD(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADDMasked(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUB(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUBMasked(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADD(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADDMasked(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUB(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUBMasked(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] b = fb.apply(SPECIES.length());
++        int[] c = fc.apply(SPECIES.length());
++        int[] rl = fr.apply(SPECIES.length());
++        int[] rr = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                IntVector bv = IntVector.fromArray(SPECIES, b, i);
++                IntVector cv = IntVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] b = fb.apply(SPECIES.length());
++        int[] c = fc.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        int[] rl = fr.apply(SPECIES.length());
++        int[] rr = fr.apply(SPECIES.length());
++
++        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                IntVector bv = IntVector.fromArray(SPECIES, b, i);
++                IntVector cv = IntVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void ANDLanes(Blackhole bh) {
          int[] a = fa.apply(SPECIES.length());
@@@ -1284,6 -1498,6 +1609,70 @@@
          bh.consume(ra);
      }
  
++    @Benchmark
++    public void UMINLanes(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int ra = Integer.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Integer.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMINMaskedLanes(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        int ra = Integer.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Integer.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXLanes(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int ra = Integer.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Integer.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXMaskedLanes(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        int ra = Integer.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Integer.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
      @Benchmark
      public void FIRST_NONZEROLanes(Blackhole bh) {
          int[] a = fa.apply(SPECIES.length());
@@@ -1346,6 -1560,6 +1735,56 @@@
          bh.consume(r);
      }
  
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] r = fr.apply(SPECIES.length());
++        int ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                ra = (int) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        int ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                ra = (int) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void withLane(Blackhole bh) {
          int[] a = fa.apply(SPECIES.length());
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Int256Vector.java
index 3713f5766dd,23aa9d12621..04d375df0c4
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Int256Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Int256Vector.java
@@@ -1026,6 -1024,6 +1026,70 @@@ public class Int256Vector extends Abstr
          bh.consume(r);
      }
  
++    @Benchmark
++    public void MIN(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MINMasked(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAX(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAXMasked(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void MIN(Blackhole bh) {
          int[] a = fa.apply(SPECIES.length());
@@@ -1060,6 -1058,222 +1124,267 @@@
          bh.consume(r);
      }
  
+     @Benchmark
+     public void UMIN(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMINMasked(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAX(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAXMasked(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADD(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADDMasked(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUB(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUBMasked(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADD(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADDMasked(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUB(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUBMasked(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] b = fb.apply(SPECIES.length());
++        int[] c = fc.apply(SPECIES.length());
++        int[] rl = fr.apply(SPECIES.length());
++        int[] rr = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                IntVector bv = IntVector.fromArray(SPECIES, b, i);
++                IntVector cv = IntVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] b = fb.apply(SPECIES.length());
++        int[] c = fc.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        int[] rl = fr.apply(SPECIES.length());
++        int[] rr = fr.apply(SPECIES.length());
++
++        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                IntVector bv = IntVector.fromArray(SPECIES, b, i);
++                IntVector cv = IntVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void ANDLanes(Blackhole bh) {
          int[] a = fa.apply(SPECIES.length());
@@@ -1284,6 -1498,6 +1609,70 @@@
          bh.consume(ra);
      }
  
++    @Benchmark
++    public void UMINLanes(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int ra = Integer.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Integer.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMINMaskedLanes(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        int ra = Integer.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Integer.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXLanes(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int ra = Integer.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Integer.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXMaskedLanes(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        int ra = Integer.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Integer.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
      @Benchmark
      public void FIRST_NONZEROLanes(Blackhole bh) {
          int[] a = fa.apply(SPECIES.length());
@@@ -1346,6 -1560,6 +1735,56 @@@
          bh.consume(r);
      }
  
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] r = fr.apply(SPECIES.length());
++        int ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                ra = (int) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        int ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                ra = (int) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void withLane(Blackhole bh) {
          int[] a = fa.apply(SPECIES.length());
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Int512Vector.java
index d05fde2d9c2,08e7e8193d7..4d0c482984b
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Int512Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Int512Vector.java
@@@ -1026,6 -1024,6 +1026,70 @@@ public class Int512Vector extends Abstr
          bh.consume(r);
      }
  
++    @Benchmark
++    public void MIN(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MINMasked(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAX(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAXMasked(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void MIN(Blackhole bh) {
          int[] a = fa.apply(SPECIES.length());
@@@ -1060,6 -1058,222 +1124,267 @@@
          bh.consume(r);
      }
  
+     @Benchmark
+     public void UMIN(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMINMasked(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAX(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAXMasked(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADD(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADDMasked(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUB(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUBMasked(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADD(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADDMasked(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUB(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUBMasked(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] b = fb.apply(SPECIES.length());
++        int[] c = fc.apply(SPECIES.length());
++        int[] rl = fr.apply(SPECIES.length());
++        int[] rr = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                IntVector bv = IntVector.fromArray(SPECIES, b, i);
++                IntVector cv = IntVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] b = fb.apply(SPECIES.length());
++        int[] c = fc.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        int[] rl = fr.apply(SPECIES.length());
++        int[] rr = fr.apply(SPECIES.length());
++
++        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                IntVector bv = IntVector.fromArray(SPECIES, b, i);
++                IntVector cv = IntVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void ANDLanes(Blackhole bh) {
          int[] a = fa.apply(SPECIES.length());
@@@ -1284,6 -1498,6 +1609,70 @@@
          bh.consume(ra);
      }
  
++    @Benchmark
++    public void UMINLanes(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int ra = Integer.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Integer.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMINMaskedLanes(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        int ra = Integer.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Integer.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXLanes(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int ra = Integer.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Integer.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXMaskedLanes(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        int ra = Integer.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Integer.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
      @Benchmark
      public void FIRST_NONZEROLanes(Blackhole bh) {
          int[] a = fa.apply(SPECIES.length());
@@@ -1346,6 -1560,6 +1735,56 @@@
          bh.consume(r);
      }
  
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] r = fr.apply(SPECIES.length());
++        int ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                ra = (int) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        int ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                ra = (int) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void withLane(Blackhole bh) {
          int[] a = fa.apply(SPECIES.length());
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Int64Vector.java
index 2330ed8455b,c689fc14f62..fa18a1a3bb4
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Int64Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Int64Vector.java
@@@ -1026,6 -1024,6 +1026,70 @@@ public class Int64Vector extends Abstra
          bh.consume(r);
      }
  
++    @Benchmark
++    public void MIN(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MINMasked(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAX(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAXMasked(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void MIN(Blackhole bh) {
          int[] a = fa.apply(SPECIES.length());
@@@ -1060,6 -1058,222 +1124,267 @@@
          bh.consume(r);
      }
  
+     @Benchmark
+     public void UMIN(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMINMasked(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAX(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAXMasked(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADD(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADDMasked(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUB(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUBMasked(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADD(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADDMasked(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUB(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUBMasked(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] b = fb.apply(SPECIES.length());
++        int[] c = fc.apply(SPECIES.length());
++        int[] rl = fr.apply(SPECIES.length());
++        int[] rr = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                IntVector bv = IntVector.fromArray(SPECIES, b, i);
++                IntVector cv = IntVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] b = fb.apply(SPECIES.length());
++        int[] c = fc.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        int[] rl = fr.apply(SPECIES.length());
++        int[] rr = fr.apply(SPECIES.length());
++
++        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                IntVector bv = IntVector.fromArray(SPECIES, b, i);
++                IntVector cv = IntVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void ANDLanes(Blackhole bh) {
          int[] a = fa.apply(SPECIES.length());
@@@ -1284,6 -1498,6 +1609,70 @@@
          bh.consume(ra);
      }
  
++    @Benchmark
++    public void UMINLanes(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int ra = Integer.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Integer.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMINMaskedLanes(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        int ra = Integer.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Integer.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXLanes(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int ra = Integer.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Integer.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXMaskedLanes(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        int ra = Integer.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Integer.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
      @Benchmark
      public void FIRST_NONZEROLanes(Blackhole bh) {
          int[] a = fa.apply(SPECIES.length());
@@@ -1346,6 -1560,6 +1735,56 @@@
          bh.consume(r);
      }
  
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] r = fr.apply(SPECIES.length());
++        int ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                ra = (int) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        int ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                ra = (int) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void withLane(Blackhole bh) {
          int[] a = fa.apply(SPECIES.length());
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/IntMaxVector.java
index 6ee05eb4b8a,47da0c9dbc1..8b04e8638cd
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/IntMaxVector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/IntMaxVector.java
@@@ -1026,6 -1024,6 +1026,70 @@@ public class IntMaxVector extends Abstr
          bh.consume(r);
      }
  
++    @Benchmark
++    public void MIN(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MINMasked(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAX(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAXMasked(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void MIN(Blackhole bh) {
          int[] a = fa.apply(SPECIES.length());
@@@ -1060,6 -1058,222 +1124,267 @@@
          bh.consume(r);
      }
  
+     @Benchmark
+     public void UMIN(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMINMasked(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAX(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAXMasked(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADD(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADDMasked(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUB(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUBMasked(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADD(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADDMasked(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUB(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUBMasked(Blackhole bh) {
+         int[] a = fa.apply(SPECIES.length());
+         int[] b = fb.apply(SPECIES.length());
+         int[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 IntVector av = IntVector.fromArray(SPECIES, a, i);
+                 IntVector bv = IntVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] b = fb.apply(SPECIES.length());
++        int[] c = fc.apply(SPECIES.length());
++        int[] rl = fr.apply(SPECIES.length());
++        int[] rr = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                IntVector bv = IntVector.fromArray(SPECIES, b, i);
++                IntVector cv = IntVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] b = fb.apply(SPECIES.length());
++        int[] c = fc.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        int[] rl = fr.apply(SPECIES.length());
++        int[] rr = fr.apply(SPECIES.length());
++
++        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                IntVector bv = IntVector.fromArray(SPECIES, b, i);
++                IntVector cv = IntVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void ANDLanes(Blackhole bh) {
          int[] a = fa.apply(SPECIES.length());
@@@ -1284,6 -1498,6 +1609,70 @@@
          bh.consume(ra);
      }
  
++    @Benchmark
++    public void UMINLanes(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int ra = Integer.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Integer.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMINMaskedLanes(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        int ra = Integer.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Integer.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXLanes(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int ra = Integer.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Integer.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXMaskedLanes(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        int ra = Integer.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Integer.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
      @Benchmark
      public void FIRST_NONZEROLanes(Blackhole bh) {
          int[] a = fa.apply(SPECIES.length());
@@@ -1346,6 -1560,6 +1735,56 @@@
          bh.consume(r);
      }
  
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] r = fr.apply(SPECIES.length());
++        int ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                ra = (int) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        int[] a = fa.apply(SPECIES.length());
++        int[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        int ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                IntVector av = IntVector.fromArray(SPECIES, a, i);
++                ra = (int) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void withLane(Blackhole bh) {
          int[] a = fa.apply(SPECIES.length());
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Long128Vector.java
index e9ecf14da33,157f6975381..4db955cab2c
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Long128Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Long128Vector.java
@@@ -1026,6 -1024,6 +1026,70 @@@ public class Long128Vector extends Abst
          bh.consume(r);
      }
  
++    @Benchmark
++    public void MIN(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MINMasked(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAX(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAXMasked(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void MIN(Blackhole bh) {
          long[] a = fa.apply(SPECIES.length());
@@@ -1060,6 -1058,222 +1124,267 @@@
          bh.consume(r);
      }
  
+     @Benchmark
+     public void UMIN(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMINMasked(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAX(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAXMasked(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADD(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADDMasked(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUB(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUBMasked(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADD(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADDMasked(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUB(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUBMasked(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] b = fb.apply(SPECIES.length());
++        long[] c = fc.apply(SPECIES.length());
++        long[] rl = fr.apply(SPECIES.length());
++        long[] rr = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                LongVector bv = LongVector.fromArray(SPECIES, b, i);
++                LongVector cv = LongVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] b = fb.apply(SPECIES.length());
++        long[] c = fc.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        long[] rl = fr.apply(SPECIES.length());
++        long[] rr = fr.apply(SPECIES.length());
++
++        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                LongVector bv = LongVector.fromArray(SPECIES, b, i);
++                LongVector cv = LongVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void ANDLanes(Blackhole bh) {
          long[] a = fa.apply(SPECIES.length());
@@@ -1284,6 -1498,6 +1609,70 @@@
          bh.consume(ra);
      }
  
++    @Benchmark
++    public void UMINLanes(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long ra = Long.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Long.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMINMaskedLanes(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        long ra = Long.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Long.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXLanes(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long ra = Long.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Long.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXMaskedLanes(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        long ra = Long.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Long.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
      @Benchmark
      public void FIRST_NONZEROLanes(Blackhole bh) {
          long[] a = fa.apply(SPECIES.length());
@@@ -1346,6 -1560,6 +1735,56 @@@
          bh.consume(r);
      }
  
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] r = fr.apply(SPECIES.length());
++        long ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                ra = (long) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        long ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                ra = (long) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void withLane(Blackhole bh) {
          long[] a = fa.apply(SPECIES.length());
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Long256Vector.java
index 440edcc1d5f,7e7a71ca43d..c0cc8a2e8f8
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Long256Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Long256Vector.java
@@@ -1026,6 -1024,6 +1026,70 @@@ public class Long256Vector extends Abst
          bh.consume(r);
      }
  
++    @Benchmark
++    public void MIN(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MINMasked(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAX(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAXMasked(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void MIN(Blackhole bh) {
          long[] a = fa.apply(SPECIES.length());
@@@ -1060,6 -1058,222 +1124,267 @@@
          bh.consume(r);
      }
  
+     @Benchmark
+     public void UMIN(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMINMasked(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAX(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAXMasked(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADD(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADDMasked(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUB(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUBMasked(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADD(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADDMasked(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUB(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUBMasked(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] b = fb.apply(SPECIES.length());
++        long[] c = fc.apply(SPECIES.length());
++        long[] rl = fr.apply(SPECIES.length());
++        long[] rr = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                LongVector bv = LongVector.fromArray(SPECIES, b, i);
++                LongVector cv = LongVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] b = fb.apply(SPECIES.length());
++        long[] c = fc.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        long[] rl = fr.apply(SPECIES.length());
++        long[] rr = fr.apply(SPECIES.length());
++
++        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                LongVector bv = LongVector.fromArray(SPECIES, b, i);
++                LongVector cv = LongVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void ANDLanes(Blackhole bh) {
          long[] a = fa.apply(SPECIES.length());
@@@ -1284,6 -1498,6 +1609,70 @@@
          bh.consume(ra);
      }
  
++    @Benchmark
++    public void UMINLanes(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long ra = Long.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Long.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMINMaskedLanes(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        long ra = Long.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Long.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXLanes(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long ra = Long.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Long.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXMaskedLanes(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        long ra = Long.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Long.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
      @Benchmark
      public void FIRST_NONZEROLanes(Blackhole bh) {
          long[] a = fa.apply(SPECIES.length());
@@@ -1346,6 -1560,6 +1735,56 @@@
          bh.consume(r);
      }
  
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] r = fr.apply(SPECIES.length());
++        long ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                ra = (long) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        long ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                ra = (long) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void withLane(Blackhole bh) {
          long[] a = fa.apply(SPECIES.length());
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Long512Vector.java
index 6ab0f9db351,0e5776e97a7..01255ac3b0a
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Long512Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Long512Vector.java
@@@ -1026,6 -1024,6 +1026,70 @@@ public class Long512Vector extends Abst
          bh.consume(r);
      }
  
++    @Benchmark
++    public void MIN(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MINMasked(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAX(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAXMasked(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void MIN(Blackhole bh) {
          long[] a = fa.apply(SPECIES.length());
@@@ -1060,6 -1058,222 +1124,267 @@@
          bh.consume(r);
      }
  
+     @Benchmark
+     public void UMIN(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMINMasked(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAX(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAXMasked(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADD(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADDMasked(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUB(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUBMasked(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADD(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADDMasked(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUB(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUBMasked(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] b = fb.apply(SPECIES.length());
++        long[] c = fc.apply(SPECIES.length());
++        long[] rl = fr.apply(SPECIES.length());
++        long[] rr = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                LongVector bv = LongVector.fromArray(SPECIES, b, i);
++                LongVector cv = LongVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] b = fb.apply(SPECIES.length());
++        long[] c = fc.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        long[] rl = fr.apply(SPECIES.length());
++        long[] rr = fr.apply(SPECIES.length());
++
++        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                LongVector bv = LongVector.fromArray(SPECIES, b, i);
++                LongVector cv = LongVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void ANDLanes(Blackhole bh) {
          long[] a = fa.apply(SPECIES.length());
@@@ -1284,6 -1498,6 +1609,70 @@@
          bh.consume(ra);
      }
  
++    @Benchmark
++    public void UMINLanes(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long ra = Long.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Long.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMINMaskedLanes(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        long ra = Long.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Long.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXLanes(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long ra = Long.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Long.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXMaskedLanes(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        long ra = Long.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Long.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
      @Benchmark
      public void FIRST_NONZEROLanes(Blackhole bh) {
          long[] a = fa.apply(SPECIES.length());
@@@ -1346,6 -1560,6 +1735,56 @@@
          bh.consume(r);
      }
  
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] r = fr.apply(SPECIES.length());
++        long ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                ra = (long) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        long ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                ra = (long) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void withLane(Blackhole bh) {
          long[] a = fa.apply(SPECIES.length());
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Long64Vector.java
index 29030ce145b,334fa130d57..e9512a505b4
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Long64Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Long64Vector.java
@@@ -1026,6 -1024,6 +1026,70 @@@ public class Long64Vector extends Abstr
          bh.consume(r);
      }
  
++    @Benchmark
++    public void MIN(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MINMasked(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAX(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAXMasked(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void MIN(Blackhole bh) {
          long[] a = fa.apply(SPECIES.length());
@@@ -1060,6 -1058,222 +1124,267 @@@
          bh.consume(r);
      }
  
+     @Benchmark
+     public void UMIN(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMINMasked(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAX(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAXMasked(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADD(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADDMasked(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUB(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUBMasked(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADD(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADDMasked(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUB(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUBMasked(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] b = fb.apply(SPECIES.length());
++        long[] c = fc.apply(SPECIES.length());
++        long[] rl = fr.apply(SPECIES.length());
++        long[] rr = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                LongVector bv = LongVector.fromArray(SPECIES, b, i);
++                LongVector cv = LongVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] b = fb.apply(SPECIES.length());
++        long[] c = fc.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        long[] rl = fr.apply(SPECIES.length());
++        long[] rr = fr.apply(SPECIES.length());
++
++        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                LongVector bv = LongVector.fromArray(SPECIES, b, i);
++                LongVector cv = LongVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void ANDLanes(Blackhole bh) {
          long[] a = fa.apply(SPECIES.length());
@@@ -1284,6 -1498,6 +1609,70 @@@
          bh.consume(ra);
      }
  
++    @Benchmark
++    public void UMINLanes(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long ra = Long.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Long.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMINMaskedLanes(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        long ra = Long.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Long.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXLanes(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long ra = Long.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Long.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXMaskedLanes(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        long ra = Long.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Long.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
      @Benchmark
      public void FIRST_NONZEROLanes(Blackhole bh) {
          long[] a = fa.apply(SPECIES.length());
@@@ -1346,6 -1560,6 +1735,56 @@@
          bh.consume(r);
      }
  
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] r = fr.apply(SPECIES.length());
++        long ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                ra = (long) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        long ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                ra = (long) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void withLane(Blackhole bh) {
          long[] a = fa.apply(SPECIES.length());
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/LongMaxVector.java
index dd51d17c8cd,4e3193ee76a..2aee93fc8a9
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/LongMaxVector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/LongMaxVector.java
@@@ -1026,6 -1024,6 +1026,70 @@@ public class LongMaxVector extends Abst
          bh.consume(r);
      }
  
++    @Benchmark
++    public void MIN(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MINMasked(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAX(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAXMasked(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void MIN(Blackhole bh) {
          long[] a = fa.apply(SPECIES.length());
@@@ -1060,6 -1058,222 +1124,267 @@@
          bh.consume(r);
      }
  
+     @Benchmark
+     public void UMIN(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMINMasked(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAX(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAXMasked(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADD(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADDMasked(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUB(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUBMasked(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADD(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADDMasked(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUB(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUBMasked(Blackhole bh) {
+         long[] a = fa.apply(SPECIES.length());
+         long[] b = fb.apply(SPECIES.length());
+         long[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 LongVector av = LongVector.fromArray(SPECIES, a, i);
+                 LongVector bv = LongVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] b = fb.apply(SPECIES.length());
++        long[] c = fc.apply(SPECIES.length());
++        long[] rl = fr.apply(SPECIES.length());
++        long[] rr = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                LongVector bv = LongVector.fromArray(SPECIES, b, i);
++                LongVector cv = LongVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] b = fb.apply(SPECIES.length());
++        long[] c = fc.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        long[] rl = fr.apply(SPECIES.length());
++        long[] rr = fr.apply(SPECIES.length());
++
++        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                LongVector bv = LongVector.fromArray(SPECIES, b, i);
++                LongVector cv = LongVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void ANDLanes(Blackhole bh) {
          long[] a = fa.apply(SPECIES.length());
@@@ -1284,6 -1498,6 +1609,70 @@@
          bh.consume(ra);
      }
  
++    @Benchmark
++    public void UMINLanes(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long ra = Long.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Long.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMINMaskedLanes(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        long ra = Long.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Long.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXLanes(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long ra = Long.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Long.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXMaskedLanes(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        long ra = Long.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Long.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
      @Benchmark
      public void FIRST_NONZEROLanes(Blackhole bh) {
          long[] a = fa.apply(SPECIES.length());
@@@ -1346,6 -1560,6 +1735,56 @@@
          bh.consume(r);
      }
  
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] r = fr.apply(SPECIES.length());
++        long ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                ra = (long) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        long[] a = fa.apply(SPECIES.length());
++        long[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        long ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                LongVector av = LongVector.fromArray(SPECIES, a, i);
++                ra = (long) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void withLane(Blackhole bh) {
          long[] a = fa.apply(SPECIES.length());
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Short128Vector.java
index 5b4cfd9cf65,3b617c92ec2..529cd8bcecb
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Short128Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Short128Vector.java
@@@ -954,6 -952,6 +954,70 @@@ public class Short128Vector extends Abs
          bh.consume(r);
      }
  
++    @Benchmark
++    public void MIN(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MINMasked(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAX(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAXMasked(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void MIN(Blackhole bh) {
          short[] a = fa.apply(SPECIES.length());
@@@ -988,6 -986,222 +1052,267 @@@
          bh.consume(r);
      }
  
+     @Benchmark
+     public void UMIN(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMINMasked(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAX(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAXMasked(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADD(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADDMasked(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUB(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUBMasked(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADD(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADDMasked(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUB(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUBMasked(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] b = fb.apply(SPECIES.length());
++        short[] c = fc.apply(SPECIES.length());
++        short[] rl = fr.apply(SPECIES.length());
++        short[] rr = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
++                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] b = fb.apply(SPECIES.length());
++        short[] c = fc.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        short[] rl = fr.apply(SPECIES.length());
++        short[] rr = fr.apply(SPECIES.length());
++
++        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
++                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void ANDLanes(Blackhole bh) {
          short[] a = fa.apply(SPECIES.length());
@@@ -1212,6 -1426,6 +1537,70 @@@
          bh.consume(ra);
      }
  
++    @Benchmark
++    public void UMINLanes(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short ra = Short.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Short.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMINMaskedLanes(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        short ra = Short.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Short.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXLanes(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short ra = Short.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Short.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXMaskedLanes(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        short ra = Short.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Short.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
      @Benchmark
      public void FIRST_NONZEROLanes(Blackhole bh) {
          short[] a = fa.apply(SPECIES.length());
@@@ -1274,6 -1488,6 +1663,56 @@@
          bh.consume(r);
      }
  
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] r = fr.apply(SPECIES.length());
++        short ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ra = (short) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        short ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ra = (short) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void withLane(Blackhole bh) {
          short[] a = fa.apply(SPECIES.length());
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Short256Vector.java
index 43767908b21,31d4330c96f..757cb42ba48
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Short256Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Short256Vector.java
@@@ -954,6 -952,6 +954,70 @@@ public class Short256Vector extends Abs
          bh.consume(r);
      }
  
++    @Benchmark
++    public void MIN(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MINMasked(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAX(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAXMasked(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void MIN(Blackhole bh) {
          short[] a = fa.apply(SPECIES.length());
@@@ -988,6 -986,222 +1052,267 @@@
          bh.consume(r);
      }
  
+     @Benchmark
+     public void UMIN(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMINMasked(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAX(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAXMasked(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADD(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADDMasked(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUB(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUBMasked(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADD(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADDMasked(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUB(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUBMasked(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] b = fb.apply(SPECIES.length());
++        short[] c = fc.apply(SPECIES.length());
++        short[] rl = fr.apply(SPECIES.length());
++        short[] rr = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
++                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] b = fb.apply(SPECIES.length());
++        short[] c = fc.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        short[] rl = fr.apply(SPECIES.length());
++        short[] rr = fr.apply(SPECIES.length());
++
++        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
++                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void ANDLanes(Blackhole bh) {
          short[] a = fa.apply(SPECIES.length());
@@@ -1212,6 -1426,6 +1537,70 @@@
          bh.consume(ra);
      }
  
++    @Benchmark
++    public void UMINLanes(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short ra = Short.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Short.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMINMaskedLanes(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        short ra = Short.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Short.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXLanes(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short ra = Short.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Short.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXMaskedLanes(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        short ra = Short.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Short.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
      @Benchmark
      public void FIRST_NONZEROLanes(Blackhole bh) {
          short[] a = fa.apply(SPECIES.length());
@@@ -1274,6 -1488,6 +1663,56 @@@
          bh.consume(r);
      }
  
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] r = fr.apply(SPECIES.length());
++        short ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ra = (short) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        short ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ra = (short) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void withLane(Blackhole bh) {
          short[] a = fa.apply(SPECIES.length());
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Short512Vector.java
index 01fdfd750e0,e1e58366640..12c1ec68b3d
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Short512Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Short512Vector.java
@@@ -954,6 -952,6 +954,70 @@@ public class Short512Vector extends Abs
          bh.consume(r);
      }
  
++    @Benchmark
++    public void MIN(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MINMasked(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAX(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAXMasked(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void MIN(Blackhole bh) {
          short[] a = fa.apply(SPECIES.length());
@@@ -988,6 -986,222 +1052,267 @@@
          bh.consume(r);
      }
  
+     @Benchmark
+     public void UMIN(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMINMasked(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAX(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAXMasked(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADD(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADDMasked(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUB(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUBMasked(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADD(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADDMasked(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUB(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUBMasked(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] b = fb.apply(SPECIES.length());
++        short[] c = fc.apply(SPECIES.length());
++        short[] rl = fr.apply(SPECIES.length());
++        short[] rr = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
++                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] b = fb.apply(SPECIES.length());
++        short[] c = fc.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        short[] rl = fr.apply(SPECIES.length());
++        short[] rr = fr.apply(SPECIES.length());
++
++        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
++                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void ANDLanes(Blackhole bh) {
          short[] a = fa.apply(SPECIES.length());
@@@ -1212,6 -1426,6 +1537,70 @@@
          bh.consume(ra);
      }
  
++    @Benchmark
++    public void UMINLanes(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short ra = Short.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Short.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMINMaskedLanes(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        short ra = Short.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Short.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXLanes(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short ra = Short.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Short.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXMaskedLanes(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        short ra = Short.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Short.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
      @Benchmark
      public void FIRST_NONZEROLanes(Blackhole bh) {
          short[] a = fa.apply(SPECIES.length());
@@@ -1274,6 -1488,6 +1663,56 @@@
          bh.consume(r);
      }
  
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] r = fr.apply(SPECIES.length());
++        short ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ra = (short) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        short ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ra = (short) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void withLane(Blackhole bh) {
          short[] a = fa.apply(SPECIES.length());
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Short64Vector.java
index 9ddfbfbac23,f9f99b2caf2..f620cde30c4
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Short64Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Short64Vector.java
@@@ -954,6 -952,6 +954,70 @@@ public class Short64Vector extends Abst
          bh.consume(r);
      }
  
++    @Benchmark
++    public void MIN(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MINMasked(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAX(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAXMasked(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void MIN(Blackhole bh) {
          short[] a = fa.apply(SPECIES.length());
@@@ -988,6 -986,222 +1052,267 @@@
          bh.consume(r);
      }
  
+     @Benchmark
+     public void UMIN(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMINMasked(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAX(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAXMasked(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADD(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADDMasked(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUB(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUBMasked(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADD(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADDMasked(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUB(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUBMasked(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] b = fb.apply(SPECIES.length());
++        short[] c = fc.apply(SPECIES.length());
++        short[] rl = fr.apply(SPECIES.length());
++        short[] rr = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
++                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] b = fb.apply(SPECIES.length());
++        short[] c = fc.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        short[] rl = fr.apply(SPECIES.length());
++        short[] rr = fr.apply(SPECIES.length());
++
++        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
++                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void ANDLanes(Blackhole bh) {
          short[] a = fa.apply(SPECIES.length());
@@@ -1212,6 -1426,6 +1537,70 @@@
          bh.consume(ra);
      }
  
++    @Benchmark
++    public void UMINLanes(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short ra = Short.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Short.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMINMaskedLanes(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        short ra = Short.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Short.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXLanes(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short ra = Short.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Short.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXMaskedLanes(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        short ra = Short.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Short.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
      @Benchmark
      public void FIRST_NONZEROLanes(Blackhole bh) {
          short[] a = fa.apply(SPECIES.length());
@@@ -1274,6 -1488,6 +1663,56 @@@
          bh.consume(r);
      }
  
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] r = fr.apply(SPECIES.length());
++        short ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ra = (short) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        short ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ra = (short) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void withLane(Blackhole bh) {
          short[] a = fa.apply(SPECIES.length());
diff --cc test/micro/org/openjdk/bench/jdk/incubator/vector/operation/ShortMaxVector.java
index 58f8f1502b8,55357b46838..f7bb3e566d7
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/ShortMaxVector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/ShortMaxVector.java
@@@ -954,6 -952,6 +954,70 @@@ public class ShortMaxVector extends Abs
          bh.consume(r);
      }
  
++    @Benchmark
++    public void MIN(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MINMasked(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAX(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] r = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void MAXMasked(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void MIN(Blackhole bh) {
          short[] a = fa.apply(SPECIES.length());
@@@ -988,6 -986,222 +1052,267 @@@
          bh.consume(r);
      }
  
+     @Benchmark
+     public void UMIN(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMINMasked(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAX(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void UMAXMasked(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADD(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SADDMasked(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUB(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SSUBMasked(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADD(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUADDMasked(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUB(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
+     @Benchmark
+     public void SUSUBMasked(Blackhole bh) {
+         short[] a = fa.apply(SPECIES.length());
+         short[] b = fb.apply(SPECIES.length());
+         short[] r = fr.apply(SPECIES.length());
+         boolean[] mask = fm.apply(SPECIES.length());
+         VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+ 
+         for (int ic = 0; ic < INVOC_COUNT; ic++) {
+             for (int i = 0; i < a.length; i += SPECIES.length()) {
+                 ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                 ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
+                 av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);
+             }
+         }
+ 
+         bh.consume(r);
+     }
+ 
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] b = fb.apply(SPECIES.length());
++        short[] c = fc.apply(SPECIES.length());
++        short[] rl = fr.apply(SPECIES.length());
++        short[] rr = fr.apply(SPECIES.length());
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
++                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] b = fb.apply(SPECIES.length());
++        short[] c = fc.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        short[] rl = fr.apply(SPECIES.length());
++        short[] rr = fr.apply(SPECIES.length());
++
++        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);
++                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);
++                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);
++                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void ANDLanes(Blackhole bh) {
          short[] a = fa.apply(SPECIES.length());
@@@ -1212,6 -1426,6 +1537,70 @@@
          bh.consume(ra);
      }
  
++    @Benchmark
++    public void UMINLanes(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short ra = Short.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Short.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMINMaskedLanes(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        short ra = Short.MAX_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Short.MAX_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXLanes(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short ra = Short.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Short.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));
++            }
++        }
++        bh.consume(ra);
++    }
++
++    @Benchmark
++    public void UMAXMaskedLanes(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        short ra = Short.MIN_VALUE;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = Short.MIN_VALUE;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));
++            }
++        }
++        bh.consume(ra);
++    }
++
      @Benchmark
      public void FIRST_NONZEROLanes(Blackhole bh) {
          short[] a = fa.apply(SPECIES.length());
@@@ -1274,6 -1488,6 +1663,56 @@@
          bh.consume(r);
      }
  
++    @Benchmark
++    public void SUADD(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] r = fr.apply(SPECIES.length());
++        short ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ra = (short) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));
++            }
++        }
++
++        bh.consume(r);
++    }
++
++    @Benchmark
++    public void SUADDMasked(Blackhole bh) {
++        short[] a = fa.apply(SPECIES.length());
++        short[] r = fr.apply(SPECIES.length());
++        boolean[] mask = fm.apply(SPECIES.length());
++        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);
++        short ra = 0;
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);
++            }
++        }
++
++        for (int ic = 0; ic < INVOC_COUNT; ic++) {
++            ra = 0;
++            for (int i = 0; i < a.length; i += SPECIES.length()) {
++                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
++                ra = (short) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));
++            }
++        }
++
++        bh.consume(r);
++    }
++
      @Benchmark
      public void withLane(Blackhole bh) {
          short[] a = fa.apply(SPECIES.length());
