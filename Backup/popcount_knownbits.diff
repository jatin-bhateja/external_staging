diff --git a/src/hotspot/share/opto/countbitsnode.cpp b/src/hotspot/share/opto/countbitsnode.cpp
index 4023678b51c..05597928cf6 100644
--- a/src/hotspot/share/opto/countbitsnode.cpp
+++ b/src/hotspot/share/opto/countbitsnode.cpp
@@ -26,6 +26,7 @@
 #include "opto/opcodes.hpp"
 #include "opto/phaseX.hpp"
 #include "opto/type.hpp"
+#include "utilities/population_count.hpp"
 
 //------------------------------Value------------------------------------------
 const Type* CountLeadingZerosINode::Value(PhaseGVN* phase) const {
@@ -116,3 +117,54 @@ const Type* CountTrailingZerosLNode::Value(PhaseGVN* phase) const {
   }
   return TypeInt::INT;
 }
+
+/*
+Lemma 1: For a given known bits information, _lo and _hi bounds of corresponding value
+        range are computed using following formulas :-
+        - _hi = ~ZEROS
+        - _lo = ONES
+Proof:-
+  - KnownBits.ZEROS and KnownBits.ONES are inferred out of common prefix of value range
+    delimiting bounds.
+
+  - Thus, ~ZEROS not only include set bits in the common prefix but optimistically assumes
+    that all other bits not included in common prefix are also set, thereby implicitly covering
+    the actual set bits at runtime.
+
+  - Consider following illustration which performs round trip translation
+    of a value range via knowbits information e.g.
+    A) Initial value range bounds to infer knownbits.
+      _lo = 0b11000100
+      _hi = 0b11000110
+      _common_prefix      = 0b11000100
+      _common_prefix_mask = 0b11111100
+      _known_bits.ones    = _lo & _common_prefix_mask  = 0b11000100
+      _known_bits.zeros   = ~_lo & _common_prefix_mask = 0b00111000
+
+    B) Now transform computed knownbits back to value range.
+      _new_lo = _known_bits.ones  = 0b11000100
+      _new_hi = ~known_bits.zeros = 0b11000111
+
+  - We now know that ~KnownBits.ZEROS >= UB >= LB >= KnownBits.ONES
+  - Therefore, popcount(~ZEROS) is guaranteed to be greater than popcount(ONES).
+  - Also, popcount(~ZEROS) >= Res.UB >= Res.LB >= popcount(ONES)
+*/
+
+const Type* PopCountINode::Value(PhaseGVN* phase) const {
+  const Type* t = phase->type(in(1));
+  if (t == Type::TOP) {
+    return Type::TOP;
+  }
+  KnownBits<juint> bits = t->isa_int()->_bits;
+  return TypeInt::make(population_count(bits._ones), population_count(~bits._zeros), Type::WidenMax);
+
+}
+
+const Type* PopCountLNode::Value(PhaseGVN* phase) const {
+  const Type* t = phase->type(in(1));
+  if (t == Type::TOP) {
+    return Type::TOP;
+  }
+  KnownBits<julong> bits = t->isa_long()->_bits;
+  return TypeLong::make(population_count(bits._ones), population_count(~bits._zeros), Type::WidenMax);
+}
diff --git a/src/hotspot/share/opto/countbitsnode.hpp b/src/hotspot/share/opto/countbitsnode.hpp
index 410d5129882..35465b1835b 100644
--- a/src/hotspot/share/opto/countbitsnode.hpp
+++ b/src/hotspot/share/opto/countbitsnode.hpp
@@ -80,6 +80,7 @@ class PopCountINode : public CountBitsNode {
   public:
   PopCountINode(Node* in1) : CountBitsNode(in1) {}
   virtual int Opcode() const;
+  virtual const Type* Value(PhaseGVN* phase) const;
 };
 
 //---------- PopCountLNode -----------------------------------------------------
@@ -88,6 +89,7 @@ class PopCountLNode : public CountBitsNode {
   public:
   PopCountLNode(Node* in1) : CountBitsNode(in1) {}
   virtual int Opcode() const;
+  virtual const Type* Value(PhaseGVN* phase) const;
 };
 
 
diff --git a/test/micro/org/openjdk/bench/java/lang/PopCountValueTransform.java b/test/micro/org/openjdk/bench/java/lang/PopCountValueTransform.java
new file mode 100644
index 00000000000..8be0ceb8007
--- /dev/null
+++ b/test/micro/org/openjdk/bench/java/lang/PopCountValueTransform.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2025, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.bench.java.lang;
+
+import org.openjdk.jmh.annotations.*;
+import java.util.concurrent.TimeUnit;
+
+@BenchmarkMode(Mode.AverageTime)
+@OutputTimeUnit(TimeUnit.NANOSECONDS)
+@State(Scope.Thread)
+
+public class PopCountValueTransform {
+
+    public int lower_bound = 0;
+
+    public int upper_bound = 10000;
+
+    @Benchmark
+    public int StockKernel() {
+        int res = 0;
+        for (int i = lower_bound; i < upper_bound; i++) {
+            i = Integer.min(1179, Integer.max(1169, i));
+            res += i;
+        }
+        return res;
+    }
+
+    @Benchmark
+    public int LogicFoldingKerenl() {
+        int res = 0;
+        for (int i = lower_bound; i < upper_bound; i++) {
+            i = Integer.min(1179, Integer.max(1169, i));
+            if (Integer.bitCount(i) > 20 || Integer.bitCount(i) < 3) {
+                throw new AssertionError("Uncommon trap");
+            }
+            res += i;
+        }
+        return res;
+    }
+}
