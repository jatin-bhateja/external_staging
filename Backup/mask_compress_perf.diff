diff --git a/configure b/configure
old mode 100644
new mode 100755
diff --git a/src/hotspot/cpu/x86/c2_MacroAssembler_x86.cpp b/src/hotspot/cpu/x86/c2_MacroAssembler_x86.cpp
index a2c1559ef26..b044b1e0bf7 100644
--- a/src/hotspot/cpu/x86/c2_MacroAssembler_x86.cpp
+++ b/src/hotspot/cpu/x86/c2_MacroAssembler_x86.cpp
@@ -4111,49 +4111,6 @@ void C2_MacroAssembler::vector_mask_operation(int opc, Register dst, XMMRegister
   }
 }
 
-void C2_MacroAssembler::vector_mask_compress(XMMRegister dst, XMMRegister src, Register rtmp1,
-                                             Register rtmp2, XMMRegister xtmp, int mask_len,
-                                             int vec_enc) {
-  int index = 0;
-  int vindex = 0;
-  vpxor(xtmp, xtmp, xtmp, vec_enc);
-  vpsubb(xtmp, xtmp, src, vec_enc);
-  vpmovmskb(rtmp1, xtmp, vec_enc);
-  andq(rtmp1, (0xFFFFFFFFFFFFFFFFUL >> (64 - mask_len)));
-  mov64(rtmp2, -1L);
-  pext(rtmp2, rtmp2, rtmp1);
-  mov64(rtmp1, 0x0101010101010101L);
-  pdep(rtmp1, rtmp2, rtmp1);
-  if (mask_len > 8) {
-    movq(xtmp, rtmp1);
-  }
-  movq(dst, rtmp1);
-
-  mask_len -= 8;
-  while (mask_len > 0) {
-    assert ((mask_len & 0x7) == 0, "mask must be multiple of 8");
-    index++;
-    if ((index % 2) == 0) {
-      pxor(xtmp, xtmp);
-    }
-    mov64(rtmp1, 0x0101010101010101L);
-    shrq(rtmp2, 8);
-    pdep(rtmp1, rtmp2, rtmp1);
-    pinsrq(xtmp, rtmp1, index % 2);
-    vindex = index / 2;
-    if (vindex) {
-      // Write entire 16 byte vector when both 64 bit
-      // lanes are update to save redundant instructions.
-      if (index % 2) {
-        vinsertf128(dst, dst, xtmp, vindex);
-      }
-    } else {
-      vmovdqu(dst, xtmp);
-    }
-    mask_len -= 8;
-  }
-}
-
 void C2_MacroAssembler::vector_mask_compress(KRegister dst, KRegister src, Register rtmp1,
                                              Register rtmp2, int mask_len) {
   kmov(rtmp1, src);
diff --git a/src/hotspot/cpu/x86/c2_MacroAssembler_x86.hpp b/src/hotspot/cpu/x86/c2_MacroAssembler_x86.hpp
index 5ecef655153..352c9fc18e5 100644
--- a/src/hotspot/cpu/x86/c2_MacroAssembler_x86.hpp
+++ b/src/hotspot/cpu/x86/c2_MacroAssembler_x86.hpp
@@ -95,9 +95,6 @@ public:
   void vector_compress_expand(int opcode, XMMRegister dst, XMMRegister src, KRegister mask,
                               bool merge, BasicType bt, int vec_enc);
 
-  void vector_mask_compress(XMMRegister dst, XMMRegister src, Register rtmp1, Register rtmp2,
-                            XMMRegister xtmp, int mask_len, int vec_enc);
-
   void vector_mask_compress(KRegister dst, KRegister src, Register rtmp1, Register rtmp2, int mask_len);
 
   void vextendbw(bool sign, XMMRegister dst, XMMRegister src, int vector_len);
diff --git a/src/hotspot/cpu/x86/x86.ad b/src/hotspot/cpu/x86/x86.ad
index 57e919b9bca..6b0609e60d8 100644
--- a/src/hotspot/cpu/x86/x86.ad
+++ b/src/hotspot/cpu/x86/x86.ad
@@ -1599,6 +1599,17 @@ const bool Matcher::match_rule_supported(int opcode) {
         return false;
       }
       break;
+    case Op_CompressM:
+      if (UseAVX < 3 || !VM_Version::supports_bmi2()) {
+        return false;
+      }
+      break;
+    case Op_CompressV:
+    case Op_ExpandV:
+      if (UseAVX < 3) {
+        return false;
+      }
+      break;
   }
   return true;  // Match rules are supported by default.
 }
@@ -1835,7 +1846,7 @@ const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType
       }
       break;
     case Op_CompressM:
-      if (UseAVX < 1 || !VM_Version::supports_bmi2()) {
+      if (UseAVX < 3 || !VM_Version::supports_bmi2()) {
         return false;
       }
       break;
@@ -1947,8 +1958,6 @@ const bool Matcher::match_rule_supported_vector_masked(int opcode, int vlen, Bas
     case Op_RShiftVL:
     case Op_URShiftVI:
     case Op_URShiftVL:
-    case Op_CompressV:
-    case Op_ExpandV:
     case Op_LoadVectorMasked:
     case Op_StoreVectorMasked:
     case Op_LoadVectorGatherMasked:
@@ -8793,32 +8802,17 @@ instruct vcompress_expand_reg_evex(vec dst, vec src, kReg mask) %{
 %}
 
 instruct vcompress_mask_reg_evex(kReg dst, kReg mask, rRegL rtmp1, rRegL rtmp2, rFlagsReg cr) %{
-  predicate(n->in(1)->bottom_type()->isa_vectmask());
   match(Set dst (CompressM mask));
   effect(TEMP rtmp1, TEMP rtmp2, KILL cr);
   format %{ "mask_compress_evex $dst, $mask\t! using $rtmp1 and $rtmp2 as TEMP" %}
   ins_encode %{
+    assert(this->in(1)->bottom_type()->isa_vectmask(), "");
     int mask_len = Matcher::vector_length(this);
     __ vector_mask_compress($dst$$KRegister, $mask$$KRegister, $rtmp1$$Register, $rtmp2$$Register, mask_len);
   %}
   ins_pipe( pipe_slow );
 %}
 
-instruct vcompress_mask_reg_avx(vec dst, vec mask, rRegL rtmp1, rRegL rtmp2, vec xtmp, rFlagsReg cr) %{
-  predicate(n->in(1)->bottom_type()->isa_vectmask() == NULL);
-  match(Set dst (CompressM mask));
-  effect(TEMP dst, TEMP rtmp1, TEMP rtmp2, TEMP xtmp, KILL cr);
-  format %{ "mask_compress_avx $dst, $mask\t! using $rtmp1, $rtmp2 and $xtmp as TEMP" %}
-  ins_encode %{
-    assert(Matcher::vector_element_basic_type(this, $mask) == T_BOOLEAN, "");
-    int mask_len = Matcher::vector_length(this, $mask);
-    int vec_enc = vector_length_encoding(this);
-    __ vector_mask_compress($dst$$XMMRegister, $mask$$XMMRegister, $rtmp1$$Register,
-                            $rtmp2$$Register, $xtmp$$XMMRegister, mask_len, vec_enc);
-  %}
-  ins_pipe( pipe_slow );
-%}
-
 #endif // _LP64
 
 // ---------------------------------- Vector Masked Operations ------------------------------------
diff --git a/src/hotspot/share/opto/c2compiler.cpp b/src/hotspot/share/opto/c2compiler.cpp
index 1692476149b..34bafa20974 100644
--- a/src/hotspot/share/opto/c2compiler.cpp
+++ b/src/hotspot/share/opto/c2compiler.cpp
@@ -488,6 +488,10 @@ bool C2Compiler::is_intrinsic_supported(const methodHandle& method, bool is_virt
   case vmIntrinsics::_fsignum:
     if (!Matcher::match_rule_supported(Op_SignumF)) return false;
     break;
+  case vmIntrinsics::_VectorComExp:
+    if (!Matcher::match_rule_supported(Op_CompressM)) return false;
+    if (!Matcher::match_rule_supported(Op_CompressV)) return false;
+    break;
   case vmIntrinsics::_hashCode:
   case vmIntrinsics::_identityHashCode:
   case vmIntrinsics::_getClass:
@@ -697,7 +701,6 @@ bool C2Compiler::is_intrinsic_supported(const methodHandle& method, bool is_virt
   case vmIntrinsics::_VectorInsert:
   case vmIntrinsics::_VectorExtract:
   case vmIntrinsics::_VectorMaskOp:
-  case vmIntrinsics::_VectorComExp:
     return EnableVectorSupport;
   case vmIntrinsics::_blackhole:
     break;
diff --git a/src/hotspot/share/opto/vectorIntrinsics.cpp b/src/hotspot/share/opto/vectorIntrinsics.cpp
index f1f1e6a172f..7a6b175b55a 100644
--- a/src/hotspot/share/opto/vectorIntrinsics.cpp
+++ b/src/hotspot/share/opto/vectorIntrinsics.cpp
@@ -2750,15 +2750,7 @@ bool LibraryCallKit::inline_vector_compress_expand() {
   BasicType elem_bt = elem_type->basic_type();
   int opc = VectorSupport::vop2ideal(opr->get_con(), elem_bt);
 
-  VectorMaskUseType checkFlags = VecMaskNotUsed;
-  if (opc == Op_CompressM) {
-     checkFlags = VecMaskUseAll;
-  } else {
-     assert(opc == Op_ExpandV || opc == Op_CompressV, "");
-     checkFlags = VecMaskUseLoad;
-  }
-
-  if (!arch_supports_vector(opc, num_elem, elem_bt, checkFlags)) {
+  if (!arch_supports_vector(opc, num_elem, elem_bt, VecMaskUseLoad)) {
     if (C->print_intrinsics()) {
       tty->print_cr("  ** not supported: opc=%d vlen=%d etype=%s ismask=useload",
                     opc, num_elem, type2name(elem_bt));
@@ -2794,16 +2786,8 @@ bool LibraryCallKit::inline_vector_compress_expand() {
     return false;
   }
 
-  Node* operation = NULL;
   const TypeVect* vt = TypeVect::make(elem_bt, num_elem, opc == Op_CompressM);
-  if (opc == Op_CompressM && vt->isa_vectmask() == NULL) {
-    mask = gvn().transform(VectorStoreMaskNode::make(gvn(), mask, elem_bt, num_elem));
-    const TypeVect* ivt = TypeVect::make(T_BOOLEAN, num_elem);
-    operation = gvn().transform(VectorNode::make(opc, opd1, mask, ivt));
-    operation = gvn().transform(new VectorLoadMaskNode(operation, vt));
-  } else {
-    operation = gvn().transform(VectorNode::make(opc, opd1, mask, vt));
-  }
+  Node* operation = gvn().transform(VectorNode::make(opc, opd1, mask, vt));
 
   // Wrap it up in VectorBox to keep object type information.
   const TypeInstPtr* box_type = opc == Op_CompressM ? mbox_type : vbox_type;
diff --git a/test/jdk/jdk/incubator/vector/Byte128VectorTests.java b/test/jdk/jdk/incubator/vector/Byte128VectorTests.java
index 5320ed59931..354e718c34b 100644
--- a/test/jdk/jdk/incubator/vector/Byte128VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Byte128VectorTests.java
@@ -4275,7 +4275,7 @@ public class Byte128VectorTests extends AbstractVectorTest {
     }
 
     @Test(dataProvider = "byteUnaryOpMaskProvider")
-    static void compressMaskedByte128VectorTests(IntFunction<byte[]> fa,
+    static void compressByte128VectorTests(IntFunction<byte[]> fa,
                                                 IntFunction<boolean[]> fm) {
         byte[] a = fa.apply(SPECIES.length());
         byte[] r = fr.apply(SPECIES.length());
@@ -4292,9 +4292,8 @@ public class Byte128VectorTests extends AbstractVectorTest {
         assertcompressArraysEquals(r, a, mask, SPECIES.length());
     }
 
-
     @Test(dataProvider = "byteUnaryOpMaskProvider")
-    static void expandMaskedByte128VectorTests(IntFunction<byte[]> fa,
+    static void expandByte128VectorTests(IntFunction<byte[]> fa,
                                                 IntFunction<boolean[]> fm) {
         byte[] a = fa.apply(SPECIES.length());
         byte[] r = fr.apply(SPECIES.length());
@@ -4311,6 +4310,23 @@ public class Byte128VectorTests extends AbstractVectorTest {
         assertexpandArraysEquals(r, a, mask, SPECIES.length());
     }
 
+    @Test(dataProvider = "maskProvider")
+    static void maskCompressByte128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
+        int trueCount = 0;
+        boolean[] a = fa.apply(SPECIES.length());
+
+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                var vmask = SPECIES.loadMask(a, i);
+                trueCount = vmask.trueCount();
+                var rmask = vmask.compress();
+                for (int j = 0; j < SPECIES.length(); j++)  {
+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
+                }
+            }
+        }
+    }
+
     @Test(dataProvider = "byteUnaryOpProvider")
     static void getByte128VectorTests(IntFunction<byte[]> fa) {
         byte[] a = fa.apply(SPECIES.length());
@@ -5585,23 +5601,6 @@ public class Byte128VectorTests extends AbstractVectorTest {
         assertMaskReductionArraysEquals(r, a, Byte128VectorTests::maskFirstTrue);
     }
 
-    @Test(dataProvider = "maskProvider")
-    static void maskCompressByte128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
-        int trueCount = 0;
-        boolean[] a = fa.apply(SPECIES.length());
-
-        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
-            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                var vmask = SPECIES.loadMask(a, i);
-                trueCount = vmask.trueCount();
-                var rmask = vmask.compress();
-                for (int j = 0; j < SPECIES.length(); j++)  {
-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
-                }
-            }
-        }
-    }
-
     @DataProvider
     public static Object[][] longMaskProvider() {
         return new Object[][]{
diff --git a/test/jdk/jdk/incubator/vector/Byte256VectorTests.java b/test/jdk/jdk/incubator/vector/Byte256VectorTests.java
index 7f79083390d..f6456d0f825 100644
--- a/test/jdk/jdk/incubator/vector/Byte256VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Byte256VectorTests.java
@@ -4275,7 +4275,7 @@ public class Byte256VectorTests extends AbstractVectorTest {
     }
 
     @Test(dataProvider = "byteUnaryOpMaskProvider")
-    static void compressMaskedByte256VectorTests(IntFunction<byte[]> fa,
+    static void compressByte256VectorTests(IntFunction<byte[]> fa,
                                                 IntFunction<boolean[]> fm) {
         byte[] a = fa.apply(SPECIES.length());
         byte[] r = fr.apply(SPECIES.length());
@@ -4292,9 +4292,8 @@ public class Byte256VectorTests extends AbstractVectorTest {
         assertcompressArraysEquals(r, a, mask, SPECIES.length());
     }
 
-
     @Test(dataProvider = "byteUnaryOpMaskProvider")
-    static void expandMaskedByte256VectorTests(IntFunction<byte[]> fa,
+    static void expandByte256VectorTests(IntFunction<byte[]> fa,
                                                 IntFunction<boolean[]> fm) {
         byte[] a = fa.apply(SPECIES.length());
         byte[] r = fr.apply(SPECIES.length());
@@ -4311,6 +4310,23 @@ public class Byte256VectorTests extends AbstractVectorTest {
         assertexpandArraysEquals(r, a, mask, SPECIES.length());
     }
 
+    @Test(dataProvider = "maskProvider")
+    static void maskCompressByte256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
+        int trueCount = 0;
+        boolean[] a = fa.apply(SPECIES.length());
+
+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                var vmask = SPECIES.loadMask(a, i);
+                trueCount = vmask.trueCount();
+                var rmask = vmask.compress();
+                for (int j = 0; j < SPECIES.length(); j++)  {
+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
+                }
+            }
+        }
+    }
+
     @Test(dataProvider = "byteUnaryOpProvider")
     static void getByte256VectorTests(IntFunction<byte[]> fa) {
         byte[] a = fa.apply(SPECIES.length());
@@ -5585,23 +5601,6 @@ public class Byte256VectorTests extends AbstractVectorTest {
         assertMaskReductionArraysEquals(r, a, Byte256VectorTests::maskFirstTrue);
     }
 
-    @Test(dataProvider = "maskProvider")
-    static void maskCompressByte256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
-        int trueCount = 0;
-        boolean[] a = fa.apply(SPECIES.length());
-
-        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
-            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                var vmask = SPECIES.loadMask(a, i);
-                trueCount = vmask.trueCount();
-                var rmask = vmask.compress();
-                for (int j = 0; j < SPECIES.length(); j++)  {
-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
-                }
-            }
-        }
-    }
-
     @DataProvider
     public static Object[][] longMaskProvider() {
         return new Object[][]{
diff --git a/test/jdk/jdk/incubator/vector/Byte512VectorTests.java b/test/jdk/jdk/incubator/vector/Byte512VectorTests.java
index e7688a2f076..bd2c62f23ef 100644
--- a/test/jdk/jdk/incubator/vector/Byte512VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Byte512VectorTests.java
@@ -4275,7 +4275,7 @@ public class Byte512VectorTests extends AbstractVectorTest {
     }
 
     @Test(dataProvider = "byteUnaryOpMaskProvider")
-    static void compressMaskedByte512VectorTests(IntFunction<byte[]> fa,
+    static void compressByte512VectorTests(IntFunction<byte[]> fa,
                                                 IntFunction<boolean[]> fm) {
         byte[] a = fa.apply(SPECIES.length());
         byte[] r = fr.apply(SPECIES.length());
@@ -4292,9 +4292,8 @@ public class Byte512VectorTests extends AbstractVectorTest {
         assertcompressArraysEquals(r, a, mask, SPECIES.length());
     }
 
-
     @Test(dataProvider = "byteUnaryOpMaskProvider")
-    static void expandMaskedByte512VectorTests(IntFunction<byte[]> fa,
+    static void expandByte512VectorTests(IntFunction<byte[]> fa,
                                                 IntFunction<boolean[]> fm) {
         byte[] a = fa.apply(SPECIES.length());
         byte[] r = fr.apply(SPECIES.length());
@@ -4311,6 +4310,23 @@ public class Byte512VectorTests extends AbstractVectorTest {
         assertexpandArraysEquals(r, a, mask, SPECIES.length());
     }
 
+    @Test(dataProvider = "maskProvider")
+    static void maskCompressByte512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
+        int trueCount = 0;
+        boolean[] a = fa.apply(SPECIES.length());
+
+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                var vmask = SPECIES.loadMask(a, i);
+                trueCount = vmask.trueCount();
+                var rmask = vmask.compress();
+                for (int j = 0; j < SPECIES.length(); j++)  {
+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
+                }
+            }
+        }
+    }
+
     @Test(dataProvider = "byteUnaryOpProvider")
     static void getByte512VectorTests(IntFunction<byte[]> fa) {
         byte[] a = fa.apply(SPECIES.length());
@@ -5585,23 +5601,6 @@ public class Byte512VectorTests extends AbstractVectorTest {
         assertMaskReductionArraysEquals(r, a, Byte512VectorTests::maskFirstTrue);
     }
 
-    @Test(dataProvider = "maskProvider")
-    static void maskCompressByte512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
-        int trueCount = 0;
-        boolean[] a = fa.apply(SPECIES.length());
-
-        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
-            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                var vmask = SPECIES.loadMask(a, i);
-                trueCount = vmask.trueCount();
-                var rmask = vmask.compress();
-                for (int j = 0; j < SPECIES.length(); j++)  {
-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
-                }
-            }
-        }
-    }
-
     @DataProvider
     public static Object[][] longMaskProvider() {
         return new Object[][]{
diff --git a/test/jdk/jdk/incubator/vector/Byte64VectorTests.java b/test/jdk/jdk/incubator/vector/Byte64VectorTests.java
index cbf2a6ec347..5d315c357cc 100644
--- a/test/jdk/jdk/incubator/vector/Byte64VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Byte64VectorTests.java
@@ -4275,7 +4275,7 @@ public class Byte64VectorTests extends AbstractVectorTest {
     }
 
     @Test(dataProvider = "byteUnaryOpMaskProvider")
-    static void compressMaskedByte64VectorTests(IntFunction<byte[]> fa,
+    static void compressByte64VectorTests(IntFunction<byte[]> fa,
                                                 IntFunction<boolean[]> fm) {
         byte[] a = fa.apply(SPECIES.length());
         byte[] r = fr.apply(SPECIES.length());
@@ -4292,9 +4292,8 @@ public class Byte64VectorTests extends AbstractVectorTest {
         assertcompressArraysEquals(r, a, mask, SPECIES.length());
     }
 
-
     @Test(dataProvider = "byteUnaryOpMaskProvider")
-    static void expandMaskedByte64VectorTests(IntFunction<byte[]> fa,
+    static void expandByte64VectorTests(IntFunction<byte[]> fa,
                                                 IntFunction<boolean[]> fm) {
         byte[] a = fa.apply(SPECIES.length());
         byte[] r = fr.apply(SPECIES.length());
@@ -4311,6 +4310,23 @@ public class Byte64VectorTests extends AbstractVectorTest {
         assertexpandArraysEquals(r, a, mask, SPECIES.length());
     }
 
+    @Test(dataProvider = "maskProvider")
+    static void maskCompressByte64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
+        int trueCount = 0;
+        boolean[] a = fa.apply(SPECIES.length());
+
+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                var vmask = SPECIES.loadMask(a, i);
+                trueCount = vmask.trueCount();
+                var rmask = vmask.compress();
+                for (int j = 0; j < SPECIES.length(); j++)  {
+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
+                }
+            }
+        }
+    }
+
     @Test(dataProvider = "byteUnaryOpProvider")
     static void getByte64VectorTests(IntFunction<byte[]> fa) {
         byte[] a = fa.apply(SPECIES.length());
@@ -5585,23 +5601,6 @@ public class Byte64VectorTests extends AbstractVectorTest {
         assertMaskReductionArraysEquals(r, a, Byte64VectorTests::maskFirstTrue);
     }
 
-    @Test(dataProvider = "maskProvider")
-    static void maskCompressByte64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
-        int trueCount = 0;
-        boolean[] a = fa.apply(SPECIES.length());
-
-        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
-            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                var vmask = SPECIES.loadMask(a, i);
-                trueCount = vmask.trueCount();
-                var rmask = vmask.compress();
-                for (int j = 0; j < SPECIES.length(); j++)  {
-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
-                }
-            }
-        }
-    }
-
     @DataProvider
     public static Object[][] longMaskProvider() {
         return new Object[][]{
diff --git a/test/jdk/jdk/incubator/vector/ByteMaxVectorTests.java b/test/jdk/jdk/incubator/vector/ByteMaxVectorTests.java
index b9497844379..0cbddcddbfd 100644
--- a/test/jdk/jdk/incubator/vector/ByteMaxVectorTests.java
+++ b/test/jdk/jdk/incubator/vector/ByteMaxVectorTests.java
@@ -4280,7 +4280,7 @@ public class ByteMaxVectorTests extends AbstractVectorTest {
     }
 
     @Test(dataProvider = "byteUnaryOpMaskProvider")
-    static void compressMaskedByteMaxVectorTests(IntFunction<byte[]> fa,
+    static void compressByteMaxVectorTests(IntFunction<byte[]> fa,
                                                 IntFunction<boolean[]> fm) {
         byte[] a = fa.apply(SPECIES.length());
         byte[] r = fr.apply(SPECIES.length());
@@ -4297,9 +4297,8 @@ public class ByteMaxVectorTests extends AbstractVectorTest {
         assertcompressArraysEquals(r, a, mask, SPECIES.length());
     }
 
-
     @Test(dataProvider = "byteUnaryOpMaskProvider")
-    static void expandMaskedByteMaxVectorTests(IntFunction<byte[]> fa,
+    static void expandByteMaxVectorTests(IntFunction<byte[]> fa,
                                                 IntFunction<boolean[]> fm) {
         byte[] a = fa.apply(SPECIES.length());
         byte[] r = fr.apply(SPECIES.length());
@@ -4316,6 +4315,23 @@ public class ByteMaxVectorTests extends AbstractVectorTest {
         assertexpandArraysEquals(r, a, mask, SPECIES.length());
     }
 
+    @Test(dataProvider = "maskProvider")
+    static void maskCompressByteMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {
+        int trueCount = 0;
+        boolean[] a = fa.apply(SPECIES.length());
+
+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                var vmask = SPECIES.loadMask(a, i);
+                trueCount = vmask.trueCount();
+                var rmask = vmask.compress();
+                for (int j = 0; j < SPECIES.length(); j++)  {
+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
+                }
+            }
+        }
+    }
+
     @Test(dataProvider = "byteUnaryOpProvider")
     static void getByteMaxVectorTests(IntFunction<byte[]> fa) {
         byte[] a = fa.apply(SPECIES.length());
@@ -5590,23 +5606,6 @@ public class ByteMaxVectorTests extends AbstractVectorTest {
         assertMaskReductionArraysEquals(r, a, ByteMaxVectorTests::maskFirstTrue);
     }
 
-    @Test(dataProvider = "maskProvider")
-    static void maskCompressByteMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {
-        int trueCount = 0;
-        boolean[] a = fa.apply(SPECIES.length());
-
-        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
-            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                var vmask = SPECIES.loadMask(a, i);
-                trueCount = vmask.trueCount();
-                var rmask = vmask.compress();
-                for (int j = 0; j < SPECIES.length(); j++)  {
-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
-                }
-            }
-        }
-    }
-
 
     @DataProvider
     public static Object[][] offsetProvider() {
diff --git a/test/jdk/jdk/incubator/vector/Double128VectorTests.java b/test/jdk/jdk/incubator/vector/Double128VectorTests.java
index a682b644164..1473acc79f4 100644
--- a/test/jdk/jdk/incubator/vector/Double128VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Double128VectorTests.java
@@ -3225,7 +3225,7 @@ public class Double128VectorTests extends AbstractVectorTest {
     }
 
     @Test(dataProvider = "doubleUnaryOpMaskProvider")
-    static void compressMaskedDouble128VectorTests(IntFunction<double[]> fa,
+    static void compressDouble128VectorTests(IntFunction<double[]> fa,
                                                 IntFunction<boolean[]> fm) {
         double[] a = fa.apply(SPECIES.length());
         double[] r = fr.apply(SPECIES.length());
@@ -3242,9 +3242,8 @@ public class Double128VectorTests extends AbstractVectorTest {
         assertcompressArraysEquals(r, a, mask, SPECIES.length());
     }
 
-
     @Test(dataProvider = "doubleUnaryOpMaskProvider")
-    static void expandMaskedDouble128VectorTests(IntFunction<double[]> fa,
+    static void expandDouble128VectorTests(IntFunction<double[]> fa,
                                                 IntFunction<boolean[]> fm) {
         double[] a = fa.apply(SPECIES.length());
         double[] r = fr.apply(SPECIES.length());
@@ -3261,6 +3260,23 @@ public class Double128VectorTests extends AbstractVectorTest {
         assertexpandArraysEquals(r, a, mask, SPECIES.length());
     }
 
+    @Test(dataProvider = "maskProvider")
+    static void maskCompressDouble128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
+        int trueCount = 0;
+        boolean[] a = fa.apply(SPECIES.length());
+
+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                var vmask = SPECIES.loadMask(a, i);
+                trueCount = vmask.trueCount();
+                var rmask = vmask.compress();
+                for (int j = 0; j < SPECIES.length(); j++)  {
+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
+                }
+            }
+        }
+    }
+
     @Test(dataProvider = "doubleUnaryOpProvider")
     static void getDouble128VectorTests(IntFunction<double[]> fa) {
         double[] a = fa.apply(SPECIES.length());
@@ -4964,23 +4980,6 @@ public class Double128VectorTests extends AbstractVectorTest {
         assertMaskReductionArraysEquals(r, a, Double128VectorTests::maskFirstTrue);
     }
 
-    @Test(dataProvider = "maskProvider")
-    static void maskCompressDouble128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
-        int trueCount = 0;
-        boolean[] a = fa.apply(SPECIES.length());
-
-        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
-            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                var vmask = SPECIES.loadMask(a, i);
-                trueCount = vmask.trueCount();
-                var rmask = vmask.compress();
-                for (int j = 0; j < SPECIES.length(); j++)  {
-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
-                }
-            }
-        }
-    }
-
     @DataProvider
     public static Object[][] longMaskProvider() {
         return new Object[][]{
diff --git a/test/jdk/jdk/incubator/vector/Double256VectorTests.java b/test/jdk/jdk/incubator/vector/Double256VectorTests.java
index ab7e2a7c210..9f0381df157 100644
--- a/test/jdk/jdk/incubator/vector/Double256VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Double256VectorTests.java
@@ -3225,7 +3225,7 @@ public class Double256VectorTests extends AbstractVectorTest {
     }
 
     @Test(dataProvider = "doubleUnaryOpMaskProvider")
-    static void compressMaskedDouble256VectorTests(IntFunction<double[]> fa,
+    static void compressDouble256VectorTests(IntFunction<double[]> fa,
                                                 IntFunction<boolean[]> fm) {
         double[] a = fa.apply(SPECIES.length());
         double[] r = fr.apply(SPECIES.length());
@@ -3242,9 +3242,8 @@ public class Double256VectorTests extends AbstractVectorTest {
         assertcompressArraysEquals(r, a, mask, SPECIES.length());
     }
 
-
     @Test(dataProvider = "doubleUnaryOpMaskProvider")
-    static void expandMaskedDouble256VectorTests(IntFunction<double[]> fa,
+    static void expandDouble256VectorTests(IntFunction<double[]> fa,
                                                 IntFunction<boolean[]> fm) {
         double[] a = fa.apply(SPECIES.length());
         double[] r = fr.apply(SPECIES.length());
@@ -3261,6 +3260,23 @@ public class Double256VectorTests extends AbstractVectorTest {
         assertexpandArraysEquals(r, a, mask, SPECIES.length());
     }
 
+    @Test(dataProvider = "maskProvider")
+    static void maskCompressDouble256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
+        int trueCount = 0;
+        boolean[] a = fa.apply(SPECIES.length());
+
+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                var vmask = SPECIES.loadMask(a, i);
+                trueCount = vmask.trueCount();
+                var rmask = vmask.compress();
+                for (int j = 0; j < SPECIES.length(); j++)  {
+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
+                }
+            }
+        }
+    }
+
     @Test(dataProvider = "doubleUnaryOpProvider")
     static void getDouble256VectorTests(IntFunction<double[]> fa) {
         double[] a = fa.apply(SPECIES.length());
@@ -4964,23 +4980,6 @@ public class Double256VectorTests extends AbstractVectorTest {
         assertMaskReductionArraysEquals(r, a, Double256VectorTests::maskFirstTrue);
     }
 
-    @Test(dataProvider = "maskProvider")
-    static void maskCompressDouble256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
-        int trueCount = 0;
-        boolean[] a = fa.apply(SPECIES.length());
-
-        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
-            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                var vmask = SPECIES.loadMask(a, i);
-                trueCount = vmask.trueCount();
-                var rmask = vmask.compress();
-                for (int j = 0; j < SPECIES.length(); j++)  {
-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
-                }
-            }
-        }
-    }
-
     @DataProvider
     public static Object[][] longMaskProvider() {
         return new Object[][]{
diff --git a/test/jdk/jdk/incubator/vector/Double512VectorTests.java b/test/jdk/jdk/incubator/vector/Double512VectorTests.java
index 122ac93a69a..5e6008f8686 100644
--- a/test/jdk/jdk/incubator/vector/Double512VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Double512VectorTests.java
@@ -3225,7 +3225,7 @@ public class Double512VectorTests extends AbstractVectorTest {
     }
 
     @Test(dataProvider = "doubleUnaryOpMaskProvider")
-    static void compressMaskedDouble512VectorTests(IntFunction<double[]> fa,
+    static void compressDouble512VectorTests(IntFunction<double[]> fa,
                                                 IntFunction<boolean[]> fm) {
         double[] a = fa.apply(SPECIES.length());
         double[] r = fr.apply(SPECIES.length());
@@ -3242,9 +3242,8 @@ public class Double512VectorTests extends AbstractVectorTest {
         assertcompressArraysEquals(r, a, mask, SPECIES.length());
     }
 
-
     @Test(dataProvider = "doubleUnaryOpMaskProvider")
-    static void expandMaskedDouble512VectorTests(IntFunction<double[]> fa,
+    static void expandDouble512VectorTests(IntFunction<double[]> fa,
                                                 IntFunction<boolean[]> fm) {
         double[] a = fa.apply(SPECIES.length());
         double[] r = fr.apply(SPECIES.length());
@@ -3261,6 +3260,23 @@ public class Double512VectorTests extends AbstractVectorTest {
         assertexpandArraysEquals(r, a, mask, SPECIES.length());
     }
 
+    @Test(dataProvider = "maskProvider")
+    static void maskCompressDouble512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
+        int trueCount = 0;
+        boolean[] a = fa.apply(SPECIES.length());
+
+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                var vmask = SPECIES.loadMask(a, i);
+                trueCount = vmask.trueCount();
+                var rmask = vmask.compress();
+                for (int j = 0; j < SPECIES.length(); j++)  {
+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
+                }
+            }
+        }
+    }
+
     @Test(dataProvider = "doubleUnaryOpProvider")
     static void getDouble512VectorTests(IntFunction<double[]> fa) {
         double[] a = fa.apply(SPECIES.length());
@@ -4964,23 +4980,6 @@ public class Double512VectorTests extends AbstractVectorTest {
         assertMaskReductionArraysEquals(r, a, Double512VectorTests::maskFirstTrue);
     }
 
-    @Test(dataProvider = "maskProvider")
-    static void maskCompressDouble512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
-        int trueCount = 0;
-        boolean[] a = fa.apply(SPECIES.length());
-
-        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
-            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                var vmask = SPECIES.loadMask(a, i);
-                trueCount = vmask.trueCount();
-                var rmask = vmask.compress();
-                for (int j = 0; j < SPECIES.length(); j++)  {
-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
-                }
-            }
-        }
-    }
-
     @DataProvider
     public static Object[][] longMaskProvider() {
         return new Object[][]{
diff --git a/test/jdk/jdk/incubator/vector/Double64VectorTests.java b/test/jdk/jdk/incubator/vector/Double64VectorTests.java
index 1a242da3759..1b0ff0e488a 100644
--- a/test/jdk/jdk/incubator/vector/Double64VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Double64VectorTests.java
@@ -3225,7 +3225,7 @@ public class Double64VectorTests extends AbstractVectorTest {
     }
 
     @Test(dataProvider = "doubleUnaryOpMaskProvider")
-    static void compressMaskedDouble64VectorTests(IntFunction<double[]> fa,
+    static void compressDouble64VectorTests(IntFunction<double[]> fa,
                                                 IntFunction<boolean[]> fm) {
         double[] a = fa.apply(SPECIES.length());
         double[] r = fr.apply(SPECIES.length());
@@ -3242,9 +3242,8 @@ public class Double64VectorTests extends AbstractVectorTest {
         assertcompressArraysEquals(r, a, mask, SPECIES.length());
     }
 
-
     @Test(dataProvider = "doubleUnaryOpMaskProvider")
-    static void expandMaskedDouble64VectorTests(IntFunction<double[]> fa,
+    static void expandDouble64VectorTests(IntFunction<double[]> fa,
                                                 IntFunction<boolean[]> fm) {
         double[] a = fa.apply(SPECIES.length());
         double[] r = fr.apply(SPECIES.length());
@@ -3261,6 +3260,23 @@ public class Double64VectorTests extends AbstractVectorTest {
         assertexpandArraysEquals(r, a, mask, SPECIES.length());
     }
 
+    @Test(dataProvider = "maskProvider")
+    static void maskCompressDouble64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
+        int trueCount = 0;
+        boolean[] a = fa.apply(SPECIES.length());
+
+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                var vmask = SPECIES.loadMask(a, i);
+                trueCount = vmask.trueCount();
+                var rmask = vmask.compress();
+                for (int j = 0; j < SPECIES.length(); j++)  {
+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
+                }
+            }
+        }
+    }
+
     @Test(dataProvider = "doubleUnaryOpProvider")
     static void getDouble64VectorTests(IntFunction<double[]> fa) {
         double[] a = fa.apply(SPECIES.length());
@@ -4964,23 +4980,6 @@ public class Double64VectorTests extends AbstractVectorTest {
         assertMaskReductionArraysEquals(r, a, Double64VectorTests::maskFirstTrue);
     }
 
-    @Test(dataProvider = "maskProvider")
-    static void maskCompressDouble64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
-        int trueCount = 0;
-        boolean[] a = fa.apply(SPECIES.length());
-
-        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
-            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                var vmask = SPECIES.loadMask(a, i);
-                trueCount = vmask.trueCount();
-                var rmask = vmask.compress();
-                for (int j = 0; j < SPECIES.length(); j++)  {
-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
-                }
-            }
-        }
-    }
-
     @DataProvider
     public static Object[][] longMaskProvider() {
         return new Object[][]{
diff --git a/test/jdk/jdk/incubator/vector/DoubleMaxVectorTests.java b/test/jdk/jdk/incubator/vector/DoubleMaxVectorTests.java
index d446cc9419b..6a3a3094522 100644
--- a/test/jdk/jdk/incubator/vector/DoubleMaxVectorTests.java
+++ b/test/jdk/jdk/incubator/vector/DoubleMaxVectorTests.java
@@ -3230,7 +3230,7 @@ public class DoubleMaxVectorTests extends AbstractVectorTest {
     }
 
     @Test(dataProvider = "doubleUnaryOpMaskProvider")
-    static void compressMaskedDoubleMaxVectorTests(IntFunction<double[]> fa,
+    static void compressDoubleMaxVectorTests(IntFunction<double[]> fa,
                                                 IntFunction<boolean[]> fm) {
         double[] a = fa.apply(SPECIES.length());
         double[] r = fr.apply(SPECIES.length());
@@ -3247,9 +3247,8 @@ public class DoubleMaxVectorTests extends AbstractVectorTest {
         assertcompressArraysEquals(r, a, mask, SPECIES.length());
     }
 
-
     @Test(dataProvider = "doubleUnaryOpMaskProvider")
-    static void expandMaskedDoubleMaxVectorTests(IntFunction<double[]> fa,
+    static void expandDoubleMaxVectorTests(IntFunction<double[]> fa,
                                                 IntFunction<boolean[]> fm) {
         double[] a = fa.apply(SPECIES.length());
         double[] r = fr.apply(SPECIES.length());
@@ -3266,6 +3265,23 @@ public class DoubleMaxVectorTests extends AbstractVectorTest {
         assertexpandArraysEquals(r, a, mask, SPECIES.length());
     }
 
+    @Test(dataProvider = "maskProvider")
+    static void maskCompressDoubleMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {
+        int trueCount = 0;
+        boolean[] a = fa.apply(SPECIES.length());
+
+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                var vmask = SPECIES.loadMask(a, i);
+                trueCount = vmask.trueCount();
+                var rmask = vmask.compress();
+                for (int j = 0; j < SPECIES.length(); j++)  {
+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
+                }
+            }
+        }
+    }
+
     @Test(dataProvider = "doubleUnaryOpProvider")
     static void getDoubleMaxVectorTests(IntFunction<double[]> fa) {
         double[] a = fa.apply(SPECIES.length());
@@ -4969,23 +4985,6 @@ public class DoubleMaxVectorTests extends AbstractVectorTest {
         assertMaskReductionArraysEquals(r, a, DoubleMaxVectorTests::maskFirstTrue);
     }
 
-    @Test(dataProvider = "maskProvider")
-    static void maskCompressDoubleMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {
-        int trueCount = 0;
-        boolean[] a = fa.apply(SPECIES.length());
-
-        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
-            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                var vmask = SPECIES.loadMask(a, i);
-                trueCount = vmask.trueCount();
-                var rmask = vmask.compress();
-                for (int j = 0; j < SPECIES.length(); j++)  {
-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
-                }
-            }
-        }
-    }
-
 
     @DataProvider
     public static Object[][] offsetProvider() {
diff --git a/test/jdk/jdk/incubator/vector/Float128VectorTests.java b/test/jdk/jdk/incubator/vector/Float128VectorTests.java
index 4362266fe2a..d32582bc8ec 100644
--- a/test/jdk/jdk/incubator/vector/Float128VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Float128VectorTests.java
@@ -3235,7 +3235,7 @@ public class Float128VectorTests extends AbstractVectorTest {
     }
 
     @Test(dataProvider = "floatUnaryOpMaskProvider")
-    static void compressMaskedFloat128VectorTests(IntFunction<float[]> fa,
+    static void compressFloat128VectorTests(IntFunction<float[]> fa,
                                                 IntFunction<boolean[]> fm) {
         float[] a = fa.apply(SPECIES.length());
         float[] r = fr.apply(SPECIES.length());
@@ -3252,9 +3252,8 @@ public class Float128VectorTests extends AbstractVectorTest {
         assertcompressArraysEquals(r, a, mask, SPECIES.length());
     }
 
-
     @Test(dataProvider = "floatUnaryOpMaskProvider")
-    static void expandMaskedFloat128VectorTests(IntFunction<float[]> fa,
+    static void expandFloat128VectorTests(IntFunction<float[]> fa,
                                                 IntFunction<boolean[]> fm) {
         float[] a = fa.apply(SPECIES.length());
         float[] r = fr.apply(SPECIES.length());
@@ -3271,6 +3270,23 @@ public class Float128VectorTests extends AbstractVectorTest {
         assertexpandArraysEquals(r, a, mask, SPECIES.length());
     }
 
+    @Test(dataProvider = "maskProvider")
+    static void maskCompressFloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
+        int trueCount = 0;
+        boolean[] a = fa.apply(SPECIES.length());
+
+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                var vmask = SPECIES.loadMask(a, i);
+                trueCount = vmask.trueCount();
+                var rmask = vmask.compress();
+                for (int j = 0; j < SPECIES.length(); j++)  {
+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
+                }
+            }
+        }
+    }
+
     @Test(dataProvider = "floatUnaryOpProvider")
     static void getFloat128VectorTests(IntFunction<float[]> fa) {
         float[] a = fa.apply(SPECIES.length());
@@ -4942,23 +4958,6 @@ public class Float128VectorTests extends AbstractVectorTest {
         assertMaskReductionArraysEquals(r, a, Float128VectorTests::maskFirstTrue);
     }
 
-    @Test(dataProvider = "maskProvider")
-    static void maskCompressFloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
-        int trueCount = 0;
-        boolean[] a = fa.apply(SPECIES.length());
-
-        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
-            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                var vmask = SPECIES.loadMask(a, i);
-                trueCount = vmask.trueCount();
-                var rmask = vmask.compress();
-                for (int j = 0; j < SPECIES.length(); j++)  {
-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
-                }
-            }
-        }
-    }
-
     @DataProvider
     public static Object[][] longMaskProvider() {
         return new Object[][]{
diff --git a/test/jdk/jdk/incubator/vector/Float256VectorTests.java b/test/jdk/jdk/incubator/vector/Float256VectorTests.java
index d37f805182a..e32e91e703b 100644
--- a/test/jdk/jdk/incubator/vector/Float256VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Float256VectorTests.java
@@ -3235,7 +3235,7 @@ public class Float256VectorTests extends AbstractVectorTest {
     }
 
     @Test(dataProvider = "floatUnaryOpMaskProvider")
-    static void compressMaskedFloat256VectorTests(IntFunction<float[]> fa,
+    static void compressFloat256VectorTests(IntFunction<float[]> fa,
                                                 IntFunction<boolean[]> fm) {
         float[] a = fa.apply(SPECIES.length());
         float[] r = fr.apply(SPECIES.length());
@@ -3252,9 +3252,8 @@ public class Float256VectorTests extends AbstractVectorTest {
         assertcompressArraysEquals(r, a, mask, SPECIES.length());
     }
 
-
     @Test(dataProvider = "floatUnaryOpMaskProvider")
-    static void expandMaskedFloat256VectorTests(IntFunction<float[]> fa,
+    static void expandFloat256VectorTests(IntFunction<float[]> fa,
                                                 IntFunction<boolean[]> fm) {
         float[] a = fa.apply(SPECIES.length());
         float[] r = fr.apply(SPECIES.length());
@@ -3271,6 +3270,23 @@ public class Float256VectorTests extends AbstractVectorTest {
         assertexpandArraysEquals(r, a, mask, SPECIES.length());
     }
 
+    @Test(dataProvider = "maskProvider")
+    static void maskCompressFloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
+        int trueCount = 0;
+        boolean[] a = fa.apply(SPECIES.length());
+
+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                var vmask = SPECIES.loadMask(a, i);
+                trueCount = vmask.trueCount();
+                var rmask = vmask.compress();
+                for (int j = 0; j < SPECIES.length(); j++)  {
+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
+                }
+            }
+        }
+    }
+
     @Test(dataProvider = "floatUnaryOpProvider")
     static void getFloat256VectorTests(IntFunction<float[]> fa) {
         float[] a = fa.apply(SPECIES.length());
@@ -4942,23 +4958,6 @@ public class Float256VectorTests extends AbstractVectorTest {
         assertMaskReductionArraysEquals(r, a, Float256VectorTests::maskFirstTrue);
     }
 
-    @Test(dataProvider = "maskProvider")
-    static void maskCompressFloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
-        int trueCount = 0;
-        boolean[] a = fa.apply(SPECIES.length());
-
-        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
-            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                var vmask = SPECIES.loadMask(a, i);
-                trueCount = vmask.trueCount();
-                var rmask = vmask.compress();
-                for (int j = 0; j < SPECIES.length(); j++)  {
-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
-                }
-            }
-        }
-    }
-
     @DataProvider
     public static Object[][] longMaskProvider() {
         return new Object[][]{
diff --git a/test/jdk/jdk/incubator/vector/Float512VectorTests.java b/test/jdk/jdk/incubator/vector/Float512VectorTests.java
index 44b0bdd5eef..09a7e7bcc0b 100644
--- a/test/jdk/jdk/incubator/vector/Float512VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Float512VectorTests.java
@@ -3235,7 +3235,7 @@ public class Float512VectorTests extends AbstractVectorTest {
     }
 
     @Test(dataProvider = "floatUnaryOpMaskProvider")
-    static void compressMaskedFloat512VectorTests(IntFunction<float[]> fa,
+    static void compressFloat512VectorTests(IntFunction<float[]> fa,
                                                 IntFunction<boolean[]> fm) {
         float[] a = fa.apply(SPECIES.length());
         float[] r = fr.apply(SPECIES.length());
@@ -3252,9 +3252,8 @@ public class Float512VectorTests extends AbstractVectorTest {
         assertcompressArraysEquals(r, a, mask, SPECIES.length());
     }
 
-
     @Test(dataProvider = "floatUnaryOpMaskProvider")
-    static void expandMaskedFloat512VectorTests(IntFunction<float[]> fa,
+    static void expandFloat512VectorTests(IntFunction<float[]> fa,
                                                 IntFunction<boolean[]> fm) {
         float[] a = fa.apply(SPECIES.length());
         float[] r = fr.apply(SPECIES.length());
@@ -3271,6 +3270,23 @@ public class Float512VectorTests extends AbstractVectorTest {
         assertexpandArraysEquals(r, a, mask, SPECIES.length());
     }
 
+    @Test(dataProvider = "maskProvider")
+    static void maskCompressFloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
+        int trueCount = 0;
+        boolean[] a = fa.apply(SPECIES.length());
+
+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                var vmask = SPECIES.loadMask(a, i);
+                trueCount = vmask.trueCount();
+                var rmask = vmask.compress();
+                for (int j = 0; j < SPECIES.length(); j++)  {
+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
+                }
+            }
+        }
+    }
+
     @Test(dataProvider = "floatUnaryOpProvider")
     static void getFloat512VectorTests(IntFunction<float[]> fa) {
         float[] a = fa.apply(SPECIES.length());
@@ -4942,23 +4958,6 @@ public class Float512VectorTests extends AbstractVectorTest {
         assertMaskReductionArraysEquals(r, a, Float512VectorTests::maskFirstTrue);
     }
 
-    @Test(dataProvider = "maskProvider")
-    static void maskCompressFloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
-        int trueCount = 0;
-        boolean[] a = fa.apply(SPECIES.length());
-
-        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
-            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                var vmask = SPECIES.loadMask(a, i);
-                trueCount = vmask.trueCount();
-                var rmask = vmask.compress();
-                for (int j = 0; j < SPECIES.length(); j++)  {
-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
-                }
-            }
-        }
-    }
-
     @DataProvider
     public static Object[][] longMaskProvider() {
         return new Object[][]{
diff --git a/test/jdk/jdk/incubator/vector/Float64VectorTests.java b/test/jdk/jdk/incubator/vector/Float64VectorTests.java
index 66b96ceb243..925d65b71dc 100644
--- a/test/jdk/jdk/incubator/vector/Float64VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Float64VectorTests.java
@@ -3235,7 +3235,7 @@ public class Float64VectorTests extends AbstractVectorTest {
     }
 
     @Test(dataProvider = "floatUnaryOpMaskProvider")
-    static void compressMaskedFloat64VectorTests(IntFunction<float[]> fa,
+    static void compressFloat64VectorTests(IntFunction<float[]> fa,
                                                 IntFunction<boolean[]> fm) {
         float[] a = fa.apply(SPECIES.length());
         float[] r = fr.apply(SPECIES.length());
@@ -3252,9 +3252,8 @@ public class Float64VectorTests extends AbstractVectorTest {
         assertcompressArraysEquals(r, a, mask, SPECIES.length());
     }
 
-
     @Test(dataProvider = "floatUnaryOpMaskProvider")
-    static void expandMaskedFloat64VectorTests(IntFunction<float[]> fa,
+    static void expandFloat64VectorTests(IntFunction<float[]> fa,
                                                 IntFunction<boolean[]> fm) {
         float[] a = fa.apply(SPECIES.length());
         float[] r = fr.apply(SPECIES.length());
@@ -3271,6 +3270,23 @@ public class Float64VectorTests extends AbstractVectorTest {
         assertexpandArraysEquals(r, a, mask, SPECIES.length());
     }
 
+    @Test(dataProvider = "maskProvider")
+    static void maskCompressFloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
+        int trueCount = 0;
+        boolean[] a = fa.apply(SPECIES.length());
+
+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                var vmask = SPECIES.loadMask(a, i);
+                trueCount = vmask.trueCount();
+                var rmask = vmask.compress();
+                for (int j = 0; j < SPECIES.length(); j++)  {
+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
+                }
+            }
+        }
+    }
+
     @Test(dataProvider = "floatUnaryOpProvider")
     static void getFloat64VectorTests(IntFunction<float[]> fa) {
         float[] a = fa.apply(SPECIES.length());
@@ -4942,23 +4958,6 @@ public class Float64VectorTests extends AbstractVectorTest {
         assertMaskReductionArraysEquals(r, a, Float64VectorTests::maskFirstTrue);
     }
 
-    @Test(dataProvider = "maskProvider")
-    static void maskCompressFloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
-        int trueCount = 0;
-        boolean[] a = fa.apply(SPECIES.length());
-
-        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
-            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                var vmask = SPECIES.loadMask(a, i);
-                trueCount = vmask.trueCount();
-                var rmask = vmask.compress();
-                for (int j = 0; j < SPECIES.length(); j++)  {
-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
-                }
-            }
-        }
-    }
-
     @DataProvider
     public static Object[][] longMaskProvider() {
         return new Object[][]{
diff --git a/test/jdk/jdk/incubator/vector/FloatMaxVectorTests.java b/test/jdk/jdk/incubator/vector/FloatMaxVectorTests.java
index 1affa26d1fd..7c6c00263e8 100644
--- a/test/jdk/jdk/incubator/vector/FloatMaxVectorTests.java
+++ b/test/jdk/jdk/incubator/vector/FloatMaxVectorTests.java
@@ -3240,7 +3240,7 @@ public class FloatMaxVectorTests extends AbstractVectorTest {
     }
 
     @Test(dataProvider = "floatUnaryOpMaskProvider")
-    static void compressMaskedFloatMaxVectorTests(IntFunction<float[]> fa,
+    static void compressFloatMaxVectorTests(IntFunction<float[]> fa,
                                                 IntFunction<boolean[]> fm) {
         float[] a = fa.apply(SPECIES.length());
         float[] r = fr.apply(SPECIES.length());
@@ -3257,9 +3257,8 @@ public class FloatMaxVectorTests extends AbstractVectorTest {
         assertcompressArraysEquals(r, a, mask, SPECIES.length());
     }
 
-
     @Test(dataProvider = "floatUnaryOpMaskProvider")
-    static void expandMaskedFloatMaxVectorTests(IntFunction<float[]> fa,
+    static void expandFloatMaxVectorTests(IntFunction<float[]> fa,
                                                 IntFunction<boolean[]> fm) {
         float[] a = fa.apply(SPECIES.length());
         float[] r = fr.apply(SPECIES.length());
@@ -3276,6 +3275,23 @@ public class FloatMaxVectorTests extends AbstractVectorTest {
         assertexpandArraysEquals(r, a, mask, SPECIES.length());
     }
 
+    @Test(dataProvider = "maskProvider")
+    static void maskCompressFloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {
+        int trueCount = 0;
+        boolean[] a = fa.apply(SPECIES.length());
+
+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                var vmask = SPECIES.loadMask(a, i);
+                trueCount = vmask.trueCount();
+                var rmask = vmask.compress();
+                for (int j = 0; j < SPECIES.length(); j++)  {
+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
+                }
+            }
+        }
+    }
+
     @Test(dataProvider = "floatUnaryOpProvider")
     static void getFloatMaxVectorTests(IntFunction<float[]> fa) {
         float[] a = fa.apply(SPECIES.length());
@@ -4947,23 +4963,6 @@ public class FloatMaxVectorTests extends AbstractVectorTest {
         assertMaskReductionArraysEquals(r, a, FloatMaxVectorTests::maskFirstTrue);
     }
 
-    @Test(dataProvider = "maskProvider")
-    static void maskCompressFloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {
-        int trueCount = 0;
-        boolean[] a = fa.apply(SPECIES.length());
-
-        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
-            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                var vmask = SPECIES.loadMask(a, i);
-                trueCount = vmask.trueCount();
-                var rmask = vmask.compress();
-                for (int j = 0; j < SPECIES.length(); j++)  {
-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
-                }
-            }
-        }
-    }
-
 
     @DataProvider
     public static Object[][] offsetProvider() {
diff --git a/test/jdk/jdk/incubator/vector/Int128VectorTests.java b/test/jdk/jdk/incubator/vector/Int128VectorTests.java
index 828dfe53a2f..9ce75125fb9 100644
--- a/test/jdk/jdk/incubator/vector/Int128VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Int128VectorTests.java
@@ -4240,7 +4240,7 @@ public class Int128VectorTests extends AbstractVectorTest {
     }
 
     @Test(dataProvider = "intUnaryOpMaskProvider")
-    static void compressMaskedInt128VectorTests(IntFunction<int[]> fa,
+    static void compressInt128VectorTests(IntFunction<int[]> fa,
                                                 IntFunction<boolean[]> fm) {
         int[] a = fa.apply(SPECIES.length());
         int[] r = fr.apply(SPECIES.length());
@@ -4257,9 +4257,8 @@ public class Int128VectorTests extends AbstractVectorTest {
         assertcompressArraysEquals(r, a, mask, SPECIES.length());
     }
 
-
     @Test(dataProvider = "intUnaryOpMaskProvider")
-    static void expandMaskedInt128VectorTests(IntFunction<int[]> fa,
+    static void expandInt128VectorTests(IntFunction<int[]> fa,
                                                 IntFunction<boolean[]> fm) {
         int[] a = fa.apply(SPECIES.length());
         int[] r = fr.apply(SPECIES.length());
@@ -4276,6 +4275,23 @@ public class Int128VectorTests extends AbstractVectorTest {
         assertexpandArraysEquals(r, a, mask, SPECIES.length());
     }
 
+    @Test(dataProvider = "maskProvider")
+    static void maskCompressInt128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
+        int trueCount = 0;
+        boolean[] a = fa.apply(SPECIES.length());
+
+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                var vmask = SPECIES.loadMask(a, i);
+                trueCount = vmask.trueCount();
+                var rmask = vmask.compress();
+                for (int j = 0; j < SPECIES.length(); j++)  {
+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
+                }
+            }
+        }
+    }
+
     @Test(dataProvider = "intUnaryOpProvider")
     static void getInt128VectorTests(IntFunction<int[]> fa) {
         int[] a = fa.apply(SPECIES.length());
@@ -5539,23 +5555,6 @@ public class Int128VectorTests extends AbstractVectorTest {
         assertMaskReductionArraysEquals(r, a, Int128VectorTests::maskFirstTrue);
     }
 
-    @Test(dataProvider = "maskProvider")
-    static void maskCompressInt128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
-        int trueCount = 0;
-        boolean[] a = fa.apply(SPECIES.length());
-
-        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
-            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                var vmask = SPECIES.loadMask(a, i);
-                trueCount = vmask.trueCount();
-                var rmask = vmask.compress();
-                for (int j = 0; j < SPECIES.length(); j++)  {
-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
-                }
-            }
-        }
-    }
-
     @DataProvider
     public static Object[][] longMaskProvider() {
         return new Object[][]{
diff --git a/test/jdk/jdk/incubator/vector/Int256VectorTests.java b/test/jdk/jdk/incubator/vector/Int256VectorTests.java
index ae853fb0576..701a4db3a25 100644
--- a/test/jdk/jdk/incubator/vector/Int256VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Int256VectorTests.java
@@ -4240,7 +4240,7 @@ public class Int256VectorTests extends AbstractVectorTest {
     }
 
     @Test(dataProvider = "intUnaryOpMaskProvider")
-    static void compressMaskedInt256VectorTests(IntFunction<int[]> fa,
+    static void compressInt256VectorTests(IntFunction<int[]> fa,
                                                 IntFunction<boolean[]> fm) {
         int[] a = fa.apply(SPECIES.length());
         int[] r = fr.apply(SPECIES.length());
@@ -4257,9 +4257,8 @@ public class Int256VectorTests extends AbstractVectorTest {
         assertcompressArraysEquals(r, a, mask, SPECIES.length());
     }
 
-
     @Test(dataProvider = "intUnaryOpMaskProvider")
-    static void expandMaskedInt256VectorTests(IntFunction<int[]> fa,
+    static void expandInt256VectorTests(IntFunction<int[]> fa,
                                                 IntFunction<boolean[]> fm) {
         int[] a = fa.apply(SPECIES.length());
         int[] r = fr.apply(SPECIES.length());
@@ -4276,6 +4275,23 @@ public class Int256VectorTests extends AbstractVectorTest {
         assertexpandArraysEquals(r, a, mask, SPECIES.length());
     }
 
+    @Test(dataProvider = "maskProvider")
+    static void maskCompressInt256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
+        int trueCount = 0;
+        boolean[] a = fa.apply(SPECIES.length());
+
+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                var vmask = SPECIES.loadMask(a, i);
+                trueCount = vmask.trueCount();
+                var rmask = vmask.compress();
+                for (int j = 0; j < SPECIES.length(); j++)  {
+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
+                }
+            }
+        }
+    }
+
     @Test(dataProvider = "intUnaryOpProvider")
     static void getInt256VectorTests(IntFunction<int[]> fa) {
         int[] a = fa.apply(SPECIES.length());
@@ -5539,23 +5555,6 @@ public class Int256VectorTests extends AbstractVectorTest {
         assertMaskReductionArraysEquals(r, a, Int256VectorTests::maskFirstTrue);
     }
 
-    @Test(dataProvider = "maskProvider")
-    static void maskCompressInt256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
-        int trueCount = 0;
-        boolean[] a = fa.apply(SPECIES.length());
-
-        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
-            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                var vmask = SPECIES.loadMask(a, i);
-                trueCount = vmask.trueCount();
-                var rmask = vmask.compress();
-                for (int j = 0; j < SPECIES.length(); j++)  {
-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
-                }
-            }
-        }
-    }
-
     @DataProvider
     public static Object[][] longMaskProvider() {
         return new Object[][]{
diff --git a/test/jdk/jdk/incubator/vector/Int512VectorTests.java b/test/jdk/jdk/incubator/vector/Int512VectorTests.java
index d5be277dc6a..589813b5bd1 100644
--- a/test/jdk/jdk/incubator/vector/Int512VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Int512VectorTests.java
@@ -4240,7 +4240,7 @@ public class Int512VectorTests extends AbstractVectorTest {
     }
 
     @Test(dataProvider = "intUnaryOpMaskProvider")
-    static void compressMaskedInt512VectorTests(IntFunction<int[]> fa,
+    static void compressInt512VectorTests(IntFunction<int[]> fa,
                                                 IntFunction<boolean[]> fm) {
         int[] a = fa.apply(SPECIES.length());
         int[] r = fr.apply(SPECIES.length());
@@ -4257,9 +4257,8 @@ public class Int512VectorTests extends AbstractVectorTest {
         assertcompressArraysEquals(r, a, mask, SPECIES.length());
     }
 
-
     @Test(dataProvider = "intUnaryOpMaskProvider")
-    static void expandMaskedInt512VectorTests(IntFunction<int[]> fa,
+    static void expandInt512VectorTests(IntFunction<int[]> fa,
                                                 IntFunction<boolean[]> fm) {
         int[] a = fa.apply(SPECIES.length());
         int[] r = fr.apply(SPECIES.length());
@@ -4276,6 +4275,23 @@ public class Int512VectorTests extends AbstractVectorTest {
         assertexpandArraysEquals(r, a, mask, SPECIES.length());
     }
 
+    @Test(dataProvider = "maskProvider")
+    static void maskCompressInt512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
+        int trueCount = 0;
+        boolean[] a = fa.apply(SPECIES.length());
+
+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                var vmask = SPECIES.loadMask(a, i);
+                trueCount = vmask.trueCount();
+                var rmask = vmask.compress();
+                for (int j = 0; j < SPECIES.length(); j++)  {
+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
+                }
+            }
+        }
+    }
+
     @Test(dataProvider = "intUnaryOpProvider")
     static void getInt512VectorTests(IntFunction<int[]> fa) {
         int[] a = fa.apply(SPECIES.length());
@@ -5539,23 +5555,6 @@ public class Int512VectorTests extends AbstractVectorTest {
         assertMaskReductionArraysEquals(r, a, Int512VectorTests::maskFirstTrue);
     }
 
-    @Test(dataProvider = "maskProvider")
-    static void maskCompressInt512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
-        int trueCount = 0;
-        boolean[] a = fa.apply(SPECIES.length());
-
-        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
-            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                var vmask = SPECIES.loadMask(a, i);
-                trueCount = vmask.trueCount();
-                var rmask = vmask.compress();
-                for (int j = 0; j < SPECIES.length(); j++)  {
-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
-                }
-            }
-        }
-    }
-
     @DataProvider
     public static Object[][] longMaskProvider() {
         return new Object[][]{
diff --git a/test/jdk/jdk/incubator/vector/Int64VectorTests.java b/test/jdk/jdk/incubator/vector/Int64VectorTests.java
index a75a5662cc0..c50f49abd9b 100644
--- a/test/jdk/jdk/incubator/vector/Int64VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Int64VectorTests.java
@@ -4240,7 +4240,7 @@ public class Int64VectorTests extends AbstractVectorTest {
     }
 
     @Test(dataProvider = "intUnaryOpMaskProvider")
-    static void compressMaskedInt64VectorTests(IntFunction<int[]> fa,
+    static void compressInt64VectorTests(IntFunction<int[]> fa,
                                                 IntFunction<boolean[]> fm) {
         int[] a = fa.apply(SPECIES.length());
         int[] r = fr.apply(SPECIES.length());
@@ -4257,9 +4257,8 @@ public class Int64VectorTests extends AbstractVectorTest {
         assertcompressArraysEquals(r, a, mask, SPECIES.length());
     }
 
-
     @Test(dataProvider = "intUnaryOpMaskProvider")
-    static void expandMaskedInt64VectorTests(IntFunction<int[]> fa,
+    static void expandInt64VectorTests(IntFunction<int[]> fa,
                                                 IntFunction<boolean[]> fm) {
         int[] a = fa.apply(SPECIES.length());
         int[] r = fr.apply(SPECIES.length());
@@ -4276,6 +4275,23 @@ public class Int64VectorTests extends AbstractVectorTest {
         assertexpandArraysEquals(r, a, mask, SPECIES.length());
     }
 
+    @Test(dataProvider = "maskProvider")
+    static void maskCompressInt64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
+        int trueCount = 0;
+        boolean[] a = fa.apply(SPECIES.length());
+
+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                var vmask = SPECIES.loadMask(a, i);
+                trueCount = vmask.trueCount();
+                var rmask = vmask.compress();
+                for (int j = 0; j < SPECIES.length(); j++)  {
+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
+                }
+            }
+        }
+    }
+
     @Test(dataProvider = "intUnaryOpProvider")
     static void getInt64VectorTests(IntFunction<int[]> fa) {
         int[] a = fa.apply(SPECIES.length());
@@ -5539,23 +5555,6 @@ public class Int64VectorTests extends AbstractVectorTest {
         assertMaskReductionArraysEquals(r, a, Int64VectorTests::maskFirstTrue);
     }
 
-    @Test(dataProvider = "maskProvider")
-    static void maskCompressInt64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
-        int trueCount = 0;
-        boolean[] a = fa.apply(SPECIES.length());
-
-        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
-            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                var vmask = SPECIES.loadMask(a, i);
-                trueCount = vmask.trueCount();
-                var rmask = vmask.compress();
-                for (int j = 0; j < SPECIES.length(); j++)  {
-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
-                }
-            }
-        }
-    }
-
     @DataProvider
     public static Object[][] longMaskProvider() {
         return new Object[][]{
diff --git a/test/jdk/jdk/incubator/vector/IntMaxVectorTests.java b/test/jdk/jdk/incubator/vector/IntMaxVectorTests.java
index 18f2b517d87..0f76dd85bfe 100644
--- a/test/jdk/jdk/incubator/vector/IntMaxVectorTests.java
+++ b/test/jdk/jdk/incubator/vector/IntMaxVectorTests.java
@@ -4245,7 +4245,7 @@ public class IntMaxVectorTests extends AbstractVectorTest {
     }
 
     @Test(dataProvider = "intUnaryOpMaskProvider")
-    static void compressMaskedIntMaxVectorTests(IntFunction<int[]> fa,
+    static void compressIntMaxVectorTests(IntFunction<int[]> fa,
                                                 IntFunction<boolean[]> fm) {
         int[] a = fa.apply(SPECIES.length());
         int[] r = fr.apply(SPECIES.length());
@@ -4262,9 +4262,8 @@ public class IntMaxVectorTests extends AbstractVectorTest {
         assertcompressArraysEquals(r, a, mask, SPECIES.length());
     }
 
-
     @Test(dataProvider = "intUnaryOpMaskProvider")
-    static void expandMaskedIntMaxVectorTests(IntFunction<int[]> fa,
+    static void expandIntMaxVectorTests(IntFunction<int[]> fa,
                                                 IntFunction<boolean[]> fm) {
         int[] a = fa.apply(SPECIES.length());
         int[] r = fr.apply(SPECIES.length());
@@ -4281,6 +4280,23 @@ public class IntMaxVectorTests extends AbstractVectorTest {
         assertexpandArraysEquals(r, a, mask, SPECIES.length());
     }
 
+    @Test(dataProvider = "maskProvider")
+    static void maskCompressIntMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {
+        int trueCount = 0;
+        boolean[] a = fa.apply(SPECIES.length());
+
+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                var vmask = SPECIES.loadMask(a, i);
+                trueCount = vmask.trueCount();
+                var rmask = vmask.compress();
+                for (int j = 0; j < SPECIES.length(); j++)  {
+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
+                }
+            }
+        }
+    }
+
     @Test(dataProvider = "intUnaryOpProvider")
     static void getIntMaxVectorTests(IntFunction<int[]> fa) {
         int[] a = fa.apply(SPECIES.length());
@@ -5544,23 +5560,6 @@ public class IntMaxVectorTests extends AbstractVectorTest {
         assertMaskReductionArraysEquals(r, a, IntMaxVectorTests::maskFirstTrue);
     }
 
-    @Test(dataProvider = "maskProvider")
-    static void maskCompressIntMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {
-        int trueCount = 0;
-        boolean[] a = fa.apply(SPECIES.length());
-
-        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
-            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                var vmask = SPECIES.loadMask(a, i);
-                trueCount = vmask.trueCount();
-                var rmask = vmask.compress();
-                for (int j = 0; j < SPECIES.length(); j++)  {
-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
-                }
-            }
-        }
-    }
-
 
     @DataProvider
     public static Object[][] offsetProvider() {
diff --git a/test/jdk/jdk/incubator/vector/Long128VectorTests.java b/test/jdk/jdk/incubator/vector/Long128VectorTests.java
index ca0eac7c664..3c50bfcda65 100644
--- a/test/jdk/jdk/incubator/vector/Long128VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Long128VectorTests.java
@@ -4190,7 +4190,7 @@ public class Long128VectorTests extends AbstractVectorTest {
     }
 
     @Test(dataProvider = "longUnaryOpMaskProvider")
-    static void compressMaskedLong128VectorTests(IntFunction<long[]> fa,
+    static void compressLong128VectorTests(IntFunction<long[]> fa,
                                                 IntFunction<boolean[]> fm) {
         long[] a = fa.apply(SPECIES.length());
         long[] r = fr.apply(SPECIES.length());
@@ -4207,9 +4207,8 @@ public class Long128VectorTests extends AbstractVectorTest {
         assertcompressArraysEquals(r, a, mask, SPECIES.length());
     }
 
-
     @Test(dataProvider = "longUnaryOpMaskProvider")
-    static void expandMaskedLong128VectorTests(IntFunction<long[]> fa,
+    static void expandLong128VectorTests(IntFunction<long[]> fa,
                                                 IntFunction<boolean[]> fm) {
         long[] a = fa.apply(SPECIES.length());
         long[] r = fr.apply(SPECIES.length());
@@ -4226,6 +4225,23 @@ public class Long128VectorTests extends AbstractVectorTest {
         assertexpandArraysEquals(r, a, mask, SPECIES.length());
     }
 
+    @Test(dataProvider = "maskProvider")
+    static void maskCompressLong128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
+        int trueCount = 0;
+        boolean[] a = fa.apply(SPECIES.length());
+
+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                var vmask = SPECIES.loadMask(a, i);
+                trueCount = vmask.trueCount();
+                var rmask = vmask.compress();
+                for (int j = 0; j < SPECIES.length(); j++)  {
+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
+                }
+            }
+        }
+    }
+
     @Test(dataProvider = "longUnaryOpProvider")
     static void getLong128VectorTests(IntFunction<long[]> fa) {
         long[] a = fa.apply(SPECIES.length());
@@ -5423,23 +5439,6 @@ public class Long128VectorTests extends AbstractVectorTest {
         assertMaskReductionArraysEquals(r, a, Long128VectorTests::maskFirstTrue);
     }
 
-    @Test(dataProvider = "maskProvider")
-    static void maskCompressLong128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
-        int trueCount = 0;
-        boolean[] a = fa.apply(SPECIES.length());
-
-        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
-            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                var vmask = SPECIES.loadMask(a, i);
-                trueCount = vmask.trueCount();
-                var rmask = vmask.compress();
-                for (int j = 0; j < SPECIES.length(); j++)  {
-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
-                }
-            }
-        }
-    }
-
     @DataProvider
     public static Object[][] longMaskProvider() {
         return new Object[][]{
diff --git a/test/jdk/jdk/incubator/vector/Long256VectorTests.java b/test/jdk/jdk/incubator/vector/Long256VectorTests.java
index dc7d1d21684..df14d9410f1 100644
--- a/test/jdk/jdk/incubator/vector/Long256VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Long256VectorTests.java
@@ -4190,7 +4190,7 @@ public class Long256VectorTests extends AbstractVectorTest {
     }
 
     @Test(dataProvider = "longUnaryOpMaskProvider")
-    static void compressMaskedLong256VectorTests(IntFunction<long[]> fa,
+    static void compressLong256VectorTests(IntFunction<long[]> fa,
                                                 IntFunction<boolean[]> fm) {
         long[] a = fa.apply(SPECIES.length());
         long[] r = fr.apply(SPECIES.length());
@@ -4207,9 +4207,8 @@ public class Long256VectorTests extends AbstractVectorTest {
         assertcompressArraysEquals(r, a, mask, SPECIES.length());
     }
 
-
     @Test(dataProvider = "longUnaryOpMaskProvider")
-    static void expandMaskedLong256VectorTests(IntFunction<long[]> fa,
+    static void expandLong256VectorTests(IntFunction<long[]> fa,
                                                 IntFunction<boolean[]> fm) {
         long[] a = fa.apply(SPECIES.length());
         long[] r = fr.apply(SPECIES.length());
@@ -4226,6 +4225,23 @@ public class Long256VectorTests extends AbstractVectorTest {
         assertexpandArraysEquals(r, a, mask, SPECIES.length());
     }
 
+    @Test(dataProvider = "maskProvider")
+    static void maskCompressLong256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
+        int trueCount = 0;
+        boolean[] a = fa.apply(SPECIES.length());
+
+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                var vmask = SPECIES.loadMask(a, i);
+                trueCount = vmask.trueCount();
+                var rmask = vmask.compress();
+                for (int j = 0; j < SPECIES.length(); j++)  {
+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
+                }
+            }
+        }
+    }
+
     @Test(dataProvider = "longUnaryOpProvider")
     static void getLong256VectorTests(IntFunction<long[]> fa) {
         long[] a = fa.apply(SPECIES.length());
@@ -5423,23 +5439,6 @@ public class Long256VectorTests extends AbstractVectorTest {
         assertMaskReductionArraysEquals(r, a, Long256VectorTests::maskFirstTrue);
     }
 
-    @Test(dataProvider = "maskProvider")
-    static void maskCompressLong256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
-        int trueCount = 0;
-        boolean[] a = fa.apply(SPECIES.length());
-
-        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
-            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                var vmask = SPECIES.loadMask(a, i);
-                trueCount = vmask.trueCount();
-                var rmask = vmask.compress();
-                for (int j = 0; j < SPECIES.length(); j++)  {
-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
-                }
-            }
-        }
-    }
-
     @DataProvider
     public static Object[][] longMaskProvider() {
         return new Object[][]{
diff --git a/test/jdk/jdk/incubator/vector/Long512VectorTests.java b/test/jdk/jdk/incubator/vector/Long512VectorTests.java
index fe6eb0bb185..ed73bffe847 100644
--- a/test/jdk/jdk/incubator/vector/Long512VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Long512VectorTests.java
@@ -4190,7 +4190,7 @@ public class Long512VectorTests extends AbstractVectorTest {
     }
 
     @Test(dataProvider = "longUnaryOpMaskProvider")
-    static void compressMaskedLong512VectorTests(IntFunction<long[]> fa,
+    static void compressLong512VectorTests(IntFunction<long[]> fa,
                                                 IntFunction<boolean[]> fm) {
         long[] a = fa.apply(SPECIES.length());
         long[] r = fr.apply(SPECIES.length());
@@ -4207,9 +4207,8 @@ public class Long512VectorTests extends AbstractVectorTest {
         assertcompressArraysEquals(r, a, mask, SPECIES.length());
     }
 
-
     @Test(dataProvider = "longUnaryOpMaskProvider")
-    static void expandMaskedLong512VectorTests(IntFunction<long[]> fa,
+    static void expandLong512VectorTests(IntFunction<long[]> fa,
                                                 IntFunction<boolean[]> fm) {
         long[] a = fa.apply(SPECIES.length());
         long[] r = fr.apply(SPECIES.length());
@@ -4226,6 +4225,23 @@ public class Long512VectorTests extends AbstractVectorTest {
         assertexpandArraysEquals(r, a, mask, SPECIES.length());
     }
 
+    @Test(dataProvider = "maskProvider")
+    static void maskCompressLong512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
+        int trueCount = 0;
+        boolean[] a = fa.apply(SPECIES.length());
+
+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                var vmask = SPECIES.loadMask(a, i);
+                trueCount = vmask.trueCount();
+                var rmask = vmask.compress();
+                for (int j = 0; j < SPECIES.length(); j++)  {
+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
+                }
+            }
+        }
+    }
+
     @Test(dataProvider = "longUnaryOpProvider")
     static void getLong512VectorTests(IntFunction<long[]> fa) {
         long[] a = fa.apply(SPECIES.length());
@@ -5423,23 +5439,6 @@ public class Long512VectorTests extends AbstractVectorTest {
         assertMaskReductionArraysEquals(r, a, Long512VectorTests::maskFirstTrue);
     }
 
-    @Test(dataProvider = "maskProvider")
-    static void maskCompressLong512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
-        int trueCount = 0;
-        boolean[] a = fa.apply(SPECIES.length());
-
-        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
-            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                var vmask = SPECIES.loadMask(a, i);
-                trueCount = vmask.trueCount();
-                var rmask = vmask.compress();
-                for (int j = 0; j < SPECIES.length(); j++)  {
-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
-                }
-            }
-        }
-    }
-
     @DataProvider
     public static Object[][] longMaskProvider() {
         return new Object[][]{
diff --git a/test/jdk/jdk/incubator/vector/Long64VectorTests.java b/test/jdk/jdk/incubator/vector/Long64VectorTests.java
index eca0c754e2a..1b12baf8c68 100644
--- a/test/jdk/jdk/incubator/vector/Long64VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Long64VectorTests.java
@@ -4190,7 +4190,7 @@ public class Long64VectorTests extends AbstractVectorTest {
     }
 
     @Test(dataProvider = "longUnaryOpMaskProvider")
-    static void compressMaskedLong64VectorTests(IntFunction<long[]> fa,
+    static void compressLong64VectorTests(IntFunction<long[]> fa,
                                                 IntFunction<boolean[]> fm) {
         long[] a = fa.apply(SPECIES.length());
         long[] r = fr.apply(SPECIES.length());
@@ -4207,9 +4207,8 @@ public class Long64VectorTests extends AbstractVectorTest {
         assertcompressArraysEquals(r, a, mask, SPECIES.length());
     }
 
-
     @Test(dataProvider = "longUnaryOpMaskProvider")
-    static void expandMaskedLong64VectorTests(IntFunction<long[]> fa,
+    static void expandLong64VectorTests(IntFunction<long[]> fa,
                                                 IntFunction<boolean[]> fm) {
         long[] a = fa.apply(SPECIES.length());
         long[] r = fr.apply(SPECIES.length());
@@ -4226,6 +4225,23 @@ public class Long64VectorTests extends AbstractVectorTest {
         assertexpandArraysEquals(r, a, mask, SPECIES.length());
     }
 
+    @Test(dataProvider = "maskProvider")
+    static void maskCompressLong64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
+        int trueCount = 0;
+        boolean[] a = fa.apply(SPECIES.length());
+
+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                var vmask = SPECIES.loadMask(a, i);
+                trueCount = vmask.trueCount();
+                var rmask = vmask.compress();
+                for (int j = 0; j < SPECIES.length(); j++)  {
+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
+                }
+            }
+        }
+    }
+
     @Test(dataProvider = "longUnaryOpProvider")
     static void getLong64VectorTests(IntFunction<long[]> fa) {
         long[] a = fa.apply(SPECIES.length());
@@ -5423,23 +5439,6 @@ public class Long64VectorTests extends AbstractVectorTest {
         assertMaskReductionArraysEquals(r, a, Long64VectorTests::maskFirstTrue);
     }
 
-    @Test(dataProvider = "maskProvider")
-    static void maskCompressLong64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
-        int trueCount = 0;
-        boolean[] a = fa.apply(SPECIES.length());
-
-        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
-            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                var vmask = SPECIES.loadMask(a, i);
-                trueCount = vmask.trueCount();
-                var rmask = vmask.compress();
-                for (int j = 0; j < SPECIES.length(); j++)  {
-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
-                }
-            }
-        }
-    }
-
     @DataProvider
     public static Object[][] longMaskProvider() {
         return new Object[][]{
diff --git a/test/jdk/jdk/incubator/vector/LongMaxVectorTests.java b/test/jdk/jdk/incubator/vector/LongMaxVectorTests.java
index 159b7328646..7153866c67e 100644
--- a/test/jdk/jdk/incubator/vector/LongMaxVectorTests.java
+++ b/test/jdk/jdk/incubator/vector/LongMaxVectorTests.java
@@ -4195,7 +4195,7 @@ public class LongMaxVectorTests extends AbstractVectorTest {
     }
 
     @Test(dataProvider = "longUnaryOpMaskProvider")
-    static void compressMaskedLongMaxVectorTests(IntFunction<long[]> fa,
+    static void compressLongMaxVectorTests(IntFunction<long[]> fa,
                                                 IntFunction<boolean[]> fm) {
         long[] a = fa.apply(SPECIES.length());
         long[] r = fr.apply(SPECIES.length());
@@ -4212,9 +4212,8 @@ public class LongMaxVectorTests extends AbstractVectorTest {
         assertcompressArraysEquals(r, a, mask, SPECIES.length());
     }
 
-
     @Test(dataProvider = "longUnaryOpMaskProvider")
-    static void expandMaskedLongMaxVectorTests(IntFunction<long[]> fa,
+    static void expandLongMaxVectorTests(IntFunction<long[]> fa,
                                                 IntFunction<boolean[]> fm) {
         long[] a = fa.apply(SPECIES.length());
         long[] r = fr.apply(SPECIES.length());
@@ -4231,6 +4230,23 @@ public class LongMaxVectorTests extends AbstractVectorTest {
         assertexpandArraysEquals(r, a, mask, SPECIES.length());
     }
 
+    @Test(dataProvider = "maskProvider")
+    static void maskCompressLongMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {
+        int trueCount = 0;
+        boolean[] a = fa.apply(SPECIES.length());
+
+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                var vmask = SPECIES.loadMask(a, i);
+                trueCount = vmask.trueCount();
+                var rmask = vmask.compress();
+                for (int j = 0; j < SPECIES.length(); j++)  {
+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
+                }
+            }
+        }
+    }
+
     @Test(dataProvider = "longUnaryOpProvider")
     static void getLongMaxVectorTests(IntFunction<long[]> fa) {
         long[] a = fa.apply(SPECIES.length());
@@ -5428,23 +5444,6 @@ public class LongMaxVectorTests extends AbstractVectorTest {
         assertMaskReductionArraysEquals(r, a, LongMaxVectorTests::maskFirstTrue);
     }
 
-    @Test(dataProvider = "maskProvider")
-    static void maskCompressLongMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {
-        int trueCount = 0;
-        boolean[] a = fa.apply(SPECIES.length());
-
-        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
-            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                var vmask = SPECIES.loadMask(a, i);
-                trueCount = vmask.trueCount();
-                var rmask = vmask.compress();
-                for (int j = 0; j < SPECIES.length(); j++)  {
-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
-                }
-            }
-        }
-    }
-
 
     @DataProvider
     public static Object[][] offsetProvider() {
diff --git a/test/jdk/jdk/incubator/vector/Short128VectorTests.java b/test/jdk/jdk/incubator/vector/Short128VectorTests.java
index e2532c7bd8a..95854ee2d2c 100644
--- a/test/jdk/jdk/incubator/vector/Short128VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Short128VectorTests.java
@@ -4265,7 +4265,7 @@ public class Short128VectorTests extends AbstractVectorTest {
     }
 
     @Test(dataProvider = "shortUnaryOpMaskProvider")
-    static void compressMaskedShort128VectorTests(IntFunction<short[]> fa,
+    static void compressShort128VectorTests(IntFunction<short[]> fa,
                                                 IntFunction<boolean[]> fm) {
         short[] a = fa.apply(SPECIES.length());
         short[] r = fr.apply(SPECIES.length());
@@ -4282,9 +4282,8 @@ public class Short128VectorTests extends AbstractVectorTest {
         assertcompressArraysEquals(r, a, mask, SPECIES.length());
     }
 
-
     @Test(dataProvider = "shortUnaryOpMaskProvider")
-    static void expandMaskedShort128VectorTests(IntFunction<short[]> fa,
+    static void expandShort128VectorTests(IntFunction<short[]> fa,
                                                 IntFunction<boolean[]> fm) {
         short[] a = fa.apply(SPECIES.length());
         short[] r = fr.apply(SPECIES.length());
@@ -4301,6 +4300,23 @@ public class Short128VectorTests extends AbstractVectorTest {
         assertexpandArraysEquals(r, a, mask, SPECIES.length());
     }
 
+    @Test(dataProvider = "maskProvider")
+    static void maskCompressShort128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
+        int trueCount = 0;
+        boolean[] a = fa.apply(SPECIES.length());
+
+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                var vmask = SPECIES.loadMask(a, i);
+                trueCount = vmask.trueCount();
+                var rmask = vmask.compress();
+                for (int j = 0; j < SPECIES.length(); j++)  {
+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
+                }
+            }
+        }
+    }
+
     @Test(dataProvider = "shortUnaryOpProvider")
     static void getShort128VectorTests(IntFunction<short[]> fa) {
         short[] a = fa.apply(SPECIES.length());
@@ -5564,23 +5580,6 @@ public class Short128VectorTests extends AbstractVectorTest {
         assertMaskReductionArraysEquals(r, a, Short128VectorTests::maskFirstTrue);
     }
 
-    @Test(dataProvider = "maskProvider")
-    static void maskCompressShort128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
-        int trueCount = 0;
-        boolean[] a = fa.apply(SPECIES.length());
-
-        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
-            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                var vmask = SPECIES.loadMask(a, i);
-                trueCount = vmask.trueCount();
-                var rmask = vmask.compress();
-                for (int j = 0; j < SPECIES.length(); j++)  {
-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
-                }
-            }
-        }
-    }
-
     @DataProvider
     public static Object[][] longMaskProvider() {
         return new Object[][]{
diff --git a/test/jdk/jdk/incubator/vector/Short256VectorTests.java b/test/jdk/jdk/incubator/vector/Short256VectorTests.java
index 05cea5314b7..c0b075ce9a6 100644
--- a/test/jdk/jdk/incubator/vector/Short256VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Short256VectorTests.java
@@ -4265,7 +4265,7 @@ public class Short256VectorTests extends AbstractVectorTest {
     }
 
     @Test(dataProvider = "shortUnaryOpMaskProvider")
-    static void compressMaskedShort256VectorTests(IntFunction<short[]> fa,
+    static void compressShort256VectorTests(IntFunction<short[]> fa,
                                                 IntFunction<boolean[]> fm) {
         short[] a = fa.apply(SPECIES.length());
         short[] r = fr.apply(SPECIES.length());
@@ -4282,9 +4282,8 @@ public class Short256VectorTests extends AbstractVectorTest {
         assertcompressArraysEquals(r, a, mask, SPECIES.length());
     }
 
-
     @Test(dataProvider = "shortUnaryOpMaskProvider")
-    static void expandMaskedShort256VectorTests(IntFunction<short[]> fa,
+    static void expandShort256VectorTests(IntFunction<short[]> fa,
                                                 IntFunction<boolean[]> fm) {
         short[] a = fa.apply(SPECIES.length());
         short[] r = fr.apply(SPECIES.length());
@@ -4301,6 +4300,23 @@ public class Short256VectorTests extends AbstractVectorTest {
         assertexpandArraysEquals(r, a, mask, SPECIES.length());
     }
 
+    @Test(dataProvider = "maskProvider")
+    static void maskCompressShort256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
+        int trueCount = 0;
+        boolean[] a = fa.apply(SPECIES.length());
+
+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                var vmask = SPECIES.loadMask(a, i);
+                trueCount = vmask.trueCount();
+                var rmask = vmask.compress();
+                for (int j = 0; j < SPECIES.length(); j++)  {
+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
+                }
+            }
+        }
+    }
+
     @Test(dataProvider = "shortUnaryOpProvider")
     static void getShort256VectorTests(IntFunction<short[]> fa) {
         short[] a = fa.apply(SPECIES.length());
@@ -5564,23 +5580,6 @@ public class Short256VectorTests extends AbstractVectorTest {
         assertMaskReductionArraysEquals(r, a, Short256VectorTests::maskFirstTrue);
     }
 
-    @Test(dataProvider = "maskProvider")
-    static void maskCompressShort256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
-        int trueCount = 0;
-        boolean[] a = fa.apply(SPECIES.length());
-
-        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
-            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                var vmask = SPECIES.loadMask(a, i);
-                trueCount = vmask.trueCount();
-                var rmask = vmask.compress();
-                for (int j = 0; j < SPECIES.length(); j++)  {
-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
-                }
-            }
-        }
-    }
-
     @DataProvider
     public static Object[][] longMaskProvider() {
         return new Object[][]{
diff --git a/test/jdk/jdk/incubator/vector/Short512VectorTests.java b/test/jdk/jdk/incubator/vector/Short512VectorTests.java
index 0b8367b4ae9..06eb999860d 100644
--- a/test/jdk/jdk/incubator/vector/Short512VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Short512VectorTests.java
@@ -4265,7 +4265,7 @@ public class Short512VectorTests extends AbstractVectorTest {
     }
 
     @Test(dataProvider = "shortUnaryOpMaskProvider")
-    static void compressMaskedShort512VectorTests(IntFunction<short[]> fa,
+    static void compressShort512VectorTests(IntFunction<short[]> fa,
                                                 IntFunction<boolean[]> fm) {
         short[] a = fa.apply(SPECIES.length());
         short[] r = fr.apply(SPECIES.length());
@@ -4282,9 +4282,8 @@ public class Short512VectorTests extends AbstractVectorTest {
         assertcompressArraysEquals(r, a, mask, SPECIES.length());
     }
 
-
     @Test(dataProvider = "shortUnaryOpMaskProvider")
-    static void expandMaskedShort512VectorTests(IntFunction<short[]> fa,
+    static void expandShort512VectorTests(IntFunction<short[]> fa,
                                                 IntFunction<boolean[]> fm) {
         short[] a = fa.apply(SPECIES.length());
         short[] r = fr.apply(SPECIES.length());
@@ -4301,6 +4300,23 @@ public class Short512VectorTests extends AbstractVectorTest {
         assertexpandArraysEquals(r, a, mask, SPECIES.length());
     }
 
+    @Test(dataProvider = "maskProvider")
+    static void maskCompressShort512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
+        int trueCount = 0;
+        boolean[] a = fa.apply(SPECIES.length());
+
+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                var vmask = SPECIES.loadMask(a, i);
+                trueCount = vmask.trueCount();
+                var rmask = vmask.compress();
+                for (int j = 0; j < SPECIES.length(); j++)  {
+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
+                }
+            }
+        }
+    }
+
     @Test(dataProvider = "shortUnaryOpProvider")
     static void getShort512VectorTests(IntFunction<short[]> fa) {
         short[] a = fa.apply(SPECIES.length());
@@ -5564,23 +5580,6 @@ public class Short512VectorTests extends AbstractVectorTest {
         assertMaskReductionArraysEquals(r, a, Short512VectorTests::maskFirstTrue);
     }
 
-    @Test(dataProvider = "maskProvider")
-    static void maskCompressShort512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
-        int trueCount = 0;
-        boolean[] a = fa.apply(SPECIES.length());
-
-        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
-            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                var vmask = SPECIES.loadMask(a, i);
-                trueCount = vmask.trueCount();
-                var rmask = vmask.compress();
-                for (int j = 0; j < SPECIES.length(); j++)  {
-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
-                }
-            }
-        }
-    }
-
     @DataProvider
     public static Object[][] longMaskProvider() {
         return new Object[][]{
diff --git a/test/jdk/jdk/incubator/vector/Short64VectorTests.java b/test/jdk/jdk/incubator/vector/Short64VectorTests.java
index 99005e80110..34c966211dc 100644
--- a/test/jdk/jdk/incubator/vector/Short64VectorTests.java
+++ b/test/jdk/jdk/incubator/vector/Short64VectorTests.java
@@ -4265,7 +4265,7 @@ public class Short64VectorTests extends AbstractVectorTest {
     }
 
     @Test(dataProvider = "shortUnaryOpMaskProvider")
-    static void compressMaskedShort64VectorTests(IntFunction<short[]> fa,
+    static void compressShort64VectorTests(IntFunction<short[]> fa,
                                                 IntFunction<boolean[]> fm) {
         short[] a = fa.apply(SPECIES.length());
         short[] r = fr.apply(SPECIES.length());
@@ -4282,9 +4282,8 @@ public class Short64VectorTests extends AbstractVectorTest {
         assertcompressArraysEquals(r, a, mask, SPECIES.length());
     }
 
-
     @Test(dataProvider = "shortUnaryOpMaskProvider")
-    static void expandMaskedShort64VectorTests(IntFunction<short[]> fa,
+    static void expandShort64VectorTests(IntFunction<short[]> fa,
                                                 IntFunction<boolean[]> fm) {
         short[] a = fa.apply(SPECIES.length());
         short[] r = fr.apply(SPECIES.length());
@@ -4301,6 +4300,23 @@ public class Short64VectorTests extends AbstractVectorTest {
         assertexpandArraysEquals(r, a, mask, SPECIES.length());
     }
 
+    @Test(dataProvider = "maskProvider")
+    static void maskCompressShort64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
+        int trueCount = 0;
+        boolean[] a = fa.apply(SPECIES.length());
+
+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                var vmask = SPECIES.loadMask(a, i);
+                trueCount = vmask.trueCount();
+                var rmask = vmask.compress();
+                for (int j = 0; j < SPECIES.length(); j++)  {
+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
+                }
+            }
+        }
+    }
+
     @Test(dataProvider = "shortUnaryOpProvider")
     static void getShort64VectorTests(IntFunction<short[]> fa) {
         short[] a = fa.apply(SPECIES.length());
@@ -5564,23 +5580,6 @@ public class Short64VectorTests extends AbstractVectorTest {
         assertMaskReductionArraysEquals(r, a, Short64VectorTests::maskFirstTrue);
     }
 
-    @Test(dataProvider = "maskProvider")
-    static void maskCompressShort64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {
-        int trueCount = 0;
-        boolean[] a = fa.apply(SPECIES.length());
-
-        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
-            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                var vmask = SPECIES.loadMask(a, i);
-                trueCount = vmask.trueCount();
-                var rmask = vmask.compress();
-                for (int j = 0; j < SPECIES.length(); j++)  {
-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
-                }
-            }
-        }
-    }
-
     @DataProvider
     public static Object[][] longMaskProvider() {
         return new Object[][]{
diff --git a/test/jdk/jdk/incubator/vector/ShortMaxVectorTests.java b/test/jdk/jdk/incubator/vector/ShortMaxVectorTests.java
index 38d8de6d94c..7520718e5ef 100644
--- a/test/jdk/jdk/incubator/vector/ShortMaxVectorTests.java
+++ b/test/jdk/jdk/incubator/vector/ShortMaxVectorTests.java
@@ -4270,7 +4270,7 @@ public class ShortMaxVectorTests extends AbstractVectorTest {
     }
 
     @Test(dataProvider = "shortUnaryOpMaskProvider")
-    static void compressMaskedShortMaxVectorTests(IntFunction<short[]> fa,
+    static void compressShortMaxVectorTests(IntFunction<short[]> fa,
                                                 IntFunction<boolean[]> fm) {
         short[] a = fa.apply(SPECIES.length());
         short[] r = fr.apply(SPECIES.length());
@@ -4287,9 +4287,8 @@ public class ShortMaxVectorTests extends AbstractVectorTest {
         assertcompressArraysEquals(r, a, mask, SPECIES.length());
     }
 
-
     @Test(dataProvider = "shortUnaryOpMaskProvider")
-    static void expandMaskedShortMaxVectorTests(IntFunction<short[]> fa,
+    static void expandShortMaxVectorTests(IntFunction<short[]> fa,
                                                 IntFunction<boolean[]> fm) {
         short[] a = fa.apply(SPECIES.length());
         short[] r = fr.apply(SPECIES.length());
@@ -4306,6 +4305,23 @@ public class ShortMaxVectorTests extends AbstractVectorTest {
         assertexpandArraysEquals(r, a, mask, SPECIES.length());
     }
 
+    @Test(dataProvider = "maskProvider")
+    static void maskCompressShortMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {
+        int trueCount = 0;
+        boolean[] a = fa.apply(SPECIES.length());
+
+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                var vmask = SPECIES.loadMask(a, i);
+                trueCount = vmask.trueCount();
+                var rmask = vmask.compress();
+                for (int j = 0; j < SPECIES.length(); j++)  {
+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
+                }
+            }
+        }
+    }
+
     @Test(dataProvider = "shortUnaryOpProvider")
     static void getShortMaxVectorTests(IntFunction<short[]> fa) {
         short[] a = fa.apply(SPECIES.length());
@@ -5569,23 +5585,6 @@ public class ShortMaxVectorTests extends AbstractVectorTest {
         assertMaskReductionArraysEquals(r, a, ShortMaxVectorTests::maskFirstTrue);
     }
 
-    @Test(dataProvider = "maskProvider")
-    static void maskCompressShortMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {
-        int trueCount = 0;
-        boolean[] a = fa.apply(SPECIES.length());
-
-        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
-            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                var vmask = SPECIES.loadMask(a, i);
-                trueCount = vmask.trueCount();
-                var rmask = vmask.compress();
-                for (int j = 0; j < SPECIES.length(); j++)  {
-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
-                }
-            }
-        }
-    }
-
 
     @DataProvider
     public static Object[][] offsetProvider() {
diff --git a/test/jdk/jdk/incubator/vector/gen-template.sh b/test/jdk/jdk/incubator/vector/gen-template.sh
index 1e00a22952d..1f2ab2fbc1b 100644
--- a/test/jdk/jdk/incubator/vector/gen-template.sh
+++ b/test/jdk/jdk/incubator/vector/gen-template.sh
@@ -505,8 +505,7 @@ gen_op_tmpl $blend "blend" ""
 gen_op_tmpl $rearrange_template "rearrange" ""
 
 # Compress/Expand
-gen_op_tmpl $compressexpand_template "compress" ""
-gen_op_tmpl $compressexpand_template "expand" ""
+gen_op_tmpl $compressexpand_template "compress_expand" ""
 
 # Get
 gen_get_op "lane" ""
diff --git a/test/jdk/jdk/incubator/vector/gen-tests.sh b/test/jdk/jdk/incubator/vector/gen-tests.sh
old mode 100644
new mode 100755
diff --git a/test/jdk/jdk/incubator/vector/templates/Unit-CompressExpand.template b/test/jdk/jdk/incubator/vector/templates/Unit-CompressExpand.template
index 4e400088308..f2aeda3e7ca 100644
--- a/test/jdk/jdk/incubator/vector/templates/Unit-CompressExpand.template
+++ b/test/jdk/jdk/incubator/vector/templates/Unit-CompressExpand.template
@@ -1,6 +1,6 @@
 
     @Test(dataProvider = "$type$UnaryOpMaskProvider")
-    static void [[TEST]]Masked$vectorteststype$(IntFunction<$type$[]> fa,
+    static void compress$vectorteststype$(IntFunction<$type$[]> fa,
                                                 IntFunction<boolean[]> fm) {
         $type$[] a = fa.apply(SPECIES.length());
         $type$[] r = fr.apply(SPECIES.length());
@@ -10,10 +10,45 @@
         for (int ic = 0; ic < INVOC_COUNT; ic++) {
             for (int i = 0; i < a.length; i += SPECIES.length()) {
                 $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);
-                av.[[TEST]](vmask).intoArray(r, i);
+                av.compress(vmask).intoArray(r, i);
             }
         }
 
-        assert[[TEST]]ArraysEquals(r, a, mask, SPECIES.length());
+        assertcompressArraysEquals(r, a, mask, SPECIES.length());
+    }
+
+    @Test(dataProvider = "$type$UnaryOpMaskProvider")
+    static void expand$vectorteststype$(IntFunction<$type$[]> fa,
+                                                IntFunction<boolean[]> fm) {
+        $type$[] a = fa.apply(SPECIES.length());
+        $type$[] r = fr.apply(SPECIES.length());
+        boolean[] mask = fm.apply(SPECIES.length());
+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);
+                av.expand(vmask).intoArray(r, i);
+            }
+        }
+
+        assertexpandArraysEquals(r, a, mask, SPECIES.length());
+    }
+
+    @Test(dataProvider = "maskProvider")
+    static void maskCompress$vectorteststype$SmokeTest(IntFunction<boolean[]> fa) {
+        int trueCount = 0;
+        boolean[] a = fa.apply(SPECIES.length());
+
+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                var vmask = SPECIES.loadMask(a, i);
+                trueCount = vmask.trueCount();
+                var rmask = vmask.compress();
+                for (int j = 0; j < SPECIES.length(); j++)  {
+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
+                }
+            }
+        }
     }
 
diff --git a/test/jdk/jdk/incubator/vector/templates/Unit-Miscellaneous.template b/test/jdk/jdk/incubator/vector/templates/Unit-Miscellaneous.template
index a19a4365931..a75a6842bd3 100644
--- a/test/jdk/jdk/incubator/vector/templates/Unit-Miscellaneous.template
+++ b/test/jdk/jdk/incubator/vector/templates/Unit-Miscellaneous.template
@@ -484,23 +484,6 @@
         assertMaskReductionArraysEquals(r, a, $vectorteststype$::maskFirstTrue);
     }
 
-    @Test(dataProvider = "maskProvider")
-    static void maskCompress$vectorteststype$SmokeTest(IntFunction<boolean[]> fa) {
-        int trueCount = 0;
-        boolean[] a = fa.apply(SPECIES.length());
-
-        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {
-            for (int i = 0; i < a.length; i += SPECIES.length()) {
-                var vmask = SPECIES.loadMask(a, i);
-                trueCount = vmask.trueCount();
-                var rmask = vmask.compress();
-                for (int j = 0; j < SPECIES.length(); j++)  {
-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);
-                }
-            }
-        }
-    }
-
 #if[!MaxBit]
     @DataProvider
     public static Object[][] longMaskProvider() {
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Byte128Vector.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Byte128Vector.java
index 1c5b07c4c12..c8e5d431574 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Byte128Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Byte128Vector.java
@@ -1317,6 +1473,56 @@ public class Byte128Vector extends AbstractVectorBenchmark {
         bh.consume(r);
     }
 
+    @Benchmark
+    public Object compress() {
+        byte[] a = fa.apply(size);
+        byte[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                av.compress(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object expand() {
+        byte[] a = fa.apply(size);
+        byte[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                av.expand(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object maskCompress() {
+        boolean[] ms = fmt.apply(size);
+        boolean[] rs = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, i);
+                m.compress().intoArray(SPECIES, rs, i);
+            }
+        }
+
+        return rs;
+    }
+
+
     @Benchmark
     public void laneextract(Blackhole bh) {
         byte[] a = fa.apply(SPECIES.length());
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Byte256Vector.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Byte256Vector.java
index 2baff5c6cd1..7ce00dc02b9 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Byte256Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Byte256Vector.java
@@ -1317,6 +1473,56 @@ public class Byte256Vector extends AbstractVectorBenchmark {
         bh.consume(r);
     }
 
+    @Benchmark
+    public Object compress() {
+        byte[] a = fa.apply(size);
+        byte[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                av.compress(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object expand() {
+        byte[] a = fa.apply(size);
+        byte[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                av.expand(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object maskCompress() {
+        boolean[] ms = fmt.apply(size);
+        boolean[] rs = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, i);
+                m.compress().intoArray(SPECIES, rs, i);
+            }
+        }
+
+        return rs;
+    }
+
+
     @Benchmark
     public void laneextract(Blackhole bh) {
         byte[] a = fa.apply(SPECIES.length());
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Byte512Vector.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Byte512Vector.java
index 025c4395093..2383e156e21 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Byte512Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Byte512Vector.java
@@ -1317,6 +1473,56 @@ public class Byte512Vector extends AbstractVectorBenchmark {
         bh.consume(r);
     }
 
+    @Benchmark
+    public Object compress() {
+        byte[] a = fa.apply(size);
+        byte[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                av.compress(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object expand() {
+        byte[] a = fa.apply(size);
+        byte[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                av.expand(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object maskCompress() {
+        boolean[] ms = fmt.apply(size);
+        boolean[] rs = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, i);
+                m.compress().intoArray(SPECIES, rs, i);
+            }
+        }
+
+        return rs;
+    }
+
+
     @Benchmark
     public void laneextract(Blackhole bh) {
         byte[] a = fa.apply(SPECIES.length());
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Byte64Vector.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Byte64Vector.java
index 5def012f601..177b7c77aa0 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Byte64Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Byte64Vector.java
@@ -1317,6 +1473,56 @@ public class Byte64Vector extends AbstractVectorBenchmark {
         bh.consume(r);
     }
 
+    @Benchmark
+    public Object compress() {
+        byte[] a = fa.apply(size);
+        byte[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                av.compress(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object expand() {
+        byte[] a = fa.apply(size);
+        byte[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                av.expand(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object maskCompress() {
+        boolean[] ms = fmt.apply(size);
+        boolean[] rs = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, i);
+                m.compress().intoArray(SPECIES, rs, i);
+            }
+        }
+
+        return rs;
+    }
+
+
     @Benchmark
     public void laneextract(Blackhole bh) {
         byte[] a = fa.apply(SPECIES.length());
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/ByteMaxVector.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/ByteMaxVector.java
index 02528a14a23..e7f87264c41 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/ByteMaxVector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/ByteMaxVector.java
@@ -1317,6 +1473,56 @@ public class ByteMaxVector extends AbstractVectorBenchmark {
         bh.consume(r);
     }
 
+    @Benchmark
+    public Object compress() {
+        byte[] a = fa.apply(size);
+        byte[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                av.compress(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object expand() {
+        byte[] a = fa.apply(size);
+        byte[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);
+                av.expand(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object maskCompress() {
+        boolean[] ms = fmt.apply(size);
+        boolean[] rs = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, i);
+                m.compress().intoArray(SPECIES, rs, i);
+            }
+        }
+
+        return rs;
+    }
+
+
     @Benchmark
     public void laneextract(Blackhole bh) {
         byte[] a = fa.apply(SPECIES.length());
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/ByteScalar.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/ByteScalar.java
index 6e52a8da642..7450ce45537 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/ByteScalar.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/ByteScalar.java
@@ -1235,6 +1399,56 @@ public class ByteScalar extends AbstractVectorBenchmark {
         int window = 512 / Byte.SIZE;
         rearrangeShared(window, bh);
     }
+
+    @Benchmark
+    public void compressScalar(Blackhole bh) {
+        byte[] as = fa.apply(size);
+        byte[] rs = new byte[size];
+        boolean[] im = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0, j = 0; i < as.length; i++) {
+                if (im[i]) {
+                    rs[j++] = as[i];
+                }
+            }
+        }
+
+        bh.consume(rs);
+    }
+
+    @Benchmark
+    public void expandScalar(Blackhole bh) {
+        byte[] as = fa.apply(size);
+        byte[] rs = new byte[size];
+        boolean[] im = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0, j = 0; i < as.length; i++) {
+                if (im[i]) {
+                    rs[i++] = as[j++];
+                }
+            }
+        }
+
+        bh.consume(rs);
+    }
+
+    @Benchmark
+    public void maskCompressScalar(Blackhole bh) {
+        boolean[] im = fmt.apply(size);
+        boolean[] rm = new boolean[size];
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0, j = 0; i < im.length; i++) {
+                if (im[i]) {
+                    rm[j++] = im[i];
+                }
+            }
+        }
+
+        bh.consume(rm);
+    }
     void broadcastShared(int window, Blackhole bh) {
         byte[] as = fa.apply(size);
         byte[] rs = fr.apply(size);
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Double128Vector.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Double128Vector.java
index 94c4cccece2..68a2f382a3a 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Double128Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Double128Vector.java
@@ -314,6 +314,14 @@ public class Double128Vector extends AbstractVectorBenchmark {
 
 
 
+
+
+
+
+
+
+
+
 
 
 
@@ -763,6 +771,56 @@ public class Double128Vector extends AbstractVectorBenchmark {
         bh.consume(r);
     }
 
+    @Benchmark
+    public Object compress() {
+        double[] a = fa.apply(size);
+        double[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);
+                av.compress(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object expand() {
+        double[] a = fa.apply(size);
+        double[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);
+                av.expand(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object maskCompress() {
+        boolean[] ms = fmt.apply(size);
+        boolean[] rs = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, i);
+                m.compress().intoArray(SPECIES, rs, i);
+            }
+        }
+
+        return rs;
+    }
+
+
     @Benchmark
     public void laneextract(Blackhole bh) {
         double[] a = fa.apply(SPECIES.length());
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Double256Vector.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Double256Vector.java
index 454078eace9..09250705ced 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Double256Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Double256Vector.java
@@ -314,6 +314,14 @@ public class Double256Vector extends AbstractVectorBenchmark {
 
 
 
+
+
+
+
+
+
+
+
 
 
 
@@ -763,6 +771,56 @@ public class Double256Vector extends AbstractVectorBenchmark {
         bh.consume(r);
     }
 
+    @Benchmark
+    public Object compress() {
+        double[] a = fa.apply(size);
+        double[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);
+                av.compress(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object expand() {
+        double[] a = fa.apply(size);
+        double[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);
+                av.expand(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object maskCompress() {
+        boolean[] ms = fmt.apply(size);
+        boolean[] rs = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, i);
+                m.compress().intoArray(SPECIES, rs, i);
+            }
+        }
+
+        return rs;
+    }
+
+
     @Benchmark
     public void laneextract(Blackhole bh) {
         double[] a = fa.apply(SPECIES.length());
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Double512Vector.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Double512Vector.java
index adade9cf6b8..16ddf7afe55 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Double512Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Double512Vector.java
@@ -314,6 +314,14 @@ public class Double512Vector extends AbstractVectorBenchmark {
 
 
 
+
+
+
+
+
+
+
+
 
 
 
@@ -763,6 +771,56 @@ public class Double512Vector extends AbstractVectorBenchmark {
         bh.consume(r);
     }
 
+    @Benchmark
+    public Object compress() {
+        double[] a = fa.apply(size);
+        double[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);
+                av.compress(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object expand() {
+        double[] a = fa.apply(size);
+        double[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);
+                av.expand(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object maskCompress() {
+        boolean[] ms = fmt.apply(size);
+        boolean[] rs = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, i);
+                m.compress().intoArray(SPECIES, rs, i);
+            }
+        }
+
+        return rs;
+    }
+
+
     @Benchmark
     public void laneextract(Blackhole bh) {
         double[] a = fa.apply(SPECIES.length());
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Double64Vector.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Double64Vector.java
index ea21c366cb6..7fdf118ae42 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Double64Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Double64Vector.java
@@ -314,6 +314,14 @@ public class Double64Vector extends AbstractVectorBenchmark {
 
 
 
+
+
+
+
+
+
+
+
 
 
 
@@ -763,6 +771,56 @@ public class Double64Vector extends AbstractVectorBenchmark {
         bh.consume(r);
     }
 
+    @Benchmark
+    public Object compress() {
+        double[] a = fa.apply(size);
+        double[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);
+                av.compress(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object expand() {
+        double[] a = fa.apply(size);
+        double[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);
+                av.expand(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object maskCompress() {
+        boolean[] ms = fmt.apply(size);
+        boolean[] rs = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, i);
+                m.compress().intoArray(SPECIES, rs, i);
+            }
+        }
+
+        return rs;
+    }
+
+
     @Benchmark
     public void laneextract(Blackhole bh) {
         double[] a = fa.apply(SPECIES.length());
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/DoubleMaxVector.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/DoubleMaxVector.java
index 36256fb84df..4db6357cbeb 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/DoubleMaxVector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/DoubleMaxVector.java
@@ -314,6 +314,14 @@ public class DoubleMaxVector extends AbstractVectorBenchmark {
 
 
 
+
+
+
+
+
+
+
+
 
 
 
@@ -763,6 +771,56 @@ public class DoubleMaxVector extends AbstractVectorBenchmark {
         bh.consume(r);
     }
 
+    @Benchmark
+    public Object compress() {
+        double[] a = fa.apply(size);
+        double[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);
+                av.compress(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object expand() {
+        double[] a = fa.apply(size);
+        double[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);
+                av.expand(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object maskCompress() {
+        boolean[] ms = fmt.apply(size);
+        boolean[] rs = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, i);
+                m.compress().intoArray(SPECIES, rs, i);
+            }
+        }
+
+        return rs;
+    }
+
+
     @Benchmark
     public void laneextract(Blackhole bh) {
         double[] a = fa.apply(SPECIES.length());
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/DoubleScalar.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/DoubleScalar.java
index 537431d5b49..6397e14cd37 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/DoubleScalar.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/DoubleScalar.java
@@ -335,6 +335,14 @@ public class DoubleScalar extends AbstractVectorBenchmark {
 
 
 
+
+
+
+
+
+
+
+
 
 
 
@@ -732,6 +740,56 @@ public class DoubleScalar extends AbstractVectorBenchmark {
         int window = 512 / Double.SIZE;
         rearrangeShared(window, bh);
     }
+
+    @Benchmark
+    public void compressScalar(Blackhole bh) {
+        double[] as = fa.apply(size);
+        double[] rs = new double[size];
+        boolean[] im = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0, j = 0; i < as.length; i++) {
+                if (im[i]) {
+                    rs[j++] = as[i];
+                }
+            }
+        }
+
+        bh.consume(rs);
+    }
+
+    @Benchmark
+    public void expandScalar(Blackhole bh) {
+        double[] as = fa.apply(size);
+        double[] rs = new double[size];
+        boolean[] im = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0, j = 0; i < as.length; i++) {
+                if (im[i]) {
+                    rs[i++] = as[j++];
+                }
+            }
+        }
+
+        bh.consume(rs);
+    }
+
+    @Benchmark
+    public void maskCompressScalar(Blackhole bh) {
+        boolean[] im = fmt.apply(size);
+        boolean[] rm = new boolean[size];
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0, j = 0; i < im.length; i++) {
+                if (im[i]) {
+                    rm[j++] = im[i];
+                }
+            }
+        }
+
+        bh.consume(rm);
+    }
     void broadcastShared(int window, Blackhole bh) {
         double[] as = fa.apply(size);
         double[] rs = fr.apply(size);
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Float128Vector.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Float128Vector.java
index 5bf054addcd..50fe6f3420c 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Float128Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Float128Vector.java
@@ -314,6 +314,14 @@ public class Float128Vector extends AbstractVectorBenchmark {
 
 
 
+
+
+
+
+
+
+
+
 
 
 
@@ -763,6 +771,56 @@ public class Float128Vector extends AbstractVectorBenchmark {
         bh.consume(r);
     }
 
+    @Benchmark
+    public Object compress() {
+        float[] a = fa.apply(size);
+        float[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);
+                av.compress(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object expand() {
+        float[] a = fa.apply(size);
+        float[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);
+                av.expand(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object maskCompress() {
+        boolean[] ms = fmt.apply(size);
+        boolean[] rs = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, i);
+                m.compress().intoArray(SPECIES, rs, i);
+            }
+        }
+
+        return rs;
+    }
+
+
     @Benchmark
     public void laneextract(Blackhole bh) {
         float[] a = fa.apply(SPECIES.length());
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Float256Vector.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Float256Vector.java
index 5afc7349afc..67266373a6c 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Float256Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Float256Vector.java
@@ -314,6 +314,14 @@ public class Float256Vector extends AbstractVectorBenchmark {
 
 
 
+
+
+
+
+
+
+
+
 
 
 
@@ -763,6 +771,56 @@ public class Float256Vector extends AbstractVectorBenchmark {
         bh.consume(r);
     }
 
+    @Benchmark
+    public Object compress() {
+        float[] a = fa.apply(size);
+        float[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);
+                av.compress(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object expand() {
+        float[] a = fa.apply(size);
+        float[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);
+                av.expand(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object maskCompress() {
+        boolean[] ms = fmt.apply(size);
+        boolean[] rs = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, i);
+                m.compress().intoArray(SPECIES, rs, i);
+            }
+        }
+
+        return rs;
+    }
+
+
     @Benchmark
     public void laneextract(Blackhole bh) {
         float[] a = fa.apply(SPECIES.length());
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Float512Vector.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Float512Vector.java
index adba35f072b..38adb5a5f02 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Float512Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Float512Vector.java
@@ -314,6 +314,14 @@ public class Float512Vector extends AbstractVectorBenchmark {
 
 
 
+
+
+
+
+
+
+
+
 
 
 
@@ -763,6 +771,56 @@ public class Float512Vector extends AbstractVectorBenchmark {
         bh.consume(r);
     }
 
+    @Benchmark
+    public Object compress() {
+        float[] a = fa.apply(size);
+        float[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);
+                av.compress(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object expand() {
+        float[] a = fa.apply(size);
+        float[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);
+                av.expand(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object maskCompress() {
+        boolean[] ms = fmt.apply(size);
+        boolean[] rs = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, i);
+                m.compress().intoArray(SPECIES, rs, i);
+            }
+        }
+
+        return rs;
+    }
+
+
     @Benchmark
     public void laneextract(Blackhole bh) {
         float[] a = fa.apply(SPECIES.length());
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Float64Vector.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Float64Vector.java
index 6515a189071..d919627eee3 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Float64Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Float64Vector.java
@@ -314,6 +314,14 @@ public class Float64Vector extends AbstractVectorBenchmark {
 
 
 
+
+
+
+
+
+
+
+
 
 
 
@@ -763,6 +771,56 @@ public class Float64Vector extends AbstractVectorBenchmark {
         bh.consume(r);
     }
 
+    @Benchmark
+    public Object compress() {
+        float[] a = fa.apply(size);
+        float[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);
+                av.compress(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object expand() {
+        float[] a = fa.apply(size);
+        float[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);
+                av.expand(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object maskCompress() {
+        boolean[] ms = fmt.apply(size);
+        boolean[] rs = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, i);
+                m.compress().intoArray(SPECIES, rs, i);
+            }
+        }
+
+        return rs;
+    }
+
+
     @Benchmark
     public void laneextract(Blackhole bh) {
         float[] a = fa.apply(SPECIES.length());
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/FloatMaxVector.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/FloatMaxVector.java
index 0d3e5a99a93..030941a1df1 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/FloatMaxVector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/FloatMaxVector.java
@@ -314,6 +314,14 @@ public class FloatMaxVector extends AbstractVectorBenchmark {
 
 
 
+
+
+
+
+
+
+
+
 
 
 
@@ -763,6 +771,56 @@ public class FloatMaxVector extends AbstractVectorBenchmark {
         bh.consume(r);
     }
 
+    @Benchmark
+    public Object compress() {
+        float[] a = fa.apply(size);
+        float[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);
+                av.compress(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object expand() {
+        float[] a = fa.apply(size);
+        float[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);
+                av.expand(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object maskCompress() {
+        boolean[] ms = fmt.apply(size);
+        boolean[] rs = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, i);
+                m.compress().intoArray(SPECIES, rs, i);
+            }
+        }
+
+        return rs;
+    }
+
+
     @Benchmark
     public void laneextract(Blackhole bh) {
         float[] a = fa.apply(SPECIES.length());
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/FloatScalar.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/FloatScalar.java
index c9ee97aeb54..4f07960fd5d 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/FloatScalar.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/FloatScalar.java
@@ -335,6 +335,14 @@ public class FloatScalar extends AbstractVectorBenchmark {
 
 
 
+
+
+
+
+
+
+
+
 
 
 
@@ -732,6 +740,56 @@ public class FloatScalar extends AbstractVectorBenchmark {
         int window = 512 / Float.SIZE;
         rearrangeShared(window, bh);
     }
+
+    @Benchmark
+    public void compressScalar(Blackhole bh) {
+        float[] as = fa.apply(size);
+        float[] rs = new float[size];
+        boolean[] im = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0, j = 0; i < as.length; i++) {
+                if (im[i]) {
+                    rs[j++] = as[i];
+                }
+            }
+        }
+
+        bh.consume(rs);
+    }
+
+    @Benchmark
+    public void expandScalar(Blackhole bh) {
+        float[] as = fa.apply(size);
+        float[] rs = new float[size];
+        boolean[] im = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0, j = 0; i < as.length; i++) {
+                if (im[i]) {
+                    rs[i++] = as[j++];
+                }
+            }
+        }
+
+        bh.consume(rs);
+    }
+
+    @Benchmark
+    public void maskCompressScalar(Blackhole bh) {
+        boolean[] im = fmt.apply(size);
+        boolean[] rm = new boolean[size];
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0, j = 0; i < im.length; i++) {
+                if (im[i]) {
+                    rm[j++] = im[i];
+                }
+            }
+        }
+
+        bh.consume(rm);
+    }
     void broadcastShared(int window, Blackhole bh) {
         float[] as = fa.apply(size);
         float[] rs = fr.apply(size);
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Int128Vector.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Int128Vector.java
index b20916c8fd9..b0a3271be25 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Int128Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Int128Vector.java
@@ -1317,6 +1473,56 @@ public class Int128Vector extends AbstractVectorBenchmark {
         bh.consume(r);
     }
 
+    @Benchmark
+    public Object compress() {
+        int[] a = fa.apply(size);
+        int[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                IntVector av = IntVector.fromArray(SPECIES, a, i);
+                av.compress(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object expand() {
+        int[] a = fa.apply(size);
+        int[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                IntVector av = IntVector.fromArray(SPECIES, a, i);
+                av.expand(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object maskCompress() {
+        boolean[] ms = fmt.apply(size);
+        boolean[] rs = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, i);
+                m.compress().intoArray(SPECIES, rs, i);
+            }
+        }
+
+        return rs;
+    }
+
+
     @Benchmark
     public void laneextract(Blackhole bh) {
         int[] a = fa.apply(SPECIES.length());
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Int256Vector.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Int256Vector.java
index f03d22138b2..10831742794 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Int256Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Int256Vector.java
@@ -1317,6 +1473,56 @@ public class Int256Vector extends AbstractVectorBenchmark {
         bh.consume(r);
     }
 
+    @Benchmark
+    public Object compress() {
+        int[] a = fa.apply(size);
+        int[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                IntVector av = IntVector.fromArray(SPECIES, a, i);
+                av.compress(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object expand() {
+        int[] a = fa.apply(size);
+        int[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                IntVector av = IntVector.fromArray(SPECIES, a, i);
+                av.expand(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object maskCompress() {
+        boolean[] ms = fmt.apply(size);
+        boolean[] rs = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, i);
+                m.compress().intoArray(SPECIES, rs, i);
+            }
+        }
+
+        return rs;
+    }
+
+
     @Benchmark
     public void laneextract(Blackhole bh) {
         int[] a = fa.apply(SPECIES.length());
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Int512Vector.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Int512Vector.java
index 801f005254f..3765ea2b441 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Int512Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Int512Vector.java
@@ -1317,6 +1473,56 @@ public class Int512Vector extends AbstractVectorBenchmark {
         bh.consume(r);
     }
 
+    @Benchmark
+    public Object compress() {
+        int[] a = fa.apply(size);
+        int[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                IntVector av = IntVector.fromArray(SPECIES, a, i);
+                av.compress(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object expand() {
+        int[] a = fa.apply(size);
+        int[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                IntVector av = IntVector.fromArray(SPECIES, a, i);
+                av.expand(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object maskCompress() {
+        boolean[] ms = fmt.apply(size);
+        boolean[] rs = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, i);
+                m.compress().intoArray(SPECIES, rs, i);
+            }
+        }
+
+        return rs;
+    }
+
+
     @Benchmark
     public void laneextract(Blackhole bh) {
         int[] a = fa.apply(SPECIES.length());
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Int64Vector.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Int64Vector.java
index a43b20238b7..5eee643c434 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Int64Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Int64Vector.java
@@ -1317,6 +1473,56 @@ public class Int64Vector extends AbstractVectorBenchmark {
         bh.consume(r);
     }
 
+    @Benchmark
+    public Object compress() {
+        int[] a = fa.apply(size);
+        int[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                IntVector av = IntVector.fromArray(SPECIES, a, i);
+                av.compress(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object expand() {
+        int[] a = fa.apply(size);
+        int[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                IntVector av = IntVector.fromArray(SPECIES, a, i);
+                av.expand(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object maskCompress() {
+        boolean[] ms = fmt.apply(size);
+        boolean[] rs = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, i);
+                m.compress().intoArray(SPECIES, rs, i);
+            }
+        }
+
+        return rs;
+    }
+
+
     @Benchmark
     public void laneextract(Blackhole bh) {
         int[] a = fa.apply(SPECIES.length());
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/IntMaxVector.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/IntMaxVector.java
index ced372012a1..e4e968e63ce 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/IntMaxVector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/IntMaxVector.java
@@ -1317,6 +1473,56 @@ public class IntMaxVector extends AbstractVectorBenchmark {
         bh.consume(r);
     }
 
+    @Benchmark
+    public Object compress() {
+        int[] a = fa.apply(size);
+        int[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                IntVector av = IntVector.fromArray(SPECIES, a, i);
+                av.compress(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object expand() {
+        int[] a = fa.apply(size);
+        int[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                IntVector av = IntVector.fromArray(SPECIES, a, i);
+                av.expand(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object maskCompress() {
+        boolean[] ms = fmt.apply(size);
+        boolean[] rs = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, i);
+                m.compress().intoArray(SPECIES, rs, i);
+            }
+        }
+
+        return rs;
+    }
+
+
     @Benchmark
     public void laneextract(Blackhole bh) {
         int[] a = fa.apply(SPECIES.length());
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/IntScalar.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/IntScalar.java
index 8dfec573dfe..aee8e1635f2 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/IntScalar.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/IntScalar.java
@@ -1235,6 +1399,56 @@ public class IntScalar extends AbstractVectorBenchmark {
         int window = 512 / Integer.SIZE;
         rearrangeShared(window, bh);
     }
+
+    @Benchmark
+    public void compressScalar(Blackhole bh) {
+        int[] as = fa.apply(size);
+        int[] rs = new int[size];
+        boolean[] im = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0, j = 0; i < as.length; i++) {
+                if (im[i]) {
+                    rs[j++] = as[i];
+                }
+            }
+        }
+
+        bh.consume(rs);
+    }
+
+    @Benchmark
+    public void expandScalar(Blackhole bh) {
+        int[] as = fa.apply(size);
+        int[] rs = new int[size];
+        boolean[] im = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0, j = 0; i < as.length; i++) {
+                if (im[i]) {
+                    rs[i++] = as[j++];
+                }
+            }
+        }
+
+        bh.consume(rs);
+    }
+
+    @Benchmark
+    public void maskCompressScalar(Blackhole bh) {
+        boolean[] im = fmt.apply(size);
+        boolean[] rm = new boolean[size];
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0, j = 0; i < im.length; i++) {
+                if (im[i]) {
+                    rm[j++] = im[i];
+                }
+            }
+        }
+
+        bh.consume(rm);
+    }
     void broadcastShared(int window, Blackhole bh) {
         int[] as = fa.apply(size);
         int[] rs = fr.apply(size);
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Long128Vector.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Long128Vector.java
index 53620102aba..083b10778f5 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Long128Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Long128Vector.java
@@ -1317,6 +1473,56 @@ public class Long128Vector extends AbstractVectorBenchmark {
         bh.consume(r);
     }
 
+    @Benchmark
+    public Object compress() {
+        long[] a = fa.apply(size);
+        long[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                LongVector av = LongVector.fromArray(SPECIES, a, i);
+                av.compress(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object expand() {
+        long[] a = fa.apply(size);
+        long[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                LongVector av = LongVector.fromArray(SPECIES, a, i);
+                av.expand(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object maskCompress() {
+        boolean[] ms = fmt.apply(size);
+        boolean[] rs = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, i);
+                m.compress().intoArray(SPECIES, rs, i);
+            }
+        }
+
+        return rs;
+    }
+
+
     @Benchmark
     public void laneextract(Blackhole bh) {
         long[] a = fa.apply(SPECIES.length());
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Long256Vector.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Long256Vector.java
index f73cbe5fea4..296e92e6925 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Long256Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Long256Vector.java
@@ -1317,6 +1473,56 @@ public class Long256Vector extends AbstractVectorBenchmark {
         bh.consume(r);
     }
 
+    @Benchmark
+    public Object compress() {
+        long[] a = fa.apply(size);
+        long[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                LongVector av = LongVector.fromArray(SPECIES, a, i);
+                av.compress(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object expand() {
+        long[] a = fa.apply(size);
+        long[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                LongVector av = LongVector.fromArray(SPECIES, a, i);
+                av.expand(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object maskCompress() {
+        boolean[] ms = fmt.apply(size);
+        boolean[] rs = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, i);
+                m.compress().intoArray(SPECIES, rs, i);
+            }
+        }
+
+        return rs;
+    }
+
+
     @Benchmark
     public void laneextract(Blackhole bh) {
         long[] a = fa.apply(SPECIES.length());
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Long512Vector.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Long512Vector.java
index 12f3df6cb92..48238d48cd8 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Long512Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Long512Vector.java
@@ -1317,6 +1473,56 @@ public class Long512Vector extends AbstractVectorBenchmark {
         bh.consume(r);
     }
 
+    @Benchmark
+    public Object compress() {
+        long[] a = fa.apply(size);
+        long[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                LongVector av = LongVector.fromArray(SPECIES, a, i);
+                av.compress(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object expand() {
+        long[] a = fa.apply(size);
+        long[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                LongVector av = LongVector.fromArray(SPECIES, a, i);
+                av.expand(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object maskCompress() {
+        boolean[] ms = fmt.apply(size);
+        boolean[] rs = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, i);
+                m.compress().intoArray(SPECIES, rs, i);
+            }
+        }
+
+        return rs;
+    }
+
+
     @Benchmark
     public void laneextract(Blackhole bh) {
         long[] a = fa.apply(SPECIES.length());
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Long64Vector.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Long64Vector.java
index 89a29ebc125..90b605195cf 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Long64Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Long64Vector.java
@@ -1317,6 +1473,56 @@ public class Long64Vector extends AbstractVectorBenchmark {
         bh.consume(r);
     }
 
+    @Benchmark
+    public Object compress() {
+        long[] a = fa.apply(size);
+        long[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                LongVector av = LongVector.fromArray(SPECIES, a, i);
+                av.compress(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object expand() {
+        long[] a = fa.apply(size);
+        long[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                LongVector av = LongVector.fromArray(SPECIES, a, i);
+                av.expand(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object maskCompress() {
+        boolean[] ms = fmt.apply(size);
+        boolean[] rs = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, i);
+                m.compress().intoArray(SPECIES, rs, i);
+            }
+        }
+
+        return rs;
+    }
+
+
     @Benchmark
     public void laneextract(Blackhole bh) {
         long[] a = fa.apply(SPECIES.length());
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/LongMaxVector.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/LongMaxVector.java
index 950635e6263..10d4dd82d0f 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/LongMaxVector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/LongMaxVector.java
@@ -1317,6 +1473,56 @@ public class LongMaxVector extends AbstractVectorBenchmark {
         bh.consume(r);
     }
 
+    @Benchmark
+    public Object compress() {
+        long[] a = fa.apply(size);
+        long[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                LongVector av = LongVector.fromArray(SPECIES, a, i);
+                av.compress(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object expand() {
+        long[] a = fa.apply(size);
+        long[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                LongVector av = LongVector.fromArray(SPECIES, a, i);
+                av.expand(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object maskCompress() {
+        boolean[] ms = fmt.apply(size);
+        boolean[] rs = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, i);
+                m.compress().intoArray(SPECIES, rs, i);
+            }
+        }
+
+        return rs;
+    }
+
+
     @Benchmark
     public void laneextract(Blackhole bh) {
         long[] a = fa.apply(SPECIES.length());
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/LongScalar.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/LongScalar.java
index 6328e3872dd..2b8c2e1f3f4 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/LongScalar.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/LongScalar.java
@@ -1235,6 +1399,56 @@ public class LongScalar extends AbstractVectorBenchmark {
         int window = 512 / Long.SIZE;
         rearrangeShared(window, bh);
     }
+
+    @Benchmark
+    public void compressScalar(Blackhole bh) {
+        long[] as = fa.apply(size);
+        long[] rs = new long[size];
+        boolean[] im = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0, j = 0; i < as.length; i++) {
+                if (im[i]) {
+                    rs[j++] = as[i];
+                }
+            }
+        }
+
+        bh.consume(rs);
+    }
+
+    @Benchmark
+    public void expandScalar(Blackhole bh) {
+        long[] as = fa.apply(size);
+        long[] rs = new long[size];
+        boolean[] im = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0, j = 0; i < as.length; i++) {
+                if (im[i]) {
+                    rs[i++] = as[j++];
+                }
+            }
+        }
+
+        bh.consume(rs);
+    }
+
+    @Benchmark
+    public void maskCompressScalar(Blackhole bh) {
+        boolean[] im = fmt.apply(size);
+        boolean[] rm = new boolean[size];
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0, j = 0; i < im.length; i++) {
+                if (im[i]) {
+                    rm[j++] = im[i];
+                }
+            }
+        }
+
+        bh.consume(rm);
+    }
     void broadcastShared(int window, Blackhole bh) {
         long[] as = fa.apply(size);
         long[] rs = fr.apply(size);
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Short128Vector.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Short128Vector.java
index 64bc30194c1..5695ca909b8 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Short128Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Short128Vector.java
@@ -1317,6 +1473,56 @@ public class Short128Vector extends AbstractVectorBenchmark {
         bh.consume(r);
     }
 
+    @Benchmark
+    public Object compress() {
+        short[] a = fa.apply(size);
+        short[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                av.compress(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object expand() {
+        short[] a = fa.apply(size);
+        short[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                av.expand(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object maskCompress() {
+        boolean[] ms = fmt.apply(size);
+        boolean[] rs = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, i);
+                m.compress().intoArray(SPECIES, rs, i);
+            }
+        }
+
+        return rs;
+    }
+
+
     @Benchmark
     public void laneextract(Blackhole bh) {
         short[] a = fa.apply(SPECIES.length());
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Short256Vector.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Short256Vector.java
index 3b629f37b65..df0b4c02254 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Short256Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Short256Vector.java
@@ -1317,6 +1473,56 @@ public class Short256Vector extends AbstractVectorBenchmark {
         bh.consume(r);
     }
 
+    @Benchmark
+    public Object compress() {
+        short[] a = fa.apply(size);
+        short[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                av.compress(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object expand() {
+        short[] a = fa.apply(size);
+        short[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                av.expand(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object maskCompress() {
+        boolean[] ms = fmt.apply(size);
+        boolean[] rs = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, i);
+                m.compress().intoArray(SPECIES, rs, i);
+            }
+        }
+
+        return rs;
+    }
+
+
     @Benchmark
     public void laneextract(Blackhole bh) {
         short[] a = fa.apply(SPECIES.length());
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Short512Vector.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Short512Vector.java
index 9225a063571..23bac0c4f6f 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Short512Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Short512Vector.java
@@ -1317,6 +1473,56 @@ public class Short512Vector extends AbstractVectorBenchmark {
         bh.consume(r);
     }
 
+    @Benchmark
+    public Object compress() {
+        short[] a = fa.apply(size);
+        short[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                av.compress(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object expand() {
+        short[] a = fa.apply(size);
+        short[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                av.expand(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object maskCompress() {
+        boolean[] ms = fmt.apply(size);
+        boolean[] rs = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, i);
+                m.compress().intoArray(SPECIES, rs, i);
+            }
+        }
+
+        return rs;
+    }
+
+
     @Benchmark
     public void laneextract(Blackhole bh) {
         short[] a = fa.apply(SPECIES.length());
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Short64Vector.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Short64Vector.java
index 507ddefdd97..84f8bea7d66 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Short64Vector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/Short64Vector.java
@@ -1317,6 +1473,56 @@ public class Short64Vector extends AbstractVectorBenchmark {
         bh.consume(r);
     }
 
+    @Benchmark
+    public Object compress() {
+        short[] a = fa.apply(size);
+        short[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                av.compress(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object expand() {
+        short[] a = fa.apply(size);
+        short[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                av.expand(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object maskCompress() {
+        boolean[] ms = fmt.apply(size);
+        boolean[] rs = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, i);
+                m.compress().intoArray(SPECIES, rs, i);
+            }
+        }
+
+        return rs;
+    }
+
+
     @Benchmark
     public void laneextract(Blackhole bh) {
         short[] a = fa.apply(SPECIES.length());
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/ShortMaxVector.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/ShortMaxVector.java
index 2d6ee43f05a..6f07f0ed803 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/ShortMaxVector.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/ShortMaxVector.java
@@ -1317,6 +1473,56 @@ public class ShortMaxVector extends AbstractVectorBenchmark {
         bh.consume(r);
     }
 
+    @Benchmark
+    public Object compress() {
+        short[] a = fa.apply(size);
+        short[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                av.compress(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object expand() {
+        short[] a = fa.apply(size);
+        short[] r = fb.apply(size);
+        boolean[] ms = fmt.apply(size);
+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);
+                av.expand(m).intoArray(SPECIES, r, i);
+            }
+        }
+
+        return r;
+    }
+
+    @Benchmark
+    public Object maskCompress() {
+        boolean[] ms = fmt.apply(size);
+        boolean[] rs = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0; i < a.length; i += SPECIES.length()) {
+                VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, i);
+                m.compress().intoArray(SPECIES, rs, i);
+            }
+        }
+
+        return rs;
+    }
+
+
     @Benchmark
     public void laneextract(Blackhole bh) {
         short[] a = fa.apply(SPECIES.length());
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/ShortScalar.java b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/ShortScalar.java
index 5d6e09d4238..7fa71540d07 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/ShortScalar.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/vector/operation/ShortScalar.java
@@ -1235,6 +1399,56 @@ public class ShortScalar extends AbstractVectorBenchmark {
         int window = 512 / Short.SIZE;
         rearrangeShared(window, bh);
     }
+
+    @Benchmark
+    public void compressScalar(Blackhole bh) {
+        short[] as = fa.apply(size);
+        short[] rs = new short[size];
+        boolean[] im = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0, j = 0; i < as.length; i++) {
+                if (im[i]) {
+                    rs[j++] = as[i];
+                }
+            }
+        }
+
+        bh.consume(rs);
+    }
+
+    @Benchmark
+    public void expandScalar(Blackhole bh) {
+        short[] as = fa.apply(size);
+        short[] rs = new short[size];
+        boolean[] im = fmt.apply(size);
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0, j = 0; i < as.length; i++) {
+                if (im[i]) {
+                    rs[i++] = as[j++];
+                }
+            }
+        }
+
+        bh.consume(rs);
+    }
+
+    @Benchmark
+    public void maskCompressScalar(Blackhole bh) {
+        boolean[] im = fmt.apply(size);
+        boolean[] rm = new boolean[size];
+
+        for (int ic = 0; ic < INVOC_COUNT; ic++) {
+            for (int i = 0, j = 0; i < im.length; i++) {
+                if (im[i]) {
+                    rm[j++] = im[i];
+                }
+            }
+        }
+
+        bh.consume(rm);
+    }
     void broadcastShared(int window, Blackhole bh) {
         short[] as = fa.apply(size);
         short[] rs = fr.apply(size);
 
