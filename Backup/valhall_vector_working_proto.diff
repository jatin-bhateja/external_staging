diff --git a/configure b/configure
old mode 100644
new mode 100755
diff --git a/make/common/JavaCompilation.gmk b/make/common/JavaCompilation.gmk
index 880f65267ad..6d332b5f933 100644
--- a/make/common/JavaCompilation.gmk
+++ b/make/common/JavaCompilation.gmk
@@ -264,7 +264,7 @@ define SetupJavaCompilationBody
   endif
 
   # Allow overriding on the command line
-  JAVA_WARNINGS_ARE_ERRORS ?= -Werror
+  JAVA_WARNINGS_ARE_ERRORS ?=
 
   # Tell javac to do exactly as told and no more
   PARANOIA_FLAGS := -implicit:none -Xprefer:source -XDignore.symbol.file=true -encoding ascii
diff --git a/src/hotspot/share/classfile/javaClasses.cpp b/src/hotspot/share/classfile/javaClasses.cpp
index 29eeb219b88..f2574b9b38b 100644
--- a/src/hotspot/share/classfile/javaClasses.cpp
+++ b/src/hotspot/share/classfile/javaClasses.cpp
@@ -5149,7 +5149,8 @@ int vector_VectorPayload::_payload_offset;
 
 void vector_VectorPayload::compute_offsets() {
   InstanceKlass* k = vmClasses::vector_VectorPayload_klass();
-  VECTORPAYLOAD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
+  //FIXME
+  // VECTORPAYLOAD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
 }
 
 #if INCLUDE_CDS
diff --git a/src/java.base/share/classes/jdk/internal/vm/vector/VectorSupport.java b/src/java.base/share/classes/jdk/internal/vm/vector/VectorSupport.java
index 418298fe898..6baadf5796e 100644
--- a/src/java.base/share/classes/jdk/internal/vm/vector/VectorSupport.java
+++ b/src/java.base/share/classes/jdk/internal/vm/vector/VectorSupport.java
@@ -25,10 +25,14 @@
 
 package jdk.internal.vm.vector;
 
+import java.util.Objects;
 import jdk.internal.vm.annotation.IntrinsicCandidate;
+import jdk.internal.vm.annotation.MultiField;
 import jdk.internal.misc.Unsafe;
 
+
 import java.util.function.*;
+import java.lang.reflect.*;
 
 public class VectorSupport {
     static {
@@ -150,32 +154,362 @@ public class VectorSupport {
 
     public static class VectorSpecies<E> {}
 
-    public static class VectorPayload {
-        private final Object payload; // array of primitives
+    public abstract static class VectorPayload {
+        protected abstract Object getPayload();
+    }
 
-        public VectorPayload(Object payload) {
-            this.payload = payload;
+    public abstract static class VectorPayloadMF {
+	private static VectorPayloadMF createNewInstance(Class<?> elemType, int length)  {
+	    VectorPayloadMF obj = null;
+            if (elemType == byte.class) {
+                switch(length) {
+                    case 2: obj = new Byte64VectorPayload(); break;
+                    case 4: obj = new Byte128VectorPayload(); break;
+                    case 8: obj = new Byte256VectorPayload(); break;
+                    case 16: obj = new Byte512VectorPayload(); break;
+                    default: assert false : "Unhandled lane count"; break;
+                }
+            } else if (elemType == short.class) {
+                switch(length) {
+                    case 2: obj = new Short64VectorPayload(); break;
+                    case 4: obj = new Short128VectorPayload(); break;
+                    case 8: obj = new Short256VectorPayload(); break;
+                    case 16: obj = new Short512VectorPayload(); break;
+                    default: assert false : "Unhandled lane count"; break;
+                }
+            } else if (elemType == int.class) {
+                switch(length) {
+                    case 2: obj = new Int64VectorPayload(); break;
+                    case 4: obj = new Int128VectorPayload(); break;
+                    case 8: obj = new Int256VectorPayload(); break;
+                    case 16: obj = new Int512VectorPayload(); break;
+                    default: assert false : "Unhandled lane count"; break;
+                }
+            } else if (elemType == long.class) {
+                switch(length) {
+                    case 2: obj = new Long64VectorPayload(); break;
+                    case 4: obj = new Long128VectorPayload(); break;
+                    case 8: obj = new Long256VectorPayload(); break;
+                    case 16: obj = new Long512VectorPayload(); break;
+                    default: assert false : "Unhandled lane count"; break;
+                }
+            } else if (elemType == float.class) {
+                switch(length) {
+                    case 2: obj = new Float64VectorPayload(); break;
+                    case 4: obj = new Float128VectorPayload(); break;
+                    case 8: obj = new Float256VectorPayload(); break;
+                    case 16: obj = new Float512VectorPayload(); break;
+                    default: assert false : "Unhandled lane count"; break;
+                }
+            } else if (elemType == double.class) {
+                switch(length) {
+                    case 2: obj = new Double64VectorPayload(); break;
+                    case 4: obj = new Double128VectorPayload(); break;
+                    case 8: obj = new Double256VectorPayload(); break;
+                    case 16: obj = new Double512VectorPayload(); break;
+                    default: assert false : "Unhandled lane count"; break;
+                }
+            } else {
+                assert false : "Unhandled type";
+            }
+            return obj;
+	}
+
+        public static VectorPayloadMF createNewInstanceB(Class<?> elemType, int length, byte init) {
+	    VectorPayloadMF obj = createNewInstance(elemType, length);
+            long start_offset = obj.multiFieldOffset();
+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);
+            for (int i = 0; i < length; i++) {
+                Unsafe.getUnsafe().putByte(obj, start_offset + i * Integer.BYTES, init);
+            }
+            Unsafe.getUnsafe().finishPrivateBuffer(obj);
+	    return obj;
         }
 
-        protected final Object getPayload() {
-            return VectorSupport.maybeRebox(this).payload;
+        public static VectorPayloadMF createNewInstanceB(Class<?> elemType, int length, byte [] init) {
+	    VectorPayloadMF obj = createNewInstance(elemType, length);
+            long start_offset = obj.multiFieldOffset();
+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);
+            for (int i = 0; i < length; i++) {
+                Unsafe.getUnsafe().putByte(obj, start_offset + i * Integer.BYTES, init[i]);
+            }
+            Unsafe.getUnsafe().finishPrivateBuffer(obj);
+	    return obj;
+        }
+        public static VectorPayloadMF createNewInstanceS(Class<?> elemType, int length, short init) {
+	    VectorPayloadMF obj = createNewInstance(elemType, length);
+            long start_offset = obj.multiFieldOffset();
+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);
+            for (int i = 0; i < length; i++) {
+                Unsafe.getUnsafe().putShort(obj, start_offset + i * Integer.BYTES, init);
+            }
+            Unsafe.getUnsafe().finishPrivateBuffer(obj);
+	    return obj;
+        }
+
+        public static VectorPayloadMF createNewInstanceS(Class<?> elemType, int length, short [] init) {
+	    VectorPayloadMF obj = createNewInstance(elemType, length);
+            long start_offset = obj.multiFieldOffset();
+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);
+            for (int i = 0; i < length; i++) {
+                Unsafe.getUnsafe().putShort(obj, start_offset + i * Integer.BYTES, init[i]);
+            }
+            Unsafe.getUnsafe().finishPrivateBuffer(obj);
+	    return obj;
+        }
+        public static VectorPayloadMF createNewInstanceI(Class<?> elemType, int length, int init) {
+	    VectorPayloadMF obj = createNewInstance(elemType, length);
+            long start_offset = obj.multiFieldOffset();
+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);
+            for (int i = 0; i < length; i++) {
+                Unsafe.getUnsafe().putInt(obj, start_offset + i * Integer.BYTES, init);
+            }
+            Unsafe.getUnsafe().finishPrivateBuffer(obj);
+	    return obj;
         }
-    }
 
-    public static class Vector<E> extends VectorPayload {
-        public Vector(Object payload) {
-            super(payload);
+        public static VectorPayloadMF createNewInstanceI(Class<?> elemType, int length, int [] init) {
+	    VectorPayloadMF obj = createNewInstance(elemType, length);
+            long start_offset = obj.multiFieldOffset();
+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);
+            for (int i = 0; i < length; i++) {
+                Unsafe.getUnsafe().putInt(obj, start_offset + i * Integer.BYTES, init[i]);
+            }
+            Unsafe.getUnsafe().finishPrivateBuffer(obj);
+	    return obj;
+        }
+        public static VectorPayloadMF createNewInstanceL(Class<?> elemType, int length, long init) {
+	    VectorPayloadMF obj = createNewInstance(elemType, length);
+            long start_offset = obj.multiFieldOffset();
+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);
+            for (int i = 0; i < length; i++) {
+                Unsafe.getUnsafe().putLong(obj, start_offset + i * Integer.BYTES, init);
+            }
+            Unsafe.getUnsafe().finishPrivateBuffer(obj);
+	    return obj;
         }
+
+        public static VectorPayloadMF createNewInstanceL(Class<?> elemType, int length, long [] init) {
+	    VectorPayloadMF obj = createNewInstance(elemType, length);
+            long start_offset = obj.multiFieldOffset();
+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);
+            for (int i = 0; i < length; i++) {
+                Unsafe.getUnsafe().putLong(obj, start_offset + i * Integer.BYTES, init[i]);
+            }
+            Unsafe.getUnsafe().finishPrivateBuffer(obj);
+	    return obj;
+        }
+        public static VectorPayloadMF createNewInstanceF(Class<?> elemType, int length, float init) {
+	    VectorPayloadMF obj = createNewInstance(elemType, length);
+            long start_offset = obj.multiFieldOffset();
+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);
+            for (int i = 0; i < length; i++) {
+                Unsafe.getUnsafe().putFloat(obj, start_offset + i * Integer.BYTES, init);
+            }
+            Unsafe.getUnsafe().finishPrivateBuffer(obj);
+	    return obj;
+        }
+
+        public static VectorPayloadMF createNewInstanceF(Class<?> elemType, int length, float [] init) {
+	    VectorPayloadMF obj = createNewInstance(elemType, length);
+            long start_offset = obj.multiFieldOffset();
+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);
+            for (int i = 0; i < length; i++) {
+                Unsafe.getUnsafe().putFloat(obj, start_offset + i * Integer.BYTES, init[i]);
+            }
+            Unsafe.getUnsafe().finishPrivateBuffer(obj);
+	    return obj;
+        }
+        public static VectorPayloadMF createNewInstanceD(Class<?> elemType, int length, double init) {
+	    VectorPayloadMF obj = createNewInstance(elemType, length);
+            long start_offset = obj.multiFieldOffset();
+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);
+            for (int i = 0; i < length; i++) {
+                Unsafe.getUnsafe().putDouble(obj, start_offset + i * Integer.BYTES, init);
+            }
+            Unsafe.getUnsafe().finishPrivateBuffer(obj);
+	    return obj;
+        }
+
+        public static VectorPayloadMF createNewInstanceD(Class<?> elemType, int length, double [] init) {
+	    VectorPayloadMF obj = createNewInstance(elemType, length);
+            long start_offset = obj.multiFieldOffset();
+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);
+            for (int i = 0; i < length; i++) {
+                Unsafe.getUnsafe().putDouble(obj, start_offset + i * Integer.BYTES, init[i]);
+            }
+            Unsafe.getUnsafe().finishPrivateBuffer(obj);
+	    return obj;
+        }
+
+        public long multiFieldOffset() {
+            try {
+                var field = this.getClass().getDeclaredField("mfield");
+                return Unsafe.getUnsafe().objectFieldOffset(field);
+            } catch (Exception e) {
+                System.out.println(e);
+	    }
+	    return -1L;
+        }
+
+        public int length() {
+            try {
+                var field = this.getClass().getDeclaredField("mfield");
+                var msanno = field.getAnnotationsByType(MultiField.class);
+
+                Objects.nonNull(msanno);
+
+                assert msanno.length == 1;
+                return msanno[0].value();
+	    } catch (Exception e) {
+                System.out.println(e);
+	    }
+	    return -1;
+
+        }
+    }
+
+    public primitive static class Byte64VectorPayload extends VectorPayloadMF {
+        @MultiField(value = 2)
+        byte mfield = 0;
+    }
+
+    public primitive static class Byte128VectorPayload extends VectorPayloadMF {
+        @MultiField(value = 4)
+        byte mfield = 0;
+    }
+
+    public primitive static class Byte256VectorPayload extends VectorPayloadMF {
+        @MultiField(value = 8)
+        byte mfield = 0;
+    }
+
+    public primitive static class Byte512VectorPayload extends VectorPayloadMF {
+        @MultiField(value = 16)
+        byte mfield = 0;
+    }
+
+    public primitive static class Short64VectorPayload extends VectorPayloadMF {
+        @MultiField(value = 2)
+        short mfield = 0;
+    }
+
+    public primitive static class Short128VectorPayload extends VectorPayloadMF {
+        @MultiField(value = 4)
+        short mfield = 0;
+    }
+
+    public primitive static class Short256VectorPayload extends VectorPayloadMF {
+        @MultiField(value = 8)
+        short mfield = 0;
+    }
+
+    public primitive static class Short512VectorPayload extends VectorPayloadMF {
+        @MultiField(value = 16)
+        short mfield = 0;
+    }
+
+    public primitive static class Int64VectorPayload extends VectorPayloadMF {
+        @MultiField(value = 2)
+        int mfield = 0;
     }
 
+    public primitive static class Int128VectorPayload extends VectorPayloadMF {
+        @MultiField(value = 4)
+        int mfield = 0;
+    }
+
+    public primitive static class Int256VectorPayload extends VectorPayloadMF {
+        @MultiField(value = 8)
+        int mfield = 0;
+    }
+
+    public primitive static class Int512VectorPayload extends VectorPayloadMF {
+        @MultiField(value = 16)
+        int mfield = 0;
+    }
+
+    public primitive static class Float64VectorPayload extends VectorPayloadMF {
+        @MultiField(value = 2)
+        float mfield = 0.0f;
+    }
+
+    public primitive static class Float128VectorPayload extends VectorPayloadMF {
+        @MultiField(value = 4)
+        float mfield = 0.0f;
+    }
+
+    public primitive static class Float256VectorPayload extends VectorPayloadMF {
+        @MultiField(value = 8)
+        float mfield = 0.0f;
+    }
+
+    public primitive static class Float512VectorPayload extends VectorPayloadMF {
+        @MultiField(value = 16)
+        float mfield = 0.0f;
+    }
+
+    public primitive static class Long64VectorPayload extends VectorPayloadMF {
+        @MultiField(value = 2)
+        long mfield = 0L;
+    }
+
+    public primitive static class Long128VectorPayload extends VectorPayloadMF {
+        @MultiField(value = 4)
+        long mfield = 0L;
+    }
+
+    public primitive static class Long256VectorPayload extends VectorPayloadMF {
+        @MultiField(value = 8)
+        long mfield = 0L;
+    }
+
+    public primitive static class Long512VectorPayload extends VectorPayloadMF {
+        @MultiField(value = 16)
+        long mfield = 0L;
+    }
+
+    public primitive static class Double64VectorPayload extends VectorPayloadMF {
+        @MultiField(value = 2)
+        double mfield = 0.0;
+    }
+
+    public primitive static class Double128VectorPayload extends VectorPayloadMF {
+        @MultiField(value = 4)
+        double mfield = 0.0;
+    }
+
+    public primitive static class Double256VectorPayload extends VectorPayloadMF {
+        @MultiField(value = 8)
+        double mfield = 0.0;
+    }
+
+    public primitive static class Double512VectorPayload extends VectorPayloadMF {
+        @MultiField(value = 16)
+        double mfield = 0.0;
+    }
+
+    public static abstract class Vector<E> extends VectorPayload { }
+
     public static class VectorShuffle<E> extends VectorPayload {
+        private final Object payload; // array of primitives
+
+        protected final Object getPayload() {
+            return VectorSupport.maybeRebox(this).payload;
+        }
         public VectorShuffle(Object payload) {
-            super(payload);
+            this.payload = payload;
         }
     }
+
     public static class VectorMask<E> extends VectorPayload {
+        private final Object payload; // array of primitives
+
+        protected final Object getPayload() {
+            return VectorSupport.maybeRebox(this).payload;
+        }
         public VectorMask(Object payload) {
-            super(payload);
+            this.payload = payload;
         }
     }
 
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractSpecies.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractSpecies.java
index 80f2de5d6cd..38de84b43c3 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractSpecies.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractSpecies.java
@@ -32,8 +32,10 @@ import java.nio.ByteOrder;
 import java.util.Arrays;
 import java.util.function.Function;
 import java.util.function.IntUnaryOperator;
+import jdk.internal.vm.vector.VectorSupport;
 
-abstract class AbstractSpecies<E> extends jdk.internal.vm.vector.VectorSupport.VectorSpecies<E>
+
+abstract class AbstractSpecies<E> extends VectorSupport.VectorSpecies<E>
                                   implements VectorSpecies<E> {
     @Stable
     final VectorShape vectorShape;
@@ -111,6 +113,8 @@ abstract class AbstractSpecies<E> extends jdk.internal.vm.vector.VectorSupport.V
     @Stable //lazy JIT constant
     AbstractVector<E> dummyVector;
 
+    @Stable //lazy JIT constant
+    AbstractVector<E> dummyVectorMF;
     @Override
     @ForceInline
     public final int length() {
@@ -310,6 +314,16 @@ abstract class AbstractSpecies<E> extends jdk.internal.vm.vector.VectorSupport.V
         // The rest of this computation is probably not JIT-ted.
         return makeDummyVector();
     }
+    @ForceInline
+    /*package-private*/
+    AbstractVector<E> dummyVectorMF() {
+        // This JITs to a constant value:
+        AbstractVector<E> dummy = dummyVectorMF;
+        if (dummy != null)  return dummy;
+        // The rest of this computation is probably not JIT-ted.
+        return makeDummyVectorMF();
+    }
+
     private AbstractVector<E> makeDummyVector() {
         Object za = Array.newInstance(elementType(), laneCount);
         return dummyVector = vectorFactory.apply(za);
@@ -318,6 +332,36 @@ abstract class AbstractSpecies<E> extends jdk.internal.vm.vector.VectorSupport.V
         // through the dummy vector.
     }
 
+    private AbstractVector<E> makeDummyVectorMF() {
+	Object za = null;
+        switch (laneType.switchKey) {
+        case LaneType.SK_FLOAT:
+            za = VectorSupport.VectorPayloadMF.createNewInstanceF(elementType(), laneCount, 0.0f);
+            break;
+        case LaneType.SK_DOUBLE:
+            za = VectorSupport.VectorPayloadMF.createNewInstanceD(elementType(), laneCount, 0.0);
+            break;
+        case LaneType.SK_BYTE:
+            za = VectorSupport.VectorPayloadMF.createNewInstanceB(elementType(), laneCount, (byte)0);
+            break;
+        case LaneType.SK_SHORT:
+            za = VectorSupport.VectorPayloadMF.createNewInstanceS(elementType(), laneCount, (short)0);
+            break;
+        case LaneType.SK_INT:
+            za = VectorSupport.VectorPayloadMF.createNewInstanceI(elementType(), laneCount, 0);
+            break;
+        case LaneType.SK_LONG:
+            za = VectorSupport.VectorPayloadMF.createNewInstanceL(elementType(), laneCount, 0L);
+            break;
+        default:
+            assert false : "Unsupported elemType in makeDummyVectorMF";
+            break;
+	}
+        return dummyVector = vectorFactory.apply(za);
+        // This is the only use of vectorFactory.
+        // All other factory requests are routed
+        // through the dummy vector.
+    }
     /**
      * Build a mask by directly calling its constructor.
      * It is an error if the array is aliased elsewhere.
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractVector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractVector.java
index aac198d6b63..f7f55ebaf00 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/AbstractVector.java
@@ -69,9 +69,9 @@ abstract class AbstractVector<E> extends Vector<E> {
     static final int OFFSET_OUT_OF_RANGE = 0;
 
     /*package-private*/
-    AbstractVector(Object bits) {
+    /*AbstractVector(Object bits) {
         super(bits);
-    }
+    }*/
 
     // Extractors
 
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte128Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte128Vector.java
index 059adb451b6..fd5c90416d4 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte128Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte128Vector.java
@@ -39,7 +39,7 @@ import static jdk.incubator.vector.VectorOperators.*;
 // -- This file was mechanically generated: Do not edit! -- //
 
 @SuppressWarnings("cast")  // warning: redundant cast
-final class Byte128Vector extends ByteVector {
+value class Byte128Vector extends ByteVector {
     static final ByteSpecies VSPECIES =
         (ByteSpecies) ByteVector.SPECIES_128;
 
@@ -54,24 +54,40 @@ final class Byte128Vector extends ByteVector {
 
     static final Class<Byte> ETYPE = byte.class; // used by the JVM
 
-    Byte128Vector(byte[] v) {
+    /*Byte128Vector(byte[] v) {
         super(v);
+    }*/
+
+    private final VectorSupport.Byte128VectorPayload mf_storage;
+
+    Byte128Vector(Object value) {
+        this.mf_storage = (VectorSupport.Byte128VectorPayload)value;
+    }
+
+    VectorSupport.VectorPayloadMF vec_mf() {
+        return mf_storage;
+    }
+
+    @Override
+    protected final Object getPayload() {
+       return vec_mf();
     }
 
     // For compatibility as Byte128Vector::new,
     // stored into species.vectorFactory.
-    Byte128Vector(Object v) {
+    /*Byte128Vector(Object v) {
         this((byte[]) v);
-    }
+    }*/
 
-    static final Byte128Vector ZERO = new Byte128Vector(new byte[VLENGTH]);
+    static final Byte128Vector ZERO = new Byte128Vector(VectorSupport.VectorPayloadMF.createNewInstanceB(byte.class, 16, Byte.valueOf((byte)0)));
     static final Byte128Vector IOTA = new Byte128Vector(VSPECIES.iotaArray());
 
     static {
         // Warm up a few species caches.
         // If we do this too much we will
         // get NPEs from bootstrap circularity.
-        VSPECIES.dummyVector();
+        // VSPECIES.dummyVector();
+        VSPECIES.dummyVectorMF();
         VSPECIES.withLanes(LaneType.BYTE);
     }
 
@@ -171,6 +187,13 @@ final class Byte128Vector extends ByteVector {
         return new Byte128Vector(vec);
     }
 
+    // Make a vector of the same species but the given elements:
+    @ForceInline
+    final @Override
+    Byte128Vector vectorFactory(VectorSupport.VectorPayloadMF vec) {
+        return new Byte128Vector(vec);
+    }
+
     @ForceInline
     final @Override
     Byte128Vector asByteVectorRaw() {
@@ -206,6 +229,12 @@ final class Byte128Vector extends ByteVector {
         return (Byte128Vector) super.bOpTemplate((Byte128Vector)v, f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Byte128Vector bOpMF(Vector<Byte> v, FBinOp f) {
+        return (Byte128Vector) super.bOpTemplateMF((Byte128Vector)v, f);  // specialize
+    }
+
     @ForceInline
     final @Override
     Byte128Vector bOp(Vector<Byte> v,
@@ -215,6 +244,15 @@ final class Byte128Vector extends ByteVector {
                               f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Byte128Vector bOpMF(Vector<Byte> v,
+                     VectorMask<Byte> m, FBinOp f) {
+        return (Byte128Vector)
+            super.bOpTemplateMF((Byte128Vector)v, (Byte128Mask)m,
+                              f);  // specialize
+    }
+
     // Ternary operator
 
     @ForceInline
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte256Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte256Vector.java
index e70a4bebfa1..a97bfcc9cef 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte256Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte256Vector.java
@@ -39,7 +39,7 @@ import static jdk.incubator.vector.VectorOperators.*;
 // -- This file was mechanically generated: Do not edit! -- //
 
 @SuppressWarnings("cast")  // warning: redundant cast
-final class Byte256Vector extends ByteVector {
+value class Byte256Vector extends ByteVector {
     static final ByteSpecies VSPECIES =
         (ByteSpecies) ByteVector.SPECIES_256;
 
@@ -54,24 +54,40 @@ final class Byte256Vector extends ByteVector {
 
     static final Class<Byte> ETYPE = byte.class; // used by the JVM
 
-    Byte256Vector(byte[] v) {
+    /*Byte256Vector(byte[] v) {
         super(v);
+    }*/
+
+    private final VectorSupport.Byte256VectorPayload mf_storage;
+
+    Byte256Vector(Object value) {
+        this.mf_storage = (VectorSupport.Byte256VectorPayload)value;
+    }
+
+    VectorSupport.VectorPayloadMF vec_mf() {
+        return mf_storage;
+    }
+
+    @Override
+    protected final Object getPayload() {
+       return vec_mf();
     }
 
     // For compatibility as Byte256Vector::new,
     // stored into species.vectorFactory.
-    Byte256Vector(Object v) {
+    /*Byte256Vector(Object v) {
         this((byte[]) v);
-    }
+    }*/
 
-    static final Byte256Vector ZERO = new Byte256Vector(new byte[VLENGTH]);
+    static final Byte256Vector ZERO = new Byte256Vector(VectorSupport.VectorPayloadMF.createNewInstanceB(byte.class, 32, Byte.valueOf((byte)0)));
     static final Byte256Vector IOTA = new Byte256Vector(VSPECIES.iotaArray());
 
     static {
         // Warm up a few species caches.
         // If we do this too much we will
         // get NPEs from bootstrap circularity.
-        VSPECIES.dummyVector();
+        // VSPECIES.dummyVector();
+        VSPECIES.dummyVectorMF();
         VSPECIES.withLanes(LaneType.BYTE);
     }
 
@@ -171,6 +187,13 @@ final class Byte256Vector extends ByteVector {
         return new Byte256Vector(vec);
     }
 
+    // Make a vector of the same species but the given elements:
+    @ForceInline
+    final @Override
+    Byte256Vector vectorFactory(VectorSupport.VectorPayloadMF vec) {
+        return new Byte256Vector(vec);
+    }
+
     @ForceInline
     final @Override
     Byte256Vector asByteVectorRaw() {
@@ -206,6 +229,12 @@ final class Byte256Vector extends ByteVector {
         return (Byte256Vector) super.bOpTemplate((Byte256Vector)v, f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Byte256Vector bOpMF(Vector<Byte> v, FBinOp f) {
+        return (Byte256Vector) super.bOpTemplateMF((Byte256Vector)v, f);  // specialize
+    }
+
     @ForceInline
     final @Override
     Byte256Vector bOp(Vector<Byte> v,
@@ -215,6 +244,15 @@ final class Byte256Vector extends ByteVector {
                               f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Byte256Vector bOpMF(Vector<Byte> v,
+                     VectorMask<Byte> m, FBinOp f) {
+        return (Byte256Vector)
+            super.bOpTemplateMF((Byte256Vector)v, (Byte256Mask)m,
+                              f);  // specialize
+    }
+
     // Ternary operator
 
     @ForceInline
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte512Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte512Vector.java
index b30955a91b0..9249c0f5878 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte512Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte512Vector.java
@@ -39,7 +39,7 @@ import static jdk.incubator.vector.VectorOperators.*;
 // -- This file was mechanically generated: Do not edit! -- //
 
 @SuppressWarnings("cast")  // warning: redundant cast
-final class Byte512Vector extends ByteVector {
+value class Byte512Vector extends ByteVector {
     static final ByteSpecies VSPECIES =
         (ByteSpecies) ByteVector.SPECIES_512;
 
@@ -54,24 +54,40 @@ final class Byte512Vector extends ByteVector {
 
     static final Class<Byte> ETYPE = byte.class; // used by the JVM
 
-    Byte512Vector(byte[] v) {
+    /*Byte512Vector(byte[] v) {
         super(v);
+    }*/
+
+    private final VectorSupport.Byte512VectorPayload mf_storage;
+
+    Byte512Vector(Object value) {
+        this.mf_storage = (VectorSupport.Byte512VectorPayload)value;
+    }
+
+    VectorSupport.VectorPayloadMF vec_mf() {
+        return mf_storage;
+    }
+
+    @Override
+    protected final Object getPayload() {
+       return vec_mf();
     }
 
     // For compatibility as Byte512Vector::new,
     // stored into species.vectorFactory.
-    Byte512Vector(Object v) {
+    /*Byte512Vector(Object v) {
         this((byte[]) v);
-    }
+    }*/
 
-    static final Byte512Vector ZERO = new Byte512Vector(new byte[VLENGTH]);
+    static final Byte512Vector ZERO = new Byte512Vector(VectorSupport.VectorPayloadMF.createNewInstanceB(byte.class, 64, Byte.valueOf((byte)0)));
     static final Byte512Vector IOTA = new Byte512Vector(VSPECIES.iotaArray());
 
     static {
         // Warm up a few species caches.
         // If we do this too much we will
         // get NPEs from bootstrap circularity.
-        VSPECIES.dummyVector();
+        // VSPECIES.dummyVector();
+        VSPECIES.dummyVectorMF();
         VSPECIES.withLanes(LaneType.BYTE);
     }
 
@@ -171,6 +187,13 @@ final class Byte512Vector extends ByteVector {
         return new Byte512Vector(vec);
     }
 
+    // Make a vector of the same species but the given elements:
+    @ForceInline
+    final @Override
+    Byte512Vector vectorFactory(VectorSupport.VectorPayloadMF vec) {
+        return new Byte512Vector(vec);
+    }
+
     @ForceInline
     final @Override
     Byte512Vector asByteVectorRaw() {
@@ -206,6 +229,12 @@ final class Byte512Vector extends ByteVector {
         return (Byte512Vector) super.bOpTemplate((Byte512Vector)v, f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Byte512Vector bOpMF(Vector<Byte> v, FBinOp f) {
+        return (Byte512Vector) super.bOpTemplateMF((Byte512Vector)v, f);  // specialize
+    }
+
     @ForceInline
     final @Override
     Byte512Vector bOp(Vector<Byte> v,
@@ -215,6 +244,15 @@ final class Byte512Vector extends ByteVector {
                               f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Byte512Vector bOpMF(Vector<Byte> v,
+                     VectorMask<Byte> m, FBinOp f) {
+        return (Byte512Vector)
+            super.bOpTemplateMF((Byte512Vector)v, (Byte512Mask)m,
+                              f);  // specialize
+    }
+
     // Ternary operator
 
     @ForceInline
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte64Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte64Vector.java
index 56824f34871..52a8b778171 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte64Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Byte64Vector.java
@@ -39,7 +39,7 @@ import static jdk.incubator.vector.VectorOperators.*;
 // -- This file was mechanically generated: Do not edit! -- //
 
 @SuppressWarnings("cast")  // warning: redundant cast
-final class Byte64Vector extends ByteVector {
+value class Byte64Vector extends ByteVector {
     static final ByteSpecies VSPECIES =
         (ByteSpecies) ByteVector.SPECIES_64;
 
@@ -54,24 +54,40 @@ final class Byte64Vector extends ByteVector {
 
     static final Class<Byte> ETYPE = byte.class; // used by the JVM
 
-    Byte64Vector(byte[] v) {
+    /*Byte64Vector(byte[] v) {
         super(v);
+    }*/
+
+    private final VectorSupport.Byte64VectorPayload mf_storage;
+
+    Byte64Vector(Object value) {
+        this.mf_storage = (VectorSupport.Byte64VectorPayload)value;
+    }
+
+    VectorSupport.VectorPayloadMF vec_mf() {
+        return mf_storage;
+    }
+
+    @Override
+    protected final Object getPayload() {
+       return vec_mf();
     }
 
     // For compatibility as Byte64Vector::new,
     // stored into species.vectorFactory.
-    Byte64Vector(Object v) {
+    /*Byte64Vector(Object v) {
         this((byte[]) v);
-    }
+    }*/
 
-    static final Byte64Vector ZERO = new Byte64Vector(new byte[VLENGTH]);
+    static final Byte64Vector ZERO = new Byte64Vector(VectorSupport.VectorPayloadMF.createNewInstanceB(byte.class, 8, Byte.valueOf((byte)0)));
     static final Byte64Vector IOTA = new Byte64Vector(VSPECIES.iotaArray());
 
     static {
         // Warm up a few species caches.
         // If we do this too much we will
         // get NPEs from bootstrap circularity.
-        VSPECIES.dummyVector();
+        // VSPECIES.dummyVector();
+        VSPECIES.dummyVectorMF();
         VSPECIES.withLanes(LaneType.BYTE);
     }
 
@@ -171,6 +187,13 @@ final class Byte64Vector extends ByteVector {
         return new Byte64Vector(vec);
     }
 
+    // Make a vector of the same species but the given elements:
+    @ForceInline
+    final @Override
+    Byte64Vector vectorFactory(VectorSupport.VectorPayloadMF vec) {
+        return new Byte64Vector(vec);
+    }
+
     @ForceInline
     final @Override
     Byte64Vector asByteVectorRaw() {
@@ -206,6 +229,12 @@ final class Byte64Vector extends ByteVector {
         return (Byte64Vector) super.bOpTemplate((Byte64Vector)v, f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Byte64Vector bOpMF(Vector<Byte> v, FBinOp f) {
+        return (Byte64Vector) super.bOpTemplateMF((Byte64Vector)v, f);  // specialize
+    }
+
     @ForceInline
     final @Override
     Byte64Vector bOp(Vector<Byte> v,
@@ -215,6 +244,15 @@ final class Byte64Vector extends ByteVector {
                               f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Byte64Vector bOpMF(Vector<Byte> v,
+                     VectorMask<Byte> m, FBinOp f) {
+        return (Byte64Vector)
+            super.bOpTemplateMF((Byte64Vector)v, (Byte64Mask)m,
+                              f);  // specialize
+    }
+
     // Ternary operator
 
     @ForceInline
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ByteMaxVector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ByteMaxVector.java
deleted file mode 100644
index 984762ed7c8..00000000000
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ByteMaxVector.java
+++ /dev/null
@@ -1,920 +0,0 @@
-/*
- * Copyright (c) 2017, 2022, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package jdk.incubator.vector;
-
-import java.lang.foreign.MemorySegment;
-import java.util.Arrays;
-import java.util.Objects;
-import java.util.function.IntUnaryOperator;
-
-import jdk.internal.vm.annotation.ForceInline;
-import jdk.internal.vm.vector.VectorSupport;
-
-import static jdk.internal.vm.vector.VectorSupport.*;
-
-import static jdk.incubator.vector.VectorOperators.*;
-
-// -- This file was mechanically generated: Do not edit! -- //
-
-@SuppressWarnings("cast")  // warning: redundant cast
-final class ByteMaxVector extends ByteVector {
-    static final ByteSpecies VSPECIES =
-        (ByteSpecies) ByteVector.SPECIES_MAX;
-
-    static final VectorShape VSHAPE =
-        VSPECIES.vectorShape();
-
-    static final Class<ByteMaxVector> VCLASS = ByteMaxVector.class;
-
-    static final int VSIZE = VSPECIES.vectorBitSize();
-
-    static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
-
-    static final Class<Byte> ETYPE = byte.class; // used by the JVM
-
-    ByteMaxVector(byte[] v) {
-        super(v);
-    }
-
-    // For compatibility as ByteMaxVector::new,
-    // stored into species.vectorFactory.
-    ByteMaxVector(Object v) {
-        this((byte[]) v);
-    }
-
-    static final ByteMaxVector ZERO = new ByteMaxVector(new byte[VLENGTH]);
-    static final ByteMaxVector IOTA = new ByteMaxVector(VSPECIES.iotaArray());
-
-    static {
-        // Warm up a few species caches.
-        // If we do this too much we will
-        // get NPEs from bootstrap circularity.
-        VSPECIES.dummyVector();
-        VSPECIES.withLanes(LaneType.BYTE);
-    }
-
-    // Specialized extractors
-
-    @ForceInline
-    final @Override
-    public ByteSpecies vspecies() {
-        // ISSUE:  This should probably be a @Stable
-        // field inside AbstractVector, rather than
-        // a megamorphic method.
-        return VSPECIES;
-    }
-
-    @ForceInline
-    @Override
-    public final Class<Byte> elementType() { return byte.class; }
-
-    @ForceInline
-    @Override
-    public final int elementSize() { return Byte.SIZE; }
-
-    @ForceInline
-    @Override
-    public final VectorShape shape() { return VSHAPE; }
-
-    @ForceInline
-    @Override
-    public final int length() { return VLENGTH; }
-
-    @ForceInline
-    @Override
-    public final int bitSize() { return VSIZE; }
-
-    @ForceInline
-    @Override
-    public final int byteSize() { return VSIZE / Byte.SIZE; }
-
-    /*package-private*/
-    @ForceInline
-    final @Override
-    byte[] vec() {
-        return (byte[])getPayload();
-    }
-
-    // Virtualized constructors
-
-    @Override
-    @ForceInline
-    public final ByteMaxVector broadcast(byte e) {
-        return (ByteMaxVector) super.broadcastTemplate(e);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final ByteMaxVector broadcast(long e) {
-        return (ByteMaxVector) super.broadcastTemplate(e);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    ByteMaxMask maskFromArray(boolean[] bits) {
-        return new ByteMaxMask(bits);
-    }
-
-    @Override
-    @ForceInline
-    ByteMaxShuffle iotaShuffle() { return ByteMaxShuffle.IOTA; }
-
-    @ForceInline
-    ByteMaxShuffle iotaShuffle(int start, int step, boolean wrap) {
-      if (wrap) {
-        return (ByteMaxShuffle)VectorSupport.shuffleIota(ETYPE, ByteMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,
-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));
-      } else {
-        return (ByteMaxShuffle)VectorSupport.shuffleIota(ETYPE, ByteMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,
-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));
-      }
-    }
-
-    @Override
-    @ForceInline
-    ByteMaxShuffle shuffleFromBytes(byte[] reorder) { return new ByteMaxShuffle(reorder); }
-
-    @Override
-    @ForceInline
-    ByteMaxShuffle shuffleFromArray(int[] indexes, int i) { return new ByteMaxShuffle(indexes, i); }
-
-    @Override
-    @ForceInline
-    ByteMaxShuffle shuffleFromOp(IntUnaryOperator fn) { return new ByteMaxShuffle(fn); }
-
-    // Make a vector of the same species but the given elements:
-    @ForceInline
-    final @Override
-    ByteMaxVector vectorFactory(byte[] vec) {
-        return new ByteMaxVector(vec);
-    }
-
-    @ForceInline
-    final @Override
-    ByteMaxVector asByteVectorRaw() {
-        return (ByteMaxVector) super.asByteVectorRawTemplate();  // specialize
-    }
-
-    @ForceInline
-    final @Override
-    AbstractVector<?> asVectorRaw(LaneType laneType) {
-        return super.asVectorRawTemplate(laneType);  // specialize
-    }
-
-    // Unary operator
-
-    @ForceInline
-    final @Override
-    ByteMaxVector uOp(FUnOp f) {
-        return (ByteMaxVector) super.uOpTemplate(f);  // specialize
-    }
-
-    @ForceInline
-    final @Override
-    ByteMaxVector uOp(VectorMask<Byte> m, FUnOp f) {
-        return (ByteMaxVector)
-            super.uOpTemplate((ByteMaxMask)m, f);  // specialize
-    }
-
-    // Binary operator
-
-    @ForceInline
-    final @Override
-    ByteMaxVector bOp(Vector<Byte> v, FBinOp f) {
-        return (ByteMaxVector) super.bOpTemplate((ByteMaxVector)v, f);  // specialize
-    }
-
-    @ForceInline
-    final @Override
-    ByteMaxVector bOp(Vector<Byte> v,
-                     VectorMask<Byte> m, FBinOp f) {
-        return (ByteMaxVector)
-            super.bOpTemplate((ByteMaxVector)v, (ByteMaxMask)m,
-                              f);  // specialize
-    }
-
-    // Ternary operator
-
-    @ForceInline
-    final @Override
-    ByteMaxVector tOp(Vector<Byte> v1, Vector<Byte> v2, FTriOp f) {
-        return (ByteMaxVector)
-            super.tOpTemplate((ByteMaxVector)v1, (ByteMaxVector)v2,
-                              f);  // specialize
-    }
-
-    @ForceInline
-    final @Override
-    ByteMaxVector tOp(Vector<Byte> v1, Vector<Byte> v2,
-                     VectorMask<Byte> m, FTriOp f) {
-        return (ByteMaxVector)
-            super.tOpTemplate((ByteMaxVector)v1, (ByteMaxVector)v2,
-                              (ByteMaxMask)m, f);  // specialize
-    }
-
-    @ForceInline
-    final @Override
-    byte rOp(byte v, VectorMask<Byte> m, FBinOp f) {
-        return super.rOpTemplate(v, m, f);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final <F>
-    Vector<F> convertShape(VectorOperators.Conversion<Byte,F> conv,
-                           VectorSpecies<F> rsp, int part) {
-        return super.convertShapeTemplate(conv, rsp, part);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final <F>
-    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {
-        return super.reinterpretShapeTemplate(toSpecies, part);  // specialize
-    }
-
-    // Specialized algebraic operations:
-
-    // The following definition forces a specialized version of this
-    // crucial method into the v-table of this class.  A call to add()
-    // will inline to a call to lanewise(ADD,), at which point the JIT
-    // intrinsic will have the opcode of ADD, plus all the metadata
-    // for this particular class, enabling it to generate precise
-    // code.
-    //
-    // There is probably no benefit to the JIT to specialize the
-    // masked or broadcast versions of the lanewise method.
-
-    @Override
-    @ForceInline
-    public ByteMaxVector lanewise(Unary op) {
-        return (ByteMaxVector) super.lanewiseTemplate(op);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public ByteMaxVector lanewise(Unary op, VectorMask<Byte> m) {
-        return (ByteMaxVector) super.lanewiseTemplate(op, ByteMaxMask.class, (ByteMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public ByteMaxVector lanewise(Binary op, Vector<Byte> v) {
-        return (ByteMaxVector) super.lanewiseTemplate(op, v);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public ByteMaxVector lanewise(Binary op, Vector<Byte> v, VectorMask<Byte> m) {
-        return (ByteMaxVector) super.lanewiseTemplate(op, ByteMaxMask.class, v, (ByteMaxMask) m);  // specialize
-    }
-
-    /*package-private*/
-    @Override
-    @ForceInline ByteMaxVector
-    lanewiseShift(VectorOperators.Binary op, int e) {
-        return (ByteMaxVector) super.lanewiseShiftTemplate(op, e);  // specialize
-    }
-
-    /*package-private*/
-    @Override
-    @ForceInline ByteMaxVector
-    lanewiseShift(VectorOperators.Binary op, int e, VectorMask<Byte> m) {
-        return (ByteMaxVector) super.lanewiseShiftTemplate(op, ByteMaxMask.class, e, (ByteMaxMask) m);  // specialize
-    }
-
-    /*package-private*/
-    @Override
-    @ForceInline
-    public final
-    ByteMaxVector
-    lanewise(Ternary op, Vector<Byte> v1, Vector<Byte> v2) {
-        return (ByteMaxVector) super.lanewiseTemplate(op, v1, v2);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final
-    ByteMaxVector
-    lanewise(Ternary op, Vector<Byte> v1, Vector<Byte> v2, VectorMask<Byte> m) {
-        return (ByteMaxVector) super.lanewiseTemplate(op, ByteMaxMask.class, v1, v2, (ByteMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final
-    ByteMaxVector addIndex(int scale) {
-        return (ByteMaxVector) super.addIndexTemplate(scale);  // specialize
-    }
-
-    // Type specific horizontal reductions
-
-    @Override
-    @ForceInline
-    public final byte reduceLanes(VectorOperators.Associative op) {
-        return super.reduceLanesTemplate(op);  // specialized
-    }
-
-    @Override
-    @ForceInline
-    public final byte reduceLanes(VectorOperators.Associative op,
-                                    VectorMask<Byte> m) {
-        return super.reduceLanesTemplate(op, ByteMaxMask.class, (ByteMaxMask) m);  // specialized
-    }
-
-    @Override
-    @ForceInline
-    public final long reduceLanesToLong(VectorOperators.Associative op) {
-        return (long) super.reduceLanesTemplate(op);  // specialized
-    }
-
-    @Override
-    @ForceInline
-    public final long reduceLanesToLong(VectorOperators.Associative op,
-                                        VectorMask<Byte> m) {
-        return (long) super.reduceLanesTemplate(op, ByteMaxMask.class, (ByteMaxMask) m);  // specialized
-    }
-
-    @ForceInline
-    public VectorShuffle<Byte> toShuffle() {
-        return super.toShuffleTemplate(ByteMaxShuffle.class); // specialize
-    }
-
-    // Specialized unary testing
-
-    @Override
-    @ForceInline
-    public final ByteMaxMask test(Test op) {
-        return super.testTemplate(ByteMaxMask.class, op);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final ByteMaxMask test(Test op, VectorMask<Byte> m) {
-        return super.testTemplate(ByteMaxMask.class, op, (ByteMaxMask) m);  // specialize
-    }
-
-    // Specialized comparisons
-
-    @Override
-    @ForceInline
-    public final ByteMaxMask compare(Comparison op, Vector<Byte> v) {
-        return super.compareTemplate(ByteMaxMask.class, op, v);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final ByteMaxMask compare(Comparison op, byte s) {
-        return super.compareTemplate(ByteMaxMask.class, op, s);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final ByteMaxMask compare(Comparison op, long s) {
-        return super.compareTemplate(ByteMaxMask.class, op, s);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final ByteMaxMask compare(Comparison op, Vector<Byte> v, VectorMask<Byte> m) {
-        return super.compareTemplate(ByteMaxMask.class, op, v, (ByteMaxMask) m);
-    }
-
-
-    @Override
-    @ForceInline
-    public ByteMaxVector blend(Vector<Byte> v, VectorMask<Byte> m) {
-        return (ByteMaxVector)
-            super.blendTemplate(ByteMaxMask.class,
-                                (ByteMaxVector) v,
-                                (ByteMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public ByteMaxVector slice(int origin, Vector<Byte> v) {
-        return (ByteMaxVector) super.sliceTemplate(origin, v);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public ByteMaxVector slice(int origin) {
-        return (ByteMaxVector) super.sliceTemplate(origin);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public ByteMaxVector unslice(int origin, Vector<Byte> w, int part) {
-        return (ByteMaxVector) super.unsliceTemplate(origin, w, part);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public ByteMaxVector unslice(int origin, Vector<Byte> w, int part, VectorMask<Byte> m) {
-        return (ByteMaxVector)
-            super.unsliceTemplate(ByteMaxMask.class,
-                                  origin, w, part,
-                                  (ByteMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public ByteMaxVector unslice(int origin) {
-        return (ByteMaxVector) super.unsliceTemplate(origin);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public ByteMaxVector rearrange(VectorShuffle<Byte> s) {
-        return (ByteMaxVector)
-            super.rearrangeTemplate(ByteMaxShuffle.class,
-                                    (ByteMaxShuffle) s);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public ByteMaxVector rearrange(VectorShuffle<Byte> shuffle,
-                                  VectorMask<Byte> m) {
-        return (ByteMaxVector)
-            super.rearrangeTemplate(ByteMaxShuffle.class,
-                                    ByteMaxMask.class,
-                                    (ByteMaxShuffle) shuffle,
-                                    (ByteMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public ByteMaxVector rearrange(VectorShuffle<Byte> s,
-                                  Vector<Byte> v) {
-        return (ByteMaxVector)
-            super.rearrangeTemplate(ByteMaxShuffle.class,
-                                    (ByteMaxShuffle) s,
-                                    (ByteMaxVector) v);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public ByteMaxVector compress(VectorMask<Byte> m) {
-        return (ByteMaxVector)
-            super.compressTemplate(ByteMaxMask.class,
-                                   (ByteMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public ByteMaxVector expand(VectorMask<Byte> m) {
-        return (ByteMaxVector)
-            super.expandTemplate(ByteMaxMask.class,
-                                   (ByteMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public ByteMaxVector selectFrom(Vector<Byte> v) {
-        return (ByteMaxVector)
-            super.selectFromTemplate((ByteMaxVector) v);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public ByteMaxVector selectFrom(Vector<Byte> v,
-                                   VectorMask<Byte> m) {
-        return (ByteMaxVector)
-            super.selectFromTemplate((ByteMaxVector) v,
-                                     (ByteMaxMask) m);  // specialize
-    }
-
-
-    @ForceInline
-    @Override
-    public byte lane(int i) {
-        if (i < 0 || i >= VLENGTH) {
-            throw new IllegalArgumentException("Index " + i + " must be zero or positive, and less than " + VLENGTH);
-        }
-        return laneHelper(i);
-    }
-
-    public byte laneHelper(int i) {
-        return (byte) VectorSupport.extract(
-                                VCLASS, ETYPE, VLENGTH,
-                                this, i,
-                                (vec, ix) -> {
-                                    byte[] vecarr = vec.vec();
-                                    return (long)vecarr[ix];
-                                });
-    }
-
-    @ForceInline
-    @Override
-    public ByteMaxVector withLane(int i, byte e) {
-        if (i < 0 || i >= VLENGTH) {
-            throw new IllegalArgumentException("Index " + i + " must be zero or positive, and less than " + VLENGTH);
-        }
-        return withLaneHelper(i, e);
-    }
-
-    public ByteMaxVector withLaneHelper(int i, byte e) {
-        return VectorSupport.insert(
-                                VCLASS, ETYPE, VLENGTH,
-                                this, i, (long)e,
-                                (v, ix, bits) -> {
-                                    byte[] res = v.vec().clone();
-                                    res[ix] = (byte)bits;
-                                    return v.vectorFactory(res);
-                                });
-    }
-
-    // Mask
-
-    static final class ByteMaxMask extends AbstractMask<Byte> {
-        static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
-        static final Class<Byte> ETYPE = byte.class; // used by the JVM
-
-        ByteMaxMask(boolean[] bits) {
-            this(bits, 0);
-        }
-
-        ByteMaxMask(boolean[] bits, int offset) {
-            super(prepare(bits, offset));
-        }
-
-        ByteMaxMask(boolean val) {
-            super(prepare(val));
-        }
-
-        private static boolean[] prepare(boolean[] bits, int offset) {
-            boolean[] newBits = new boolean[VSPECIES.laneCount()];
-            for (int i = 0; i < newBits.length; i++) {
-                newBits[i] = bits[offset + i];
-            }
-            return newBits;
-        }
-
-        private static boolean[] prepare(boolean val) {
-            boolean[] bits = new boolean[VSPECIES.laneCount()];
-            Arrays.fill(bits, val);
-            return bits;
-        }
-
-        @ForceInline
-        final @Override
-        public ByteSpecies vspecies() {
-            // ISSUE:  This should probably be a @Stable
-            // field inside AbstractMask, rather than
-            // a megamorphic method.
-            return VSPECIES;
-        }
-
-        @ForceInline
-        boolean[] getBits() {
-            return (boolean[])getPayload();
-        }
-
-        @Override
-        ByteMaxMask uOp(MUnOp f) {
-            boolean[] res = new boolean[vspecies().laneCount()];
-            boolean[] bits = getBits();
-            for (int i = 0; i < res.length; i++) {
-                res[i] = f.apply(i, bits[i]);
-            }
-            return new ByteMaxMask(res);
-        }
-
-        @Override
-        ByteMaxMask bOp(VectorMask<Byte> m, MBinOp f) {
-            boolean[] res = new boolean[vspecies().laneCount()];
-            boolean[] bits = getBits();
-            boolean[] mbits = ((ByteMaxMask)m).getBits();
-            for (int i = 0; i < res.length; i++) {
-                res[i] = f.apply(i, bits[i], mbits[i]);
-            }
-            return new ByteMaxMask(res);
-        }
-
-        @ForceInline
-        @Override
-        public final
-        ByteMaxVector toVector() {
-            return (ByteMaxVector) super.toVectorTemplate();  // specialize
-        }
-
-        /**
-         * Helper function for lane-wise mask conversions.
-         * This function kicks in after intrinsic failure.
-         */
-        @ForceInline
-        private final <E>
-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {
-            if (length() != dsp.laneCount())
-                throw new IllegalArgumentException("VectorMask length and species length differ");
-            boolean[] maskArray = toArray();
-            return  dsp.maskFactory(maskArray).check(dsp);
-        }
-
-        @Override
-        @ForceInline
-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;
-            if (length() != species.laneCount())
-                throw new IllegalArgumentException("VectorMask length and species length differ");
-
-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,
-                this.getClass(), ETYPE, VLENGTH,
-                species.maskType(), species.elementType(), VLENGTH,
-                this, species,
-                (m, s) -> s.maskFactory(m.toArray()).check(s));
-        }
-
-        @Override
-        @ForceInline
-        public ByteMaxMask eq(VectorMask<Byte> mask) {
-            Objects.requireNonNull(mask);
-            ByteMaxMask m = (ByteMaxMask)mask;
-            return xor(m.not());
-        }
-
-        // Unary operations
-
-        @Override
-        @ForceInline
-        public ByteMaxMask not() {
-            return xor(maskAll(true));
-        }
-
-        @Override
-        @ForceInline
-        public ByteMaxMask compress() {
-            return (ByteMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                ByteMaxVector.class, ByteMaxMask.class, ETYPE, VLENGTH, null, this,
-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
-        }
-
-
-        // Binary operations
-
-        @Override
-        @ForceInline
-        public ByteMaxMask and(VectorMask<Byte> mask) {
-            Objects.requireNonNull(mask);
-            ByteMaxMask m = (ByteMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, ByteMaxMask.class, null, byte.class, VLENGTH,
-                                          this, m, null,
-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
-        }
-
-        @Override
-        @ForceInline
-        public ByteMaxMask or(VectorMask<Byte> mask) {
-            Objects.requireNonNull(mask);
-            ByteMaxMask m = (ByteMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, ByteMaxMask.class, null, byte.class, VLENGTH,
-                                          this, m, null,
-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
-        }
-
-        @ForceInline
-        /* package-private */
-        ByteMaxMask xor(VectorMask<Byte> mask) {
-            Objects.requireNonNull(mask);
-            ByteMaxMask m = (ByteMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, ByteMaxMask.class, null, byte.class, VLENGTH,
-                                          this, m, null,
-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
-        }
-
-        // Mask Query operations
-
-        @Override
-        @ForceInline
-        public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, ByteMaxMask.class, byte.class, VLENGTH, this,
-                                                      (m) -> trueCountHelper(m.getBits()));
-        }
-
-        @Override
-        @ForceInline
-        public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, ByteMaxMask.class, byte.class, VLENGTH, this,
-                                                      (m) -> firstTrueHelper(m.getBits()));
-        }
-
-        @Override
-        @ForceInline
-        public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, ByteMaxMask.class, byte.class, VLENGTH, this,
-                                                      (m) -> lastTrueHelper(m.getBits()));
-        }
-
-        @Override
-        @ForceInline
-        public long toLong() {
-            if (length() > Long.SIZE) {
-                throw new UnsupportedOperationException("too many lanes for one long");
-            }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, ByteMaxMask.class, byte.class, VLENGTH, this,
-                                                      (m) -> toLongHelper(m.getBits()));
-        }
-
-        // Reductions
-
-        @Override
-        @ForceInline
-        public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, ByteMaxMask.class, byte.class, VLENGTH,
-                                         this, vspecies().maskAll(true),
-                                         (m, __) -> anyTrueHelper(((ByteMaxMask)m).getBits()));
-        }
-
-        @Override
-        @ForceInline
-        public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, ByteMaxMask.class, byte.class, VLENGTH,
-                                         this, vspecies().maskAll(true),
-                                         (m, __) -> allTrueHelper(((ByteMaxMask)m).getBits()));
-        }
-
-        @ForceInline
-        /*package-private*/
-        static ByteMaxMask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(ByteMaxMask.class, byte.class, VLENGTH,
-                                                 (bit ? -1 : 0), MODE_BROADCAST, null,
-                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
-        }
-        private static final ByteMaxMask  TRUE_MASK = new ByteMaxMask(true);
-        private static final ByteMaxMask FALSE_MASK = new ByteMaxMask(false);
-
-    }
-
-    // Shuffle
-
-    static final class ByteMaxShuffle extends AbstractShuffle<Byte> {
-        static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
-        static final Class<Byte> ETYPE = byte.class; // used by the JVM
-
-        ByteMaxShuffle(byte[] reorder) {
-            super(VLENGTH, reorder);
-        }
-
-        public ByteMaxShuffle(int[] reorder) {
-            super(VLENGTH, reorder);
-        }
-
-        public ByteMaxShuffle(int[] reorder, int i) {
-            super(VLENGTH, reorder, i);
-        }
-
-        public ByteMaxShuffle(IntUnaryOperator fn) {
-            super(VLENGTH, fn);
-        }
-
-        @Override
-        public ByteSpecies vspecies() {
-            return VSPECIES;
-        }
-
-        static {
-            // There must be enough bits in the shuffle lanes to encode
-            // VLENGTH valid indexes and VLENGTH exceptional ones.
-            assert(VLENGTH < Byte.MAX_VALUE);
-            assert(Byte.MIN_VALUE <= -VLENGTH);
-        }
-        static final ByteMaxShuffle IOTA = new ByteMaxShuffle(IDENTITY);
-
-        @Override
-        @ForceInline
-        public ByteMaxVector toVector() {
-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, ByteMaxShuffle.class, this, VLENGTH,
-                                                    (s) -> ((ByteMaxVector)(((AbstractShuffle<Byte>)(s)).toVectorTemplate())));
-        }
-
-        @Override
-        @ForceInline
-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {
-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;
-            if (length() != species.laneCount())
-                throw new IllegalArgumentException("VectorShuffle length and species length differ");
-            int[] shuffleArray = toArray();
-            return s.shuffleFromArray(shuffleArray, 0).check(s);
-        }
-
-        @ForceInline
-        @Override
-        public ByteMaxShuffle rearrange(VectorShuffle<Byte> shuffle) {
-            ByteMaxShuffle s = (ByteMaxShuffle) shuffle;
-            byte[] reorder1 = reorder();
-            byte[] reorder2 = s.reorder();
-            byte[] r = new byte[reorder1.length];
-            for (int i = 0; i < reorder1.length; i++) {
-                int ssi = reorder2[i];
-                r[i] = reorder1[ssi];  // throws on exceptional index
-            }
-            return new ByteMaxShuffle(r);
-        }
-    }
-
-    // ================================================
-
-    // Specialized low-level memory operations.
-
-    @ForceInline
-    @Override
-    final
-    ByteVector fromArray0(byte[] a, int offset) {
-        return super.fromArray0Template(a, offset);  // specialize
-    }
-
-    @ForceInline
-    @Override
-    final
-    ByteVector fromArray0(byte[] a, int offset, VectorMask<Byte> m, int offsetInRange) {
-        return super.fromArray0Template(ByteMaxMask.class, a, offset, (ByteMaxMask) m, offsetInRange);  // specialize
-    }
-
-
-
-    @ForceInline
-    @Override
-    final
-    ByteVector fromBooleanArray0(boolean[] a, int offset) {
-        return super.fromBooleanArray0Template(a, offset);  // specialize
-    }
-
-    @ForceInline
-    @Override
-    final
-    ByteVector fromBooleanArray0(boolean[] a, int offset, VectorMask<Byte> m, int offsetInRange) {
-        return super.fromBooleanArray0Template(ByteMaxMask.class, a, offset, (ByteMaxMask) m, offsetInRange);  // specialize
-    }
-
-    @ForceInline
-    @Override
-    final
-    ByteVector fromMemorySegment0(MemorySegment ms, long offset) {
-        return super.fromMemorySegment0Template(ms, offset);  // specialize
-    }
-
-    @ForceInline
-    @Override
-    final
-    ByteVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Byte> m, int offsetInRange) {
-        return super.fromMemorySegment0Template(ByteMaxMask.class, ms, offset, (ByteMaxMask) m, offsetInRange);  // specialize
-    }
-
-    @ForceInline
-    @Override
-    final
-    void intoArray0(byte[] a, int offset) {
-        super.intoArray0Template(a, offset);  // specialize
-    }
-
-    @ForceInline
-    @Override
-    final
-    void intoArray0(byte[] a, int offset, VectorMask<Byte> m) {
-        super.intoArray0Template(ByteMaxMask.class, a, offset, (ByteMaxMask) m);
-    }
-
-
-    @ForceInline
-    @Override
-    final
-    void intoBooleanArray0(boolean[] a, int offset, VectorMask<Byte> m) {
-        super.intoBooleanArray0Template(ByteMaxMask.class, a, offset, (ByteMaxMask) m);
-    }
-
-    @ForceInline
-    @Override
-    final
-    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Byte> m) {
-        super.intoMemorySegment0Template(ByteMaxMask.class, ms, offset, (ByteMaxMask) m);
-    }
-
-
-    // End of specialized low-level memory operations.
-
-    // ================================================
-
-}
-
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ByteVector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ByteVector.java
index 0ae566fda7f..9d4f4fd6815 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ByteVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ByteVector.java
@@ -51,9 +51,9 @@ import static jdk.incubator.vector.VectorOperators.*;
 @SuppressWarnings("cast")  // warning: redundant cast
 public abstract class ByteVector extends AbstractVector<Byte> {
 
-    ByteVector(byte[] vec) {
+    /*ByteVector(byte[] vec) {
         super(vec);
-    }
+    }*/
 
     static final int FORBID_OPCODE_KIND = VO_ONLYFP;
 
@@ -96,6 +96,8 @@ public abstract class ByteVector extends AbstractVector<Byte> {
     /*package-private*/
     abstract byte[] vec();
 
+    abstract VectorSupport.VectorPayloadMF vec_mf();
+
     // Virtualized constructors
 
     /**
@@ -105,6 +107,17 @@ public abstract class ByteVector extends AbstractVector<Byte> {
     /*package-private*/
     abstract ByteVector vectorFactory(byte[] vec);
 
+    abstract ByteVector vectorFactory(VectorSupport.VectorPayloadMF vec);
+
+    @ForceInline
+    public static
+    ByteVector fromArray(VectorSpecies<Byte> species,
+                                   byte[] a, int offset) {
+        offset = checkFromIndexSize(offset, species.length(), a.length);
+        ByteSpecies vsp = (ByteSpecies) species;
+        return vsp.dummyVectorMF().fromArray0(a, offset);
+    }
+
     /**
      * Build a mask directly using my species.
      * It is an error if the array is aliased elsewhere.
@@ -210,6 +223,30 @@ public abstract class ByteVector extends AbstractVector<Byte> {
         return vectorFactory(res);
     }
 
+    /*package-private*/
+    abstract
+    ByteVector bOpMF(Vector<Byte> o,
+                             FBinOp f);
+    @ForceInline
+    final
+    ByteVector bOpTemplateMF(Vector<Byte> o,
+                                     FBinOp f) {
+        VectorSupport.VectorPayloadMF vec1 = this.vec_mf();
+        VectorSupport.VectorPayloadMF vec2 = this.vec_mf();
+        VectorSupport.VectorPayloadMF tpayload = 
+            Unsafe.getUnsafe().makePrivateBuffer(VectorSupport.VectorPayloadMF.createNewInstanceB(
+                   byte.class, length(), Byte.valueOf((byte)0)));
+        long start_offset = tpayload.multiFieldOffset();
+        int length = tpayload.length();
+        for (int i = 0; i < length; i++) {
+            byte v1 = Unsafe.getUnsafe().getByte(vec1, start_offset + i * Integer.BYTES);
+            byte v2 = Unsafe.getUnsafe().getByte(vec2, start_offset + i * Integer.BYTES);
+            Unsafe.getUnsafe().putByte(tpayload, start_offset + i * Integer.BYTES, f.apply(i, v1, v2));
+        }
+        Unsafe.getUnsafe().finishPrivateBuffer(tpayload);
+        return vectorFactory(tpayload);
+    }
+
     /*package-private*/
     abstract
     ByteVector bOp(Vector<Byte> o,
@@ -233,6 +270,36 @@ public abstract class ByteVector extends AbstractVector<Byte> {
         return vectorFactory(res);
     }
 
+    /*package-private*/
+    abstract
+    ByteVector bOpMF(Vector<Byte> o,
+                             VectorMask<Byte> m,
+                             FBinOp f);
+    @ForceInline
+    final
+    ByteVector bOpTemplateMF(Vector<Byte> o,
+                                     VectorMask<Byte> m,
+                                     FBinOp f) {
+        if (m == null) {
+            return bOpTemplateMF(o, f);
+        }
+        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();
+        VectorSupport.VectorPayloadMF vec1 = this.vec_mf();
+        VectorSupport.VectorPayloadMF vec2 = this.vec_mf();
+        VectorSupport.VectorPayloadMF tpayload =
+            Unsafe.getUnsafe().makePrivateBuffer(VectorSupport.VectorPayloadMF.createNewInstanceB(
+                byte.class, length(), Byte.valueOf((byte)0)));
+        long start_offset = tpayload.multiFieldOffset();
+        int length = tpayload.length();
+        for (int i = 0; i < length; i++) {
+            byte v1 = Unsafe.getUnsafe().getByte(vec1, start_offset + i * Integer.BYTES);
+            byte v2 = Unsafe.getUnsafe().getByte(vec2, start_offset + i * Integer.BYTES);
+            Unsafe.getUnsafe().putByte(tpayload, start_offset + i * Integer.BYTES, mbits[i] ? f.apply(i, v1, v2): v1);
+        }
+        Unsafe.getUnsafe().finishPrivateBuffer(tpayload);
+        return vectorFactory(tpayload);
+    }
+
     // Ternary operator
 
     /*package-private*/
@@ -353,6 +420,45 @@ public abstract class ByteVector extends AbstractVector<Byte> {
         return vectorFactory(res);
     }
 
+    /*package-private*/
+    @ForceInline
+    final
+    <M> ByteVector ldOpMF(M memory, int offset,
+                                  FLdOp<M> f) {
+        VectorSupport.VectorPayloadMF tpayload =
+            Unsafe.getUnsafe().makePrivateBuffer(VectorSupport.VectorPayloadMF.createNewInstanceB(
+                byte.class, length(), Byte.valueOf((byte)0)));
+        int length = tpayload.length();
+        long start_offset = tpayload.multiFieldOffset();
+        for (int i = 0; i < length; i++) {
+            Unsafe.getUnsafe().putByte(tpayload, start_offset + i * Integer.BYTES, f.apply(memory, offset, i));
+        }
+        Unsafe.getUnsafe().finishPrivateBuffer(tpayload);
+        return vectorFactory(tpayload);
+    }
+
+    /*package-private*/
+    @ForceInline
+    final
+    <M> ByteVector ldOpMF(M memory, int offset,
+                                  VectorMask<Byte> m,
+                                  FLdOp<M> f) {
+        VectorSupport.VectorPayloadMF tpayload =
+            Unsafe.getUnsafe().makePrivateBuffer(VectorSupport.VectorPayloadMF.createNewInstanceB(
+                byte.class, length(), Byte.valueOf((byte)0)));
+        int length = tpayload.length();
+        long start_offset = tpayload.multiFieldOffset();
+        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();
+        for (int i = 0; i < length; i++) {
+            if (mbits[i]) {
+                Unsafe.getUnsafe().putByte(tpayload, start_offset + i * Integer.BYTES, f.apply(memory, offset, i));
+            }
+        }
+        Unsafe.getUnsafe().finishPrivateBuffer(tpayload);
+        return vectorFactory(tpayload);
+    }
+
+
     /*package-private*/
     interface FLdLongOp {
         byte apply(MemorySegment memory, long offset, int i);
@@ -422,6 +528,37 @@ public abstract class ByteVector extends AbstractVector<Byte> {
         }
     }
 
+    /*package-private*/
+    @ForceInline
+    final
+    <M> void stOpMF(M memory, int offset,
+                  FStOp<M> f) {
+        VectorSupport.VectorPayloadMF vec = vec_mf();
+        long start_offset = vec.multiFieldOffset();
+        int length = vec.length();
+        for (int i = 0; i < length; i++) {
+            f.apply(memory, offset, i, Unsafe.getUnsafe().getByte(vec, start_offset + i * Integer.BYTES));
+        }
+    }
+
+    /*package-private*/
+   @ForceInline
+    final
+    <M> void stOpMF(M memory, int offset,
+                  VectorMask<Byte> m,
+                  FStOp<M> f) {
+        VectorSupport.VectorPayloadMF vec = vec_mf();
+        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();
+        long start_offset = vec.multiFieldOffset();
+        int length = vec.length();
+        for (int i = 0; i < length; i++) {
+            if (mbits[i]) {
+                f.apply(memory, offset, i, Unsafe.getUnsafe().getByte(vec, start_offset + i * Integer.BYTES));
+            }
+        }
+    }
+
+
     interface FStLongOp {
         void apply(MemorySegment memory, long offset, int i, byte a);
     }
@@ -780,11 +917,18 @@ public abstract class ByteVector extends AbstractVector<Byte> {
             }
         }
 
+        /*
         int opc = opCode(op);
         return VectorSupport.binaryOp(
             opc, getClass(), null, byte.class, length(),
             this, that, null,
             BIN_IMPL.find(op, opc, ByteVector::binaryOperations));
+        */
+        int opc = opCode(op);
+        return VectorSupport.binaryOp(
+            opc, getClass(), null, byte.class, length(),
+            this, that, null,
+            BIN_IMPL.find(op, opc, ByteVector::binaryOperationsMF));
     }
 
     /**
@@ -875,6 +1019,25 @@ public abstract class ByteVector extends AbstractVector<Byte> {
         }
     }
 
+    private static BinaryOperation<ByteVector, VectorMask<Byte>> binaryOperationsMF(int opc_) {
+        switch (opc_) {
+            case VECTOR_OP_ADD: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)(a + b));
+            case VECTOR_OP_SUB: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)(a - b));
+            case VECTOR_OP_MUL: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)(a * b));
+            case VECTOR_OP_DIV: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)(a / b));
+            case VECTOR_OP_MAX: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)Math.max(a, b));
+            case VECTOR_OP_MIN: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)Math.min(a, b));
+            default: return null;
+        }
+    }
+
+
     // FIXME: Maybe all of the public final methods in this file (the
     // simple ones that just call lanewise) should be pushed down to
     // the X-VectorBits template.  They can't optimize properly at
@@ -2968,6 +3131,7 @@ public abstract class ByteVector extends AbstractVector<Byte> {
      *         if {@code offset+N < 0} or {@code offset+N >= a.length}
      *         for any lane {@code N} in the vector
      */
+    /*
     @ForceInline
     public static
     ByteVector fromArray(VectorSpecies<Byte> species,
@@ -2975,7 +3139,7 @@ public abstract class ByteVector extends AbstractVector<Byte> {
         offset = checkFromIndexSize(offset, species.length(), a.length);
         ByteSpecies vsp = (ByteSpecies) species;
         return vsp.dummyVector().fromArray0(a, offset);
-    }
+    }*/
 
     /**
      * Loads a vector from an array of type {@code byte[]}
@@ -3375,6 +3539,7 @@ public abstract class ByteVector extends AbstractVector<Byte> {
     void intoArray(byte[] a, int offset) {
         offset = checkFromIndexSize(offset, length(), a.length);
         ByteSpecies vsp = vspecies();
+        /*
         VectorSupport.store(
             vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
             a, arrayAddress(a, offset),
@@ -3383,6 +3548,16 @@ public abstract class ByteVector extends AbstractVector<Byte> {
             (arr, off, v)
             -> v.stOp(arr, (int) off,
                       (arr_, off_, i, e) -> arr_[off_ + i] = e));
+         */
+        VectorSupport.store(
+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
+            a, arrayAddress(a, offset),
+            this,
+            a, offset,
+            (arr, off, v)
+            -> v.stOpMF(arr, (int) off,
+                      (arr_, off_, i, e) -> arr_[off_ + i] = e));
+
     }
 
     /**
@@ -3737,6 +3912,7 @@ public abstract class ByteVector extends AbstractVector<Byte> {
     ByteVector fromArray0(byte[] a, int offset);
     @ForceInline
     final
+    /*
     ByteVector fromArray0Template(byte[] a, int offset) {
         ByteSpecies vsp = vspecies();
         return VectorSupport.load(
@@ -3745,6 +3921,16 @@ public abstract class ByteVector extends AbstractVector<Byte> {
             a, offset, vsp,
             (arr, off, s) -> s.ldOp(arr, (int) off,
                                     (arr_, off_, i) -> arr_[off_ + i]));
+    }*/
+
+    ByteVector fromArray0Template(byte[] a, int offset) {
+        ByteSpecies vsp = vspecies();
+        return VectorSupport.load(
+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
+            a, arrayAddress(a, offset),
+            a, offset, vsp,
+            (arr, off, s) -> s.ldOpMF(arr, (int) off,
+                                    (arr_, off_, i) -> arr_[off_ + i]));
     }
 
     /*package-private*/
@@ -4209,6 +4395,12 @@ public abstract class ByteVector extends AbstractVector<Byte> {
             return (ByteVector) super.dummyVector();
         }
 
+        @ForceInline
+        @Override final
+        ByteVector dummyVectorMF() {
+            return (ByteVector) super.dummyVectorMF();
+        }
+
         /*package-private*/
         final @Override
         @ForceInline
@@ -4255,6 +4447,22 @@ public abstract class ByteVector extends AbstractVector<Byte> {
             return dummyVector().ldOp(memory, offset, m, f);
         }
 
+        /*package-private*/
+        @ForceInline
+        <M> ByteVector ldOpMF(M memory, int offset,
+                                      FLdOp<M> f) {
+            return dummyVectorMF().ldOpMF(memory, offset, f);
+        }
+
+        /*package-private*/
+        @ForceInline
+        <M> ByteVector ldOpMF(M memory, int offset,
+                                      VectorMask<Byte> m,
+                                      FLdOp<M> f) {
+            return dummyVectorMF().ldOpMF(memory, offset, m, f);
+        }
+
+
         /*package-private*/
         @ForceInline
         ByteVector ldLongOp(MemorySegment memory, long offset,
@@ -4284,6 +4492,21 @@ public abstract class ByteVector extends AbstractVector<Byte> {
             dummyVector().stOp(memory, offset, m, f);
         }
 
+        /*package-private*/
+        @ForceInline
+        <M> void stOpMF(M memory, int offset, FStOp<M> f) {
+            dummyVectorMF().stOpMF(memory, offset, f);
+        }
+
+        /*package-private*/
+        @ForceInline
+        <M> void stOpMF(M memory, int offset,
+                     AbstractMask<Byte> m,
+                      FStOp<M> f) {
+            dummyVectorMF().stOpMF(memory, offset, m, f);
+        }
+
+
         /*package-private*/
         @ForceInline
         void stLongOp(MemorySegment memory, long offset, FStLongOp f) {
@@ -4309,8 +4532,8 @@ public abstract class ByteVector extends AbstractVector<Byte> {
         @Override
         @ForceInline
         public final ByteVector zero() {
-            if ((Class<?>) vectorType() == ByteMaxVector.class)
-                return ByteMaxVector.ZERO;
+            //if ((Class<?>) vectorType() == ByteMaxVector.class)
+            //    return ByteMaxVector.ZERO;
             switch (vectorBitSize()) {
                 case 64: return Byte64Vector.ZERO;
                 case 128: return Byte128Vector.ZERO;
@@ -4323,8 +4546,8 @@ public abstract class ByteVector extends AbstractVector<Byte> {
         @Override
         @ForceInline
         public final ByteVector iota() {
-            if ((Class<?>) vectorType() == ByteMaxVector.class)
-                return ByteMaxVector.IOTA;
+            //if ((Class<?>) vectorType() == ByteMaxVector.class)
+            //    return ByteMaxVector.IOTA;
             switch (vectorBitSize()) {
                 case 64: return Byte64Vector.IOTA;
                 case 128: return Byte128Vector.IOTA;
@@ -4338,8 +4561,8 @@ public abstract class ByteVector extends AbstractVector<Byte> {
         @Override
         @ForceInline
         public final VectorMask<Byte> maskAll(boolean bit) {
-            if ((Class<?>) vectorType() == ByteMaxVector.class)
-                return ByteMaxVector.ByteMaxMask.maskAll(bit);
+            //if ((Class<?>) vectorType() == ByteMaxVector.class)
+            //    return ByteMaxVector.ByteMaxMask.maskAll(bit);
             switch (vectorBitSize()) {
                 case 64: return Byte64Vector.Byte64Mask.maskAll(bit);
                 case 128: return Byte128Vector.Byte128Mask.maskAll(bit);
@@ -4348,6 +4571,16 @@ public abstract class ByteVector extends AbstractVector<Byte> {
             }
             throw new AssertionError();
         }
+
+        @Override
+        Object iotaArray() {
+            int laneCount = laneCount();
+            byte [] init = new byte[laneCount];
+            for (int i = 0; i < laneCount; i++) {
+                init[i] = (byte)i;
+            }
+           return VectorSupport.VectorPayloadMF.createNewInstanceB(elementType(), laneCount, init);
+        }
     }
 
     /**
@@ -4364,7 +4597,7 @@ public abstract class ByteVector extends AbstractVector<Byte> {
             case VectorShape.SK_128_BIT: return (ByteSpecies) SPECIES_128;
             case VectorShape.SK_256_BIT: return (ByteSpecies) SPECIES_256;
             case VectorShape.SK_512_BIT: return (ByteSpecies) SPECIES_512;
-            case VectorShape.SK_Max_BIT: return (ByteSpecies) SPECIES_MAX;
+            //case VectorShape.SK_Max_BIT: return (ByteSpecies) SPECIES_MAX;
             default: throw new IllegalArgumentException("Bad shape: " + s);
         }
     }
@@ -4398,11 +4631,12 @@ public abstract class ByteVector extends AbstractVector<Byte> {
                             Byte512Vector::new);
 
     /** Species representing {@link ByteVector}s of {@link VectorShape#S_Max_BIT VectorShape.S_Max_BIT}. */
-    public static final VectorSpecies<Byte> SPECIES_MAX
+    /*public static final VectorSpecies<Byte> SPECIES_MAX
         = new ByteSpecies(VectorShape.S_Max_BIT,
                             ByteMaxVector.class,
                             ByteMaxVector.ByteMaxMask.class,
                             ByteMaxVector::new);
+     */
 
     /**
      * Preferred species for {@link ByteVector}s.
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double128Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double128Vector.java
index cf774e3678f..49c69f9c7c4 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double128Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double128Vector.java
@@ -39,7 +39,7 @@ import static jdk.incubator.vector.VectorOperators.*;
 // -- This file was mechanically generated: Do not edit! -- //
 
 @SuppressWarnings("cast")  // warning: redundant cast
-final class Double128Vector extends DoubleVector {
+value class Double128Vector extends DoubleVector {
     static final DoubleSpecies VSPECIES =
         (DoubleSpecies) DoubleVector.SPECIES_128;
 
@@ -54,24 +54,40 @@ final class Double128Vector extends DoubleVector {
 
     static final Class<Double> ETYPE = double.class; // used by the JVM
 
-    Double128Vector(double[] v) {
+    /*Double128Vector(double[] v) {
         super(v);
+    }*/
+
+    private final VectorSupport.Double128VectorPayload mf_storage;
+
+    Double128Vector(Object value) {
+        this.mf_storage = (VectorSupport.Double128VectorPayload)value;
+    }
+
+    VectorSupport.VectorPayloadMF vec_mf() {
+        return mf_storage;
+    }
+
+    @Override
+    protected final Object getPayload() {
+       return vec_mf();
     }
 
     // For compatibility as Double128Vector::new,
     // stored into species.vectorFactory.
-    Double128Vector(Object v) {
+    /*Double128Vector(Object v) {
         this((double[]) v);
-    }
+    }*/
 
-    static final Double128Vector ZERO = new Double128Vector(new double[VLENGTH]);
+    static final Double128Vector ZERO = new Double128Vector(VectorSupport.VectorPayloadMF.createNewInstanceD(double.class, 2, Double.valueOf((double)0)));
     static final Double128Vector IOTA = new Double128Vector(VSPECIES.iotaArray());
 
     static {
         // Warm up a few species caches.
         // If we do this too much we will
         // get NPEs from bootstrap circularity.
-        VSPECIES.dummyVector();
+        // VSPECIES.dummyVector();
+        VSPECIES.dummyVectorMF();
         VSPECIES.withLanes(LaneType.BYTE);
     }
 
@@ -171,6 +187,13 @@ final class Double128Vector extends DoubleVector {
         return new Double128Vector(vec);
     }
 
+    // Make a vector of the same species but the given elements:
+    @ForceInline
+    final @Override
+    Double128Vector vectorFactory(VectorSupport.VectorPayloadMF vec) {
+        return new Double128Vector(vec);
+    }
+
     @ForceInline
     final @Override
     Byte128Vector asByteVectorRaw() {
@@ -206,6 +229,12 @@ final class Double128Vector extends DoubleVector {
         return (Double128Vector) super.bOpTemplate((Double128Vector)v, f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Double128Vector bOpMF(Vector<Double> v, FBinOp f) {
+        return (Double128Vector) super.bOpTemplateMF((Double128Vector)v, f);  // specialize
+    }
+
     @ForceInline
     final @Override
     Double128Vector bOp(Vector<Double> v,
@@ -215,6 +244,15 @@ final class Double128Vector extends DoubleVector {
                               f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Double128Vector bOpMF(Vector<Double> v,
+                     VectorMask<Double> m, FBinOp f) {
+        return (Double128Vector)
+            super.bOpTemplateMF((Double128Vector)v, (Double128Mask)m,
+                              f);  // specialize
+    }
+
     // Ternary operator
 
     @ForceInline
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double256Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double256Vector.java
index 25738ae7ae7..032130c4f6a 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double256Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double256Vector.java
@@ -39,7 +39,7 @@ import static jdk.incubator.vector.VectorOperators.*;
 // -- This file was mechanically generated: Do not edit! -- //
 
 @SuppressWarnings("cast")  // warning: redundant cast
-final class Double256Vector extends DoubleVector {
+value class Double256Vector extends DoubleVector {
     static final DoubleSpecies VSPECIES =
         (DoubleSpecies) DoubleVector.SPECIES_256;
 
@@ -54,24 +54,40 @@ final class Double256Vector extends DoubleVector {
 
     static final Class<Double> ETYPE = double.class; // used by the JVM
 
-    Double256Vector(double[] v) {
+    /*Double256Vector(double[] v) {
         super(v);
+    }*/
+
+    private final VectorSupport.Double256VectorPayload mf_storage;
+
+    Double256Vector(Object value) {
+        this.mf_storage = (VectorSupport.Double256VectorPayload)value;
+    }
+
+    VectorSupport.VectorPayloadMF vec_mf() {
+        return mf_storage;
+    }
+
+    @Override
+    protected final Object getPayload() {
+       return vec_mf();
     }
 
     // For compatibility as Double256Vector::new,
     // stored into species.vectorFactory.
-    Double256Vector(Object v) {
+    /*Double256Vector(Object v) {
         this((double[]) v);
-    }
+    }*/
 
-    static final Double256Vector ZERO = new Double256Vector(new double[VLENGTH]);
+    static final Double256Vector ZERO = new Double256Vector(VectorSupport.VectorPayloadMF.createNewInstanceD(double.class, 4, Double.valueOf((double)0)));
     static final Double256Vector IOTA = new Double256Vector(VSPECIES.iotaArray());
 
     static {
         // Warm up a few species caches.
         // If we do this too much we will
         // get NPEs from bootstrap circularity.
-        VSPECIES.dummyVector();
+        // VSPECIES.dummyVector();
+        VSPECIES.dummyVectorMF();
         VSPECIES.withLanes(LaneType.BYTE);
     }
 
@@ -171,6 +187,13 @@ final class Double256Vector extends DoubleVector {
         return new Double256Vector(vec);
     }
 
+    // Make a vector of the same species but the given elements:
+    @ForceInline
+    final @Override
+    Double256Vector vectorFactory(VectorSupport.VectorPayloadMF vec) {
+        return new Double256Vector(vec);
+    }
+
     @ForceInline
     final @Override
     Byte256Vector asByteVectorRaw() {
@@ -206,6 +229,12 @@ final class Double256Vector extends DoubleVector {
         return (Double256Vector) super.bOpTemplate((Double256Vector)v, f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Double256Vector bOpMF(Vector<Double> v, FBinOp f) {
+        return (Double256Vector) super.bOpTemplateMF((Double256Vector)v, f);  // specialize
+    }
+
     @ForceInline
     final @Override
     Double256Vector bOp(Vector<Double> v,
@@ -215,6 +244,15 @@ final class Double256Vector extends DoubleVector {
                               f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Double256Vector bOpMF(Vector<Double> v,
+                     VectorMask<Double> m, FBinOp f) {
+        return (Double256Vector)
+            super.bOpTemplateMF((Double256Vector)v, (Double256Mask)m,
+                              f);  // specialize
+    }
+
     // Ternary operator
 
     @ForceInline
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double512Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double512Vector.java
index f4e999c808c..865c0ffa844 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double512Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double512Vector.java
@@ -39,7 +39,7 @@ import static jdk.incubator.vector.VectorOperators.*;
 // -- This file was mechanically generated: Do not edit! -- //
 
 @SuppressWarnings("cast")  // warning: redundant cast
-final class Double512Vector extends DoubleVector {
+value class Double512Vector extends DoubleVector {
     static final DoubleSpecies VSPECIES =
         (DoubleSpecies) DoubleVector.SPECIES_512;
 
@@ -54,24 +54,40 @@ final class Double512Vector extends DoubleVector {
 
     static final Class<Double> ETYPE = double.class; // used by the JVM
 
-    Double512Vector(double[] v) {
+    /*Double512Vector(double[] v) {
         super(v);
+    }*/
+
+    private final VectorSupport.Double512VectorPayload mf_storage;
+
+    Double512Vector(Object value) {
+        this.mf_storage = (VectorSupport.Double512VectorPayload)value;
+    }
+
+    VectorSupport.VectorPayloadMF vec_mf() {
+        return mf_storage;
+    }
+
+    @Override
+    protected final Object getPayload() {
+       return vec_mf();
     }
 
     // For compatibility as Double512Vector::new,
     // stored into species.vectorFactory.
-    Double512Vector(Object v) {
+    /*Double512Vector(Object v) {
         this((double[]) v);
-    }
+    }*/
 
-    static final Double512Vector ZERO = new Double512Vector(new double[VLENGTH]);
+    static final Double512Vector ZERO = new Double512Vector(VectorSupport.VectorPayloadMF.createNewInstanceD(double.class, 8, Double.valueOf((double)0)));
     static final Double512Vector IOTA = new Double512Vector(VSPECIES.iotaArray());
 
     static {
         // Warm up a few species caches.
         // If we do this too much we will
         // get NPEs from bootstrap circularity.
-        VSPECIES.dummyVector();
+        // VSPECIES.dummyVector();
+        VSPECIES.dummyVectorMF();
         VSPECIES.withLanes(LaneType.BYTE);
     }
 
@@ -171,6 +187,13 @@ final class Double512Vector extends DoubleVector {
         return new Double512Vector(vec);
     }
 
+    // Make a vector of the same species but the given elements:
+    @ForceInline
+    final @Override
+    Double512Vector vectorFactory(VectorSupport.VectorPayloadMF vec) {
+        return new Double512Vector(vec);
+    }
+
     @ForceInline
     final @Override
     Byte512Vector asByteVectorRaw() {
@@ -206,6 +229,12 @@ final class Double512Vector extends DoubleVector {
         return (Double512Vector) super.bOpTemplate((Double512Vector)v, f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Double512Vector bOpMF(Vector<Double> v, FBinOp f) {
+        return (Double512Vector) super.bOpTemplateMF((Double512Vector)v, f);  // specialize
+    }
+
     @ForceInline
     final @Override
     Double512Vector bOp(Vector<Double> v,
@@ -215,6 +244,15 @@ final class Double512Vector extends DoubleVector {
                               f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Double512Vector bOpMF(Vector<Double> v,
+                     VectorMask<Double> m, FBinOp f) {
+        return (Double512Vector)
+            super.bOpTemplateMF((Double512Vector)v, (Double512Mask)m,
+                              f);  // specialize
+    }
+
     // Ternary operator
 
     @ForceInline
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double64Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double64Vector.java
index 510d739d976..86a361cd5a5 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double64Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Double64Vector.java
@@ -39,7 +39,7 @@ import static jdk.incubator.vector.VectorOperators.*;
 // -- This file was mechanically generated: Do not edit! -- //
 
 @SuppressWarnings("cast")  // warning: redundant cast
-final class Double64Vector extends DoubleVector {
+value class Double64Vector extends DoubleVector {
     static final DoubleSpecies VSPECIES =
         (DoubleSpecies) DoubleVector.SPECIES_64;
 
@@ -54,24 +54,40 @@ final class Double64Vector extends DoubleVector {
 
     static final Class<Double> ETYPE = double.class; // used by the JVM
 
-    Double64Vector(double[] v) {
+    /*Double64Vector(double[] v) {
         super(v);
+    }*/
+
+    private final VectorSupport.Double64VectorPayload mf_storage;
+
+    Double64Vector(Object value) {
+        this.mf_storage = (VectorSupport.Double64VectorPayload)value;
+    }
+
+    VectorSupport.VectorPayloadMF vec_mf() {
+        return mf_storage;
+    }
+
+    @Override
+    protected final Object getPayload() {
+       return vec_mf();
     }
 
     // For compatibility as Double64Vector::new,
     // stored into species.vectorFactory.
-    Double64Vector(Object v) {
+    /*Double64Vector(Object v) {
         this((double[]) v);
-    }
+    }*/
 
-    static final Double64Vector ZERO = new Double64Vector(new double[VLENGTH]);
+    static final Double64Vector ZERO = new Double64Vector(VectorSupport.VectorPayloadMF.createNewInstanceD(double.class, 1, Double.valueOf((double)0)));
     static final Double64Vector IOTA = new Double64Vector(VSPECIES.iotaArray());
 
     static {
         // Warm up a few species caches.
         // If we do this too much we will
         // get NPEs from bootstrap circularity.
-        VSPECIES.dummyVector();
+        // VSPECIES.dummyVector();
+        VSPECIES.dummyVectorMF();
         VSPECIES.withLanes(LaneType.BYTE);
     }
 
@@ -171,6 +187,13 @@ final class Double64Vector extends DoubleVector {
         return new Double64Vector(vec);
     }
 
+    // Make a vector of the same species but the given elements:
+    @ForceInline
+    final @Override
+    Double64Vector vectorFactory(VectorSupport.VectorPayloadMF vec) {
+        return new Double64Vector(vec);
+    }
+
     @ForceInline
     final @Override
     Byte64Vector asByteVectorRaw() {
@@ -206,6 +229,12 @@ final class Double64Vector extends DoubleVector {
         return (Double64Vector) super.bOpTemplate((Double64Vector)v, f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Double64Vector bOpMF(Vector<Double> v, FBinOp f) {
+        return (Double64Vector) super.bOpTemplateMF((Double64Vector)v, f);  // specialize
+    }
+
     @ForceInline
     final @Override
     Double64Vector bOp(Vector<Double> v,
@@ -215,6 +244,15 @@ final class Double64Vector extends DoubleVector {
                               f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Double64Vector bOpMF(Vector<Double> v,
+                     VectorMask<Double> m, FBinOp f) {
+        return (Double64Vector)
+            super.bOpTemplateMF((Double64Vector)v, (Double64Mask)m,
+                              f);  // specialize
+    }
+
     // Ternary operator
 
     @ForceInline
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/DoubleMaxVector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/DoubleMaxVector.java
deleted file mode 100644
index 877b14e24ba..00000000000
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/DoubleMaxVector.java
+++ /dev/null
@@ -1,901 +0,0 @@
-/*
- * Copyright (c) 2017, 2022, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package jdk.incubator.vector;
-
-import java.lang.foreign.MemorySegment;
-import java.util.Arrays;
-import java.util.Objects;
-import java.util.function.IntUnaryOperator;
-
-import jdk.internal.vm.annotation.ForceInline;
-import jdk.internal.vm.vector.VectorSupport;
-
-import static jdk.internal.vm.vector.VectorSupport.*;
-
-import static jdk.incubator.vector.VectorOperators.*;
-
-// -- This file was mechanically generated: Do not edit! -- //
-
-@SuppressWarnings("cast")  // warning: redundant cast
-final class DoubleMaxVector extends DoubleVector {
-    static final DoubleSpecies VSPECIES =
-        (DoubleSpecies) DoubleVector.SPECIES_MAX;
-
-    static final VectorShape VSHAPE =
-        VSPECIES.vectorShape();
-
-    static final Class<DoubleMaxVector> VCLASS = DoubleMaxVector.class;
-
-    static final int VSIZE = VSPECIES.vectorBitSize();
-
-    static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
-
-    static final Class<Double> ETYPE = double.class; // used by the JVM
-
-    DoubleMaxVector(double[] v) {
-        super(v);
-    }
-
-    // For compatibility as DoubleMaxVector::new,
-    // stored into species.vectorFactory.
-    DoubleMaxVector(Object v) {
-        this((double[]) v);
-    }
-
-    static final DoubleMaxVector ZERO = new DoubleMaxVector(new double[VLENGTH]);
-    static final DoubleMaxVector IOTA = new DoubleMaxVector(VSPECIES.iotaArray());
-
-    static {
-        // Warm up a few species caches.
-        // If we do this too much we will
-        // get NPEs from bootstrap circularity.
-        VSPECIES.dummyVector();
-        VSPECIES.withLanes(LaneType.BYTE);
-    }
-
-    // Specialized extractors
-
-    @ForceInline
-    final @Override
-    public DoubleSpecies vspecies() {
-        // ISSUE:  This should probably be a @Stable
-        // field inside AbstractVector, rather than
-        // a megamorphic method.
-        return VSPECIES;
-    }
-
-    @ForceInline
-    @Override
-    public final Class<Double> elementType() { return double.class; }
-
-    @ForceInline
-    @Override
-    public final int elementSize() { return Double.SIZE; }
-
-    @ForceInline
-    @Override
-    public final VectorShape shape() { return VSHAPE; }
-
-    @ForceInline
-    @Override
-    public final int length() { return VLENGTH; }
-
-    @ForceInline
-    @Override
-    public final int bitSize() { return VSIZE; }
-
-    @ForceInline
-    @Override
-    public final int byteSize() { return VSIZE / Byte.SIZE; }
-
-    /*package-private*/
-    @ForceInline
-    final @Override
-    double[] vec() {
-        return (double[])getPayload();
-    }
-
-    // Virtualized constructors
-
-    @Override
-    @ForceInline
-    public final DoubleMaxVector broadcast(double e) {
-        return (DoubleMaxVector) super.broadcastTemplate(e);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final DoubleMaxVector broadcast(long e) {
-        return (DoubleMaxVector) super.broadcastTemplate(e);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    DoubleMaxMask maskFromArray(boolean[] bits) {
-        return new DoubleMaxMask(bits);
-    }
-
-    @Override
-    @ForceInline
-    DoubleMaxShuffle iotaShuffle() { return DoubleMaxShuffle.IOTA; }
-
-    @ForceInline
-    DoubleMaxShuffle iotaShuffle(int start, int step, boolean wrap) {
-      if (wrap) {
-        return (DoubleMaxShuffle)VectorSupport.shuffleIota(ETYPE, DoubleMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,
-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));
-      } else {
-        return (DoubleMaxShuffle)VectorSupport.shuffleIota(ETYPE, DoubleMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,
-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));
-      }
-    }
-
-    @Override
-    @ForceInline
-    DoubleMaxShuffle shuffleFromBytes(byte[] reorder) { return new DoubleMaxShuffle(reorder); }
-
-    @Override
-    @ForceInline
-    DoubleMaxShuffle shuffleFromArray(int[] indexes, int i) { return new DoubleMaxShuffle(indexes, i); }
-
-    @Override
-    @ForceInline
-    DoubleMaxShuffle shuffleFromOp(IntUnaryOperator fn) { return new DoubleMaxShuffle(fn); }
-
-    // Make a vector of the same species but the given elements:
-    @ForceInline
-    final @Override
-    DoubleMaxVector vectorFactory(double[] vec) {
-        return new DoubleMaxVector(vec);
-    }
-
-    @ForceInline
-    final @Override
-    ByteMaxVector asByteVectorRaw() {
-        return (ByteMaxVector) super.asByteVectorRawTemplate();  // specialize
-    }
-
-    @ForceInline
-    final @Override
-    AbstractVector<?> asVectorRaw(LaneType laneType) {
-        return super.asVectorRawTemplate(laneType);  // specialize
-    }
-
-    // Unary operator
-
-    @ForceInline
-    final @Override
-    DoubleMaxVector uOp(FUnOp f) {
-        return (DoubleMaxVector) super.uOpTemplate(f);  // specialize
-    }
-
-    @ForceInline
-    final @Override
-    DoubleMaxVector uOp(VectorMask<Double> m, FUnOp f) {
-        return (DoubleMaxVector)
-            super.uOpTemplate((DoubleMaxMask)m, f);  // specialize
-    }
-
-    // Binary operator
-
-    @ForceInline
-    final @Override
-    DoubleMaxVector bOp(Vector<Double> v, FBinOp f) {
-        return (DoubleMaxVector) super.bOpTemplate((DoubleMaxVector)v, f);  // specialize
-    }
-
-    @ForceInline
-    final @Override
-    DoubleMaxVector bOp(Vector<Double> v,
-                     VectorMask<Double> m, FBinOp f) {
-        return (DoubleMaxVector)
-            super.bOpTemplate((DoubleMaxVector)v, (DoubleMaxMask)m,
-                              f);  // specialize
-    }
-
-    // Ternary operator
-
-    @ForceInline
-    final @Override
-    DoubleMaxVector tOp(Vector<Double> v1, Vector<Double> v2, FTriOp f) {
-        return (DoubleMaxVector)
-            super.tOpTemplate((DoubleMaxVector)v1, (DoubleMaxVector)v2,
-                              f);  // specialize
-    }
-
-    @ForceInline
-    final @Override
-    DoubleMaxVector tOp(Vector<Double> v1, Vector<Double> v2,
-                     VectorMask<Double> m, FTriOp f) {
-        return (DoubleMaxVector)
-            super.tOpTemplate((DoubleMaxVector)v1, (DoubleMaxVector)v2,
-                              (DoubleMaxMask)m, f);  // specialize
-    }
-
-    @ForceInline
-    final @Override
-    double rOp(double v, VectorMask<Double> m, FBinOp f) {
-        return super.rOpTemplate(v, m, f);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final <F>
-    Vector<F> convertShape(VectorOperators.Conversion<Double,F> conv,
-                           VectorSpecies<F> rsp, int part) {
-        return super.convertShapeTemplate(conv, rsp, part);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final <F>
-    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {
-        return super.reinterpretShapeTemplate(toSpecies, part);  // specialize
-    }
-
-    // Specialized algebraic operations:
-
-    // The following definition forces a specialized version of this
-    // crucial method into the v-table of this class.  A call to add()
-    // will inline to a call to lanewise(ADD,), at which point the JIT
-    // intrinsic will have the opcode of ADD, plus all the metadata
-    // for this particular class, enabling it to generate precise
-    // code.
-    //
-    // There is probably no benefit to the JIT to specialize the
-    // masked or broadcast versions of the lanewise method.
-
-    @Override
-    @ForceInline
-    public DoubleMaxVector lanewise(Unary op) {
-        return (DoubleMaxVector) super.lanewiseTemplate(op);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public DoubleMaxVector lanewise(Unary op, VectorMask<Double> m) {
-        return (DoubleMaxVector) super.lanewiseTemplate(op, DoubleMaxMask.class, (DoubleMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public DoubleMaxVector lanewise(Binary op, Vector<Double> v) {
-        return (DoubleMaxVector) super.lanewiseTemplate(op, v);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public DoubleMaxVector lanewise(Binary op, Vector<Double> v, VectorMask<Double> m) {
-        return (DoubleMaxVector) super.lanewiseTemplate(op, DoubleMaxMask.class, v, (DoubleMaxMask) m);  // specialize
-    }
-
-
-    /*package-private*/
-    @Override
-    @ForceInline
-    public final
-    DoubleMaxVector
-    lanewise(Ternary op, Vector<Double> v1, Vector<Double> v2) {
-        return (DoubleMaxVector) super.lanewiseTemplate(op, v1, v2);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final
-    DoubleMaxVector
-    lanewise(Ternary op, Vector<Double> v1, Vector<Double> v2, VectorMask<Double> m) {
-        return (DoubleMaxVector) super.lanewiseTemplate(op, DoubleMaxMask.class, v1, v2, (DoubleMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final
-    DoubleMaxVector addIndex(int scale) {
-        return (DoubleMaxVector) super.addIndexTemplate(scale);  // specialize
-    }
-
-    // Type specific horizontal reductions
-
-    @Override
-    @ForceInline
-    public final double reduceLanes(VectorOperators.Associative op) {
-        return super.reduceLanesTemplate(op);  // specialized
-    }
-
-    @Override
-    @ForceInline
-    public final double reduceLanes(VectorOperators.Associative op,
-                                    VectorMask<Double> m) {
-        return super.reduceLanesTemplate(op, DoubleMaxMask.class, (DoubleMaxMask) m);  // specialized
-    }
-
-    @Override
-    @ForceInline
-    public final long reduceLanesToLong(VectorOperators.Associative op) {
-        return (long) super.reduceLanesTemplate(op);  // specialized
-    }
-
-    @Override
-    @ForceInline
-    public final long reduceLanesToLong(VectorOperators.Associative op,
-                                        VectorMask<Double> m) {
-        return (long) super.reduceLanesTemplate(op, DoubleMaxMask.class, (DoubleMaxMask) m);  // specialized
-    }
-
-    @ForceInline
-    public VectorShuffle<Double> toShuffle() {
-        return super.toShuffleTemplate(DoubleMaxShuffle.class); // specialize
-    }
-
-    // Specialized unary testing
-
-    @Override
-    @ForceInline
-    public final DoubleMaxMask test(Test op) {
-        return super.testTemplate(DoubleMaxMask.class, op);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final DoubleMaxMask test(Test op, VectorMask<Double> m) {
-        return super.testTemplate(DoubleMaxMask.class, op, (DoubleMaxMask) m);  // specialize
-    }
-
-    // Specialized comparisons
-
-    @Override
-    @ForceInline
-    public final DoubleMaxMask compare(Comparison op, Vector<Double> v) {
-        return super.compareTemplate(DoubleMaxMask.class, op, v);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final DoubleMaxMask compare(Comparison op, double s) {
-        return super.compareTemplate(DoubleMaxMask.class, op, s);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final DoubleMaxMask compare(Comparison op, long s) {
-        return super.compareTemplate(DoubleMaxMask.class, op, s);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final DoubleMaxMask compare(Comparison op, Vector<Double> v, VectorMask<Double> m) {
-        return super.compareTemplate(DoubleMaxMask.class, op, v, (DoubleMaxMask) m);
-    }
-
-
-    @Override
-    @ForceInline
-    public DoubleMaxVector blend(Vector<Double> v, VectorMask<Double> m) {
-        return (DoubleMaxVector)
-            super.blendTemplate(DoubleMaxMask.class,
-                                (DoubleMaxVector) v,
-                                (DoubleMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public DoubleMaxVector slice(int origin, Vector<Double> v) {
-        return (DoubleMaxVector) super.sliceTemplate(origin, v);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public DoubleMaxVector slice(int origin) {
-        return (DoubleMaxVector) super.sliceTemplate(origin);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public DoubleMaxVector unslice(int origin, Vector<Double> w, int part) {
-        return (DoubleMaxVector) super.unsliceTemplate(origin, w, part);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public DoubleMaxVector unslice(int origin, Vector<Double> w, int part, VectorMask<Double> m) {
-        return (DoubleMaxVector)
-            super.unsliceTemplate(DoubleMaxMask.class,
-                                  origin, w, part,
-                                  (DoubleMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public DoubleMaxVector unslice(int origin) {
-        return (DoubleMaxVector) super.unsliceTemplate(origin);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public DoubleMaxVector rearrange(VectorShuffle<Double> s) {
-        return (DoubleMaxVector)
-            super.rearrangeTemplate(DoubleMaxShuffle.class,
-                                    (DoubleMaxShuffle) s);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public DoubleMaxVector rearrange(VectorShuffle<Double> shuffle,
-                                  VectorMask<Double> m) {
-        return (DoubleMaxVector)
-            super.rearrangeTemplate(DoubleMaxShuffle.class,
-                                    DoubleMaxMask.class,
-                                    (DoubleMaxShuffle) shuffle,
-                                    (DoubleMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public DoubleMaxVector rearrange(VectorShuffle<Double> s,
-                                  Vector<Double> v) {
-        return (DoubleMaxVector)
-            super.rearrangeTemplate(DoubleMaxShuffle.class,
-                                    (DoubleMaxShuffle) s,
-                                    (DoubleMaxVector) v);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public DoubleMaxVector compress(VectorMask<Double> m) {
-        return (DoubleMaxVector)
-            super.compressTemplate(DoubleMaxMask.class,
-                                   (DoubleMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public DoubleMaxVector expand(VectorMask<Double> m) {
-        return (DoubleMaxVector)
-            super.expandTemplate(DoubleMaxMask.class,
-                                   (DoubleMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public DoubleMaxVector selectFrom(Vector<Double> v) {
-        return (DoubleMaxVector)
-            super.selectFromTemplate((DoubleMaxVector) v);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public DoubleMaxVector selectFrom(Vector<Double> v,
-                                   VectorMask<Double> m) {
-        return (DoubleMaxVector)
-            super.selectFromTemplate((DoubleMaxVector) v,
-                                     (DoubleMaxMask) m);  // specialize
-    }
-
-
-    @ForceInline
-    @Override
-    public double lane(int i) {
-        if (i < 0 || i >= VLENGTH) {
-            throw new IllegalArgumentException("Index " + i + " must be zero or positive, and less than " + VLENGTH);
-        }
-        long bits = laneHelper(i);
-        return Double.longBitsToDouble(bits);
-    }
-
-    public long laneHelper(int i) {
-        return (long) VectorSupport.extract(
-                     VCLASS, ETYPE, VLENGTH,
-                     this, i,
-                     (vec, ix) -> {
-                     double[] vecarr = vec.vec();
-                     return (long)Double.doubleToLongBits(vecarr[ix]);
-                     });
-    }
-
-    @ForceInline
-    @Override
-    public DoubleMaxVector withLane(int i, double e) {
-        if (i < 0 || i >= VLENGTH) {
-            throw new IllegalArgumentException("Index " + i + " must be zero or positive, and less than " + VLENGTH);
-        }
-        return withLaneHelper(i, e);
-    }
-
-    public DoubleMaxVector withLaneHelper(int i, double e) {
-        return VectorSupport.insert(
-                                VCLASS, ETYPE, VLENGTH,
-                                this, i, (long)Double.doubleToLongBits(e),
-                                (v, ix, bits) -> {
-                                    double[] res = v.vec().clone();
-                                    res[ix] = Double.longBitsToDouble((long)bits);
-                                    return v.vectorFactory(res);
-                                });
-    }
-
-    // Mask
-
-    static final class DoubleMaxMask extends AbstractMask<Double> {
-        static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
-        static final Class<Double> ETYPE = double.class; // used by the JVM
-
-        DoubleMaxMask(boolean[] bits) {
-            this(bits, 0);
-        }
-
-        DoubleMaxMask(boolean[] bits, int offset) {
-            super(prepare(bits, offset));
-        }
-
-        DoubleMaxMask(boolean val) {
-            super(prepare(val));
-        }
-
-        private static boolean[] prepare(boolean[] bits, int offset) {
-            boolean[] newBits = new boolean[VSPECIES.laneCount()];
-            for (int i = 0; i < newBits.length; i++) {
-                newBits[i] = bits[offset + i];
-            }
-            return newBits;
-        }
-
-        private static boolean[] prepare(boolean val) {
-            boolean[] bits = new boolean[VSPECIES.laneCount()];
-            Arrays.fill(bits, val);
-            return bits;
-        }
-
-        @ForceInline
-        final @Override
-        public DoubleSpecies vspecies() {
-            // ISSUE:  This should probably be a @Stable
-            // field inside AbstractMask, rather than
-            // a megamorphic method.
-            return VSPECIES;
-        }
-
-        @ForceInline
-        boolean[] getBits() {
-            return (boolean[])getPayload();
-        }
-
-        @Override
-        DoubleMaxMask uOp(MUnOp f) {
-            boolean[] res = new boolean[vspecies().laneCount()];
-            boolean[] bits = getBits();
-            for (int i = 0; i < res.length; i++) {
-                res[i] = f.apply(i, bits[i]);
-            }
-            return new DoubleMaxMask(res);
-        }
-
-        @Override
-        DoubleMaxMask bOp(VectorMask<Double> m, MBinOp f) {
-            boolean[] res = new boolean[vspecies().laneCount()];
-            boolean[] bits = getBits();
-            boolean[] mbits = ((DoubleMaxMask)m).getBits();
-            for (int i = 0; i < res.length; i++) {
-                res[i] = f.apply(i, bits[i], mbits[i]);
-            }
-            return new DoubleMaxMask(res);
-        }
-
-        @ForceInline
-        @Override
-        public final
-        DoubleMaxVector toVector() {
-            return (DoubleMaxVector) super.toVectorTemplate();  // specialize
-        }
-
-        /**
-         * Helper function for lane-wise mask conversions.
-         * This function kicks in after intrinsic failure.
-         */
-        @ForceInline
-        private final <E>
-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {
-            if (length() != dsp.laneCount())
-                throw new IllegalArgumentException("VectorMask length and species length differ");
-            boolean[] maskArray = toArray();
-            return  dsp.maskFactory(maskArray).check(dsp);
-        }
-
-        @Override
-        @ForceInline
-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;
-            if (length() != species.laneCount())
-                throw new IllegalArgumentException("VectorMask length and species length differ");
-
-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,
-                this.getClass(), ETYPE, VLENGTH,
-                species.maskType(), species.elementType(), VLENGTH,
-                this, species,
-                (m, s) -> s.maskFactory(m.toArray()).check(s));
-        }
-
-        @Override
-        @ForceInline
-        public DoubleMaxMask eq(VectorMask<Double> mask) {
-            Objects.requireNonNull(mask);
-            DoubleMaxMask m = (DoubleMaxMask)mask;
-            return xor(m.not());
-        }
-
-        // Unary operations
-
-        @Override
-        @ForceInline
-        public DoubleMaxMask not() {
-            return xor(maskAll(true));
-        }
-
-        @Override
-        @ForceInline
-        public DoubleMaxMask compress() {
-            return (DoubleMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                DoubleMaxVector.class, DoubleMaxMask.class, ETYPE, VLENGTH, null, this,
-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
-        }
-
-
-        // Binary operations
-
-        @Override
-        @ForceInline
-        public DoubleMaxMask and(VectorMask<Double> mask) {
-            Objects.requireNonNull(mask);
-            DoubleMaxMask m = (DoubleMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, DoubleMaxMask.class, null, long.class, VLENGTH,
-                                          this, m, null,
-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
-        }
-
-        @Override
-        @ForceInline
-        public DoubleMaxMask or(VectorMask<Double> mask) {
-            Objects.requireNonNull(mask);
-            DoubleMaxMask m = (DoubleMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, DoubleMaxMask.class, null, long.class, VLENGTH,
-                                          this, m, null,
-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
-        }
-
-        @ForceInline
-        /* package-private */
-        DoubleMaxMask xor(VectorMask<Double> mask) {
-            Objects.requireNonNull(mask);
-            DoubleMaxMask m = (DoubleMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, DoubleMaxMask.class, null, long.class, VLENGTH,
-                                          this, m, null,
-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
-        }
-
-        // Mask Query operations
-
-        @Override
-        @ForceInline
-        public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, DoubleMaxMask.class, long.class, VLENGTH, this,
-                                                      (m) -> trueCountHelper(m.getBits()));
-        }
-
-        @Override
-        @ForceInline
-        public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, DoubleMaxMask.class, long.class, VLENGTH, this,
-                                                      (m) -> firstTrueHelper(m.getBits()));
-        }
-
-        @Override
-        @ForceInline
-        public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, DoubleMaxMask.class, long.class, VLENGTH, this,
-                                                      (m) -> lastTrueHelper(m.getBits()));
-        }
-
-        @Override
-        @ForceInline
-        public long toLong() {
-            if (length() > Long.SIZE) {
-                throw new UnsupportedOperationException("too many lanes for one long");
-            }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, DoubleMaxMask.class, long.class, VLENGTH, this,
-                                                      (m) -> toLongHelper(m.getBits()));
-        }
-
-        // Reductions
-
-        @Override
-        @ForceInline
-        public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, DoubleMaxMask.class, long.class, VLENGTH,
-                                         this, vspecies().maskAll(true),
-                                         (m, __) -> anyTrueHelper(((DoubleMaxMask)m).getBits()));
-        }
-
-        @Override
-        @ForceInline
-        public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, DoubleMaxMask.class, long.class, VLENGTH,
-                                         this, vspecies().maskAll(true),
-                                         (m, __) -> allTrueHelper(((DoubleMaxMask)m).getBits()));
-        }
-
-        @ForceInline
-        /*package-private*/
-        static DoubleMaxMask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(DoubleMaxMask.class, long.class, VLENGTH,
-                                                 (bit ? -1 : 0), MODE_BROADCAST, null,
-                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
-        }
-        private static final DoubleMaxMask  TRUE_MASK = new DoubleMaxMask(true);
-        private static final DoubleMaxMask FALSE_MASK = new DoubleMaxMask(false);
-
-    }
-
-    // Shuffle
-
-    static final class DoubleMaxShuffle extends AbstractShuffle<Double> {
-        static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
-        static final Class<Double> ETYPE = double.class; // used by the JVM
-
-        DoubleMaxShuffle(byte[] reorder) {
-            super(VLENGTH, reorder);
-        }
-
-        public DoubleMaxShuffle(int[] reorder) {
-            super(VLENGTH, reorder);
-        }
-
-        public DoubleMaxShuffle(int[] reorder, int i) {
-            super(VLENGTH, reorder, i);
-        }
-
-        public DoubleMaxShuffle(IntUnaryOperator fn) {
-            super(VLENGTH, fn);
-        }
-
-        @Override
-        public DoubleSpecies vspecies() {
-            return VSPECIES;
-        }
-
-        static {
-            // There must be enough bits in the shuffle lanes to encode
-            // VLENGTH valid indexes and VLENGTH exceptional ones.
-            assert(VLENGTH < Byte.MAX_VALUE);
-            assert(Byte.MIN_VALUE <= -VLENGTH);
-        }
-        static final DoubleMaxShuffle IOTA = new DoubleMaxShuffle(IDENTITY);
-
-        @Override
-        @ForceInline
-        public DoubleMaxVector toVector() {
-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, DoubleMaxShuffle.class, this, VLENGTH,
-                                                    (s) -> ((DoubleMaxVector)(((AbstractShuffle<Double>)(s)).toVectorTemplate())));
-        }
-
-        @Override
-        @ForceInline
-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {
-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;
-            if (length() != species.laneCount())
-                throw new IllegalArgumentException("VectorShuffle length and species length differ");
-            int[] shuffleArray = toArray();
-            return s.shuffleFromArray(shuffleArray, 0).check(s);
-        }
-
-        @ForceInline
-        @Override
-        public DoubleMaxShuffle rearrange(VectorShuffle<Double> shuffle) {
-            DoubleMaxShuffle s = (DoubleMaxShuffle) shuffle;
-            byte[] reorder1 = reorder();
-            byte[] reorder2 = s.reorder();
-            byte[] r = new byte[reorder1.length];
-            for (int i = 0; i < reorder1.length; i++) {
-                int ssi = reorder2[i];
-                r[i] = reorder1[ssi];  // throws on exceptional index
-            }
-            return new DoubleMaxShuffle(r);
-        }
-    }
-
-    // ================================================
-
-    // Specialized low-level memory operations.
-
-    @ForceInline
-    @Override
-    final
-    DoubleVector fromArray0(double[] a, int offset) {
-        return super.fromArray0Template(a, offset);  // specialize
-    }
-
-    @ForceInline
-    @Override
-    final
-    DoubleVector fromArray0(double[] a, int offset, VectorMask<Double> m, int offsetInRange) {
-        return super.fromArray0Template(DoubleMaxMask.class, a, offset, (DoubleMaxMask) m, offsetInRange);  // specialize
-    }
-
-    @ForceInline
-    @Override
-    final
-    DoubleVector fromArray0(double[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Double> m) {
-        return super.fromArray0Template(DoubleMaxMask.class, a, offset, indexMap, mapOffset, (DoubleMaxMask) m);
-    }
-
-
-
-    @ForceInline
-    @Override
-    final
-    DoubleVector fromMemorySegment0(MemorySegment ms, long offset) {
-        return super.fromMemorySegment0Template(ms, offset);  // specialize
-    }
-
-    @ForceInline
-    @Override
-    final
-    DoubleVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Double> m, int offsetInRange) {
-        return super.fromMemorySegment0Template(DoubleMaxMask.class, ms, offset, (DoubleMaxMask) m, offsetInRange);  // specialize
-    }
-
-    @ForceInline
-    @Override
-    final
-    void intoArray0(double[] a, int offset) {
-        super.intoArray0Template(a, offset);  // specialize
-    }
-
-    @ForceInline
-    @Override
-    final
-    void intoArray0(double[] a, int offset, VectorMask<Double> m) {
-        super.intoArray0Template(DoubleMaxMask.class, a, offset, (DoubleMaxMask) m);
-    }
-
-    @ForceInline
-    @Override
-    final
-    void intoArray0(double[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Double> m) {
-        super.intoArray0Template(DoubleMaxMask.class, a, offset, indexMap, mapOffset, (DoubleMaxMask) m);
-    }
-
-
-    @ForceInline
-    @Override
-    final
-    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Double> m) {
-        super.intoMemorySegment0Template(DoubleMaxMask.class, ms, offset, (DoubleMaxMask) m);
-    }
-
-
-    // End of specialized low-level memory operations.
-
-    // ================================================
-
-}
-
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/DoubleVector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/DoubleVector.java
index 64bd795f817..5877d41856c 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/DoubleVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/DoubleVector.java
@@ -51,9 +51,9 @@ import static jdk.incubator.vector.VectorOperators.*;
 @SuppressWarnings("cast")  // warning: redundant cast
 public abstract class DoubleVector extends AbstractVector<Double> {
 
-    DoubleVector(double[] vec) {
+    /*DoubleVector(double[] vec) {
         super(vec);
-    }
+    }*/
 
     static final int FORBID_OPCODE_KIND = VO_NOFP;
 
@@ -96,6 +96,8 @@ public abstract class DoubleVector extends AbstractVector<Double> {
     /*package-private*/
     abstract double[] vec();
 
+    abstract VectorSupport.VectorPayloadMF vec_mf();
+
     // Virtualized constructors
 
     /**
@@ -105,6 +107,17 @@ public abstract class DoubleVector extends AbstractVector<Double> {
     /*package-private*/
     abstract DoubleVector vectorFactory(double[] vec);
 
+    abstract DoubleVector vectorFactory(VectorSupport.VectorPayloadMF vec);
+
+    @ForceInline
+    public static
+    DoubleVector fromArray(VectorSpecies<Double> species,
+                                   double[] a, int offset) {
+        offset = checkFromIndexSize(offset, species.length(), a.length);
+        DoubleSpecies vsp = (DoubleSpecies) species;
+        return vsp.dummyVectorMF().fromArray0(a, offset);
+    }
+
     /**
      * Build a mask directly using my species.
      * It is an error if the array is aliased elsewhere.
@@ -210,6 +223,30 @@ public abstract class DoubleVector extends AbstractVector<Double> {
         return vectorFactory(res);
     }
 
+    /*package-private*/
+    abstract
+    DoubleVector bOpMF(Vector<Double> o,
+                             FBinOp f);
+    @ForceInline
+    final
+    DoubleVector bOpTemplateMF(Vector<Double> o,
+                                     FBinOp f) {
+        VectorSupport.VectorPayloadMF vec1 = this.vec_mf();
+        VectorSupport.VectorPayloadMF vec2 = this.vec_mf();
+        VectorSupport.VectorPayloadMF tpayload = 
+            Unsafe.getUnsafe().makePrivateBuffer(VectorSupport.VectorPayloadMF.createNewInstanceD(
+                   double.class, length(), Double.valueOf((double)0)));
+        long start_offset = tpayload.multiFieldOffset();
+        int length = tpayload.length();
+        for (int i = 0; i < length; i++) {
+            double v1 = Unsafe.getUnsafe().getDouble(vec1, start_offset + i * Integer.BYTES);
+            double v2 = Unsafe.getUnsafe().getDouble(vec2, start_offset + i * Integer.BYTES);
+            Unsafe.getUnsafe().putDouble(tpayload, start_offset + i * Integer.BYTES, f.apply(i, v1, v2));
+        }
+        Unsafe.getUnsafe().finishPrivateBuffer(tpayload);
+        return vectorFactory(tpayload);
+    }
+
     /*package-private*/
     abstract
     DoubleVector bOp(Vector<Double> o,
@@ -233,6 +270,36 @@ public abstract class DoubleVector extends AbstractVector<Double> {
         return vectorFactory(res);
     }
 
+    /*package-private*/
+    abstract
+    DoubleVector bOpMF(Vector<Double> o,
+                             VectorMask<Double> m,
+                             FBinOp f);
+    @ForceInline
+    final
+    DoubleVector bOpTemplateMF(Vector<Double> o,
+                                     VectorMask<Double> m,
+                                     FBinOp f) {
+        if (m == null) {
+            return bOpTemplateMF(o, f);
+        }
+        boolean[] mbits = ((AbstractMask<Double>)m).getBits();
+        VectorSupport.VectorPayloadMF vec1 = this.vec_mf();
+        VectorSupport.VectorPayloadMF vec2 = this.vec_mf();
+        VectorSupport.VectorPayloadMF tpayload =
+            Unsafe.getUnsafe().makePrivateBuffer(VectorSupport.VectorPayloadMF.createNewInstanceD(
+                double.class, length(), Double.valueOf((double)0)));
+        long start_offset = tpayload.multiFieldOffset();
+        int length = tpayload.length();
+        for (int i = 0; i < length; i++) {
+            double v1 = Unsafe.getUnsafe().getDouble(vec1, start_offset + i * Integer.BYTES);
+            double v2 = Unsafe.getUnsafe().getDouble(vec2, start_offset + i * Integer.BYTES);
+            Unsafe.getUnsafe().putDouble(tpayload, start_offset + i * Integer.BYTES, mbits[i] ? f.apply(i, v1, v2): v1);
+        }
+        Unsafe.getUnsafe().finishPrivateBuffer(tpayload);
+        return vectorFactory(tpayload);
+    }
+
     // Ternary operator
 
     /*package-private*/
@@ -353,6 +420,45 @@ public abstract class DoubleVector extends AbstractVector<Double> {
         return vectorFactory(res);
     }
 
+    /*package-private*/
+    @ForceInline
+    final
+    <M> DoubleVector ldOpMF(M memory, int offset,
+                                  FLdOp<M> f) {
+        VectorSupport.VectorPayloadMF tpayload =
+            Unsafe.getUnsafe().makePrivateBuffer(VectorSupport.VectorPayloadMF.createNewInstanceD(
+                double.class, length(), Double.valueOf((double)0)));
+        int length = tpayload.length();
+        long start_offset = tpayload.multiFieldOffset();
+        for (int i = 0; i < length; i++) {
+            Unsafe.getUnsafe().putDouble(tpayload, start_offset + i * Integer.BYTES, f.apply(memory, offset, i));
+        }
+        Unsafe.getUnsafe().finishPrivateBuffer(tpayload);
+        return vectorFactory(tpayload);
+    }
+
+    /*package-private*/
+    @ForceInline
+    final
+    <M> DoubleVector ldOpMF(M memory, int offset,
+                                  VectorMask<Double> m,
+                                  FLdOp<M> f) {
+        VectorSupport.VectorPayloadMF tpayload =
+            Unsafe.getUnsafe().makePrivateBuffer(VectorSupport.VectorPayloadMF.createNewInstanceD(
+                double.class, length(), Double.valueOf((double)0)));
+        int length = tpayload.length();
+        long start_offset = tpayload.multiFieldOffset();
+        boolean[] mbits = ((AbstractMask<Double>)m).getBits();
+        for (int i = 0; i < length; i++) {
+            if (mbits[i]) {
+                Unsafe.getUnsafe().putDouble(tpayload, start_offset + i * Integer.BYTES, f.apply(memory, offset, i));
+            }
+        }
+        Unsafe.getUnsafe().finishPrivateBuffer(tpayload);
+        return vectorFactory(tpayload);
+    }
+
+
     /*package-private*/
     interface FLdLongOp {
         double apply(MemorySegment memory, long offset, int i);
@@ -422,6 +528,37 @@ public abstract class DoubleVector extends AbstractVector<Double> {
         }
     }
 
+    /*package-private*/
+    @ForceInline
+    final
+    <M> void stOpMF(M memory, int offset,
+                  FStOp<M> f) {
+        VectorSupport.VectorPayloadMF vec = vec_mf();
+        long start_offset = vec.multiFieldOffset();
+        int length = vec.length();
+        for (int i = 0; i < length; i++) {
+            f.apply(memory, offset, i, Unsafe.getUnsafe().getDouble(vec, start_offset + i * Integer.BYTES));
+        }
+    }
+
+    /*package-private*/
+   @ForceInline
+    final
+    <M> void stOpMF(M memory, int offset,
+                  VectorMask<Double> m,
+                  FStOp<M> f) {
+        VectorSupport.VectorPayloadMF vec = vec_mf();
+        boolean[] mbits = ((AbstractMask<Double>)m).getBits();
+        long start_offset = vec.multiFieldOffset();
+        int length = vec.length();
+        for (int i = 0; i < length; i++) {
+            if (mbits[i]) {
+                f.apply(memory, offset, i, Unsafe.getUnsafe().getDouble(vec, start_offset + i * Integer.BYTES));
+            }
+        }
+    }
+
+
     interface FStLongOp {
         void apply(MemorySegment memory, long offset, int i, double a);
     }
@@ -770,11 +907,18 @@ public abstract class DoubleVector extends AbstractVector<Double> {
             }
         }
 
+        /*
         int opc = opCode(op);
         return VectorSupport.binaryOp(
             opc, getClass(), null, double.class, length(),
             this, that, null,
             BIN_IMPL.find(op, opc, DoubleVector::binaryOperations));
+        */
+        int opc = opCode(op);
+        return VectorSupport.binaryOp(
+            opc, getClass(), null, double.class, length(),
+            this, that, null,
+            BIN_IMPL.find(op, opc, DoubleVector::binaryOperationsMF));
     }
 
     /**
@@ -841,6 +985,25 @@ public abstract class DoubleVector extends AbstractVector<Double> {
         }
     }
 
+    private static BinaryOperation<DoubleVector, VectorMask<Double>> binaryOperationsMF(int opc_) {
+        switch (opc_) {
+            case VECTOR_OP_ADD: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (double)(a + b));
+            case VECTOR_OP_SUB: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (double)(a - b));
+            case VECTOR_OP_MUL: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (double)(a * b));
+            case VECTOR_OP_DIV: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (double)(a / b));
+            case VECTOR_OP_MAX: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (double)Math.max(a, b));
+            case VECTOR_OP_MIN: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (double)Math.min(a, b));
+            default: return null;
+        }
+    }
+
+
     // FIXME: Maybe all of the public final methods in this file (the
     // simple ones that just call lanewise) should be pushed down to
     // the X-VectorBits template.  They can't optimize properly at
@@ -2766,6 +2929,7 @@ public abstract class DoubleVector extends AbstractVector<Double> {
      *         if {@code offset+N < 0} or {@code offset+N >= a.length}
      *         for any lane {@code N} in the vector
      */
+    /*
     @ForceInline
     public static
     DoubleVector fromArray(VectorSpecies<Double> species,
@@ -2773,7 +2937,7 @@ public abstract class DoubleVector extends AbstractVector<Double> {
         offset = checkFromIndexSize(offset, species.length(), a.length);
         DoubleSpecies vsp = (DoubleSpecies) species;
         return vsp.dummyVector().fromArray0(a, offset);
-    }
+    }*/
 
     /**
      * Loads a vector from an array of type {@code double[]}
@@ -2857,7 +3021,7 @@ public abstract class DoubleVector extends AbstractVector<Double> {
         }
 
         // Index vector: vix[0:n] = k -> offset + indexMap[mapOffset + k]
-        IntVector vix;
+        IntVector vix = null;
         if (isp.laneCount() != vsp.laneCount()) {
             // For DoubleMaxVector,  if vector length is non-power-of-two or
             // 2048 bits, indexShape of Double species is S_MAX_BIT.
@@ -2866,9 +3030,11 @@ public abstract class DoubleVector extends AbstractVector<Double> {
             // indexShape is still S_MAX_BIT, but the lane count of int vector
             // is 64. So when loading index vector (IntVector), only lower half
             // of index data is needed.
-            vix = IntVector
+            /*vix = IntVector
                 .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)
                 .add(offset);
+             */
+             assert false : "Unhandled case";
         } else {
             vix = IntVector
                 .fromArray(isp, indexMap, mapOffset)
@@ -3063,6 +3229,7 @@ public abstract class DoubleVector extends AbstractVector<Double> {
     void intoArray(double[] a, int offset) {
         offset = checkFromIndexSize(offset, length(), a.length);
         DoubleSpecies vsp = vspecies();
+        /*
         VectorSupport.store(
             vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
             a, arrayAddress(a, offset),
@@ -3071,6 +3238,16 @@ public abstract class DoubleVector extends AbstractVector<Double> {
             (arr, off, v)
             -> v.stOp(arr, (int) off,
                       (arr_, off_, i, e) -> arr_[off_ + i] = e));
+         */
+        VectorSupport.store(
+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
+            a, arrayAddress(a, offset),
+            this,
+            a, offset,
+            (arr, off, v)
+            -> v.stOpMF(arr, (int) off,
+                      (arr_, off_, i, e) -> arr_[off_ + i] = e));
+
     }
 
     /**
@@ -3150,7 +3327,7 @@ public abstract class DoubleVector extends AbstractVector<Double> {
         }
 
         // Index vector: vix[0:n] = i -> offset + indexMap[mo + i]
-        IntVector vix;
+        IntVector vix = null;
         if (isp.laneCount() != vsp.laneCount()) {
             // For DoubleMaxVector,  if vector length  is 2048 bits, indexShape
             // of Double species is S_MAX_BIT. and the lane count of Double
@@ -3158,9 +3335,11 @@ public abstract class DoubleVector extends AbstractVector<Double> {
             // indexShape is still S_MAX_BIT, but the lane count of int vector
             // is 64. So when loading index vector (IntVector), only lower half
             // of index data is needed.
-            vix = IntVector
+            /*vix = IntVector
                 .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)
                 .add(offset);
+             */
+             assert false : "Unhandled case";
         } else {
             vix = IntVector
                 .fromArray(isp, indexMap, mapOffset)
@@ -3294,6 +3473,7 @@ public abstract class DoubleVector extends AbstractVector<Double> {
     DoubleVector fromArray0(double[] a, int offset);
     @ForceInline
     final
+    /*
     DoubleVector fromArray0Template(double[] a, int offset) {
         DoubleSpecies vsp = vspecies();
         return VectorSupport.load(
@@ -3302,6 +3482,16 @@ public abstract class DoubleVector extends AbstractVector<Double> {
             a, offset, vsp,
             (arr, off, s) -> s.ldOp(arr, (int) off,
                                     (arr_, off_, i) -> arr_[off_ + i]));
+    }*/
+
+    DoubleVector fromArray0Template(double[] a, int offset) {
+        DoubleSpecies vsp = vspecies();
+        return VectorSupport.load(
+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
+            a, arrayAddress(a, offset),
+            a, offset, vsp,
+            (arr, off, s) -> s.ldOpMF(arr, (int) off,
+                                    (arr_, off_, i) -> arr_[off_ + i]));
     }
 
     /*package-private*/
@@ -3343,7 +3533,7 @@ public abstract class DoubleVector extends AbstractVector<Double> {
         }
 
         // Index vector: vix[0:n] = k -> offset + indexMap[mapOffset + k]
-        IntVector vix;
+        IntVector vix = null;
         if (isp.laneCount() != vsp.laneCount()) {
             // For DoubleMaxVector,  if vector length is non-power-of-two or
             // 2048 bits, indexShape of Double species is S_MAX_BIT.
@@ -3352,9 +3542,11 @@ public abstract class DoubleVector extends AbstractVector<Double> {
             // indexShape is still S_MAX_BIT, but the lane count of int vector
             // is 64. So when loading index vector (IntVector), only lower half
             // of index data is needed.
-            vix = IntVector
+            /*vix = IntVector
                 .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)
                 .add(offset);
+             */
+            assert false : "Unhandled case";
         } else {
             vix = IntVector
                 .fromArray(isp, indexMap, mapOffset)
@@ -3459,7 +3651,7 @@ public abstract class DoubleVector extends AbstractVector<Double> {
         }
 
         // Index vector: vix[0:n] = i -> offset + indexMap[mo + i]
-        IntVector vix;
+        IntVector vix = null;
         if (isp.laneCount() != vsp.laneCount()) {
             // For DoubleMaxVector,  if vector length  is 2048 bits, indexShape
             // of Double species is S_MAX_BIT. and the lane count of Double
@@ -3467,9 +3659,12 @@ public abstract class DoubleVector extends AbstractVector<Double> {
             // indexShape is still S_MAX_BIT, but the lane count of int vector
             // is 64. So when loading index vector (IntVector), only lower half
             // of index data is needed.
-            vix = IntVector
+            /*vix = IntVector
                 .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)
                 .add(offset);
+             */
+             assert false : "Unhandled case";
+
         } else {
             vix = IntVector
                 .fromArray(isp, indexMap, mapOffset)
@@ -3812,6 +4007,12 @@ public abstract class DoubleVector extends AbstractVector<Double> {
             return (DoubleVector) super.dummyVector();
         }
 
+        @ForceInline
+        @Override final
+        DoubleVector dummyVectorMF() {
+            return (DoubleVector) super.dummyVectorMF();
+        }
+
         /*package-private*/
         final @Override
         @ForceInline
@@ -3858,6 +4059,22 @@ public abstract class DoubleVector extends AbstractVector<Double> {
             return dummyVector().ldOp(memory, offset, m, f);
         }
 
+        /*package-private*/
+        @ForceInline
+        <M> DoubleVector ldOpMF(M memory, int offset,
+                                      FLdOp<M> f) {
+            return dummyVectorMF().ldOpMF(memory, offset, f);
+        }
+
+        /*package-private*/
+        @ForceInline
+        <M> DoubleVector ldOpMF(M memory, int offset,
+                                      VectorMask<Double> m,
+                                      FLdOp<M> f) {
+            return dummyVectorMF().ldOpMF(memory, offset, m, f);
+        }
+
+
         /*package-private*/
         @ForceInline
         DoubleVector ldLongOp(MemorySegment memory, long offset,
@@ -3887,6 +4104,21 @@ public abstract class DoubleVector extends AbstractVector<Double> {
             dummyVector().stOp(memory, offset, m, f);
         }
 
+        /*package-private*/
+        @ForceInline
+        <M> void stOpMF(M memory, int offset, FStOp<M> f) {
+            dummyVectorMF().stOpMF(memory, offset, f);
+        }
+
+        /*package-private*/
+        @ForceInline
+        <M> void stOpMF(M memory, int offset,
+                     AbstractMask<Double> m,
+                      FStOp<M> f) {
+            dummyVectorMF().stOpMF(memory, offset, m, f);
+        }
+
+
         /*package-private*/
         @ForceInline
         void stLongOp(MemorySegment memory, long offset, FStLongOp f) {
@@ -3912,8 +4144,8 @@ public abstract class DoubleVector extends AbstractVector<Double> {
         @Override
         @ForceInline
         public final DoubleVector zero() {
-            if ((Class<?>) vectorType() == DoubleMaxVector.class)
-                return DoubleMaxVector.ZERO;
+            //if ((Class<?>) vectorType() == DoubleMaxVector.class)
+            //    return DoubleMaxVector.ZERO;
             switch (vectorBitSize()) {
                 case 64: return Double64Vector.ZERO;
                 case 128: return Double128Vector.ZERO;
@@ -3926,8 +4158,8 @@ public abstract class DoubleVector extends AbstractVector<Double> {
         @Override
         @ForceInline
         public final DoubleVector iota() {
-            if ((Class<?>) vectorType() == DoubleMaxVector.class)
-                return DoubleMaxVector.IOTA;
+            //if ((Class<?>) vectorType() == DoubleMaxVector.class)
+            //    return DoubleMaxVector.IOTA;
             switch (vectorBitSize()) {
                 case 64: return Double64Vector.IOTA;
                 case 128: return Double128Vector.IOTA;
@@ -3941,8 +4173,8 @@ public abstract class DoubleVector extends AbstractVector<Double> {
         @Override
         @ForceInline
         public final VectorMask<Double> maskAll(boolean bit) {
-            if ((Class<?>) vectorType() == DoubleMaxVector.class)
-                return DoubleMaxVector.DoubleMaxMask.maskAll(bit);
+            //if ((Class<?>) vectorType() == DoubleMaxVector.class)
+            //    return DoubleMaxVector.DoubleMaxMask.maskAll(bit);
             switch (vectorBitSize()) {
                 case 64: return Double64Vector.Double64Mask.maskAll(bit);
                 case 128: return Double128Vector.Double128Mask.maskAll(bit);
@@ -3951,6 +4183,16 @@ public abstract class DoubleVector extends AbstractVector<Double> {
             }
             throw new AssertionError();
         }
+
+        @Override
+        Object iotaArray() {
+            int laneCount = laneCount();
+            double [] init = new double[laneCount];
+            for (int i = 0; i < laneCount; i++) {
+                init[i] = (double)i;
+            }
+           return VectorSupport.VectorPayloadMF.createNewInstanceD(elementType(), laneCount, init);
+        }
     }
 
     /**
@@ -3967,7 +4209,7 @@ public abstract class DoubleVector extends AbstractVector<Double> {
             case VectorShape.SK_128_BIT: return (DoubleSpecies) SPECIES_128;
             case VectorShape.SK_256_BIT: return (DoubleSpecies) SPECIES_256;
             case VectorShape.SK_512_BIT: return (DoubleSpecies) SPECIES_512;
-            case VectorShape.SK_Max_BIT: return (DoubleSpecies) SPECIES_MAX;
+            //case VectorShape.SK_Max_BIT: return (DoubleSpecies) SPECIES_MAX;
             default: throw new IllegalArgumentException("Bad shape: " + s);
         }
     }
@@ -4001,11 +4243,12 @@ public abstract class DoubleVector extends AbstractVector<Double> {
                             Double512Vector::new);
 
     /** Species representing {@link DoubleVector}s of {@link VectorShape#S_Max_BIT VectorShape.S_Max_BIT}. */
-    public static final VectorSpecies<Double> SPECIES_MAX
+    /*public static final VectorSpecies<Double> SPECIES_MAX
         = new DoubleSpecies(VectorShape.S_Max_BIT,
                             DoubleMaxVector.class,
                             DoubleMaxVector.DoubleMaxMask.class,
                             DoubleMaxVector::new);
+     */
 
     /**
      * Preferred species for {@link DoubleVector}s.
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float128Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float128Vector.java
index 972802387f3..ceadf8d0057 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float128Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float128Vector.java
@@ -39,7 +39,7 @@ import static jdk.incubator.vector.VectorOperators.*;
 // -- This file was mechanically generated: Do not edit! -- //
 
 @SuppressWarnings("cast")  // warning: redundant cast
-final class Float128Vector extends FloatVector {
+value class Float128Vector extends FloatVector {
     static final FloatSpecies VSPECIES =
         (FloatSpecies) FloatVector.SPECIES_128;
 
@@ -54,24 +54,40 @@ final class Float128Vector extends FloatVector {
 
     static final Class<Float> ETYPE = float.class; // used by the JVM
 
-    Float128Vector(float[] v) {
+    /*Float128Vector(float[] v) {
         super(v);
+    }*/
+
+    private final VectorSupport.Float128VectorPayload mf_storage;
+
+    Float128Vector(Object value) {
+        this.mf_storage = (VectorSupport.Float128VectorPayload)value;
+    }
+
+    VectorSupport.VectorPayloadMF vec_mf() {
+        return mf_storage;
+    }
+
+    @Override
+    protected final Object getPayload() {
+       return vec_mf();
     }
 
     // For compatibility as Float128Vector::new,
     // stored into species.vectorFactory.
-    Float128Vector(Object v) {
+    /*Float128Vector(Object v) {
         this((float[]) v);
-    }
+    }*/
 
-    static final Float128Vector ZERO = new Float128Vector(new float[VLENGTH]);
+    static final Float128Vector ZERO = new Float128Vector(VectorSupport.VectorPayloadMF.createNewInstanceF(float.class, 4, Float.valueOf((float)0)));
     static final Float128Vector IOTA = new Float128Vector(VSPECIES.iotaArray());
 
     static {
         // Warm up a few species caches.
         // If we do this too much we will
         // get NPEs from bootstrap circularity.
-        VSPECIES.dummyVector();
+        // VSPECIES.dummyVector();
+        VSPECIES.dummyVectorMF();
         VSPECIES.withLanes(LaneType.BYTE);
     }
 
@@ -171,6 +187,13 @@ final class Float128Vector extends FloatVector {
         return new Float128Vector(vec);
     }
 
+    // Make a vector of the same species but the given elements:
+    @ForceInline
+    final @Override
+    Float128Vector vectorFactory(VectorSupport.VectorPayloadMF vec) {
+        return new Float128Vector(vec);
+    }
+
     @ForceInline
     final @Override
     Byte128Vector asByteVectorRaw() {
@@ -206,6 +229,12 @@ final class Float128Vector extends FloatVector {
         return (Float128Vector) super.bOpTemplate((Float128Vector)v, f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Float128Vector bOpMF(Vector<Float> v, FBinOp f) {
+        return (Float128Vector) super.bOpTemplateMF((Float128Vector)v, f);  // specialize
+    }
+
     @ForceInline
     final @Override
     Float128Vector bOp(Vector<Float> v,
@@ -215,6 +244,15 @@ final class Float128Vector extends FloatVector {
                               f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Float128Vector bOpMF(Vector<Float> v,
+                     VectorMask<Float> m, FBinOp f) {
+        return (Float128Vector)
+            super.bOpTemplateMF((Float128Vector)v, (Float128Mask)m,
+                              f);  // specialize
+    }
+
     // Ternary operator
 
     @ForceInline
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float256Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float256Vector.java
index 79326ac6f9f..d71ca571d51 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float256Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float256Vector.java
@@ -39,7 +39,7 @@ import static jdk.incubator.vector.VectorOperators.*;
 // -- This file was mechanically generated: Do not edit! -- //
 
 @SuppressWarnings("cast")  // warning: redundant cast
-final class Float256Vector extends FloatVector {
+value class Float256Vector extends FloatVector {
     static final FloatSpecies VSPECIES =
         (FloatSpecies) FloatVector.SPECIES_256;
 
@@ -54,24 +54,40 @@ final class Float256Vector extends FloatVector {
 
     static final Class<Float> ETYPE = float.class; // used by the JVM
 
-    Float256Vector(float[] v) {
+    /*Float256Vector(float[] v) {
         super(v);
+    }*/
+
+    private final VectorSupport.Float256VectorPayload mf_storage;
+
+    Float256Vector(Object value) {
+        this.mf_storage = (VectorSupport.Float256VectorPayload)value;
+    }
+
+    VectorSupport.VectorPayloadMF vec_mf() {
+        return mf_storage;
+    }
+
+    @Override
+    protected final Object getPayload() {
+       return vec_mf();
     }
 
     // For compatibility as Float256Vector::new,
     // stored into species.vectorFactory.
-    Float256Vector(Object v) {
+    /*Float256Vector(Object v) {
         this((float[]) v);
-    }
+    }*/
 
-    static final Float256Vector ZERO = new Float256Vector(new float[VLENGTH]);
+    static final Float256Vector ZERO = new Float256Vector(VectorSupport.VectorPayloadMF.createNewInstanceF(float.class, 8, Float.valueOf((float)0)));
     static final Float256Vector IOTA = new Float256Vector(VSPECIES.iotaArray());
 
     static {
         // Warm up a few species caches.
         // If we do this too much we will
         // get NPEs from bootstrap circularity.
-        VSPECIES.dummyVector();
+        // VSPECIES.dummyVector();
+        VSPECIES.dummyVectorMF();
         VSPECIES.withLanes(LaneType.BYTE);
     }
 
@@ -171,6 +187,13 @@ final class Float256Vector extends FloatVector {
         return new Float256Vector(vec);
     }
 
+    // Make a vector of the same species but the given elements:
+    @ForceInline
+    final @Override
+    Float256Vector vectorFactory(VectorSupport.VectorPayloadMF vec) {
+        return new Float256Vector(vec);
+    }
+
     @ForceInline
     final @Override
     Byte256Vector asByteVectorRaw() {
@@ -206,6 +229,12 @@ final class Float256Vector extends FloatVector {
         return (Float256Vector) super.bOpTemplate((Float256Vector)v, f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Float256Vector bOpMF(Vector<Float> v, FBinOp f) {
+        return (Float256Vector) super.bOpTemplateMF((Float256Vector)v, f);  // specialize
+    }
+
     @ForceInline
     final @Override
     Float256Vector bOp(Vector<Float> v,
@@ -215,6 +244,15 @@ final class Float256Vector extends FloatVector {
                               f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Float256Vector bOpMF(Vector<Float> v,
+                     VectorMask<Float> m, FBinOp f) {
+        return (Float256Vector)
+            super.bOpTemplateMF((Float256Vector)v, (Float256Mask)m,
+                              f);  // specialize
+    }
+
     // Ternary operator
 
     @ForceInline
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float512Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float512Vector.java
index 7e0489b9e6a..7fd3932a4f2 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float512Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float512Vector.java
@@ -39,7 +39,7 @@ import static jdk.incubator.vector.VectorOperators.*;
 // -- This file was mechanically generated: Do not edit! -- //
 
 @SuppressWarnings("cast")  // warning: redundant cast
-final class Float512Vector extends FloatVector {
+value class Float512Vector extends FloatVector {
     static final FloatSpecies VSPECIES =
         (FloatSpecies) FloatVector.SPECIES_512;
 
@@ -54,24 +54,40 @@ final class Float512Vector extends FloatVector {
 
     static final Class<Float> ETYPE = float.class; // used by the JVM
 
-    Float512Vector(float[] v) {
+    /*Float512Vector(float[] v) {
         super(v);
+    }*/
+
+    private final VectorSupport.Float512VectorPayload mf_storage;
+
+    Float512Vector(Object value) {
+        this.mf_storage = (VectorSupport.Float512VectorPayload)value;
+    }
+
+    VectorSupport.VectorPayloadMF vec_mf() {
+        return mf_storage;
+    }
+
+    @Override
+    protected final Object getPayload() {
+       return vec_mf();
     }
 
     // For compatibility as Float512Vector::new,
     // stored into species.vectorFactory.
-    Float512Vector(Object v) {
+    /*Float512Vector(Object v) {
         this((float[]) v);
-    }
+    }*/
 
-    static final Float512Vector ZERO = new Float512Vector(new float[VLENGTH]);
+    static final Float512Vector ZERO = new Float512Vector(VectorSupport.VectorPayloadMF.createNewInstanceF(float.class, 16, Float.valueOf((float)0)));
     static final Float512Vector IOTA = new Float512Vector(VSPECIES.iotaArray());
 
     static {
         // Warm up a few species caches.
         // If we do this too much we will
         // get NPEs from bootstrap circularity.
-        VSPECIES.dummyVector();
+        // VSPECIES.dummyVector();
+        VSPECIES.dummyVectorMF();
         VSPECIES.withLanes(LaneType.BYTE);
     }
 
@@ -171,6 +187,13 @@ final class Float512Vector extends FloatVector {
         return new Float512Vector(vec);
     }
 
+    // Make a vector of the same species but the given elements:
+    @ForceInline
+    final @Override
+    Float512Vector vectorFactory(VectorSupport.VectorPayloadMF vec) {
+        return new Float512Vector(vec);
+    }
+
     @ForceInline
     final @Override
     Byte512Vector asByteVectorRaw() {
@@ -206,6 +229,12 @@ final class Float512Vector extends FloatVector {
         return (Float512Vector) super.bOpTemplate((Float512Vector)v, f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Float512Vector bOpMF(Vector<Float> v, FBinOp f) {
+        return (Float512Vector) super.bOpTemplateMF((Float512Vector)v, f);  // specialize
+    }
+
     @ForceInline
     final @Override
     Float512Vector bOp(Vector<Float> v,
@@ -215,6 +244,15 @@ final class Float512Vector extends FloatVector {
                               f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Float512Vector bOpMF(Vector<Float> v,
+                     VectorMask<Float> m, FBinOp f) {
+        return (Float512Vector)
+            super.bOpTemplateMF((Float512Vector)v, (Float512Mask)m,
+                              f);  // specialize
+    }
+
     // Ternary operator
 
     @ForceInline
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float64Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float64Vector.java
index c82adda2632..a7cb6d5fcb6 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float64Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Float64Vector.java
@@ -39,7 +39,7 @@ import static jdk.incubator.vector.VectorOperators.*;
 // -- This file was mechanically generated: Do not edit! -- //
 
 @SuppressWarnings("cast")  // warning: redundant cast
-final class Float64Vector extends FloatVector {
+value class Float64Vector extends FloatVector {
     static final FloatSpecies VSPECIES =
         (FloatSpecies) FloatVector.SPECIES_64;
 
@@ -54,24 +54,40 @@ final class Float64Vector extends FloatVector {
 
     static final Class<Float> ETYPE = float.class; // used by the JVM
 
-    Float64Vector(float[] v) {
+    /*Float64Vector(float[] v) {
         super(v);
+    }*/
+
+    private final VectorSupport.Float64VectorPayload mf_storage;
+
+    Float64Vector(Object value) {
+        this.mf_storage = (VectorSupport.Float64VectorPayload)value;
+    }
+
+    VectorSupport.VectorPayloadMF vec_mf() {
+        return mf_storage;
+    }
+
+    @Override
+    protected final Object getPayload() {
+       return vec_mf();
     }
 
     // For compatibility as Float64Vector::new,
     // stored into species.vectorFactory.
-    Float64Vector(Object v) {
+    /*Float64Vector(Object v) {
         this((float[]) v);
-    }
+    }*/
 
-    static final Float64Vector ZERO = new Float64Vector(new float[VLENGTH]);
+    static final Float64Vector ZERO = new Float64Vector(VectorSupport.VectorPayloadMF.createNewInstanceF(float.class, 2, Float.valueOf((float)0)));
     static final Float64Vector IOTA = new Float64Vector(VSPECIES.iotaArray());
 
     static {
         // Warm up a few species caches.
         // If we do this too much we will
         // get NPEs from bootstrap circularity.
-        VSPECIES.dummyVector();
+        // VSPECIES.dummyVector();
+        VSPECIES.dummyVectorMF();
         VSPECIES.withLanes(LaneType.BYTE);
     }
 
@@ -171,6 +187,13 @@ final class Float64Vector extends FloatVector {
         return new Float64Vector(vec);
     }
 
+    // Make a vector of the same species but the given elements:
+    @ForceInline
+    final @Override
+    Float64Vector vectorFactory(VectorSupport.VectorPayloadMF vec) {
+        return new Float64Vector(vec);
+    }
+
     @ForceInline
     final @Override
     Byte64Vector asByteVectorRaw() {
@@ -206,6 +229,12 @@ final class Float64Vector extends FloatVector {
         return (Float64Vector) super.bOpTemplate((Float64Vector)v, f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Float64Vector bOpMF(Vector<Float> v, FBinOp f) {
+        return (Float64Vector) super.bOpTemplateMF((Float64Vector)v, f);  // specialize
+    }
+
     @ForceInline
     final @Override
     Float64Vector bOp(Vector<Float> v,
@@ -215,6 +244,15 @@ final class Float64Vector extends FloatVector {
                               f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Float64Vector bOpMF(Vector<Float> v,
+                     VectorMask<Float> m, FBinOp f) {
+        return (Float64Vector)
+            super.bOpTemplateMF((Float64Vector)v, (Float64Mask)m,
+                              f);  // specialize
+    }
+
     // Ternary operator
 
     @ForceInline
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/FloatMaxVector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/FloatMaxVector.java
deleted file mode 100644
index 4d2c1c17876..00000000000
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/FloatMaxVector.java
+++ /dev/null
@@ -1,901 +0,0 @@
-/*
- * Copyright (c) 2017, 2022, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package jdk.incubator.vector;
-
-import java.lang.foreign.MemorySegment;
-import java.util.Arrays;
-import java.util.Objects;
-import java.util.function.IntUnaryOperator;
-
-import jdk.internal.vm.annotation.ForceInline;
-import jdk.internal.vm.vector.VectorSupport;
-
-import static jdk.internal.vm.vector.VectorSupport.*;
-
-import static jdk.incubator.vector.VectorOperators.*;
-
-// -- This file was mechanically generated: Do not edit! -- //
-
-@SuppressWarnings("cast")  // warning: redundant cast
-final class FloatMaxVector extends FloatVector {
-    static final FloatSpecies VSPECIES =
-        (FloatSpecies) FloatVector.SPECIES_MAX;
-
-    static final VectorShape VSHAPE =
-        VSPECIES.vectorShape();
-
-    static final Class<FloatMaxVector> VCLASS = FloatMaxVector.class;
-
-    static final int VSIZE = VSPECIES.vectorBitSize();
-
-    static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
-
-    static final Class<Float> ETYPE = float.class; // used by the JVM
-
-    FloatMaxVector(float[] v) {
-        super(v);
-    }
-
-    // For compatibility as FloatMaxVector::new,
-    // stored into species.vectorFactory.
-    FloatMaxVector(Object v) {
-        this((float[]) v);
-    }
-
-    static final FloatMaxVector ZERO = new FloatMaxVector(new float[VLENGTH]);
-    static final FloatMaxVector IOTA = new FloatMaxVector(VSPECIES.iotaArray());
-
-    static {
-        // Warm up a few species caches.
-        // If we do this too much we will
-        // get NPEs from bootstrap circularity.
-        VSPECIES.dummyVector();
-        VSPECIES.withLanes(LaneType.BYTE);
-    }
-
-    // Specialized extractors
-
-    @ForceInline
-    final @Override
-    public FloatSpecies vspecies() {
-        // ISSUE:  This should probably be a @Stable
-        // field inside AbstractVector, rather than
-        // a megamorphic method.
-        return VSPECIES;
-    }
-
-    @ForceInline
-    @Override
-    public final Class<Float> elementType() { return float.class; }
-
-    @ForceInline
-    @Override
-    public final int elementSize() { return Float.SIZE; }
-
-    @ForceInline
-    @Override
-    public final VectorShape shape() { return VSHAPE; }
-
-    @ForceInline
-    @Override
-    public final int length() { return VLENGTH; }
-
-    @ForceInline
-    @Override
-    public final int bitSize() { return VSIZE; }
-
-    @ForceInline
-    @Override
-    public final int byteSize() { return VSIZE / Byte.SIZE; }
-
-    /*package-private*/
-    @ForceInline
-    final @Override
-    float[] vec() {
-        return (float[])getPayload();
-    }
-
-    // Virtualized constructors
-
-    @Override
-    @ForceInline
-    public final FloatMaxVector broadcast(float e) {
-        return (FloatMaxVector) super.broadcastTemplate(e);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final FloatMaxVector broadcast(long e) {
-        return (FloatMaxVector) super.broadcastTemplate(e);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    FloatMaxMask maskFromArray(boolean[] bits) {
-        return new FloatMaxMask(bits);
-    }
-
-    @Override
-    @ForceInline
-    FloatMaxShuffle iotaShuffle() { return FloatMaxShuffle.IOTA; }
-
-    @ForceInline
-    FloatMaxShuffle iotaShuffle(int start, int step, boolean wrap) {
-      if (wrap) {
-        return (FloatMaxShuffle)VectorSupport.shuffleIota(ETYPE, FloatMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,
-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));
-      } else {
-        return (FloatMaxShuffle)VectorSupport.shuffleIota(ETYPE, FloatMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,
-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));
-      }
-    }
-
-    @Override
-    @ForceInline
-    FloatMaxShuffle shuffleFromBytes(byte[] reorder) { return new FloatMaxShuffle(reorder); }
-
-    @Override
-    @ForceInline
-    FloatMaxShuffle shuffleFromArray(int[] indexes, int i) { return new FloatMaxShuffle(indexes, i); }
-
-    @Override
-    @ForceInline
-    FloatMaxShuffle shuffleFromOp(IntUnaryOperator fn) { return new FloatMaxShuffle(fn); }
-
-    // Make a vector of the same species but the given elements:
-    @ForceInline
-    final @Override
-    FloatMaxVector vectorFactory(float[] vec) {
-        return new FloatMaxVector(vec);
-    }
-
-    @ForceInline
-    final @Override
-    ByteMaxVector asByteVectorRaw() {
-        return (ByteMaxVector) super.asByteVectorRawTemplate();  // specialize
-    }
-
-    @ForceInline
-    final @Override
-    AbstractVector<?> asVectorRaw(LaneType laneType) {
-        return super.asVectorRawTemplate(laneType);  // specialize
-    }
-
-    // Unary operator
-
-    @ForceInline
-    final @Override
-    FloatMaxVector uOp(FUnOp f) {
-        return (FloatMaxVector) super.uOpTemplate(f);  // specialize
-    }
-
-    @ForceInline
-    final @Override
-    FloatMaxVector uOp(VectorMask<Float> m, FUnOp f) {
-        return (FloatMaxVector)
-            super.uOpTemplate((FloatMaxMask)m, f);  // specialize
-    }
-
-    // Binary operator
-
-    @ForceInline
-    final @Override
-    FloatMaxVector bOp(Vector<Float> v, FBinOp f) {
-        return (FloatMaxVector) super.bOpTemplate((FloatMaxVector)v, f);  // specialize
-    }
-
-    @ForceInline
-    final @Override
-    FloatMaxVector bOp(Vector<Float> v,
-                     VectorMask<Float> m, FBinOp f) {
-        return (FloatMaxVector)
-            super.bOpTemplate((FloatMaxVector)v, (FloatMaxMask)m,
-                              f);  // specialize
-    }
-
-    // Ternary operator
-
-    @ForceInline
-    final @Override
-    FloatMaxVector tOp(Vector<Float> v1, Vector<Float> v2, FTriOp f) {
-        return (FloatMaxVector)
-            super.tOpTemplate((FloatMaxVector)v1, (FloatMaxVector)v2,
-                              f);  // specialize
-    }
-
-    @ForceInline
-    final @Override
-    FloatMaxVector tOp(Vector<Float> v1, Vector<Float> v2,
-                     VectorMask<Float> m, FTriOp f) {
-        return (FloatMaxVector)
-            super.tOpTemplate((FloatMaxVector)v1, (FloatMaxVector)v2,
-                              (FloatMaxMask)m, f);  // specialize
-    }
-
-    @ForceInline
-    final @Override
-    float rOp(float v, VectorMask<Float> m, FBinOp f) {
-        return super.rOpTemplate(v, m, f);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final <F>
-    Vector<F> convertShape(VectorOperators.Conversion<Float,F> conv,
-                           VectorSpecies<F> rsp, int part) {
-        return super.convertShapeTemplate(conv, rsp, part);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final <F>
-    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {
-        return super.reinterpretShapeTemplate(toSpecies, part);  // specialize
-    }
-
-    // Specialized algebraic operations:
-
-    // The following definition forces a specialized version of this
-    // crucial method into the v-table of this class.  A call to add()
-    // will inline to a call to lanewise(ADD,), at which point the JIT
-    // intrinsic will have the opcode of ADD, plus all the metadata
-    // for this particular class, enabling it to generate precise
-    // code.
-    //
-    // There is probably no benefit to the JIT to specialize the
-    // masked or broadcast versions of the lanewise method.
-
-    @Override
-    @ForceInline
-    public FloatMaxVector lanewise(Unary op) {
-        return (FloatMaxVector) super.lanewiseTemplate(op);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public FloatMaxVector lanewise(Unary op, VectorMask<Float> m) {
-        return (FloatMaxVector) super.lanewiseTemplate(op, FloatMaxMask.class, (FloatMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public FloatMaxVector lanewise(Binary op, Vector<Float> v) {
-        return (FloatMaxVector) super.lanewiseTemplate(op, v);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public FloatMaxVector lanewise(Binary op, Vector<Float> v, VectorMask<Float> m) {
-        return (FloatMaxVector) super.lanewiseTemplate(op, FloatMaxMask.class, v, (FloatMaxMask) m);  // specialize
-    }
-
-
-    /*package-private*/
-    @Override
-    @ForceInline
-    public final
-    FloatMaxVector
-    lanewise(Ternary op, Vector<Float> v1, Vector<Float> v2) {
-        return (FloatMaxVector) super.lanewiseTemplate(op, v1, v2);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final
-    FloatMaxVector
-    lanewise(Ternary op, Vector<Float> v1, Vector<Float> v2, VectorMask<Float> m) {
-        return (FloatMaxVector) super.lanewiseTemplate(op, FloatMaxMask.class, v1, v2, (FloatMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final
-    FloatMaxVector addIndex(int scale) {
-        return (FloatMaxVector) super.addIndexTemplate(scale);  // specialize
-    }
-
-    // Type specific horizontal reductions
-
-    @Override
-    @ForceInline
-    public final float reduceLanes(VectorOperators.Associative op) {
-        return super.reduceLanesTemplate(op);  // specialized
-    }
-
-    @Override
-    @ForceInline
-    public final float reduceLanes(VectorOperators.Associative op,
-                                    VectorMask<Float> m) {
-        return super.reduceLanesTemplate(op, FloatMaxMask.class, (FloatMaxMask) m);  // specialized
-    }
-
-    @Override
-    @ForceInline
-    public final long reduceLanesToLong(VectorOperators.Associative op) {
-        return (long) super.reduceLanesTemplate(op);  // specialized
-    }
-
-    @Override
-    @ForceInline
-    public final long reduceLanesToLong(VectorOperators.Associative op,
-                                        VectorMask<Float> m) {
-        return (long) super.reduceLanesTemplate(op, FloatMaxMask.class, (FloatMaxMask) m);  // specialized
-    }
-
-    @ForceInline
-    public VectorShuffle<Float> toShuffle() {
-        return super.toShuffleTemplate(FloatMaxShuffle.class); // specialize
-    }
-
-    // Specialized unary testing
-
-    @Override
-    @ForceInline
-    public final FloatMaxMask test(Test op) {
-        return super.testTemplate(FloatMaxMask.class, op);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final FloatMaxMask test(Test op, VectorMask<Float> m) {
-        return super.testTemplate(FloatMaxMask.class, op, (FloatMaxMask) m);  // specialize
-    }
-
-    // Specialized comparisons
-
-    @Override
-    @ForceInline
-    public final FloatMaxMask compare(Comparison op, Vector<Float> v) {
-        return super.compareTemplate(FloatMaxMask.class, op, v);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final FloatMaxMask compare(Comparison op, float s) {
-        return super.compareTemplate(FloatMaxMask.class, op, s);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final FloatMaxMask compare(Comparison op, long s) {
-        return super.compareTemplate(FloatMaxMask.class, op, s);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final FloatMaxMask compare(Comparison op, Vector<Float> v, VectorMask<Float> m) {
-        return super.compareTemplate(FloatMaxMask.class, op, v, (FloatMaxMask) m);
-    }
-
-
-    @Override
-    @ForceInline
-    public FloatMaxVector blend(Vector<Float> v, VectorMask<Float> m) {
-        return (FloatMaxVector)
-            super.blendTemplate(FloatMaxMask.class,
-                                (FloatMaxVector) v,
-                                (FloatMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public FloatMaxVector slice(int origin, Vector<Float> v) {
-        return (FloatMaxVector) super.sliceTemplate(origin, v);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public FloatMaxVector slice(int origin) {
-        return (FloatMaxVector) super.sliceTemplate(origin);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public FloatMaxVector unslice(int origin, Vector<Float> w, int part) {
-        return (FloatMaxVector) super.unsliceTemplate(origin, w, part);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public FloatMaxVector unslice(int origin, Vector<Float> w, int part, VectorMask<Float> m) {
-        return (FloatMaxVector)
-            super.unsliceTemplate(FloatMaxMask.class,
-                                  origin, w, part,
-                                  (FloatMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public FloatMaxVector unslice(int origin) {
-        return (FloatMaxVector) super.unsliceTemplate(origin);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public FloatMaxVector rearrange(VectorShuffle<Float> s) {
-        return (FloatMaxVector)
-            super.rearrangeTemplate(FloatMaxShuffle.class,
-                                    (FloatMaxShuffle) s);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public FloatMaxVector rearrange(VectorShuffle<Float> shuffle,
-                                  VectorMask<Float> m) {
-        return (FloatMaxVector)
-            super.rearrangeTemplate(FloatMaxShuffle.class,
-                                    FloatMaxMask.class,
-                                    (FloatMaxShuffle) shuffle,
-                                    (FloatMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public FloatMaxVector rearrange(VectorShuffle<Float> s,
-                                  Vector<Float> v) {
-        return (FloatMaxVector)
-            super.rearrangeTemplate(FloatMaxShuffle.class,
-                                    (FloatMaxShuffle) s,
-                                    (FloatMaxVector) v);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public FloatMaxVector compress(VectorMask<Float> m) {
-        return (FloatMaxVector)
-            super.compressTemplate(FloatMaxMask.class,
-                                   (FloatMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public FloatMaxVector expand(VectorMask<Float> m) {
-        return (FloatMaxVector)
-            super.expandTemplate(FloatMaxMask.class,
-                                   (FloatMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public FloatMaxVector selectFrom(Vector<Float> v) {
-        return (FloatMaxVector)
-            super.selectFromTemplate((FloatMaxVector) v);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public FloatMaxVector selectFrom(Vector<Float> v,
-                                   VectorMask<Float> m) {
-        return (FloatMaxVector)
-            super.selectFromTemplate((FloatMaxVector) v,
-                                     (FloatMaxMask) m);  // specialize
-    }
-
-
-    @ForceInline
-    @Override
-    public float lane(int i) {
-        if (i < 0 || i >= VLENGTH) {
-            throw new IllegalArgumentException("Index " + i + " must be zero or positive, and less than " + VLENGTH);
-        }
-        int bits = laneHelper(i);
-        return Float.intBitsToFloat(bits);
-    }
-
-    public int laneHelper(int i) {
-        return (int) VectorSupport.extract(
-                     VCLASS, ETYPE, VLENGTH,
-                     this, i,
-                     (vec, ix) -> {
-                     float[] vecarr = vec.vec();
-                     return (long)Float.floatToIntBits(vecarr[ix]);
-                     });
-    }
-
-    @ForceInline
-    @Override
-    public FloatMaxVector withLane(int i, float e) {
-        if (i < 0 || i >= VLENGTH) {
-            throw new IllegalArgumentException("Index " + i + " must be zero or positive, and less than " + VLENGTH);
-        }
-        return withLaneHelper(i, e);
-    }
-
-    public FloatMaxVector withLaneHelper(int i, float e) {
-        return VectorSupport.insert(
-                                VCLASS, ETYPE, VLENGTH,
-                                this, i, (long)Float.floatToIntBits(e),
-                                (v, ix, bits) -> {
-                                    float[] res = v.vec().clone();
-                                    res[ix] = Float.intBitsToFloat((int)bits);
-                                    return v.vectorFactory(res);
-                                });
-    }
-
-    // Mask
-
-    static final class FloatMaxMask extends AbstractMask<Float> {
-        static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
-        static final Class<Float> ETYPE = float.class; // used by the JVM
-
-        FloatMaxMask(boolean[] bits) {
-            this(bits, 0);
-        }
-
-        FloatMaxMask(boolean[] bits, int offset) {
-            super(prepare(bits, offset));
-        }
-
-        FloatMaxMask(boolean val) {
-            super(prepare(val));
-        }
-
-        private static boolean[] prepare(boolean[] bits, int offset) {
-            boolean[] newBits = new boolean[VSPECIES.laneCount()];
-            for (int i = 0; i < newBits.length; i++) {
-                newBits[i] = bits[offset + i];
-            }
-            return newBits;
-        }
-
-        private static boolean[] prepare(boolean val) {
-            boolean[] bits = new boolean[VSPECIES.laneCount()];
-            Arrays.fill(bits, val);
-            return bits;
-        }
-
-        @ForceInline
-        final @Override
-        public FloatSpecies vspecies() {
-            // ISSUE:  This should probably be a @Stable
-            // field inside AbstractMask, rather than
-            // a megamorphic method.
-            return VSPECIES;
-        }
-
-        @ForceInline
-        boolean[] getBits() {
-            return (boolean[])getPayload();
-        }
-
-        @Override
-        FloatMaxMask uOp(MUnOp f) {
-            boolean[] res = new boolean[vspecies().laneCount()];
-            boolean[] bits = getBits();
-            for (int i = 0; i < res.length; i++) {
-                res[i] = f.apply(i, bits[i]);
-            }
-            return new FloatMaxMask(res);
-        }
-
-        @Override
-        FloatMaxMask bOp(VectorMask<Float> m, MBinOp f) {
-            boolean[] res = new boolean[vspecies().laneCount()];
-            boolean[] bits = getBits();
-            boolean[] mbits = ((FloatMaxMask)m).getBits();
-            for (int i = 0; i < res.length; i++) {
-                res[i] = f.apply(i, bits[i], mbits[i]);
-            }
-            return new FloatMaxMask(res);
-        }
-
-        @ForceInline
-        @Override
-        public final
-        FloatMaxVector toVector() {
-            return (FloatMaxVector) super.toVectorTemplate();  // specialize
-        }
-
-        /**
-         * Helper function for lane-wise mask conversions.
-         * This function kicks in after intrinsic failure.
-         */
-        @ForceInline
-        private final <E>
-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {
-            if (length() != dsp.laneCount())
-                throw new IllegalArgumentException("VectorMask length and species length differ");
-            boolean[] maskArray = toArray();
-            return  dsp.maskFactory(maskArray).check(dsp);
-        }
-
-        @Override
-        @ForceInline
-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;
-            if (length() != species.laneCount())
-                throw new IllegalArgumentException("VectorMask length and species length differ");
-
-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,
-                this.getClass(), ETYPE, VLENGTH,
-                species.maskType(), species.elementType(), VLENGTH,
-                this, species,
-                (m, s) -> s.maskFactory(m.toArray()).check(s));
-        }
-
-        @Override
-        @ForceInline
-        public FloatMaxMask eq(VectorMask<Float> mask) {
-            Objects.requireNonNull(mask);
-            FloatMaxMask m = (FloatMaxMask)mask;
-            return xor(m.not());
-        }
-
-        // Unary operations
-
-        @Override
-        @ForceInline
-        public FloatMaxMask not() {
-            return xor(maskAll(true));
-        }
-
-        @Override
-        @ForceInline
-        public FloatMaxMask compress() {
-            return (FloatMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                FloatMaxVector.class, FloatMaxMask.class, ETYPE, VLENGTH, null, this,
-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
-        }
-
-
-        // Binary operations
-
-        @Override
-        @ForceInline
-        public FloatMaxMask and(VectorMask<Float> mask) {
-            Objects.requireNonNull(mask);
-            FloatMaxMask m = (FloatMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, FloatMaxMask.class, null, int.class, VLENGTH,
-                                          this, m, null,
-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
-        }
-
-        @Override
-        @ForceInline
-        public FloatMaxMask or(VectorMask<Float> mask) {
-            Objects.requireNonNull(mask);
-            FloatMaxMask m = (FloatMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, FloatMaxMask.class, null, int.class, VLENGTH,
-                                          this, m, null,
-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
-        }
-
-        @ForceInline
-        /* package-private */
-        FloatMaxMask xor(VectorMask<Float> mask) {
-            Objects.requireNonNull(mask);
-            FloatMaxMask m = (FloatMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, FloatMaxMask.class, null, int.class, VLENGTH,
-                                          this, m, null,
-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
-        }
-
-        // Mask Query operations
-
-        @Override
-        @ForceInline
-        public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, FloatMaxMask.class, int.class, VLENGTH, this,
-                                                      (m) -> trueCountHelper(m.getBits()));
-        }
-
-        @Override
-        @ForceInline
-        public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, FloatMaxMask.class, int.class, VLENGTH, this,
-                                                      (m) -> firstTrueHelper(m.getBits()));
-        }
-
-        @Override
-        @ForceInline
-        public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, FloatMaxMask.class, int.class, VLENGTH, this,
-                                                      (m) -> lastTrueHelper(m.getBits()));
-        }
-
-        @Override
-        @ForceInline
-        public long toLong() {
-            if (length() > Long.SIZE) {
-                throw new UnsupportedOperationException("too many lanes for one long");
-            }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, FloatMaxMask.class, int.class, VLENGTH, this,
-                                                      (m) -> toLongHelper(m.getBits()));
-        }
-
-        // Reductions
-
-        @Override
-        @ForceInline
-        public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, FloatMaxMask.class, int.class, VLENGTH,
-                                         this, vspecies().maskAll(true),
-                                         (m, __) -> anyTrueHelper(((FloatMaxMask)m).getBits()));
-        }
-
-        @Override
-        @ForceInline
-        public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, FloatMaxMask.class, int.class, VLENGTH,
-                                         this, vspecies().maskAll(true),
-                                         (m, __) -> allTrueHelper(((FloatMaxMask)m).getBits()));
-        }
-
-        @ForceInline
-        /*package-private*/
-        static FloatMaxMask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(FloatMaxMask.class, int.class, VLENGTH,
-                                                 (bit ? -1 : 0), MODE_BROADCAST, null,
-                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
-        }
-        private static final FloatMaxMask  TRUE_MASK = new FloatMaxMask(true);
-        private static final FloatMaxMask FALSE_MASK = new FloatMaxMask(false);
-
-    }
-
-    // Shuffle
-
-    static final class FloatMaxShuffle extends AbstractShuffle<Float> {
-        static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
-        static final Class<Float> ETYPE = float.class; // used by the JVM
-
-        FloatMaxShuffle(byte[] reorder) {
-            super(VLENGTH, reorder);
-        }
-
-        public FloatMaxShuffle(int[] reorder) {
-            super(VLENGTH, reorder);
-        }
-
-        public FloatMaxShuffle(int[] reorder, int i) {
-            super(VLENGTH, reorder, i);
-        }
-
-        public FloatMaxShuffle(IntUnaryOperator fn) {
-            super(VLENGTH, fn);
-        }
-
-        @Override
-        public FloatSpecies vspecies() {
-            return VSPECIES;
-        }
-
-        static {
-            // There must be enough bits in the shuffle lanes to encode
-            // VLENGTH valid indexes and VLENGTH exceptional ones.
-            assert(VLENGTH < Byte.MAX_VALUE);
-            assert(Byte.MIN_VALUE <= -VLENGTH);
-        }
-        static final FloatMaxShuffle IOTA = new FloatMaxShuffle(IDENTITY);
-
-        @Override
-        @ForceInline
-        public FloatMaxVector toVector() {
-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, FloatMaxShuffle.class, this, VLENGTH,
-                                                    (s) -> ((FloatMaxVector)(((AbstractShuffle<Float>)(s)).toVectorTemplate())));
-        }
-
-        @Override
-        @ForceInline
-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {
-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;
-            if (length() != species.laneCount())
-                throw new IllegalArgumentException("VectorShuffle length and species length differ");
-            int[] shuffleArray = toArray();
-            return s.shuffleFromArray(shuffleArray, 0).check(s);
-        }
-
-        @ForceInline
-        @Override
-        public FloatMaxShuffle rearrange(VectorShuffle<Float> shuffle) {
-            FloatMaxShuffle s = (FloatMaxShuffle) shuffle;
-            byte[] reorder1 = reorder();
-            byte[] reorder2 = s.reorder();
-            byte[] r = new byte[reorder1.length];
-            for (int i = 0; i < reorder1.length; i++) {
-                int ssi = reorder2[i];
-                r[i] = reorder1[ssi];  // throws on exceptional index
-            }
-            return new FloatMaxShuffle(r);
-        }
-    }
-
-    // ================================================
-
-    // Specialized low-level memory operations.
-
-    @ForceInline
-    @Override
-    final
-    FloatVector fromArray0(float[] a, int offset) {
-        return super.fromArray0Template(a, offset);  // specialize
-    }
-
-    @ForceInline
-    @Override
-    final
-    FloatVector fromArray0(float[] a, int offset, VectorMask<Float> m, int offsetInRange) {
-        return super.fromArray0Template(FloatMaxMask.class, a, offset, (FloatMaxMask) m, offsetInRange);  // specialize
-    }
-
-    @ForceInline
-    @Override
-    final
-    FloatVector fromArray0(float[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float> m) {
-        return super.fromArray0Template(FloatMaxMask.class, a, offset, indexMap, mapOffset, (FloatMaxMask) m);
-    }
-
-
-
-    @ForceInline
-    @Override
-    final
-    FloatVector fromMemorySegment0(MemorySegment ms, long offset) {
-        return super.fromMemorySegment0Template(ms, offset);  // specialize
-    }
-
-    @ForceInline
-    @Override
-    final
-    FloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float> m, int offsetInRange) {
-        return super.fromMemorySegment0Template(FloatMaxMask.class, ms, offset, (FloatMaxMask) m, offsetInRange);  // specialize
-    }
-
-    @ForceInline
-    @Override
-    final
-    void intoArray0(float[] a, int offset) {
-        super.intoArray0Template(a, offset);  // specialize
-    }
-
-    @ForceInline
-    @Override
-    final
-    void intoArray0(float[] a, int offset, VectorMask<Float> m) {
-        super.intoArray0Template(FloatMaxMask.class, a, offset, (FloatMaxMask) m);
-    }
-
-    @ForceInline
-    @Override
-    final
-    void intoArray0(float[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float> m) {
-        super.intoArray0Template(FloatMaxMask.class, a, offset, indexMap, mapOffset, (FloatMaxMask) m);
-    }
-
-
-    @ForceInline
-    @Override
-    final
-    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Float> m) {
-        super.intoMemorySegment0Template(FloatMaxMask.class, ms, offset, (FloatMaxMask) m);
-    }
-
-
-    // End of specialized low-level memory operations.
-
-    // ================================================
-
-}
-
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/FloatVector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/FloatVector.java
index 30ed43e3029..136918f0fd6 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/FloatVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/FloatVector.java
@@ -51,9 +51,9 @@ import static jdk.incubator.vector.VectorOperators.*;
 @SuppressWarnings("cast")  // warning: redundant cast
 public abstract class FloatVector extends AbstractVector<Float> {
 
-    FloatVector(float[] vec) {
+    /*FloatVector(float[] vec) {
         super(vec);
-    }
+    }*/
 
     static final int FORBID_OPCODE_KIND = VO_NOFP;
 
@@ -96,6 +96,8 @@ public abstract class FloatVector extends AbstractVector<Float> {
     /*package-private*/
     abstract float[] vec();
 
+    abstract VectorSupport.VectorPayloadMF vec_mf();
+
     // Virtualized constructors
 
     /**
@@ -105,6 +107,17 @@ public abstract class FloatVector extends AbstractVector<Float> {
     /*package-private*/
     abstract FloatVector vectorFactory(float[] vec);
 
+    abstract FloatVector vectorFactory(VectorSupport.VectorPayloadMF vec);
+
+    @ForceInline
+    public static
+    FloatVector fromArray(VectorSpecies<Float> species,
+                                   float[] a, int offset) {
+        offset = checkFromIndexSize(offset, species.length(), a.length);
+        FloatSpecies vsp = (FloatSpecies) species;
+        return vsp.dummyVectorMF().fromArray0(a, offset);
+    }
+
     /**
      * Build a mask directly using my species.
      * It is an error if the array is aliased elsewhere.
@@ -210,6 +223,30 @@ public abstract class FloatVector extends AbstractVector<Float> {
         return vectorFactory(res);
     }
 
+    /*package-private*/
+    abstract
+    FloatVector bOpMF(Vector<Float> o,
+                             FBinOp f);
+    @ForceInline
+    final
+    FloatVector bOpTemplateMF(Vector<Float> o,
+                                     FBinOp f) {
+        VectorSupport.VectorPayloadMF vec1 = this.vec_mf();
+        VectorSupport.VectorPayloadMF vec2 = this.vec_mf();
+        VectorSupport.VectorPayloadMF tpayload = 
+            Unsafe.getUnsafe().makePrivateBuffer(VectorSupport.VectorPayloadMF.createNewInstanceF(
+                   float.class, length(), Float.valueOf((float)0)));
+        long start_offset = tpayload.multiFieldOffset();
+        int length = tpayload.length();
+        for (int i = 0; i < length; i++) {
+            float v1 = Unsafe.getUnsafe().getFloat(vec1, start_offset + i * Integer.BYTES);
+            float v2 = Unsafe.getUnsafe().getFloat(vec2, start_offset + i * Integer.BYTES);
+            Unsafe.getUnsafe().putFloat(tpayload, start_offset + i * Integer.BYTES, f.apply(i, v1, v2));
+        }
+        Unsafe.getUnsafe().finishPrivateBuffer(tpayload);
+        return vectorFactory(tpayload);
+    }
+
     /*package-private*/
     abstract
     FloatVector bOp(Vector<Float> o,
@@ -233,6 +270,36 @@ public abstract class FloatVector extends AbstractVector<Float> {
         return vectorFactory(res);
     }
 
+    /*package-private*/
+    abstract
+    FloatVector bOpMF(Vector<Float> o,
+                             VectorMask<Float> m,
+                             FBinOp f);
+    @ForceInline
+    final
+    FloatVector bOpTemplateMF(Vector<Float> o,
+                                     VectorMask<Float> m,
+                                     FBinOp f) {
+        if (m == null) {
+            return bOpTemplateMF(o, f);
+        }
+        boolean[] mbits = ((AbstractMask<Float>)m).getBits();
+        VectorSupport.VectorPayloadMF vec1 = this.vec_mf();
+        VectorSupport.VectorPayloadMF vec2 = this.vec_mf();
+        VectorSupport.VectorPayloadMF tpayload =
+            Unsafe.getUnsafe().makePrivateBuffer(VectorSupport.VectorPayloadMF.createNewInstanceF(
+                float.class, length(), Float.valueOf((float)0)));
+        long start_offset = tpayload.multiFieldOffset();
+        int length = tpayload.length();
+        for (int i = 0; i < length; i++) {
+            float v1 = Unsafe.getUnsafe().getFloat(vec1, start_offset + i * Integer.BYTES);
+            float v2 = Unsafe.getUnsafe().getFloat(vec2, start_offset + i * Integer.BYTES);
+            Unsafe.getUnsafe().putFloat(tpayload, start_offset + i * Integer.BYTES, mbits[i] ? f.apply(i, v1, v2): v1);
+        }
+        Unsafe.getUnsafe().finishPrivateBuffer(tpayload);
+        return vectorFactory(tpayload);
+    }
+
     // Ternary operator
 
     /*package-private*/
@@ -353,6 +420,45 @@ public abstract class FloatVector extends AbstractVector<Float> {
         return vectorFactory(res);
     }
 
+    /*package-private*/
+    @ForceInline
+    final
+    <M> FloatVector ldOpMF(M memory, int offset,
+                                  FLdOp<M> f) {
+        VectorSupport.VectorPayloadMF tpayload =
+            Unsafe.getUnsafe().makePrivateBuffer(VectorSupport.VectorPayloadMF.createNewInstanceF(
+                float.class, length(), Float.valueOf((float)0)));
+        int length = tpayload.length();
+        long start_offset = tpayload.multiFieldOffset();
+        for (int i = 0; i < length; i++) {
+            Unsafe.getUnsafe().putFloat(tpayload, start_offset + i * Integer.BYTES, f.apply(memory, offset, i));
+        }
+        Unsafe.getUnsafe().finishPrivateBuffer(tpayload);
+        return vectorFactory(tpayload);
+    }
+
+    /*package-private*/
+    @ForceInline
+    final
+    <M> FloatVector ldOpMF(M memory, int offset,
+                                  VectorMask<Float> m,
+                                  FLdOp<M> f) {
+        VectorSupport.VectorPayloadMF tpayload =
+            Unsafe.getUnsafe().makePrivateBuffer(VectorSupport.VectorPayloadMF.createNewInstanceF(
+                float.class, length(), Float.valueOf((float)0)));
+        int length = tpayload.length();
+        long start_offset = tpayload.multiFieldOffset();
+        boolean[] mbits = ((AbstractMask<Float>)m).getBits();
+        for (int i = 0; i < length; i++) {
+            if (mbits[i]) {
+                Unsafe.getUnsafe().putFloat(tpayload, start_offset + i * Integer.BYTES, f.apply(memory, offset, i));
+            }
+        }
+        Unsafe.getUnsafe().finishPrivateBuffer(tpayload);
+        return vectorFactory(tpayload);
+    }
+
+
     /*package-private*/
     interface FLdLongOp {
         float apply(MemorySegment memory, long offset, int i);
@@ -422,6 +528,37 @@ public abstract class FloatVector extends AbstractVector<Float> {
         }
     }
 
+    /*package-private*/
+    @ForceInline
+    final
+    <M> void stOpMF(M memory, int offset,
+                  FStOp<M> f) {
+        VectorSupport.VectorPayloadMF vec = vec_mf();
+        long start_offset = vec.multiFieldOffset();
+        int length = vec.length();
+        for (int i = 0; i < length; i++) {
+            f.apply(memory, offset, i, Unsafe.getUnsafe().getFloat(vec, start_offset + i * Integer.BYTES));
+        }
+    }
+
+    /*package-private*/
+   @ForceInline
+    final
+    <M> void stOpMF(M memory, int offset,
+                  VectorMask<Float> m,
+                  FStOp<M> f) {
+        VectorSupport.VectorPayloadMF vec = vec_mf();
+        boolean[] mbits = ((AbstractMask<Float>)m).getBits();
+        long start_offset = vec.multiFieldOffset();
+        int length = vec.length();
+        for (int i = 0; i < length; i++) {
+            if (mbits[i]) {
+                f.apply(memory, offset, i, Unsafe.getUnsafe().getFloat(vec, start_offset + i * Integer.BYTES));
+            }
+        }
+    }
+
+
     interface FStLongOp {
         void apply(MemorySegment memory, long offset, int i, float a);
     }
@@ -770,11 +907,18 @@ public abstract class FloatVector extends AbstractVector<Float> {
             }
         }
 
+        /*
         int opc = opCode(op);
         return VectorSupport.binaryOp(
             opc, getClass(), null, float.class, length(),
             this, that, null,
             BIN_IMPL.find(op, opc, FloatVector::binaryOperations));
+        */
+        int opc = opCode(op);
+        return VectorSupport.binaryOp(
+            opc, getClass(), null, float.class, length(),
+            this, that, null,
+            BIN_IMPL.find(op, opc, FloatVector::binaryOperationsMF));
     }
 
     /**
@@ -841,6 +985,25 @@ public abstract class FloatVector extends AbstractVector<Float> {
         }
     }
 
+    private static BinaryOperation<FloatVector, VectorMask<Float>> binaryOperationsMF(int opc_) {
+        switch (opc_) {
+            case VECTOR_OP_ADD: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (float)(a + b));
+            case VECTOR_OP_SUB: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (float)(a - b));
+            case VECTOR_OP_MUL: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (float)(a * b));
+            case VECTOR_OP_DIV: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (float)(a / b));
+            case VECTOR_OP_MAX: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (float)Math.max(a, b));
+            case VECTOR_OP_MIN: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (float)Math.min(a, b));
+            default: return null;
+        }
+    }
+
+
     // FIXME: Maybe all of the public final methods in this file (the
     // simple ones that just call lanewise) should be pushed down to
     // the X-VectorBits template.  They can't optimize properly at
@@ -2790,6 +2953,7 @@ public abstract class FloatVector extends AbstractVector<Float> {
      *         if {@code offset+N < 0} or {@code offset+N >= a.length}
      *         for any lane {@code N} in the vector
      */
+    /*
     @ForceInline
     public static
     FloatVector fromArray(VectorSpecies<Float> species,
@@ -2797,7 +2961,7 @@ public abstract class FloatVector extends AbstractVector<Float> {
         offset = checkFromIndexSize(offset, species.length(), a.length);
         FloatSpecies vsp = (FloatSpecies) species;
         return vsp.dummyVector().fromArray0(a, offset);
-    }
+    }*/
 
     /**
      * Loads a vector from an array of type {@code float[]}
@@ -3069,6 +3233,7 @@ public abstract class FloatVector extends AbstractVector<Float> {
     void intoArray(float[] a, int offset) {
         offset = checkFromIndexSize(offset, length(), a.length);
         FloatSpecies vsp = vspecies();
+        /*
         VectorSupport.store(
             vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
             a, arrayAddress(a, offset),
@@ -3077,6 +3242,16 @@ public abstract class FloatVector extends AbstractVector<Float> {
             (arr, off, v)
             -> v.stOp(arr, (int) off,
                       (arr_, off_, i, e) -> arr_[off_ + i] = e));
+         */
+        VectorSupport.store(
+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
+            a, arrayAddress(a, offset),
+            this,
+            a, offset,
+            (arr, off, v)
+            -> v.stOpMF(arr, (int) off,
+                      (arr_, off_, i, e) -> arr_[off_ + i] = e));
+
     }
 
     /**
@@ -3281,6 +3456,7 @@ public abstract class FloatVector extends AbstractVector<Float> {
     FloatVector fromArray0(float[] a, int offset);
     @ForceInline
     final
+    /*
     FloatVector fromArray0Template(float[] a, int offset) {
         FloatSpecies vsp = vspecies();
         return VectorSupport.load(
@@ -3289,6 +3465,16 @@ public abstract class FloatVector extends AbstractVector<Float> {
             a, offset, vsp,
             (arr, off, s) -> s.ldOp(arr, (int) off,
                                     (arr_, off_, i) -> arr_[off_ + i]));
+    }*/
+
+    FloatVector fromArray0Template(float[] a, int offset) {
+        FloatSpecies vsp = vspecies();
+        return VectorSupport.load(
+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
+            a, arrayAddress(a, offset),
+            a, offset, vsp,
+            (arr, off, s) -> s.ldOpMF(arr, (int) off,
+                                    (arr_, off_, i) -> arr_[off_ + i]));
     }
 
     /*package-private*/
@@ -3762,6 +3948,12 @@ public abstract class FloatVector extends AbstractVector<Float> {
             return (FloatVector) super.dummyVector();
         }
 
+        @ForceInline
+        @Override final
+        FloatVector dummyVectorMF() {
+            return (FloatVector) super.dummyVectorMF();
+        }
+
         /*package-private*/
         final @Override
         @ForceInline
@@ -3808,6 +4000,22 @@ public abstract class FloatVector extends AbstractVector<Float> {
             return dummyVector().ldOp(memory, offset, m, f);
         }
 
+        /*package-private*/
+        @ForceInline
+        <M> FloatVector ldOpMF(M memory, int offset,
+                                      FLdOp<M> f) {
+            return dummyVectorMF().ldOpMF(memory, offset, f);
+        }
+
+        /*package-private*/
+        @ForceInline
+        <M> FloatVector ldOpMF(M memory, int offset,
+                                      VectorMask<Float> m,
+                                      FLdOp<M> f) {
+            return dummyVectorMF().ldOpMF(memory, offset, m, f);
+        }
+
+
         /*package-private*/
         @ForceInline
         FloatVector ldLongOp(MemorySegment memory, long offset,
@@ -3837,6 +4045,21 @@ public abstract class FloatVector extends AbstractVector<Float> {
             dummyVector().stOp(memory, offset, m, f);
         }
 
+        /*package-private*/
+        @ForceInline
+        <M> void stOpMF(M memory, int offset, FStOp<M> f) {
+            dummyVectorMF().stOpMF(memory, offset, f);
+        }
+
+        /*package-private*/
+        @ForceInline
+        <M> void stOpMF(M memory, int offset,
+                     AbstractMask<Float> m,
+                      FStOp<M> f) {
+            dummyVectorMF().stOpMF(memory, offset, m, f);
+        }
+
+
         /*package-private*/
         @ForceInline
         void stLongOp(MemorySegment memory, long offset, FStLongOp f) {
@@ -3862,8 +4085,8 @@ public abstract class FloatVector extends AbstractVector<Float> {
         @Override
         @ForceInline
         public final FloatVector zero() {
-            if ((Class<?>) vectorType() == FloatMaxVector.class)
-                return FloatMaxVector.ZERO;
+            //if ((Class<?>) vectorType() == FloatMaxVector.class)
+            //    return FloatMaxVector.ZERO;
             switch (vectorBitSize()) {
                 case 64: return Float64Vector.ZERO;
                 case 128: return Float128Vector.ZERO;
@@ -3876,8 +4099,8 @@ public abstract class FloatVector extends AbstractVector<Float> {
         @Override
         @ForceInline
         public final FloatVector iota() {
-            if ((Class<?>) vectorType() == FloatMaxVector.class)
-                return FloatMaxVector.IOTA;
+            //if ((Class<?>) vectorType() == FloatMaxVector.class)
+            //    return FloatMaxVector.IOTA;
             switch (vectorBitSize()) {
                 case 64: return Float64Vector.IOTA;
                 case 128: return Float128Vector.IOTA;
@@ -3891,8 +4114,8 @@ public abstract class FloatVector extends AbstractVector<Float> {
         @Override
         @ForceInline
         public final VectorMask<Float> maskAll(boolean bit) {
-            if ((Class<?>) vectorType() == FloatMaxVector.class)
-                return FloatMaxVector.FloatMaxMask.maskAll(bit);
+            //if ((Class<?>) vectorType() == FloatMaxVector.class)
+            //    return FloatMaxVector.FloatMaxMask.maskAll(bit);
             switch (vectorBitSize()) {
                 case 64: return Float64Vector.Float64Mask.maskAll(bit);
                 case 128: return Float128Vector.Float128Mask.maskAll(bit);
@@ -3901,6 +4124,16 @@ public abstract class FloatVector extends AbstractVector<Float> {
             }
             throw new AssertionError();
         }
+
+        @Override
+        Object iotaArray() {
+            int laneCount = laneCount();
+            float [] init = new float[laneCount];
+            for (int i = 0; i < laneCount; i++) {
+                init[i] = (float)i;
+            }
+           return VectorSupport.VectorPayloadMF.createNewInstanceF(elementType(), laneCount, init);
+        }
     }
 
     /**
@@ -3917,7 +4150,7 @@ public abstract class FloatVector extends AbstractVector<Float> {
             case VectorShape.SK_128_BIT: return (FloatSpecies) SPECIES_128;
             case VectorShape.SK_256_BIT: return (FloatSpecies) SPECIES_256;
             case VectorShape.SK_512_BIT: return (FloatSpecies) SPECIES_512;
-            case VectorShape.SK_Max_BIT: return (FloatSpecies) SPECIES_MAX;
+            //case VectorShape.SK_Max_BIT: return (FloatSpecies) SPECIES_MAX;
             default: throw new IllegalArgumentException("Bad shape: " + s);
         }
     }
@@ -3951,11 +4184,12 @@ public abstract class FloatVector extends AbstractVector<Float> {
                             Float512Vector::new);
 
     /** Species representing {@link FloatVector}s of {@link VectorShape#S_Max_BIT VectorShape.S_Max_BIT}. */
-    public static final VectorSpecies<Float> SPECIES_MAX
+    /*public static final VectorSpecies<Float> SPECIES_MAX
         = new FloatSpecies(VectorShape.S_Max_BIT,
                             FloatMaxVector.class,
                             FloatMaxVector.FloatMaxMask.class,
                             FloatMaxVector::new);
+     */
 
     /**
      * Preferred species for {@link FloatVector}s.
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int128Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int128Vector.java
index b51bd2e25c5..ecc449f4037 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int128Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int128Vector.java
@@ -39,7 +39,7 @@ import static jdk.incubator.vector.VectorOperators.*;
 // -- This file was mechanically generated: Do not edit! -- //
 
 @SuppressWarnings("cast")  // warning: redundant cast
-final class Int128Vector extends IntVector {
+value class Int128Vector extends IntVector {
     static final IntSpecies VSPECIES =
         (IntSpecies) IntVector.SPECIES_128;
 
@@ -54,24 +54,40 @@ final class Int128Vector extends IntVector {
 
     static final Class<Integer> ETYPE = int.class; // used by the JVM
 
-    Int128Vector(int[] v) {
+    /*Int128Vector(int[] v) {
         super(v);
+    }*/
+
+    private final VectorSupport.Int128VectorPayload mf_storage;
+
+    Int128Vector(Object value) {
+        this.mf_storage = (VectorSupport.Int128VectorPayload)value;
+    }
+
+    VectorSupport.VectorPayloadMF vec_mf() {
+        return mf_storage;
+    }
+
+    @Override
+    protected final Object getPayload() {
+       return vec_mf();
     }
 
     // For compatibility as Int128Vector::new,
     // stored into species.vectorFactory.
-    Int128Vector(Object v) {
+    /*Int128Vector(Object v) {
         this((int[]) v);
-    }
+    }*/
 
-    static final Int128Vector ZERO = new Int128Vector(new int[VLENGTH]);
+    static final Int128Vector ZERO = new Int128Vector(VectorSupport.VectorPayloadMF.createNewInstanceI(int.class, 4, Integer.valueOf((int)0)));
     static final Int128Vector IOTA = new Int128Vector(VSPECIES.iotaArray());
 
     static {
         // Warm up a few species caches.
         // If we do this too much we will
         // get NPEs from bootstrap circularity.
-        VSPECIES.dummyVector();
+        // VSPECIES.dummyVector();
+        VSPECIES.dummyVectorMF();
         VSPECIES.withLanes(LaneType.BYTE);
     }
 
@@ -171,6 +187,13 @@ final class Int128Vector extends IntVector {
         return new Int128Vector(vec);
     }
 
+    // Make a vector of the same species but the given elements:
+    @ForceInline
+    final @Override
+    Int128Vector vectorFactory(VectorSupport.VectorPayloadMF vec) {
+        return new Int128Vector(vec);
+    }
+
     @ForceInline
     final @Override
     Byte128Vector asByteVectorRaw() {
@@ -206,6 +229,12 @@ final class Int128Vector extends IntVector {
         return (Int128Vector) super.bOpTemplate((Int128Vector)v, f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Int128Vector bOpMF(Vector<Integer> v, FBinOp f) {
+        return (Int128Vector) super.bOpTemplateMF((Int128Vector)v, f);  // specialize
+    }
+
     @ForceInline
     final @Override
     Int128Vector bOp(Vector<Integer> v,
@@ -215,6 +244,15 @@ final class Int128Vector extends IntVector {
                               f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Int128Vector bOpMF(Vector<Integer> v,
+                     VectorMask<Integer> m, FBinOp f) {
+        return (Int128Vector)
+            super.bOpTemplateMF((Int128Vector)v, (Int128Mask)m,
+                              f);  // specialize
+    }
+
     // Ternary operator
 
     @ForceInline
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int256Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int256Vector.java
index fe1471d8d32..9ff6674fff5 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int256Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int256Vector.java
@@ -39,7 +39,7 @@ import static jdk.incubator.vector.VectorOperators.*;
 // -- This file was mechanically generated: Do not edit! -- //
 
 @SuppressWarnings("cast")  // warning: redundant cast
-final class Int256Vector extends IntVector {
+value class Int256Vector extends IntVector {
     static final IntSpecies VSPECIES =
         (IntSpecies) IntVector.SPECIES_256;
 
@@ -54,24 +54,40 @@ final class Int256Vector extends IntVector {
 
     static final Class<Integer> ETYPE = int.class; // used by the JVM
 
-    Int256Vector(int[] v) {
+    /*Int256Vector(int[] v) {
         super(v);
+    }*/
+
+    private final VectorSupport.Int256VectorPayload mf_storage;
+
+    Int256Vector(Object value) {
+        this.mf_storage = (VectorSupport.Int256VectorPayload)value;
+    }
+
+    VectorSupport.VectorPayloadMF vec_mf() {
+        return mf_storage;
+    }
+
+    @Override
+    protected final Object getPayload() {
+       return vec_mf();
     }
 
     // For compatibility as Int256Vector::new,
     // stored into species.vectorFactory.
-    Int256Vector(Object v) {
+    /*Int256Vector(Object v) {
         this((int[]) v);
-    }
+    }*/
 
-    static final Int256Vector ZERO = new Int256Vector(new int[VLENGTH]);
+    static final Int256Vector ZERO = new Int256Vector(VectorSupport.VectorPayloadMF.createNewInstanceI(int.class, 8, Integer.valueOf((int)0)));
     static final Int256Vector IOTA = new Int256Vector(VSPECIES.iotaArray());
 
     static {
         // Warm up a few species caches.
         // If we do this too much we will
         // get NPEs from bootstrap circularity.
-        VSPECIES.dummyVector();
+        // VSPECIES.dummyVector();
+        VSPECIES.dummyVectorMF();
         VSPECIES.withLanes(LaneType.BYTE);
     }
 
@@ -171,6 +187,13 @@ final class Int256Vector extends IntVector {
         return new Int256Vector(vec);
     }
 
+    // Make a vector of the same species but the given elements:
+    @ForceInline
+    final @Override
+    Int256Vector vectorFactory(VectorSupport.VectorPayloadMF vec) {
+        return new Int256Vector(vec);
+    }
+
     @ForceInline
     final @Override
     Byte256Vector asByteVectorRaw() {
@@ -206,6 +229,12 @@ final class Int256Vector extends IntVector {
         return (Int256Vector) super.bOpTemplate((Int256Vector)v, f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Int256Vector bOpMF(Vector<Integer> v, FBinOp f) {
+        return (Int256Vector) super.bOpTemplateMF((Int256Vector)v, f);  // specialize
+    }
+
     @ForceInline
     final @Override
     Int256Vector bOp(Vector<Integer> v,
@@ -215,6 +244,15 @@ final class Int256Vector extends IntVector {
                               f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Int256Vector bOpMF(Vector<Integer> v,
+                     VectorMask<Integer> m, FBinOp f) {
+        return (Int256Vector)
+            super.bOpTemplateMF((Int256Vector)v, (Int256Mask)m,
+                              f);  // specialize
+    }
+
     // Ternary operator
 
     @ForceInline
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int512Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int512Vector.java
index 675aab8ef3a..72e95b61dbd 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int512Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int512Vector.java
@@ -39,7 +39,7 @@ import static jdk.incubator.vector.VectorOperators.*;
 // -- This file was mechanically generated: Do not edit! -- //
 
 @SuppressWarnings("cast")  // warning: redundant cast
-final class Int512Vector extends IntVector {
+value class Int512Vector extends IntVector {
     static final IntSpecies VSPECIES =
         (IntSpecies) IntVector.SPECIES_512;
 
@@ -54,24 +54,40 @@ final class Int512Vector extends IntVector {
 
     static final Class<Integer> ETYPE = int.class; // used by the JVM
 
-    Int512Vector(int[] v) {
+    /*Int512Vector(int[] v) {
         super(v);
+    }*/
+
+    private final VectorSupport.Int512VectorPayload mf_storage;
+
+    Int512Vector(Object value) {
+        this.mf_storage = (VectorSupport.Int512VectorPayload)value;
+    }
+
+    VectorSupport.VectorPayloadMF vec_mf() {
+        return mf_storage;
+    }
+
+    @Override
+    protected final Object getPayload() {
+       return vec_mf();
     }
 
     // For compatibility as Int512Vector::new,
     // stored into species.vectorFactory.
-    Int512Vector(Object v) {
+    /*Int512Vector(Object v) {
         this((int[]) v);
-    }
+    }*/
 
-    static final Int512Vector ZERO = new Int512Vector(new int[VLENGTH]);
+    static final Int512Vector ZERO = new Int512Vector(VectorSupport.VectorPayloadMF.createNewInstanceI(int.class, 16, Integer.valueOf((int)0)));
     static final Int512Vector IOTA = new Int512Vector(VSPECIES.iotaArray());
 
     static {
         // Warm up a few species caches.
         // If we do this too much we will
         // get NPEs from bootstrap circularity.
-        VSPECIES.dummyVector();
+        // VSPECIES.dummyVector();
+        VSPECIES.dummyVectorMF();
         VSPECIES.withLanes(LaneType.BYTE);
     }
 
@@ -171,6 +187,13 @@ final class Int512Vector extends IntVector {
         return new Int512Vector(vec);
     }
 
+    // Make a vector of the same species but the given elements:
+    @ForceInline
+    final @Override
+    Int512Vector vectorFactory(VectorSupport.VectorPayloadMF vec) {
+        return new Int512Vector(vec);
+    }
+
     @ForceInline
     final @Override
     Byte512Vector asByteVectorRaw() {
@@ -206,6 +229,12 @@ final class Int512Vector extends IntVector {
         return (Int512Vector) super.bOpTemplate((Int512Vector)v, f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Int512Vector bOpMF(Vector<Integer> v, FBinOp f) {
+        return (Int512Vector) super.bOpTemplateMF((Int512Vector)v, f);  // specialize
+    }
+
     @ForceInline
     final @Override
     Int512Vector bOp(Vector<Integer> v,
@@ -215,6 +244,15 @@ final class Int512Vector extends IntVector {
                               f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Int512Vector bOpMF(Vector<Integer> v,
+                     VectorMask<Integer> m, FBinOp f) {
+        return (Int512Vector)
+            super.bOpTemplateMF((Int512Vector)v, (Int512Mask)m,
+                              f);  // specialize
+    }
+
     // Ternary operator
 
     @ForceInline
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int64Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int64Vector.java
index e876cd83576..483bde9d63e 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int64Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Int64Vector.java
@@ -39,7 +39,7 @@ import static jdk.incubator.vector.VectorOperators.*;
 // -- This file was mechanically generated: Do not edit! -- //
 
 @SuppressWarnings("cast")  // warning: redundant cast
-final class Int64Vector extends IntVector {
+value class Int64Vector extends IntVector {
     static final IntSpecies VSPECIES =
         (IntSpecies) IntVector.SPECIES_64;
 
@@ -54,24 +54,40 @@ final class Int64Vector extends IntVector {
 
     static final Class<Integer> ETYPE = int.class; // used by the JVM
 
-    Int64Vector(int[] v) {
+    /*Int64Vector(int[] v) {
         super(v);
+    }*/
+
+    private final VectorSupport.Int64VectorPayload mf_storage;
+
+    Int64Vector(Object value) {
+        this.mf_storage = (VectorSupport.Int64VectorPayload)value;
+    }
+
+    VectorSupport.VectorPayloadMF vec_mf() {
+        return mf_storage;
+    }
+
+    @Override
+    protected final Object getPayload() {
+       return vec_mf();
     }
 
     // For compatibility as Int64Vector::new,
     // stored into species.vectorFactory.
-    Int64Vector(Object v) {
+    /*Int64Vector(Object v) {
         this((int[]) v);
-    }
+    }*/
 
-    static final Int64Vector ZERO = new Int64Vector(new int[VLENGTH]);
+    static final Int64Vector ZERO = new Int64Vector(VectorSupport.VectorPayloadMF.createNewInstanceI(int.class, 2, Integer.valueOf((int)0)));
     static final Int64Vector IOTA = new Int64Vector(VSPECIES.iotaArray());
 
     static {
         // Warm up a few species caches.
         // If we do this too much we will
         // get NPEs from bootstrap circularity.
-        VSPECIES.dummyVector();
+        // VSPECIES.dummyVector();
+        VSPECIES.dummyVectorMF();
         VSPECIES.withLanes(LaneType.BYTE);
     }
 
@@ -171,6 +187,13 @@ final class Int64Vector extends IntVector {
         return new Int64Vector(vec);
     }
 
+    // Make a vector of the same species but the given elements:
+    @ForceInline
+    final @Override
+    Int64Vector vectorFactory(VectorSupport.VectorPayloadMF vec) {
+        return new Int64Vector(vec);
+    }
+
     @ForceInline
     final @Override
     Byte64Vector asByteVectorRaw() {
@@ -206,6 +229,12 @@ final class Int64Vector extends IntVector {
         return (Int64Vector) super.bOpTemplate((Int64Vector)v, f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Int64Vector bOpMF(Vector<Integer> v, FBinOp f) {
+        return (Int64Vector) super.bOpTemplateMF((Int64Vector)v, f);  // specialize
+    }
+
     @ForceInline
     final @Override
     Int64Vector bOp(Vector<Integer> v,
@@ -215,6 +244,15 @@ final class Int64Vector extends IntVector {
                               f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Int64Vector bOpMF(Vector<Integer> v,
+                     VectorMask<Integer> m, FBinOp f) {
+        return (Int64Vector)
+            super.bOpTemplateMF((Int64Vector)v, (Int64Mask)m,
+                              f);  // specialize
+    }
+
     // Ternary operator
 
     @ForceInline
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/IntMaxVector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/IntMaxVector.java
deleted file mode 100644
index 2316da250d4..00000000000
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/IntMaxVector.java
+++ /dev/null
@@ -1,924 +0,0 @@
-/*
- * Copyright (c) 2017, 2022, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package jdk.incubator.vector;
-
-import java.lang.foreign.MemorySegment;
-import java.util.Arrays;
-import java.util.Objects;
-import java.util.function.IntUnaryOperator;
-
-import jdk.internal.vm.annotation.ForceInline;
-import jdk.internal.vm.vector.VectorSupport;
-
-import static jdk.internal.vm.vector.VectorSupport.*;
-
-import static jdk.incubator.vector.VectorOperators.*;
-
-// -- This file was mechanically generated: Do not edit! -- //
-
-@SuppressWarnings("cast")  // warning: redundant cast
-final class IntMaxVector extends IntVector {
-    static final IntSpecies VSPECIES =
-        (IntSpecies) IntVector.SPECIES_MAX;
-
-    static final VectorShape VSHAPE =
-        VSPECIES.vectorShape();
-
-    static final Class<IntMaxVector> VCLASS = IntMaxVector.class;
-
-    static final int VSIZE = VSPECIES.vectorBitSize();
-
-    static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
-
-    static final Class<Integer> ETYPE = int.class; // used by the JVM
-
-    IntMaxVector(int[] v) {
-        super(v);
-    }
-
-    // For compatibility as IntMaxVector::new,
-    // stored into species.vectorFactory.
-    IntMaxVector(Object v) {
-        this((int[]) v);
-    }
-
-    static final IntMaxVector ZERO = new IntMaxVector(new int[VLENGTH]);
-    static final IntMaxVector IOTA = new IntMaxVector(VSPECIES.iotaArray());
-
-    static {
-        // Warm up a few species caches.
-        // If we do this too much we will
-        // get NPEs from bootstrap circularity.
-        VSPECIES.dummyVector();
-        VSPECIES.withLanes(LaneType.BYTE);
-    }
-
-    // Specialized extractors
-
-    @ForceInline
-    final @Override
-    public IntSpecies vspecies() {
-        // ISSUE:  This should probably be a @Stable
-        // field inside AbstractVector, rather than
-        // a megamorphic method.
-        return VSPECIES;
-    }
-
-    @ForceInline
-    @Override
-    public final Class<Integer> elementType() { return int.class; }
-
-    @ForceInline
-    @Override
-    public final int elementSize() { return Integer.SIZE; }
-
-    @ForceInline
-    @Override
-    public final VectorShape shape() { return VSHAPE; }
-
-    @ForceInline
-    @Override
-    public final int length() { return VLENGTH; }
-
-    @ForceInline
-    @Override
-    public final int bitSize() { return VSIZE; }
-
-    @ForceInline
-    @Override
-    public final int byteSize() { return VSIZE / Byte.SIZE; }
-
-    /*package-private*/
-    @ForceInline
-    final @Override
-    int[] vec() {
-        return (int[])getPayload();
-    }
-
-    // Virtualized constructors
-
-    @Override
-    @ForceInline
-    public final IntMaxVector broadcast(int e) {
-        return (IntMaxVector) super.broadcastTemplate(e);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final IntMaxVector broadcast(long e) {
-        return (IntMaxVector) super.broadcastTemplate(e);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    IntMaxMask maskFromArray(boolean[] bits) {
-        return new IntMaxMask(bits);
-    }
-
-    @Override
-    @ForceInline
-    IntMaxShuffle iotaShuffle() { return IntMaxShuffle.IOTA; }
-
-    @ForceInline
-    IntMaxShuffle iotaShuffle(int start, int step, boolean wrap) {
-      if (wrap) {
-        return (IntMaxShuffle)VectorSupport.shuffleIota(ETYPE, IntMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,
-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));
-      } else {
-        return (IntMaxShuffle)VectorSupport.shuffleIota(ETYPE, IntMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,
-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));
-      }
-    }
-
-    @Override
-    @ForceInline
-    IntMaxShuffle shuffleFromBytes(byte[] reorder) { return new IntMaxShuffle(reorder); }
-
-    @Override
-    @ForceInline
-    IntMaxShuffle shuffleFromArray(int[] indexes, int i) { return new IntMaxShuffle(indexes, i); }
-
-    @Override
-    @ForceInline
-    IntMaxShuffle shuffleFromOp(IntUnaryOperator fn) { return new IntMaxShuffle(fn); }
-
-    // Make a vector of the same species but the given elements:
-    @ForceInline
-    final @Override
-    IntMaxVector vectorFactory(int[] vec) {
-        return new IntMaxVector(vec);
-    }
-
-    @ForceInline
-    final @Override
-    ByteMaxVector asByteVectorRaw() {
-        return (ByteMaxVector) super.asByteVectorRawTemplate();  // specialize
-    }
-
-    @ForceInline
-    final @Override
-    AbstractVector<?> asVectorRaw(LaneType laneType) {
-        return super.asVectorRawTemplate(laneType);  // specialize
-    }
-
-    // Unary operator
-
-    @ForceInline
-    final @Override
-    IntMaxVector uOp(FUnOp f) {
-        return (IntMaxVector) super.uOpTemplate(f);  // specialize
-    }
-
-    @ForceInline
-    final @Override
-    IntMaxVector uOp(VectorMask<Integer> m, FUnOp f) {
-        return (IntMaxVector)
-            super.uOpTemplate((IntMaxMask)m, f);  // specialize
-    }
-
-    // Binary operator
-
-    @ForceInline
-    final @Override
-    IntMaxVector bOp(Vector<Integer> v, FBinOp f) {
-        return (IntMaxVector) super.bOpTemplate((IntMaxVector)v, f);  // specialize
-    }
-
-    @ForceInline
-    final @Override
-    IntMaxVector bOp(Vector<Integer> v,
-                     VectorMask<Integer> m, FBinOp f) {
-        return (IntMaxVector)
-            super.bOpTemplate((IntMaxVector)v, (IntMaxMask)m,
-                              f);  // specialize
-    }
-
-    // Ternary operator
-
-    @ForceInline
-    final @Override
-    IntMaxVector tOp(Vector<Integer> v1, Vector<Integer> v2, FTriOp f) {
-        return (IntMaxVector)
-            super.tOpTemplate((IntMaxVector)v1, (IntMaxVector)v2,
-                              f);  // specialize
-    }
-
-    @ForceInline
-    final @Override
-    IntMaxVector tOp(Vector<Integer> v1, Vector<Integer> v2,
-                     VectorMask<Integer> m, FTriOp f) {
-        return (IntMaxVector)
-            super.tOpTemplate((IntMaxVector)v1, (IntMaxVector)v2,
-                              (IntMaxMask)m, f);  // specialize
-    }
-
-    @ForceInline
-    final @Override
-    int rOp(int v, VectorMask<Integer> m, FBinOp f) {
-        return super.rOpTemplate(v, m, f);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final <F>
-    Vector<F> convertShape(VectorOperators.Conversion<Integer,F> conv,
-                           VectorSpecies<F> rsp, int part) {
-        return super.convertShapeTemplate(conv, rsp, part);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final <F>
-    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {
-        return super.reinterpretShapeTemplate(toSpecies, part);  // specialize
-    }
-
-    // Specialized algebraic operations:
-
-    // The following definition forces a specialized version of this
-    // crucial method into the v-table of this class.  A call to add()
-    // will inline to a call to lanewise(ADD,), at which point the JIT
-    // intrinsic will have the opcode of ADD, plus all the metadata
-    // for this particular class, enabling it to generate precise
-    // code.
-    //
-    // There is probably no benefit to the JIT to specialize the
-    // masked or broadcast versions of the lanewise method.
-
-    @Override
-    @ForceInline
-    public IntMaxVector lanewise(Unary op) {
-        return (IntMaxVector) super.lanewiseTemplate(op);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public IntMaxVector lanewise(Unary op, VectorMask<Integer> m) {
-        return (IntMaxVector) super.lanewiseTemplate(op, IntMaxMask.class, (IntMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public IntMaxVector lanewise(Binary op, Vector<Integer> v) {
-        return (IntMaxVector) super.lanewiseTemplate(op, v);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public IntMaxVector lanewise(Binary op, Vector<Integer> v, VectorMask<Integer> m) {
-        return (IntMaxVector) super.lanewiseTemplate(op, IntMaxMask.class, v, (IntMaxMask) m);  // specialize
-    }
-
-    /*package-private*/
-    @Override
-    @ForceInline IntMaxVector
-    lanewiseShift(VectorOperators.Binary op, int e) {
-        return (IntMaxVector) super.lanewiseShiftTemplate(op, e);  // specialize
-    }
-
-    /*package-private*/
-    @Override
-    @ForceInline IntMaxVector
-    lanewiseShift(VectorOperators.Binary op, int e, VectorMask<Integer> m) {
-        return (IntMaxVector) super.lanewiseShiftTemplate(op, IntMaxMask.class, e, (IntMaxMask) m);  // specialize
-    }
-
-    /*package-private*/
-    @Override
-    @ForceInline
-    public final
-    IntMaxVector
-    lanewise(Ternary op, Vector<Integer> v1, Vector<Integer> v2) {
-        return (IntMaxVector) super.lanewiseTemplate(op, v1, v2);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final
-    IntMaxVector
-    lanewise(Ternary op, Vector<Integer> v1, Vector<Integer> v2, VectorMask<Integer> m) {
-        return (IntMaxVector) super.lanewiseTemplate(op, IntMaxMask.class, v1, v2, (IntMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final
-    IntMaxVector addIndex(int scale) {
-        return (IntMaxVector) super.addIndexTemplate(scale);  // specialize
-    }
-
-    // Type specific horizontal reductions
-
-    @Override
-    @ForceInline
-    public final int reduceLanes(VectorOperators.Associative op) {
-        return super.reduceLanesTemplate(op);  // specialized
-    }
-
-    @Override
-    @ForceInline
-    public final int reduceLanes(VectorOperators.Associative op,
-                                    VectorMask<Integer> m) {
-        return super.reduceLanesTemplate(op, IntMaxMask.class, (IntMaxMask) m);  // specialized
-    }
-
-    @Override
-    @ForceInline
-    public final long reduceLanesToLong(VectorOperators.Associative op) {
-        return (long) super.reduceLanesTemplate(op);  // specialized
-    }
-
-    @Override
-    @ForceInline
-    public final long reduceLanesToLong(VectorOperators.Associative op,
-                                        VectorMask<Integer> m) {
-        return (long) super.reduceLanesTemplate(op, IntMaxMask.class, (IntMaxMask) m);  // specialized
-    }
-
-    @ForceInline
-    public VectorShuffle<Integer> toShuffle() {
-        return super.toShuffleTemplate(IntMaxShuffle.class); // specialize
-    }
-
-    // Specialized unary testing
-
-    @Override
-    @ForceInline
-    public final IntMaxMask test(Test op) {
-        return super.testTemplate(IntMaxMask.class, op);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final IntMaxMask test(Test op, VectorMask<Integer> m) {
-        return super.testTemplate(IntMaxMask.class, op, (IntMaxMask) m);  // specialize
-    }
-
-    // Specialized comparisons
-
-    @Override
-    @ForceInline
-    public final IntMaxMask compare(Comparison op, Vector<Integer> v) {
-        return super.compareTemplate(IntMaxMask.class, op, v);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final IntMaxMask compare(Comparison op, int s) {
-        return super.compareTemplate(IntMaxMask.class, op, s);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final IntMaxMask compare(Comparison op, long s) {
-        return super.compareTemplate(IntMaxMask.class, op, s);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final IntMaxMask compare(Comparison op, Vector<Integer> v, VectorMask<Integer> m) {
-        return super.compareTemplate(IntMaxMask.class, op, v, (IntMaxMask) m);
-    }
-
-
-    @Override
-    @ForceInline
-    public IntMaxVector blend(Vector<Integer> v, VectorMask<Integer> m) {
-        return (IntMaxVector)
-            super.blendTemplate(IntMaxMask.class,
-                                (IntMaxVector) v,
-                                (IntMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public IntMaxVector slice(int origin, Vector<Integer> v) {
-        return (IntMaxVector) super.sliceTemplate(origin, v);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public IntMaxVector slice(int origin) {
-        return (IntMaxVector) super.sliceTemplate(origin);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public IntMaxVector unslice(int origin, Vector<Integer> w, int part) {
-        return (IntMaxVector) super.unsliceTemplate(origin, w, part);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public IntMaxVector unslice(int origin, Vector<Integer> w, int part, VectorMask<Integer> m) {
-        return (IntMaxVector)
-            super.unsliceTemplate(IntMaxMask.class,
-                                  origin, w, part,
-                                  (IntMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public IntMaxVector unslice(int origin) {
-        return (IntMaxVector) super.unsliceTemplate(origin);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public IntMaxVector rearrange(VectorShuffle<Integer> s) {
-        return (IntMaxVector)
-            super.rearrangeTemplate(IntMaxShuffle.class,
-                                    (IntMaxShuffle) s);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public IntMaxVector rearrange(VectorShuffle<Integer> shuffle,
-                                  VectorMask<Integer> m) {
-        return (IntMaxVector)
-            super.rearrangeTemplate(IntMaxShuffle.class,
-                                    IntMaxMask.class,
-                                    (IntMaxShuffle) shuffle,
-                                    (IntMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public IntMaxVector rearrange(VectorShuffle<Integer> s,
-                                  Vector<Integer> v) {
-        return (IntMaxVector)
-            super.rearrangeTemplate(IntMaxShuffle.class,
-                                    (IntMaxShuffle) s,
-                                    (IntMaxVector) v);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public IntMaxVector compress(VectorMask<Integer> m) {
-        return (IntMaxVector)
-            super.compressTemplate(IntMaxMask.class,
-                                   (IntMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public IntMaxVector expand(VectorMask<Integer> m) {
-        return (IntMaxVector)
-            super.expandTemplate(IntMaxMask.class,
-                                   (IntMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public IntMaxVector selectFrom(Vector<Integer> v) {
-        return (IntMaxVector)
-            super.selectFromTemplate((IntMaxVector) v);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public IntMaxVector selectFrom(Vector<Integer> v,
-                                   VectorMask<Integer> m) {
-        return (IntMaxVector)
-            super.selectFromTemplate((IntMaxVector) v,
-                                     (IntMaxMask) m);  // specialize
-    }
-
-
-    @ForceInline
-    @Override
-    public int lane(int i) {
-        if (i < 0 || i >= VLENGTH) {
-            throw new IllegalArgumentException("Index " + i + " must be zero or positive, and less than " + VLENGTH);
-        }
-        return laneHelper(i);
-    }
-
-    public int laneHelper(int i) {
-        return (int) VectorSupport.extract(
-                                VCLASS, ETYPE, VLENGTH,
-                                this, i,
-                                (vec, ix) -> {
-                                    int[] vecarr = vec.vec();
-                                    return (long)vecarr[ix];
-                                });
-    }
-
-    @ForceInline
-    @Override
-    public IntMaxVector withLane(int i, int e) {
-        if (i < 0 || i >= VLENGTH) {
-            throw new IllegalArgumentException("Index " + i + " must be zero or positive, and less than " + VLENGTH);
-        }
-        return withLaneHelper(i, e);
-    }
-
-    public IntMaxVector withLaneHelper(int i, int e) {
-        return VectorSupport.insert(
-                                VCLASS, ETYPE, VLENGTH,
-                                this, i, (long)e,
-                                (v, ix, bits) -> {
-                                    int[] res = v.vec().clone();
-                                    res[ix] = (int)bits;
-                                    return v.vectorFactory(res);
-                                });
-    }
-
-    // Mask
-
-    static final class IntMaxMask extends AbstractMask<Integer> {
-        static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
-        static final Class<Integer> ETYPE = int.class; // used by the JVM
-
-        IntMaxMask(boolean[] bits) {
-            this(bits, 0);
-        }
-
-        IntMaxMask(boolean[] bits, int offset) {
-            super(prepare(bits, offset));
-        }
-
-        IntMaxMask(boolean val) {
-            super(prepare(val));
-        }
-
-        private static boolean[] prepare(boolean[] bits, int offset) {
-            boolean[] newBits = new boolean[VSPECIES.laneCount()];
-            for (int i = 0; i < newBits.length; i++) {
-                newBits[i] = bits[offset + i];
-            }
-            return newBits;
-        }
-
-        private static boolean[] prepare(boolean val) {
-            boolean[] bits = new boolean[VSPECIES.laneCount()];
-            Arrays.fill(bits, val);
-            return bits;
-        }
-
-        @ForceInline
-        final @Override
-        public IntSpecies vspecies() {
-            // ISSUE:  This should probably be a @Stable
-            // field inside AbstractMask, rather than
-            // a megamorphic method.
-            return VSPECIES;
-        }
-
-        @ForceInline
-        boolean[] getBits() {
-            return (boolean[])getPayload();
-        }
-
-        @Override
-        IntMaxMask uOp(MUnOp f) {
-            boolean[] res = new boolean[vspecies().laneCount()];
-            boolean[] bits = getBits();
-            for (int i = 0; i < res.length; i++) {
-                res[i] = f.apply(i, bits[i]);
-            }
-            return new IntMaxMask(res);
-        }
-
-        @Override
-        IntMaxMask bOp(VectorMask<Integer> m, MBinOp f) {
-            boolean[] res = new boolean[vspecies().laneCount()];
-            boolean[] bits = getBits();
-            boolean[] mbits = ((IntMaxMask)m).getBits();
-            for (int i = 0; i < res.length; i++) {
-                res[i] = f.apply(i, bits[i], mbits[i]);
-            }
-            return new IntMaxMask(res);
-        }
-
-        @ForceInline
-        @Override
-        public final
-        IntMaxVector toVector() {
-            return (IntMaxVector) super.toVectorTemplate();  // specialize
-        }
-
-        /**
-         * Helper function for lane-wise mask conversions.
-         * This function kicks in after intrinsic failure.
-         */
-        @ForceInline
-        private final <E>
-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {
-            if (length() != dsp.laneCount())
-                throw new IllegalArgumentException("VectorMask length and species length differ");
-            boolean[] maskArray = toArray();
-            return  dsp.maskFactory(maskArray).check(dsp);
-        }
-
-        @Override
-        @ForceInline
-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;
-            if (length() != species.laneCount())
-                throw new IllegalArgumentException("VectorMask length and species length differ");
-
-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,
-                this.getClass(), ETYPE, VLENGTH,
-                species.maskType(), species.elementType(), VLENGTH,
-                this, species,
-                (m, s) -> s.maskFactory(m.toArray()).check(s));
-        }
-
-        @Override
-        @ForceInline
-        public IntMaxMask eq(VectorMask<Integer> mask) {
-            Objects.requireNonNull(mask);
-            IntMaxMask m = (IntMaxMask)mask;
-            return xor(m.not());
-        }
-
-        // Unary operations
-
-        @Override
-        @ForceInline
-        public IntMaxMask not() {
-            return xor(maskAll(true));
-        }
-
-        @Override
-        @ForceInline
-        public IntMaxMask compress() {
-            return (IntMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                IntMaxVector.class, IntMaxMask.class, ETYPE, VLENGTH, null, this,
-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
-        }
-
-
-        // Binary operations
-
-        @Override
-        @ForceInline
-        public IntMaxMask and(VectorMask<Integer> mask) {
-            Objects.requireNonNull(mask);
-            IntMaxMask m = (IntMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, IntMaxMask.class, null, int.class, VLENGTH,
-                                          this, m, null,
-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
-        }
-
-        @Override
-        @ForceInline
-        public IntMaxMask or(VectorMask<Integer> mask) {
-            Objects.requireNonNull(mask);
-            IntMaxMask m = (IntMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, IntMaxMask.class, null, int.class, VLENGTH,
-                                          this, m, null,
-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
-        }
-
-        @ForceInline
-        /* package-private */
-        IntMaxMask xor(VectorMask<Integer> mask) {
-            Objects.requireNonNull(mask);
-            IntMaxMask m = (IntMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, IntMaxMask.class, null, int.class, VLENGTH,
-                                          this, m, null,
-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
-        }
-
-        // Mask Query operations
-
-        @Override
-        @ForceInline
-        public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, IntMaxMask.class, int.class, VLENGTH, this,
-                                                      (m) -> trueCountHelper(m.getBits()));
-        }
-
-        @Override
-        @ForceInline
-        public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, IntMaxMask.class, int.class, VLENGTH, this,
-                                                      (m) -> firstTrueHelper(m.getBits()));
-        }
-
-        @Override
-        @ForceInline
-        public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, IntMaxMask.class, int.class, VLENGTH, this,
-                                                      (m) -> lastTrueHelper(m.getBits()));
-        }
-
-        @Override
-        @ForceInline
-        public long toLong() {
-            if (length() > Long.SIZE) {
-                throw new UnsupportedOperationException("too many lanes for one long");
-            }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, IntMaxMask.class, int.class, VLENGTH, this,
-                                                      (m) -> toLongHelper(m.getBits()));
-        }
-
-        // Reductions
-
-        @Override
-        @ForceInline
-        public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, IntMaxMask.class, int.class, VLENGTH,
-                                         this, vspecies().maskAll(true),
-                                         (m, __) -> anyTrueHelper(((IntMaxMask)m).getBits()));
-        }
-
-        @Override
-        @ForceInline
-        public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, IntMaxMask.class, int.class, VLENGTH,
-                                         this, vspecies().maskAll(true),
-                                         (m, __) -> allTrueHelper(((IntMaxMask)m).getBits()));
-        }
-
-        @ForceInline
-        /*package-private*/
-        static IntMaxMask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(IntMaxMask.class, int.class, VLENGTH,
-                                                 (bit ? -1 : 0), MODE_BROADCAST, null,
-                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
-        }
-        private static final IntMaxMask  TRUE_MASK = new IntMaxMask(true);
-        private static final IntMaxMask FALSE_MASK = new IntMaxMask(false);
-
-
-        static boolean[] maskLowerHalf() {
-            boolean[] a = new boolean[VLENGTH];
-            int len = a.length >> 1;
-            for (int i = 0; i < len; i++) {
-                a[i] = true;
-            }
-            return a;
-        }
-
-        static final IntMaxMask LOWER_HALF_TRUE_MASK = new IntMaxMask(maskLowerHalf());
-    }
-
-    // Shuffle
-
-    static final class IntMaxShuffle extends AbstractShuffle<Integer> {
-        static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
-        static final Class<Integer> ETYPE = int.class; // used by the JVM
-
-        IntMaxShuffle(byte[] reorder) {
-            super(VLENGTH, reorder);
-        }
-
-        public IntMaxShuffle(int[] reorder) {
-            super(VLENGTH, reorder);
-        }
-
-        public IntMaxShuffle(int[] reorder, int i) {
-            super(VLENGTH, reorder, i);
-        }
-
-        public IntMaxShuffle(IntUnaryOperator fn) {
-            super(VLENGTH, fn);
-        }
-
-        @Override
-        public IntSpecies vspecies() {
-            return VSPECIES;
-        }
-
-        static {
-            // There must be enough bits in the shuffle lanes to encode
-            // VLENGTH valid indexes and VLENGTH exceptional ones.
-            assert(VLENGTH < Byte.MAX_VALUE);
-            assert(Byte.MIN_VALUE <= -VLENGTH);
-        }
-        static final IntMaxShuffle IOTA = new IntMaxShuffle(IDENTITY);
-
-        @Override
-        @ForceInline
-        public IntMaxVector toVector() {
-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, IntMaxShuffle.class, this, VLENGTH,
-                                                    (s) -> ((IntMaxVector)(((AbstractShuffle<Integer>)(s)).toVectorTemplate())));
-        }
-
-        @Override
-        @ForceInline
-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {
-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;
-            if (length() != species.laneCount())
-                throw new IllegalArgumentException("VectorShuffle length and species length differ");
-            int[] shuffleArray = toArray();
-            return s.shuffleFromArray(shuffleArray, 0).check(s);
-        }
-
-        @ForceInline
-        @Override
-        public IntMaxShuffle rearrange(VectorShuffle<Integer> shuffle) {
-            IntMaxShuffle s = (IntMaxShuffle) shuffle;
-            byte[] reorder1 = reorder();
-            byte[] reorder2 = s.reorder();
-            byte[] r = new byte[reorder1.length];
-            for (int i = 0; i < reorder1.length; i++) {
-                int ssi = reorder2[i];
-                r[i] = reorder1[ssi];  // throws on exceptional index
-            }
-            return new IntMaxShuffle(r);
-        }
-    }
-
-    // ================================================
-
-    // Specialized low-level memory operations.
-
-    @ForceInline
-    @Override
-    final
-    IntVector fromArray0(int[] a, int offset) {
-        return super.fromArray0Template(a, offset);  // specialize
-    }
-
-    @ForceInline
-    @Override
-    final
-    IntVector fromArray0(int[] a, int offset, VectorMask<Integer> m, int offsetInRange) {
-        return super.fromArray0Template(IntMaxMask.class, a, offset, (IntMaxMask) m, offsetInRange);  // specialize
-    }
-
-    @ForceInline
-    @Override
-    final
-    IntVector fromArray0(int[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Integer> m) {
-        return super.fromArray0Template(IntMaxMask.class, a, offset, indexMap, mapOffset, (IntMaxMask) m);
-    }
-
-
-
-    @ForceInline
-    @Override
-    final
-    IntVector fromMemorySegment0(MemorySegment ms, long offset) {
-        return super.fromMemorySegment0Template(ms, offset);  // specialize
-    }
-
-    @ForceInline
-    @Override
-    final
-    IntVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Integer> m, int offsetInRange) {
-        return super.fromMemorySegment0Template(IntMaxMask.class, ms, offset, (IntMaxMask) m, offsetInRange);  // specialize
-    }
-
-    @ForceInline
-    @Override
-    final
-    void intoArray0(int[] a, int offset) {
-        super.intoArray0Template(a, offset);  // specialize
-    }
-
-    @ForceInline
-    @Override
-    final
-    void intoArray0(int[] a, int offset, VectorMask<Integer> m) {
-        super.intoArray0Template(IntMaxMask.class, a, offset, (IntMaxMask) m);
-    }
-
-    @ForceInline
-    @Override
-    final
-    void intoArray0(int[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Integer> m) {
-        super.intoArray0Template(IntMaxMask.class, a, offset, indexMap, mapOffset, (IntMaxMask) m);
-    }
-
-
-    @ForceInline
-    @Override
-    final
-    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Integer> m) {
-        super.intoMemorySegment0Template(IntMaxMask.class, ms, offset, (IntMaxMask) m);
-    }
-
-
-    // End of specialized low-level memory operations.
-
-    // ================================================
-
-}
-
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/IntVector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/IntVector.java
index 87787b9a611..e0be1f82e6b 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/IntVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/IntVector.java
@@ -51,9 +51,9 @@ import static jdk.incubator.vector.VectorOperators.*;
 @SuppressWarnings("cast")  // warning: redundant cast
 public abstract class IntVector extends AbstractVector<Integer> {
 
-    IntVector(int[] vec) {
+    /*IntVector(int[] vec) {
         super(vec);
-    }
+    }*/
 
     static final int FORBID_OPCODE_KIND = VO_ONLYFP;
 
@@ -96,6 +96,8 @@ public abstract class IntVector extends AbstractVector<Integer> {
     /*package-private*/
     abstract int[] vec();
 
+    abstract VectorSupport.VectorPayloadMF vec_mf();
+
     // Virtualized constructors
 
     /**
@@ -105,6 +107,17 @@ public abstract class IntVector extends AbstractVector<Integer> {
     /*package-private*/
     abstract IntVector vectorFactory(int[] vec);
 
+    abstract IntVector vectorFactory(VectorSupport.VectorPayloadMF vec);
+
+    @ForceInline
+    public static
+    IntVector fromArray(VectorSpecies<Integer> species,
+                                   int[] a, int offset) {
+        offset = checkFromIndexSize(offset, species.length(), a.length);
+        IntSpecies vsp = (IntSpecies) species;
+        return vsp.dummyVectorMF().fromArray0(a, offset);
+    }
+
     /**
      * Build a mask directly using my species.
      * It is an error if the array is aliased elsewhere.
@@ -210,6 +223,30 @@ public abstract class IntVector extends AbstractVector<Integer> {
         return vectorFactory(res);
     }
 
+    /*package-private*/
+    abstract
+    IntVector bOpMF(Vector<Integer> o,
+                             FBinOp f);
+    @ForceInline
+    final
+    IntVector bOpTemplateMF(Vector<Integer> o,
+                                     FBinOp f) {
+        VectorSupport.VectorPayloadMF vec1 = this.vec_mf();
+        VectorSupport.VectorPayloadMF vec2 = this.vec_mf();
+        VectorSupport.VectorPayloadMF tpayload = 
+            Unsafe.getUnsafe().makePrivateBuffer(VectorSupport.VectorPayloadMF.createNewInstanceI(
+                   int.class, length(), Integer.valueOf((int)0)));
+        long start_offset = tpayload.multiFieldOffset();
+        int length = tpayload.length();
+        for (int i = 0; i < length; i++) {
+            int v1 = Unsafe.getUnsafe().getInt(vec1, start_offset + i * Integer.BYTES);
+            int v2 = Unsafe.getUnsafe().getInt(vec2, start_offset + i * Integer.BYTES);
+            Unsafe.getUnsafe().putInt(tpayload, start_offset + i * Integer.BYTES, f.apply(i, v1, v2));
+        }
+        Unsafe.getUnsafe().finishPrivateBuffer(tpayload);
+        return vectorFactory(tpayload);
+    }
+
     /*package-private*/
     abstract
     IntVector bOp(Vector<Integer> o,
@@ -233,6 +270,36 @@ public abstract class IntVector extends AbstractVector<Integer> {
         return vectorFactory(res);
     }
 
+    /*package-private*/
+    abstract
+    IntVector bOpMF(Vector<Integer> o,
+                             VectorMask<Integer> m,
+                             FBinOp f);
+    @ForceInline
+    final
+    IntVector bOpTemplateMF(Vector<Integer> o,
+                                     VectorMask<Integer> m,
+                                     FBinOp f) {
+        if (m == null) {
+            return bOpTemplateMF(o, f);
+        }
+        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();
+        VectorSupport.VectorPayloadMF vec1 = this.vec_mf();
+        VectorSupport.VectorPayloadMF vec2 = this.vec_mf();
+        VectorSupport.VectorPayloadMF tpayload =
+            Unsafe.getUnsafe().makePrivateBuffer(VectorSupport.VectorPayloadMF.createNewInstanceI(
+                int.class, length(), Integer.valueOf((int)0)));
+        long start_offset = tpayload.multiFieldOffset();
+        int length = tpayload.length();
+        for (int i = 0; i < length; i++) {
+            int v1 = Unsafe.getUnsafe().getInt(vec1, start_offset + i * Integer.BYTES);
+            int v2 = Unsafe.getUnsafe().getInt(vec2, start_offset + i * Integer.BYTES);
+            Unsafe.getUnsafe().putInt(tpayload, start_offset + i * Integer.BYTES, mbits[i] ? f.apply(i, v1, v2): v1);
+        }
+        Unsafe.getUnsafe().finishPrivateBuffer(tpayload);
+        return vectorFactory(tpayload);
+    }
+
     // Ternary operator
 
     /*package-private*/
@@ -353,6 +420,45 @@ public abstract class IntVector extends AbstractVector<Integer> {
         return vectorFactory(res);
     }
 
+    /*package-private*/
+    @ForceInline
+    final
+    <M> IntVector ldOpMF(M memory, int offset,
+                                  FLdOp<M> f) {
+        VectorSupport.VectorPayloadMF tpayload =
+            Unsafe.getUnsafe().makePrivateBuffer(VectorSupport.VectorPayloadMF.createNewInstanceI(
+                int.class, length(), Integer.valueOf((int)0)));
+        int length = tpayload.length();
+        long start_offset = tpayload.multiFieldOffset();
+        for (int i = 0; i < length; i++) {
+            Unsafe.getUnsafe().putInt(tpayload, start_offset + i * Integer.BYTES, f.apply(memory, offset, i));
+        }
+        Unsafe.getUnsafe().finishPrivateBuffer(tpayload);
+        return vectorFactory(tpayload);
+    }
+
+    /*package-private*/
+    @ForceInline
+    final
+    <M> IntVector ldOpMF(M memory, int offset,
+                                  VectorMask<Integer> m,
+                                  FLdOp<M> f) {
+        VectorSupport.VectorPayloadMF tpayload =
+            Unsafe.getUnsafe().makePrivateBuffer(VectorSupport.VectorPayloadMF.createNewInstanceI(
+                int.class, length(), Integer.valueOf((int)0)));
+        int length = tpayload.length();
+        long start_offset = tpayload.multiFieldOffset();
+        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();
+        for (int i = 0; i < length; i++) {
+            if (mbits[i]) {
+                Unsafe.getUnsafe().putInt(tpayload, start_offset + i * Integer.BYTES, f.apply(memory, offset, i));
+            }
+        }
+        Unsafe.getUnsafe().finishPrivateBuffer(tpayload);
+        return vectorFactory(tpayload);
+    }
+
+
     /*package-private*/
     interface FLdLongOp {
         int apply(MemorySegment memory, long offset, int i);
@@ -422,6 +528,37 @@ public abstract class IntVector extends AbstractVector<Integer> {
         }
     }
 
+    /*package-private*/
+    @ForceInline
+    final
+    <M> void stOpMF(M memory, int offset,
+                  FStOp<M> f) {
+        VectorSupport.VectorPayloadMF vec = vec_mf();
+        long start_offset = vec.multiFieldOffset();
+        int length = vec.length();
+        for (int i = 0; i < length; i++) {
+            f.apply(memory, offset, i, Unsafe.getUnsafe().getInt(vec, start_offset + i * Integer.BYTES));
+        }
+    }
+
+    /*package-private*/
+   @ForceInline
+    final
+    <M> void stOpMF(M memory, int offset,
+                  VectorMask<Integer> m,
+                  FStOp<M> f) {
+        VectorSupport.VectorPayloadMF vec = vec_mf();
+        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();
+        long start_offset = vec.multiFieldOffset();
+        int length = vec.length();
+        for (int i = 0; i < length; i++) {
+            if (mbits[i]) {
+                f.apply(memory, offset, i, Unsafe.getUnsafe().getInt(vec, start_offset + i * Integer.BYTES));
+            }
+        }
+    }
+
+
     interface FStLongOp {
         void apply(MemorySegment memory, long offset, int i, int a);
     }
@@ -780,11 +917,18 @@ public abstract class IntVector extends AbstractVector<Integer> {
             }
         }
 
+        /*
         int opc = opCode(op);
         return VectorSupport.binaryOp(
             opc, getClass(), null, int.class, length(),
             this, that, null,
             BIN_IMPL.find(op, opc, IntVector::binaryOperations));
+        */
+        int opc = opCode(op);
+        return VectorSupport.binaryOp(
+            opc, getClass(), null, int.class, length(),
+            this, that, null,
+            BIN_IMPL.find(op, opc, IntVector::binaryOperationsMF));
     }
 
     /**
@@ -879,6 +1023,25 @@ public abstract class IntVector extends AbstractVector<Integer> {
         }
     }
 
+    private static BinaryOperation<IntVector, VectorMask<Integer>> binaryOperationsMF(int opc_) {
+        switch (opc_) {
+            case VECTOR_OP_ADD: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)(a + b));
+            case VECTOR_OP_SUB: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)(a - b));
+            case VECTOR_OP_MUL: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)(a * b));
+            case VECTOR_OP_DIV: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)(a / b));
+            case VECTOR_OP_MAX: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)Math.max(a, b));
+            case VECTOR_OP_MIN: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)Math.min(a, b));
+            default: return null;
+        }
+    }
+
+
     // FIXME: Maybe all of the public final methods in this file (the
     // simple ones that just call lanewise) should be pushed down to
     // the X-VectorBits template.  They can't optimize properly at
@@ -2946,6 +3109,7 @@ public abstract class IntVector extends AbstractVector<Integer> {
      *         if {@code offset+N < 0} or {@code offset+N >= a.length}
      *         for any lane {@code N} in the vector
      */
+    /*
     @ForceInline
     public static
     IntVector fromArray(VectorSpecies<Integer> species,
@@ -2953,7 +3117,7 @@ public abstract class IntVector extends AbstractVector<Integer> {
         offset = checkFromIndexSize(offset, species.length(), a.length);
         IntSpecies vsp = (IntSpecies) species;
         return vsp.dummyVector().fromArray0(a, offset);
-    }
+    }*/
 
     /**
      * Loads a vector from an array of type {@code int[]}
@@ -3225,6 +3389,7 @@ public abstract class IntVector extends AbstractVector<Integer> {
     void intoArray(int[] a, int offset) {
         offset = checkFromIndexSize(offset, length(), a.length);
         IntSpecies vsp = vspecies();
+        /*
         VectorSupport.store(
             vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
             a, arrayAddress(a, offset),
@@ -3233,6 +3398,16 @@ public abstract class IntVector extends AbstractVector<Integer> {
             (arr, off, v)
             -> v.stOp(arr, (int) off,
                       (arr_, off_, i, e) -> arr_[off_ + i] = e));
+         */
+        VectorSupport.store(
+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
+            a, arrayAddress(a, offset),
+            this,
+            a, offset,
+            (arr, off, v)
+            -> v.stOpMF(arr, (int) off,
+                      (arr_, off_, i, e) -> arr_[off_ + i] = e));
+
     }
 
     /**
@@ -3437,6 +3612,7 @@ public abstract class IntVector extends AbstractVector<Integer> {
     IntVector fromArray0(int[] a, int offset);
     @ForceInline
     final
+    /*
     IntVector fromArray0Template(int[] a, int offset) {
         IntSpecies vsp = vspecies();
         return VectorSupport.load(
@@ -3445,6 +3621,16 @@ public abstract class IntVector extends AbstractVector<Integer> {
             a, offset, vsp,
             (arr, off, s) -> s.ldOp(arr, (int) off,
                                     (arr_, off_, i) -> arr_[off_ + i]));
+    }*/
+
+    IntVector fromArray0Template(int[] a, int offset) {
+        IntSpecies vsp = vspecies();
+        return VectorSupport.load(
+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
+            a, arrayAddress(a, offset),
+            a, offset, vsp,
+            (arr, off, s) -> s.ldOpMF(arr, (int) off,
+                                    (arr_, off_, i) -> arr_[off_ + i]));
     }
 
     /*package-private*/
@@ -3918,6 +4104,12 @@ public abstract class IntVector extends AbstractVector<Integer> {
             return (IntVector) super.dummyVector();
         }
 
+        @ForceInline
+        @Override final
+        IntVector dummyVectorMF() {
+            return (IntVector) super.dummyVectorMF();
+        }
+
         /*package-private*/
         final @Override
         @ForceInline
@@ -3964,6 +4156,22 @@ public abstract class IntVector extends AbstractVector<Integer> {
             return dummyVector().ldOp(memory, offset, m, f);
         }
 
+        /*package-private*/
+        @ForceInline
+        <M> IntVector ldOpMF(M memory, int offset,
+                                      FLdOp<M> f) {
+            return dummyVectorMF().ldOpMF(memory, offset, f);
+        }
+
+        /*package-private*/
+        @ForceInline
+        <M> IntVector ldOpMF(M memory, int offset,
+                                      VectorMask<Integer> m,
+                                      FLdOp<M> f) {
+            return dummyVectorMF().ldOpMF(memory, offset, m, f);
+        }
+
+
         /*package-private*/
         @ForceInline
         IntVector ldLongOp(MemorySegment memory, long offset,
@@ -3993,6 +4201,21 @@ public abstract class IntVector extends AbstractVector<Integer> {
             dummyVector().stOp(memory, offset, m, f);
         }
 
+        /*package-private*/
+        @ForceInline
+        <M> void stOpMF(M memory, int offset, FStOp<M> f) {
+            dummyVectorMF().stOpMF(memory, offset, f);
+        }
+
+        /*package-private*/
+        @ForceInline
+        <M> void stOpMF(M memory, int offset,
+                     AbstractMask<Integer> m,
+                      FStOp<M> f) {
+            dummyVectorMF().stOpMF(memory, offset, m, f);
+        }
+
+
         /*package-private*/
         @ForceInline
         void stLongOp(MemorySegment memory, long offset, FStLongOp f) {
@@ -4018,8 +4241,8 @@ public abstract class IntVector extends AbstractVector<Integer> {
         @Override
         @ForceInline
         public final IntVector zero() {
-            if ((Class<?>) vectorType() == IntMaxVector.class)
-                return IntMaxVector.ZERO;
+            //if ((Class<?>) vectorType() == IntMaxVector.class)
+            //    return IntMaxVector.ZERO;
             switch (vectorBitSize()) {
                 case 64: return Int64Vector.ZERO;
                 case 128: return Int128Vector.ZERO;
@@ -4032,8 +4255,8 @@ public abstract class IntVector extends AbstractVector<Integer> {
         @Override
         @ForceInline
         public final IntVector iota() {
-            if ((Class<?>) vectorType() == IntMaxVector.class)
-                return IntMaxVector.IOTA;
+            //if ((Class<?>) vectorType() == IntMaxVector.class)
+            //    return IntMaxVector.IOTA;
             switch (vectorBitSize()) {
                 case 64: return Int64Vector.IOTA;
                 case 128: return Int128Vector.IOTA;
@@ -4047,8 +4270,8 @@ public abstract class IntVector extends AbstractVector<Integer> {
         @Override
         @ForceInline
         public final VectorMask<Integer> maskAll(boolean bit) {
-            if ((Class<?>) vectorType() == IntMaxVector.class)
-                return IntMaxVector.IntMaxMask.maskAll(bit);
+            //if ((Class<?>) vectorType() == IntMaxVector.class)
+            //    return IntMaxVector.IntMaxMask.maskAll(bit);
             switch (vectorBitSize()) {
                 case 64: return Int64Vector.Int64Mask.maskAll(bit);
                 case 128: return Int128Vector.Int128Mask.maskAll(bit);
@@ -4057,6 +4280,16 @@ public abstract class IntVector extends AbstractVector<Integer> {
             }
             throw new AssertionError();
         }
+
+        @Override
+        Object iotaArray() {
+            int laneCount = laneCount();
+            int [] init = new int[laneCount];
+            for (int i = 0; i < laneCount; i++) {
+                init[i] = (int)i;
+            }
+           return VectorSupport.VectorPayloadMF.createNewInstanceI(elementType(), laneCount, init);
+        }
     }
 
     /**
@@ -4073,7 +4306,7 @@ public abstract class IntVector extends AbstractVector<Integer> {
             case VectorShape.SK_128_BIT: return (IntSpecies) SPECIES_128;
             case VectorShape.SK_256_BIT: return (IntSpecies) SPECIES_256;
             case VectorShape.SK_512_BIT: return (IntSpecies) SPECIES_512;
-            case VectorShape.SK_Max_BIT: return (IntSpecies) SPECIES_MAX;
+            //case VectorShape.SK_Max_BIT: return (IntSpecies) SPECIES_MAX;
             default: throw new IllegalArgumentException("Bad shape: " + s);
         }
     }
@@ -4107,11 +4340,12 @@ public abstract class IntVector extends AbstractVector<Integer> {
                             Int512Vector::new);
 
     /** Species representing {@link IntVector}s of {@link VectorShape#S_Max_BIT VectorShape.S_Max_BIT}. */
-    public static final VectorSpecies<Integer> SPECIES_MAX
+    /*public static final VectorSpecies<Integer> SPECIES_MAX
         = new IntSpecies(VectorShape.S_Max_BIT,
                             IntMaxVector.class,
                             IntMaxVector.IntMaxMask.class,
                             IntMaxVector::new);
+     */
 
     /**
      * Preferred species for {@link IntVector}s.
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long128Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long128Vector.java
index ff08bd64b39..3fbb45c5b5f 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long128Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long128Vector.java
@@ -39,7 +39,7 @@ import static jdk.incubator.vector.VectorOperators.*;
 // -- This file was mechanically generated: Do not edit! -- //
 
 @SuppressWarnings("cast")  // warning: redundant cast
-final class Long128Vector extends LongVector {
+value class Long128Vector extends LongVector {
     static final LongSpecies VSPECIES =
         (LongSpecies) LongVector.SPECIES_128;
 
@@ -54,24 +54,40 @@ final class Long128Vector extends LongVector {
 
     static final Class<Long> ETYPE = long.class; // used by the JVM
 
-    Long128Vector(long[] v) {
+    /*Long128Vector(long[] v) {
         super(v);
+    }*/
+
+    private final VectorSupport.Long128VectorPayload mf_storage;
+
+    Long128Vector(Object value) {
+        this.mf_storage = (VectorSupport.Long128VectorPayload)value;
+    }
+
+    VectorSupport.VectorPayloadMF vec_mf() {
+        return mf_storage;
+    }
+
+    @Override
+    protected final Object getPayload() {
+       return vec_mf();
     }
 
     // For compatibility as Long128Vector::new,
     // stored into species.vectorFactory.
-    Long128Vector(Object v) {
+    /*Long128Vector(Object v) {
         this((long[]) v);
-    }
+    }*/
 
-    static final Long128Vector ZERO = new Long128Vector(new long[VLENGTH]);
+    static final Long128Vector ZERO = new Long128Vector(VectorSupport.VectorPayloadMF.createNewInstanceL(long.class, 2, Long.valueOf((long)0)));
     static final Long128Vector IOTA = new Long128Vector(VSPECIES.iotaArray());
 
     static {
         // Warm up a few species caches.
         // If we do this too much we will
         // get NPEs from bootstrap circularity.
-        VSPECIES.dummyVector();
+        // VSPECIES.dummyVector();
+        VSPECIES.dummyVectorMF();
         VSPECIES.withLanes(LaneType.BYTE);
     }
 
@@ -166,6 +182,13 @@ final class Long128Vector extends LongVector {
         return new Long128Vector(vec);
     }
 
+    // Make a vector of the same species but the given elements:
+    @ForceInline
+    final @Override
+    Long128Vector vectorFactory(VectorSupport.VectorPayloadMF vec) {
+        return new Long128Vector(vec);
+    }
+
     @ForceInline
     final @Override
     Byte128Vector asByteVectorRaw() {
@@ -201,6 +224,12 @@ final class Long128Vector extends LongVector {
         return (Long128Vector) super.bOpTemplate((Long128Vector)v, f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Long128Vector bOpMF(Vector<Long> v, FBinOp f) {
+        return (Long128Vector) super.bOpTemplateMF((Long128Vector)v, f);  // specialize
+    }
+
     @ForceInline
     final @Override
     Long128Vector bOp(Vector<Long> v,
@@ -210,6 +239,15 @@ final class Long128Vector extends LongVector {
                               f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Long128Vector bOpMF(Vector<Long> v,
+                     VectorMask<Long> m, FBinOp f) {
+        return (Long128Vector)
+            super.bOpTemplateMF((Long128Vector)v, (Long128Mask)m,
+                              f);  // specialize
+    }
+
     // Ternary operator
 
     @ForceInline
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long256Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long256Vector.java
index ed62368f40a..934f6922208 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long256Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long256Vector.java
@@ -39,7 +39,7 @@ import static jdk.incubator.vector.VectorOperators.*;
 // -- This file was mechanically generated: Do not edit! -- //
 
 @SuppressWarnings("cast")  // warning: redundant cast
-final class Long256Vector extends LongVector {
+value class Long256Vector extends LongVector {
     static final LongSpecies VSPECIES =
         (LongSpecies) LongVector.SPECIES_256;
 
@@ -54,24 +54,40 @@ final class Long256Vector extends LongVector {
 
     static final Class<Long> ETYPE = long.class; // used by the JVM
 
-    Long256Vector(long[] v) {
+    /*Long256Vector(long[] v) {
         super(v);
+    }*/
+
+    private final VectorSupport.Long256VectorPayload mf_storage;
+
+    Long256Vector(Object value) {
+        this.mf_storage = (VectorSupport.Long256VectorPayload)value;
+    }
+
+    VectorSupport.VectorPayloadMF vec_mf() {
+        return mf_storage;
+    }
+
+    @Override
+    protected final Object getPayload() {
+       return vec_mf();
     }
 
     // For compatibility as Long256Vector::new,
     // stored into species.vectorFactory.
-    Long256Vector(Object v) {
+    /*Long256Vector(Object v) {
         this((long[]) v);
-    }
+    }*/
 
-    static final Long256Vector ZERO = new Long256Vector(new long[VLENGTH]);
+    static final Long256Vector ZERO = new Long256Vector(VectorSupport.VectorPayloadMF.createNewInstanceL(long.class, 4, Long.valueOf((long)0)));
     static final Long256Vector IOTA = new Long256Vector(VSPECIES.iotaArray());
 
     static {
         // Warm up a few species caches.
         // If we do this too much we will
         // get NPEs from bootstrap circularity.
-        VSPECIES.dummyVector();
+        // VSPECIES.dummyVector();
+        VSPECIES.dummyVectorMF();
         VSPECIES.withLanes(LaneType.BYTE);
     }
 
@@ -166,6 +182,13 @@ final class Long256Vector extends LongVector {
         return new Long256Vector(vec);
     }
 
+    // Make a vector of the same species but the given elements:
+    @ForceInline
+    final @Override
+    Long256Vector vectorFactory(VectorSupport.VectorPayloadMF vec) {
+        return new Long256Vector(vec);
+    }
+
     @ForceInline
     final @Override
     Byte256Vector asByteVectorRaw() {
@@ -201,6 +224,12 @@ final class Long256Vector extends LongVector {
         return (Long256Vector) super.bOpTemplate((Long256Vector)v, f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Long256Vector bOpMF(Vector<Long> v, FBinOp f) {
+        return (Long256Vector) super.bOpTemplateMF((Long256Vector)v, f);  // specialize
+    }
+
     @ForceInline
     final @Override
     Long256Vector bOp(Vector<Long> v,
@@ -210,6 +239,15 @@ final class Long256Vector extends LongVector {
                               f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Long256Vector bOpMF(Vector<Long> v,
+                     VectorMask<Long> m, FBinOp f) {
+        return (Long256Vector)
+            super.bOpTemplateMF((Long256Vector)v, (Long256Mask)m,
+                              f);  // specialize
+    }
+
     // Ternary operator
 
     @ForceInline
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long512Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long512Vector.java
index 290369a6874..59f74a52495 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long512Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long512Vector.java
@@ -39,7 +39,7 @@ import static jdk.incubator.vector.VectorOperators.*;
 // -- This file was mechanically generated: Do not edit! -- //
 
 @SuppressWarnings("cast")  // warning: redundant cast
-final class Long512Vector extends LongVector {
+value class Long512Vector extends LongVector {
     static final LongSpecies VSPECIES =
         (LongSpecies) LongVector.SPECIES_512;
 
@@ -54,24 +54,40 @@ final class Long512Vector extends LongVector {
 
     static final Class<Long> ETYPE = long.class; // used by the JVM
 
-    Long512Vector(long[] v) {
+    /*Long512Vector(long[] v) {
         super(v);
+    }*/
+
+    private final VectorSupport.Long512VectorPayload mf_storage;
+
+    Long512Vector(Object value) {
+        this.mf_storage = (VectorSupport.Long512VectorPayload)value;
+    }
+
+    VectorSupport.VectorPayloadMF vec_mf() {
+        return mf_storage;
+    }
+
+    @Override
+    protected final Object getPayload() {
+       return vec_mf();
     }
 
     // For compatibility as Long512Vector::new,
     // stored into species.vectorFactory.
-    Long512Vector(Object v) {
+    /*Long512Vector(Object v) {
         this((long[]) v);
-    }
+    }*/
 
-    static final Long512Vector ZERO = new Long512Vector(new long[VLENGTH]);
+    static final Long512Vector ZERO = new Long512Vector(VectorSupport.VectorPayloadMF.createNewInstanceL(long.class, 8, Long.valueOf((long)0)));
     static final Long512Vector IOTA = new Long512Vector(VSPECIES.iotaArray());
 
     static {
         // Warm up a few species caches.
         // If we do this too much we will
         // get NPEs from bootstrap circularity.
-        VSPECIES.dummyVector();
+        // VSPECIES.dummyVector();
+        VSPECIES.dummyVectorMF();
         VSPECIES.withLanes(LaneType.BYTE);
     }
 
@@ -166,6 +182,13 @@ final class Long512Vector extends LongVector {
         return new Long512Vector(vec);
     }
 
+    // Make a vector of the same species but the given elements:
+    @ForceInline
+    final @Override
+    Long512Vector vectorFactory(VectorSupport.VectorPayloadMF vec) {
+        return new Long512Vector(vec);
+    }
+
     @ForceInline
     final @Override
     Byte512Vector asByteVectorRaw() {
@@ -201,6 +224,12 @@ final class Long512Vector extends LongVector {
         return (Long512Vector) super.bOpTemplate((Long512Vector)v, f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Long512Vector bOpMF(Vector<Long> v, FBinOp f) {
+        return (Long512Vector) super.bOpTemplateMF((Long512Vector)v, f);  // specialize
+    }
+
     @ForceInline
     final @Override
     Long512Vector bOp(Vector<Long> v,
@@ -210,6 +239,15 @@ final class Long512Vector extends LongVector {
                               f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Long512Vector bOpMF(Vector<Long> v,
+                     VectorMask<Long> m, FBinOp f) {
+        return (Long512Vector)
+            super.bOpTemplateMF((Long512Vector)v, (Long512Mask)m,
+                              f);  // specialize
+    }
+
     // Ternary operator
 
     @ForceInline
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long64Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long64Vector.java
index dfb438bf6ee..504debe3321 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long64Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Long64Vector.java
@@ -39,7 +39,7 @@ import static jdk.incubator.vector.VectorOperators.*;
 // -- This file was mechanically generated: Do not edit! -- //
 
 @SuppressWarnings("cast")  // warning: redundant cast
-final class Long64Vector extends LongVector {
+value class Long64Vector extends LongVector {
     static final LongSpecies VSPECIES =
         (LongSpecies) LongVector.SPECIES_64;
 
@@ -54,24 +54,40 @@ final class Long64Vector extends LongVector {
 
     static final Class<Long> ETYPE = long.class; // used by the JVM
 
-    Long64Vector(long[] v) {
+    /*Long64Vector(long[] v) {
         super(v);
+    }*/
+
+    private final VectorSupport.Long64VectorPayload mf_storage;
+
+    Long64Vector(Object value) {
+        this.mf_storage = (VectorSupport.Long64VectorPayload)value;
+    }
+
+    VectorSupport.VectorPayloadMF vec_mf() {
+        return mf_storage;
+    }
+
+    @Override
+    protected final Object getPayload() {
+       return vec_mf();
     }
 
     // For compatibility as Long64Vector::new,
     // stored into species.vectorFactory.
-    Long64Vector(Object v) {
+    /*Long64Vector(Object v) {
         this((long[]) v);
-    }
+    }*/
 
-    static final Long64Vector ZERO = new Long64Vector(new long[VLENGTH]);
+    static final Long64Vector ZERO = new Long64Vector(VectorSupport.VectorPayloadMF.createNewInstanceL(long.class, 1, Long.valueOf((long)0)));
     static final Long64Vector IOTA = new Long64Vector(VSPECIES.iotaArray());
 
     static {
         // Warm up a few species caches.
         // If we do this too much we will
         // get NPEs from bootstrap circularity.
-        VSPECIES.dummyVector();
+        // VSPECIES.dummyVector();
+        VSPECIES.dummyVectorMF();
         VSPECIES.withLanes(LaneType.BYTE);
     }
 
@@ -166,6 +182,13 @@ final class Long64Vector extends LongVector {
         return new Long64Vector(vec);
     }
 
+    // Make a vector of the same species but the given elements:
+    @ForceInline
+    final @Override
+    Long64Vector vectorFactory(VectorSupport.VectorPayloadMF vec) {
+        return new Long64Vector(vec);
+    }
+
     @ForceInline
     final @Override
     Byte64Vector asByteVectorRaw() {
@@ -201,6 +224,12 @@ final class Long64Vector extends LongVector {
         return (Long64Vector) super.bOpTemplate((Long64Vector)v, f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Long64Vector bOpMF(Vector<Long> v, FBinOp f) {
+        return (Long64Vector) super.bOpTemplateMF((Long64Vector)v, f);  // specialize
+    }
+
     @ForceInline
     final @Override
     Long64Vector bOp(Vector<Long> v,
@@ -210,6 +239,15 @@ final class Long64Vector extends LongVector {
                               f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Long64Vector bOpMF(Vector<Long> v,
+                     VectorMask<Long> m, FBinOp f) {
+        return (Long64Vector)
+            super.bOpTemplateMF((Long64Vector)v, (Long64Mask)m,
+                              f);  // specialize
+    }
+
     // Ternary operator
 
     @ForceInline
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/LongMaxVector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/LongMaxVector.java
deleted file mode 100644
index abcc2294d12..00000000000
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/LongMaxVector.java
+++ /dev/null
@@ -1,903 +0,0 @@
-/*
- * Copyright (c) 2017, 2022, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package jdk.incubator.vector;
-
-import java.lang.foreign.MemorySegment;
-import java.util.Arrays;
-import java.util.Objects;
-import java.util.function.IntUnaryOperator;
-
-import jdk.internal.vm.annotation.ForceInline;
-import jdk.internal.vm.vector.VectorSupport;
-
-import static jdk.internal.vm.vector.VectorSupport.*;
-
-import static jdk.incubator.vector.VectorOperators.*;
-
-// -- This file was mechanically generated: Do not edit! -- //
-
-@SuppressWarnings("cast")  // warning: redundant cast
-final class LongMaxVector extends LongVector {
-    static final LongSpecies VSPECIES =
-        (LongSpecies) LongVector.SPECIES_MAX;
-
-    static final VectorShape VSHAPE =
-        VSPECIES.vectorShape();
-
-    static final Class<LongMaxVector> VCLASS = LongMaxVector.class;
-
-    static final int VSIZE = VSPECIES.vectorBitSize();
-
-    static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
-
-    static final Class<Long> ETYPE = long.class; // used by the JVM
-
-    LongMaxVector(long[] v) {
-        super(v);
-    }
-
-    // For compatibility as LongMaxVector::new,
-    // stored into species.vectorFactory.
-    LongMaxVector(Object v) {
-        this((long[]) v);
-    }
-
-    static final LongMaxVector ZERO = new LongMaxVector(new long[VLENGTH]);
-    static final LongMaxVector IOTA = new LongMaxVector(VSPECIES.iotaArray());
-
-    static {
-        // Warm up a few species caches.
-        // If we do this too much we will
-        // get NPEs from bootstrap circularity.
-        VSPECIES.dummyVector();
-        VSPECIES.withLanes(LaneType.BYTE);
-    }
-
-    // Specialized extractors
-
-    @ForceInline
-    final @Override
-    public LongSpecies vspecies() {
-        // ISSUE:  This should probably be a @Stable
-        // field inside AbstractVector, rather than
-        // a megamorphic method.
-        return VSPECIES;
-    }
-
-    @ForceInline
-    @Override
-    public final Class<Long> elementType() { return long.class; }
-
-    @ForceInline
-    @Override
-    public final int elementSize() { return Long.SIZE; }
-
-    @ForceInline
-    @Override
-    public final VectorShape shape() { return VSHAPE; }
-
-    @ForceInline
-    @Override
-    public final int length() { return VLENGTH; }
-
-    @ForceInline
-    @Override
-    public final int bitSize() { return VSIZE; }
-
-    @ForceInline
-    @Override
-    public final int byteSize() { return VSIZE / Byte.SIZE; }
-
-    /*package-private*/
-    @ForceInline
-    final @Override
-    long[] vec() {
-        return (long[])getPayload();
-    }
-
-    // Virtualized constructors
-
-    @Override
-    @ForceInline
-    public final LongMaxVector broadcast(long e) {
-        return (LongMaxVector) super.broadcastTemplate(e);  // specialize
-    }
-
-
-    @Override
-    @ForceInline
-    LongMaxMask maskFromArray(boolean[] bits) {
-        return new LongMaxMask(bits);
-    }
-
-    @Override
-    @ForceInline
-    LongMaxShuffle iotaShuffle() { return LongMaxShuffle.IOTA; }
-
-    @ForceInline
-    LongMaxShuffle iotaShuffle(int start, int step, boolean wrap) {
-      if (wrap) {
-        return (LongMaxShuffle)VectorSupport.shuffleIota(ETYPE, LongMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,
-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));
-      } else {
-        return (LongMaxShuffle)VectorSupport.shuffleIota(ETYPE, LongMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,
-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));
-      }
-    }
-
-    @Override
-    @ForceInline
-    LongMaxShuffle shuffleFromBytes(byte[] reorder) { return new LongMaxShuffle(reorder); }
-
-    @Override
-    @ForceInline
-    LongMaxShuffle shuffleFromArray(int[] indexes, int i) { return new LongMaxShuffle(indexes, i); }
-
-    @Override
-    @ForceInline
-    LongMaxShuffle shuffleFromOp(IntUnaryOperator fn) { return new LongMaxShuffle(fn); }
-
-    // Make a vector of the same species but the given elements:
-    @ForceInline
-    final @Override
-    LongMaxVector vectorFactory(long[] vec) {
-        return new LongMaxVector(vec);
-    }
-
-    @ForceInline
-    final @Override
-    ByteMaxVector asByteVectorRaw() {
-        return (ByteMaxVector) super.asByteVectorRawTemplate();  // specialize
-    }
-
-    @ForceInline
-    final @Override
-    AbstractVector<?> asVectorRaw(LaneType laneType) {
-        return super.asVectorRawTemplate(laneType);  // specialize
-    }
-
-    // Unary operator
-
-    @ForceInline
-    final @Override
-    LongMaxVector uOp(FUnOp f) {
-        return (LongMaxVector) super.uOpTemplate(f);  // specialize
-    }
-
-    @ForceInline
-    final @Override
-    LongMaxVector uOp(VectorMask<Long> m, FUnOp f) {
-        return (LongMaxVector)
-            super.uOpTemplate((LongMaxMask)m, f);  // specialize
-    }
-
-    // Binary operator
-
-    @ForceInline
-    final @Override
-    LongMaxVector bOp(Vector<Long> v, FBinOp f) {
-        return (LongMaxVector) super.bOpTemplate((LongMaxVector)v, f);  // specialize
-    }
-
-    @ForceInline
-    final @Override
-    LongMaxVector bOp(Vector<Long> v,
-                     VectorMask<Long> m, FBinOp f) {
-        return (LongMaxVector)
-            super.bOpTemplate((LongMaxVector)v, (LongMaxMask)m,
-                              f);  // specialize
-    }
-
-    // Ternary operator
-
-    @ForceInline
-    final @Override
-    LongMaxVector tOp(Vector<Long> v1, Vector<Long> v2, FTriOp f) {
-        return (LongMaxVector)
-            super.tOpTemplate((LongMaxVector)v1, (LongMaxVector)v2,
-                              f);  // specialize
-    }
-
-    @ForceInline
-    final @Override
-    LongMaxVector tOp(Vector<Long> v1, Vector<Long> v2,
-                     VectorMask<Long> m, FTriOp f) {
-        return (LongMaxVector)
-            super.tOpTemplate((LongMaxVector)v1, (LongMaxVector)v2,
-                              (LongMaxMask)m, f);  // specialize
-    }
-
-    @ForceInline
-    final @Override
-    long rOp(long v, VectorMask<Long> m, FBinOp f) {
-        return super.rOpTemplate(v, m, f);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final <F>
-    Vector<F> convertShape(VectorOperators.Conversion<Long,F> conv,
-                           VectorSpecies<F> rsp, int part) {
-        return super.convertShapeTemplate(conv, rsp, part);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final <F>
-    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {
-        return super.reinterpretShapeTemplate(toSpecies, part);  // specialize
-    }
-
-    // Specialized algebraic operations:
-
-    // The following definition forces a specialized version of this
-    // crucial method into the v-table of this class.  A call to add()
-    // will inline to a call to lanewise(ADD,), at which point the JIT
-    // intrinsic will have the opcode of ADD, plus all the metadata
-    // for this particular class, enabling it to generate precise
-    // code.
-    //
-    // There is probably no benefit to the JIT to specialize the
-    // masked or broadcast versions of the lanewise method.
-
-    @Override
-    @ForceInline
-    public LongMaxVector lanewise(Unary op) {
-        return (LongMaxVector) super.lanewiseTemplate(op);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public LongMaxVector lanewise(Unary op, VectorMask<Long> m) {
-        return (LongMaxVector) super.lanewiseTemplate(op, LongMaxMask.class, (LongMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public LongMaxVector lanewise(Binary op, Vector<Long> v) {
-        return (LongMaxVector) super.lanewiseTemplate(op, v);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public LongMaxVector lanewise(Binary op, Vector<Long> v, VectorMask<Long> m) {
-        return (LongMaxVector) super.lanewiseTemplate(op, LongMaxMask.class, v, (LongMaxMask) m);  // specialize
-    }
-
-    /*package-private*/
-    @Override
-    @ForceInline LongMaxVector
-    lanewiseShift(VectorOperators.Binary op, int e) {
-        return (LongMaxVector) super.lanewiseShiftTemplate(op, e);  // specialize
-    }
-
-    /*package-private*/
-    @Override
-    @ForceInline LongMaxVector
-    lanewiseShift(VectorOperators.Binary op, int e, VectorMask<Long> m) {
-        return (LongMaxVector) super.lanewiseShiftTemplate(op, LongMaxMask.class, e, (LongMaxMask) m);  // specialize
-    }
-
-    /*package-private*/
-    @Override
-    @ForceInline
-    public final
-    LongMaxVector
-    lanewise(Ternary op, Vector<Long> v1, Vector<Long> v2) {
-        return (LongMaxVector) super.lanewiseTemplate(op, v1, v2);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final
-    LongMaxVector
-    lanewise(Ternary op, Vector<Long> v1, Vector<Long> v2, VectorMask<Long> m) {
-        return (LongMaxVector) super.lanewiseTemplate(op, LongMaxMask.class, v1, v2, (LongMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final
-    LongMaxVector addIndex(int scale) {
-        return (LongMaxVector) super.addIndexTemplate(scale);  // specialize
-    }
-
-    // Type specific horizontal reductions
-
-    @Override
-    @ForceInline
-    public final long reduceLanes(VectorOperators.Associative op) {
-        return super.reduceLanesTemplate(op);  // specialized
-    }
-
-    @Override
-    @ForceInline
-    public final long reduceLanes(VectorOperators.Associative op,
-                                    VectorMask<Long> m) {
-        return super.reduceLanesTemplate(op, LongMaxMask.class, (LongMaxMask) m);  // specialized
-    }
-
-    @Override
-    @ForceInline
-    public final long reduceLanesToLong(VectorOperators.Associative op) {
-        return (long) super.reduceLanesTemplate(op);  // specialized
-    }
-
-    @Override
-    @ForceInline
-    public final long reduceLanesToLong(VectorOperators.Associative op,
-                                        VectorMask<Long> m) {
-        return (long) super.reduceLanesTemplate(op, LongMaxMask.class, (LongMaxMask) m);  // specialized
-    }
-
-    @ForceInline
-    public VectorShuffle<Long> toShuffle() {
-        return super.toShuffleTemplate(LongMaxShuffle.class); // specialize
-    }
-
-    // Specialized unary testing
-
-    @Override
-    @ForceInline
-    public final LongMaxMask test(Test op) {
-        return super.testTemplate(LongMaxMask.class, op);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final LongMaxMask test(Test op, VectorMask<Long> m) {
-        return super.testTemplate(LongMaxMask.class, op, (LongMaxMask) m);  // specialize
-    }
-
-    // Specialized comparisons
-
-    @Override
-    @ForceInline
-    public final LongMaxMask compare(Comparison op, Vector<Long> v) {
-        return super.compareTemplate(LongMaxMask.class, op, v);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final LongMaxMask compare(Comparison op, long s) {
-        return super.compareTemplate(LongMaxMask.class, op, s);  // specialize
-    }
-
-
-    @Override
-    @ForceInline
-    public final LongMaxMask compare(Comparison op, Vector<Long> v, VectorMask<Long> m) {
-        return super.compareTemplate(LongMaxMask.class, op, v, (LongMaxMask) m);
-    }
-
-
-    @Override
-    @ForceInline
-    public LongMaxVector blend(Vector<Long> v, VectorMask<Long> m) {
-        return (LongMaxVector)
-            super.blendTemplate(LongMaxMask.class,
-                                (LongMaxVector) v,
-                                (LongMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public LongMaxVector slice(int origin, Vector<Long> v) {
-        return (LongMaxVector) super.sliceTemplate(origin, v);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public LongMaxVector slice(int origin) {
-        return (LongMaxVector) super.sliceTemplate(origin);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public LongMaxVector unslice(int origin, Vector<Long> w, int part) {
-        return (LongMaxVector) super.unsliceTemplate(origin, w, part);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public LongMaxVector unslice(int origin, Vector<Long> w, int part, VectorMask<Long> m) {
-        return (LongMaxVector)
-            super.unsliceTemplate(LongMaxMask.class,
-                                  origin, w, part,
-                                  (LongMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public LongMaxVector unslice(int origin) {
-        return (LongMaxVector) super.unsliceTemplate(origin);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public LongMaxVector rearrange(VectorShuffle<Long> s) {
-        return (LongMaxVector)
-            super.rearrangeTemplate(LongMaxShuffle.class,
-                                    (LongMaxShuffle) s);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public LongMaxVector rearrange(VectorShuffle<Long> shuffle,
-                                  VectorMask<Long> m) {
-        return (LongMaxVector)
-            super.rearrangeTemplate(LongMaxShuffle.class,
-                                    LongMaxMask.class,
-                                    (LongMaxShuffle) shuffle,
-                                    (LongMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public LongMaxVector rearrange(VectorShuffle<Long> s,
-                                  Vector<Long> v) {
-        return (LongMaxVector)
-            super.rearrangeTemplate(LongMaxShuffle.class,
-                                    (LongMaxShuffle) s,
-                                    (LongMaxVector) v);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public LongMaxVector compress(VectorMask<Long> m) {
-        return (LongMaxVector)
-            super.compressTemplate(LongMaxMask.class,
-                                   (LongMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public LongMaxVector expand(VectorMask<Long> m) {
-        return (LongMaxVector)
-            super.expandTemplate(LongMaxMask.class,
-                                   (LongMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public LongMaxVector selectFrom(Vector<Long> v) {
-        return (LongMaxVector)
-            super.selectFromTemplate((LongMaxVector) v);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public LongMaxVector selectFrom(Vector<Long> v,
-                                   VectorMask<Long> m) {
-        return (LongMaxVector)
-            super.selectFromTemplate((LongMaxVector) v,
-                                     (LongMaxMask) m);  // specialize
-    }
-
-
-    @ForceInline
-    @Override
-    public long lane(int i) {
-        if (i < 0 || i >= VLENGTH) {
-            throw new IllegalArgumentException("Index " + i + " must be zero or positive, and less than " + VLENGTH);
-        }
-        return laneHelper(i);
-    }
-
-    public long laneHelper(int i) {
-        return (long) VectorSupport.extract(
-                                VCLASS, ETYPE, VLENGTH,
-                                this, i,
-                                (vec, ix) -> {
-                                    long[] vecarr = vec.vec();
-                                    return (long)vecarr[ix];
-                                });
-    }
-
-    @ForceInline
-    @Override
-    public LongMaxVector withLane(int i, long e) {
-        if (i < 0 || i >= VLENGTH) {
-            throw new IllegalArgumentException("Index " + i + " must be zero or positive, and less than " + VLENGTH);
-        }
-        return withLaneHelper(i, e);
-    }
-
-    public LongMaxVector withLaneHelper(int i, long e) {
-        return VectorSupport.insert(
-                                VCLASS, ETYPE, VLENGTH,
-                                this, i, (long)e,
-                                (v, ix, bits) -> {
-                                    long[] res = v.vec().clone();
-                                    res[ix] = (long)bits;
-                                    return v.vectorFactory(res);
-                                });
-    }
-
-    // Mask
-
-    static final class LongMaxMask extends AbstractMask<Long> {
-        static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
-        static final Class<Long> ETYPE = long.class; // used by the JVM
-
-        LongMaxMask(boolean[] bits) {
-            this(bits, 0);
-        }
-
-        LongMaxMask(boolean[] bits, int offset) {
-            super(prepare(bits, offset));
-        }
-
-        LongMaxMask(boolean val) {
-            super(prepare(val));
-        }
-
-        private static boolean[] prepare(boolean[] bits, int offset) {
-            boolean[] newBits = new boolean[VSPECIES.laneCount()];
-            for (int i = 0; i < newBits.length; i++) {
-                newBits[i] = bits[offset + i];
-            }
-            return newBits;
-        }
-
-        private static boolean[] prepare(boolean val) {
-            boolean[] bits = new boolean[VSPECIES.laneCount()];
-            Arrays.fill(bits, val);
-            return bits;
-        }
-
-        @ForceInline
-        final @Override
-        public LongSpecies vspecies() {
-            // ISSUE:  This should probably be a @Stable
-            // field inside AbstractMask, rather than
-            // a megamorphic method.
-            return VSPECIES;
-        }
-
-        @ForceInline
-        boolean[] getBits() {
-            return (boolean[])getPayload();
-        }
-
-        @Override
-        LongMaxMask uOp(MUnOp f) {
-            boolean[] res = new boolean[vspecies().laneCount()];
-            boolean[] bits = getBits();
-            for (int i = 0; i < res.length; i++) {
-                res[i] = f.apply(i, bits[i]);
-            }
-            return new LongMaxMask(res);
-        }
-
-        @Override
-        LongMaxMask bOp(VectorMask<Long> m, MBinOp f) {
-            boolean[] res = new boolean[vspecies().laneCount()];
-            boolean[] bits = getBits();
-            boolean[] mbits = ((LongMaxMask)m).getBits();
-            for (int i = 0; i < res.length; i++) {
-                res[i] = f.apply(i, bits[i], mbits[i]);
-            }
-            return new LongMaxMask(res);
-        }
-
-        @ForceInline
-        @Override
-        public final
-        LongMaxVector toVector() {
-            return (LongMaxVector) super.toVectorTemplate();  // specialize
-        }
-
-        /**
-         * Helper function for lane-wise mask conversions.
-         * This function kicks in after intrinsic failure.
-         */
-        @ForceInline
-        private final <E>
-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {
-            if (length() != dsp.laneCount())
-                throw new IllegalArgumentException("VectorMask length and species length differ");
-            boolean[] maskArray = toArray();
-            return  dsp.maskFactory(maskArray).check(dsp);
-        }
-
-        @Override
-        @ForceInline
-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;
-            if (length() != species.laneCount())
-                throw new IllegalArgumentException("VectorMask length and species length differ");
-
-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,
-                this.getClass(), ETYPE, VLENGTH,
-                species.maskType(), species.elementType(), VLENGTH,
-                this, species,
-                (m, s) -> s.maskFactory(m.toArray()).check(s));
-        }
-
-        @Override
-        @ForceInline
-        public LongMaxMask eq(VectorMask<Long> mask) {
-            Objects.requireNonNull(mask);
-            LongMaxMask m = (LongMaxMask)mask;
-            return xor(m.not());
-        }
-
-        // Unary operations
-
-        @Override
-        @ForceInline
-        public LongMaxMask not() {
-            return xor(maskAll(true));
-        }
-
-        @Override
-        @ForceInline
-        public LongMaxMask compress() {
-            return (LongMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                LongMaxVector.class, LongMaxMask.class, ETYPE, VLENGTH, null, this,
-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
-        }
-
-
-        // Binary operations
-
-        @Override
-        @ForceInline
-        public LongMaxMask and(VectorMask<Long> mask) {
-            Objects.requireNonNull(mask);
-            LongMaxMask m = (LongMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, LongMaxMask.class, null, long.class, VLENGTH,
-                                          this, m, null,
-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
-        }
-
-        @Override
-        @ForceInline
-        public LongMaxMask or(VectorMask<Long> mask) {
-            Objects.requireNonNull(mask);
-            LongMaxMask m = (LongMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, LongMaxMask.class, null, long.class, VLENGTH,
-                                          this, m, null,
-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
-        }
-
-        @ForceInline
-        /* package-private */
-        LongMaxMask xor(VectorMask<Long> mask) {
-            Objects.requireNonNull(mask);
-            LongMaxMask m = (LongMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, LongMaxMask.class, null, long.class, VLENGTH,
-                                          this, m, null,
-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
-        }
-
-        // Mask Query operations
-
-        @Override
-        @ForceInline
-        public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, LongMaxMask.class, long.class, VLENGTH, this,
-                                                      (m) -> trueCountHelper(m.getBits()));
-        }
-
-        @Override
-        @ForceInline
-        public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, LongMaxMask.class, long.class, VLENGTH, this,
-                                                      (m) -> firstTrueHelper(m.getBits()));
-        }
-
-        @Override
-        @ForceInline
-        public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, LongMaxMask.class, long.class, VLENGTH, this,
-                                                      (m) -> lastTrueHelper(m.getBits()));
-        }
-
-        @Override
-        @ForceInline
-        public long toLong() {
-            if (length() > Long.SIZE) {
-                throw new UnsupportedOperationException("too many lanes for one long");
-            }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, LongMaxMask.class, long.class, VLENGTH, this,
-                                                      (m) -> toLongHelper(m.getBits()));
-        }
-
-        // Reductions
-
-        @Override
-        @ForceInline
-        public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, LongMaxMask.class, long.class, VLENGTH,
-                                         this, vspecies().maskAll(true),
-                                         (m, __) -> anyTrueHelper(((LongMaxMask)m).getBits()));
-        }
-
-        @Override
-        @ForceInline
-        public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, LongMaxMask.class, long.class, VLENGTH,
-                                         this, vspecies().maskAll(true),
-                                         (m, __) -> allTrueHelper(((LongMaxMask)m).getBits()));
-        }
-
-        @ForceInline
-        /*package-private*/
-        static LongMaxMask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(LongMaxMask.class, long.class, VLENGTH,
-                                                 (bit ? -1 : 0), MODE_BROADCAST, null,
-                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
-        }
-        private static final LongMaxMask  TRUE_MASK = new LongMaxMask(true);
-        private static final LongMaxMask FALSE_MASK = new LongMaxMask(false);
-
-    }
-
-    // Shuffle
-
-    static final class LongMaxShuffle extends AbstractShuffle<Long> {
-        static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
-        static final Class<Long> ETYPE = long.class; // used by the JVM
-
-        LongMaxShuffle(byte[] reorder) {
-            super(VLENGTH, reorder);
-        }
-
-        public LongMaxShuffle(int[] reorder) {
-            super(VLENGTH, reorder);
-        }
-
-        public LongMaxShuffle(int[] reorder, int i) {
-            super(VLENGTH, reorder, i);
-        }
-
-        public LongMaxShuffle(IntUnaryOperator fn) {
-            super(VLENGTH, fn);
-        }
-
-        @Override
-        public LongSpecies vspecies() {
-            return VSPECIES;
-        }
-
-        static {
-            // There must be enough bits in the shuffle lanes to encode
-            // VLENGTH valid indexes and VLENGTH exceptional ones.
-            assert(VLENGTH < Byte.MAX_VALUE);
-            assert(Byte.MIN_VALUE <= -VLENGTH);
-        }
-        static final LongMaxShuffle IOTA = new LongMaxShuffle(IDENTITY);
-
-        @Override
-        @ForceInline
-        public LongMaxVector toVector() {
-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, LongMaxShuffle.class, this, VLENGTH,
-                                                    (s) -> ((LongMaxVector)(((AbstractShuffle<Long>)(s)).toVectorTemplate())));
-        }
-
-        @Override
-        @ForceInline
-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {
-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;
-            if (length() != species.laneCount())
-                throw new IllegalArgumentException("VectorShuffle length and species length differ");
-            int[] shuffleArray = toArray();
-            return s.shuffleFromArray(shuffleArray, 0).check(s);
-        }
-
-        @ForceInline
-        @Override
-        public LongMaxShuffle rearrange(VectorShuffle<Long> shuffle) {
-            LongMaxShuffle s = (LongMaxShuffle) shuffle;
-            byte[] reorder1 = reorder();
-            byte[] reorder2 = s.reorder();
-            byte[] r = new byte[reorder1.length];
-            for (int i = 0; i < reorder1.length; i++) {
-                int ssi = reorder2[i];
-                r[i] = reorder1[ssi];  // throws on exceptional index
-            }
-            return new LongMaxShuffle(r);
-        }
-    }
-
-    // ================================================
-
-    // Specialized low-level memory operations.
-
-    @ForceInline
-    @Override
-    final
-    LongVector fromArray0(long[] a, int offset) {
-        return super.fromArray0Template(a, offset);  // specialize
-    }
-
-    @ForceInline
-    @Override
-    final
-    LongVector fromArray0(long[] a, int offset, VectorMask<Long> m, int offsetInRange) {
-        return super.fromArray0Template(LongMaxMask.class, a, offset, (LongMaxMask) m, offsetInRange);  // specialize
-    }
-
-    @ForceInline
-    @Override
-    final
-    LongVector fromArray0(long[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Long> m) {
-        return super.fromArray0Template(LongMaxMask.class, a, offset, indexMap, mapOffset, (LongMaxMask) m);
-    }
-
-
-
-    @ForceInline
-    @Override
-    final
-    LongVector fromMemorySegment0(MemorySegment ms, long offset) {
-        return super.fromMemorySegment0Template(ms, offset);  // specialize
-    }
-
-    @ForceInline
-    @Override
-    final
-    LongVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Long> m, int offsetInRange) {
-        return super.fromMemorySegment0Template(LongMaxMask.class, ms, offset, (LongMaxMask) m, offsetInRange);  // specialize
-    }
-
-    @ForceInline
-    @Override
-    final
-    void intoArray0(long[] a, int offset) {
-        super.intoArray0Template(a, offset);  // specialize
-    }
-
-    @ForceInline
-    @Override
-    final
-    void intoArray0(long[] a, int offset, VectorMask<Long> m) {
-        super.intoArray0Template(LongMaxMask.class, a, offset, (LongMaxMask) m);
-    }
-
-    @ForceInline
-    @Override
-    final
-    void intoArray0(long[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Long> m) {
-        super.intoArray0Template(LongMaxMask.class, a, offset, indexMap, mapOffset, (LongMaxMask) m);
-    }
-
-
-    @ForceInline
-    @Override
-    final
-    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Long> m) {
-        super.intoMemorySegment0Template(LongMaxMask.class, ms, offset, (LongMaxMask) m);
-    }
-
-
-    // End of specialized low-level memory operations.
-
-    // ================================================
-
-}
-
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/LongVector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/LongVector.java
index 446d214a21b..b7ee9215c7a 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/LongVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/LongVector.java
@@ -51,9 +51,9 @@ import static jdk.incubator.vector.VectorOperators.*;
 @SuppressWarnings("cast")  // warning: redundant cast
 public abstract class LongVector extends AbstractVector<Long> {
 
-    LongVector(long[] vec) {
+    /*LongVector(long[] vec) {
         super(vec);
-    }
+    }*/
 
     static final int FORBID_OPCODE_KIND = VO_ONLYFP;
 
@@ -96,6 +96,8 @@ public abstract class LongVector extends AbstractVector<Long> {
     /*package-private*/
     abstract long[] vec();
 
+    abstract VectorSupport.VectorPayloadMF vec_mf();
+
     // Virtualized constructors
 
     /**
@@ -105,6 +107,17 @@ public abstract class LongVector extends AbstractVector<Long> {
     /*package-private*/
     abstract LongVector vectorFactory(long[] vec);
 
+    abstract LongVector vectorFactory(VectorSupport.VectorPayloadMF vec);
+
+    @ForceInline
+    public static
+    LongVector fromArray(VectorSpecies<Long> species,
+                                   long[] a, int offset) {
+        offset = checkFromIndexSize(offset, species.length(), a.length);
+        LongSpecies vsp = (LongSpecies) species;
+        return vsp.dummyVectorMF().fromArray0(a, offset);
+    }
+
     /**
      * Build a mask directly using my species.
      * It is an error if the array is aliased elsewhere.
@@ -210,6 +223,30 @@ public abstract class LongVector extends AbstractVector<Long> {
         return vectorFactory(res);
     }
 
+    /*package-private*/
+    abstract
+    LongVector bOpMF(Vector<Long> o,
+                             FBinOp f);
+    @ForceInline
+    final
+    LongVector bOpTemplateMF(Vector<Long> o,
+                                     FBinOp f) {
+        VectorSupport.VectorPayloadMF vec1 = this.vec_mf();
+        VectorSupport.VectorPayloadMF vec2 = this.vec_mf();
+        VectorSupport.VectorPayloadMF tpayload = 
+            Unsafe.getUnsafe().makePrivateBuffer(VectorSupport.VectorPayloadMF.createNewInstanceL(
+                   long.class, length(), Long.valueOf((long)0)));
+        long start_offset = tpayload.multiFieldOffset();
+        int length = tpayload.length();
+        for (int i = 0; i < length; i++) {
+            long v1 = Unsafe.getUnsafe().getLong(vec1, start_offset + i * Integer.BYTES);
+            long v2 = Unsafe.getUnsafe().getLong(vec2, start_offset + i * Integer.BYTES);
+            Unsafe.getUnsafe().putLong(tpayload, start_offset + i * Integer.BYTES, f.apply(i, v1, v2));
+        }
+        Unsafe.getUnsafe().finishPrivateBuffer(tpayload);
+        return vectorFactory(tpayload);
+    }
+
     /*package-private*/
     abstract
     LongVector bOp(Vector<Long> o,
@@ -233,6 +270,36 @@ public abstract class LongVector extends AbstractVector<Long> {
         return vectorFactory(res);
     }
 
+    /*package-private*/
+    abstract
+    LongVector bOpMF(Vector<Long> o,
+                             VectorMask<Long> m,
+                             FBinOp f);
+    @ForceInline
+    final
+    LongVector bOpTemplateMF(Vector<Long> o,
+                                     VectorMask<Long> m,
+                                     FBinOp f) {
+        if (m == null) {
+            return bOpTemplateMF(o, f);
+        }
+        boolean[] mbits = ((AbstractMask<Long>)m).getBits();
+        VectorSupport.VectorPayloadMF vec1 = this.vec_mf();
+        VectorSupport.VectorPayloadMF vec2 = this.vec_mf();
+        VectorSupport.VectorPayloadMF tpayload =
+            Unsafe.getUnsafe().makePrivateBuffer(VectorSupport.VectorPayloadMF.createNewInstanceL(
+                long.class, length(), Long.valueOf((long)0)));
+        long start_offset = tpayload.multiFieldOffset();
+        int length = tpayload.length();
+        for (int i = 0; i < length; i++) {
+            long v1 = Unsafe.getUnsafe().getLong(vec1, start_offset + i * Integer.BYTES);
+            long v2 = Unsafe.getUnsafe().getLong(vec2, start_offset + i * Integer.BYTES);
+            Unsafe.getUnsafe().putLong(tpayload, start_offset + i * Integer.BYTES, mbits[i] ? f.apply(i, v1, v2): v1);
+        }
+        Unsafe.getUnsafe().finishPrivateBuffer(tpayload);
+        return vectorFactory(tpayload);
+    }
+
     // Ternary operator
 
     /*package-private*/
@@ -353,6 +420,45 @@ public abstract class LongVector extends AbstractVector<Long> {
         return vectorFactory(res);
     }
 
+    /*package-private*/
+    @ForceInline
+    final
+    <M> LongVector ldOpMF(M memory, int offset,
+                                  FLdOp<M> f) {
+        VectorSupport.VectorPayloadMF tpayload =
+            Unsafe.getUnsafe().makePrivateBuffer(VectorSupport.VectorPayloadMF.createNewInstanceL(
+                long.class, length(), Long.valueOf((long)0)));
+        int length = tpayload.length();
+        long start_offset = tpayload.multiFieldOffset();
+        for (int i = 0; i < length; i++) {
+            Unsafe.getUnsafe().putLong(tpayload, start_offset + i * Integer.BYTES, f.apply(memory, offset, i));
+        }
+        Unsafe.getUnsafe().finishPrivateBuffer(tpayload);
+        return vectorFactory(tpayload);
+    }
+
+    /*package-private*/
+    @ForceInline
+    final
+    <M> LongVector ldOpMF(M memory, int offset,
+                                  VectorMask<Long> m,
+                                  FLdOp<M> f) {
+        VectorSupport.VectorPayloadMF tpayload =
+            Unsafe.getUnsafe().makePrivateBuffer(VectorSupport.VectorPayloadMF.createNewInstanceL(
+                long.class, length(), Long.valueOf((long)0)));
+        int length = tpayload.length();
+        long start_offset = tpayload.multiFieldOffset();
+        boolean[] mbits = ((AbstractMask<Long>)m).getBits();
+        for (int i = 0; i < length; i++) {
+            if (mbits[i]) {
+                Unsafe.getUnsafe().putLong(tpayload, start_offset + i * Integer.BYTES, f.apply(memory, offset, i));
+            }
+        }
+        Unsafe.getUnsafe().finishPrivateBuffer(tpayload);
+        return vectorFactory(tpayload);
+    }
+
+
     /*package-private*/
     interface FLdLongOp {
         long apply(MemorySegment memory, long offset, int i);
@@ -422,6 +528,37 @@ public abstract class LongVector extends AbstractVector<Long> {
         }
     }
 
+    /*package-private*/
+    @ForceInline
+    final
+    <M> void stOpMF(M memory, int offset,
+                  FStOp<M> f) {
+        VectorSupport.VectorPayloadMF vec = vec_mf();
+        long start_offset = vec.multiFieldOffset();
+        int length = vec.length();
+        for (int i = 0; i < length; i++) {
+            f.apply(memory, offset, i, Unsafe.getUnsafe().getLong(vec, start_offset + i * Integer.BYTES));
+        }
+    }
+
+    /*package-private*/
+   @ForceInline
+    final
+    <M> void stOpMF(M memory, int offset,
+                  VectorMask<Long> m,
+                  FStOp<M> f) {
+        VectorSupport.VectorPayloadMF vec = vec_mf();
+        boolean[] mbits = ((AbstractMask<Long>)m).getBits();
+        long start_offset = vec.multiFieldOffset();
+        int length = vec.length();
+        for (int i = 0; i < length; i++) {
+            if (mbits[i]) {
+                f.apply(memory, offset, i, Unsafe.getUnsafe().getLong(vec, start_offset + i * Integer.BYTES));
+            }
+        }
+    }
+
+
     interface FStLongOp {
         void apply(MemorySegment memory, long offset, int i, long a);
     }
@@ -738,11 +875,18 @@ public abstract class LongVector extends AbstractVector<Long> {
             }
         }
 
+        /*
         int opc = opCode(op);
         return VectorSupport.binaryOp(
             opc, getClass(), null, long.class, length(),
             this, that, null,
             BIN_IMPL.find(op, opc, LongVector::binaryOperations));
+        */
+        int opc = opCode(op);
+        return VectorSupport.binaryOp(
+            opc, getClass(), null, long.class, length(),
+            this, that, null,
+            BIN_IMPL.find(op, opc, LongVector::binaryOperationsMF));
     }
 
     /**
@@ -837,6 +981,25 @@ public abstract class LongVector extends AbstractVector<Long> {
         }
     }
 
+    private static BinaryOperation<LongVector, VectorMask<Long>> binaryOperationsMF(int opc_) {
+        switch (opc_) {
+            case VECTOR_OP_ADD: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)(a + b));
+            case VECTOR_OP_SUB: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)(a - b));
+            case VECTOR_OP_MUL: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)(a * b));
+            case VECTOR_OP_DIV: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)(a / b));
+            case VECTOR_OP_MAX: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)Math.max(a, b));
+            case VECTOR_OP_MIN: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)Math.min(a, b));
+            default: return null;
+        }
+    }
+
+
     // FIXME: Maybe all of the public final methods in this file (the
     // simple ones that just call lanewise) should be pushed down to
     // the X-VectorBits template.  They can't optimize properly at
@@ -2807,6 +2970,7 @@ public abstract class LongVector extends AbstractVector<Long> {
      *         if {@code offset+N < 0} or {@code offset+N >= a.length}
      *         for any lane {@code N} in the vector
      */
+    /*
     @ForceInline
     public static
     LongVector fromArray(VectorSpecies<Long> species,
@@ -2814,7 +2978,7 @@ public abstract class LongVector extends AbstractVector<Long> {
         offset = checkFromIndexSize(offset, species.length(), a.length);
         LongSpecies vsp = (LongSpecies) species;
         return vsp.dummyVector().fromArray0(a, offset);
-    }
+    }*/
 
     /**
      * Loads a vector from an array of type {@code long[]}
@@ -2898,7 +3062,7 @@ public abstract class LongVector extends AbstractVector<Long> {
         }
 
         // Index vector: vix[0:n] = k -> offset + indexMap[mapOffset + k]
-        IntVector vix;
+        IntVector vix = null;
         if (isp.laneCount() != vsp.laneCount()) {
             // For LongMaxVector,  if vector length is non-power-of-two or
             // 2048 bits, indexShape of Long species is S_MAX_BIT.
@@ -2907,9 +3071,11 @@ public abstract class LongVector extends AbstractVector<Long> {
             // indexShape is still S_MAX_BIT, but the lane count of int vector
             // is 64. So when loading index vector (IntVector), only lower half
             // of index data is needed.
-            vix = IntVector
+            /*vix = IntVector
                 .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)
                 .add(offset);
+             */
+             assert false : "Unhandled case";
         } else {
             vix = IntVector
                 .fromArray(isp, indexMap, mapOffset)
@@ -3104,6 +3270,7 @@ public abstract class LongVector extends AbstractVector<Long> {
     void intoArray(long[] a, int offset) {
         offset = checkFromIndexSize(offset, length(), a.length);
         LongSpecies vsp = vspecies();
+        /*
         VectorSupport.store(
             vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
             a, arrayAddress(a, offset),
@@ -3112,6 +3279,16 @@ public abstract class LongVector extends AbstractVector<Long> {
             (arr, off, v)
             -> v.stOp(arr, (int) off,
                       (arr_, off_, i, e) -> arr_[off_ + i] = e));
+         */
+        VectorSupport.store(
+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
+            a, arrayAddress(a, offset),
+            this,
+            a, offset,
+            (arr, off, v)
+            -> v.stOpMF(arr, (int) off,
+                      (arr_, off_, i, e) -> arr_[off_ + i] = e));
+
     }
 
     /**
@@ -3191,7 +3368,7 @@ public abstract class LongVector extends AbstractVector<Long> {
         }
 
         // Index vector: vix[0:n] = i -> offset + indexMap[mo + i]
-        IntVector vix;
+        IntVector vix = null;
         if (isp.laneCount() != vsp.laneCount()) {
             // For LongMaxVector,  if vector length  is 2048 bits, indexShape
             // of Long species is S_MAX_BIT. and the lane count of Long
@@ -3199,9 +3376,11 @@ public abstract class LongVector extends AbstractVector<Long> {
             // indexShape is still S_MAX_BIT, but the lane count of int vector
             // is 64. So when loading index vector (IntVector), only lower half
             // of index data is needed.
-            vix = IntVector
+            /*vix = IntVector
                 .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)
                 .add(offset);
+             */
+             assert false : "Unhandled case";
         } else {
             vix = IntVector
                 .fromArray(isp, indexMap, mapOffset)
@@ -3335,6 +3514,7 @@ public abstract class LongVector extends AbstractVector<Long> {
     LongVector fromArray0(long[] a, int offset);
     @ForceInline
     final
+    /*
     LongVector fromArray0Template(long[] a, int offset) {
         LongSpecies vsp = vspecies();
         return VectorSupport.load(
@@ -3343,6 +3523,16 @@ public abstract class LongVector extends AbstractVector<Long> {
             a, offset, vsp,
             (arr, off, s) -> s.ldOp(arr, (int) off,
                                     (arr_, off_, i) -> arr_[off_ + i]));
+    }*/
+
+    LongVector fromArray0Template(long[] a, int offset) {
+        LongSpecies vsp = vspecies();
+        return VectorSupport.load(
+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
+            a, arrayAddress(a, offset),
+            a, offset, vsp,
+            (arr, off, s) -> s.ldOpMF(arr, (int) off,
+                                    (arr_, off_, i) -> arr_[off_ + i]));
     }
 
     /*package-private*/
@@ -3384,7 +3574,7 @@ public abstract class LongVector extends AbstractVector<Long> {
         }
 
         // Index vector: vix[0:n] = k -> offset + indexMap[mapOffset + k]
-        IntVector vix;
+        IntVector vix = null;
         if (isp.laneCount() != vsp.laneCount()) {
             // For LongMaxVector,  if vector length is non-power-of-two or
             // 2048 bits, indexShape of Long species is S_MAX_BIT.
@@ -3393,9 +3583,11 @@ public abstract class LongVector extends AbstractVector<Long> {
             // indexShape is still S_MAX_BIT, but the lane count of int vector
             // is 64. So when loading index vector (IntVector), only lower half
             // of index data is needed.
-            vix = IntVector
+            /*vix = IntVector
                 .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)
                 .add(offset);
+             */
+            assert false : "Unhandled case";
         } else {
             vix = IntVector
                 .fromArray(isp, indexMap, mapOffset)
@@ -3500,7 +3692,7 @@ public abstract class LongVector extends AbstractVector<Long> {
         }
 
         // Index vector: vix[0:n] = i -> offset + indexMap[mo + i]
-        IntVector vix;
+        IntVector vix = null;
         if (isp.laneCount() != vsp.laneCount()) {
             // For LongMaxVector,  if vector length  is 2048 bits, indexShape
             // of Long species is S_MAX_BIT. and the lane count of Long
@@ -3508,9 +3700,12 @@ public abstract class LongVector extends AbstractVector<Long> {
             // indexShape is still S_MAX_BIT, but the lane count of int vector
             // is 64. So when loading index vector (IntVector), only lower half
             // of index data is needed.
-            vix = IntVector
+            /*vix = IntVector
                 .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)
                 .add(offset);
+             */
+             assert false : "Unhandled case";
+
         } else {
             vix = IntVector
                 .fromArray(isp, indexMap, mapOffset)
@@ -3844,6 +4039,12 @@ public abstract class LongVector extends AbstractVector<Long> {
             return (LongVector) super.dummyVector();
         }
 
+        @ForceInline
+        @Override final
+        LongVector dummyVectorMF() {
+            return (LongVector) super.dummyVectorMF();
+        }
+
         /*package-private*/
         final @Override
         @ForceInline
@@ -3890,6 +4091,22 @@ public abstract class LongVector extends AbstractVector<Long> {
             return dummyVector().ldOp(memory, offset, m, f);
         }
 
+        /*package-private*/
+        @ForceInline
+        <M> LongVector ldOpMF(M memory, int offset,
+                                      FLdOp<M> f) {
+            return dummyVectorMF().ldOpMF(memory, offset, f);
+        }
+
+        /*package-private*/
+        @ForceInline
+        <M> LongVector ldOpMF(M memory, int offset,
+                                      VectorMask<Long> m,
+                                      FLdOp<M> f) {
+            return dummyVectorMF().ldOpMF(memory, offset, m, f);
+        }
+
+
         /*package-private*/
         @ForceInline
         LongVector ldLongOp(MemorySegment memory, long offset,
@@ -3919,6 +4136,21 @@ public abstract class LongVector extends AbstractVector<Long> {
             dummyVector().stOp(memory, offset, m, f);
         }
 
+        /*package-private*/
+        @ForceInline
+        <M> void stOpMF(M memory, int offset, FStOp<M> f) {
+            dummyVectorMF().stOpMF(memory, offset, f);
+        }
+
+        /*package-private*/
+        @ForceInline
+        <M> void stOpMF(M memory, int offset,
+                     AbstractMask<Long> m,
+                      FStOp<M> f) {
+            dummyVectorMF().stOpMF(memory, offset, m, f);
+        }
+
+
         /*package-private*/
         @ForceInline
         void stLongOp(MemorySegment memory, long offset, FStLongOp f) {
@@ -3944,8 +4176,8 @@ public abstract class LongVector extends AbstractVector<Long> {
         @Override
         @ForceInline
         public final LongVector zero() {
-            if ((Class<?>) vectorType() == LongMaxVector.class)
-                return LongMaxVector.ZERO;
+            //if ((Class<?>) vectorType() == LongMaxVector.class)
+            //    return LongMaxVector.ZERO;
             switch (vectorBitSize()) {
                 case 64: return Long64Vector.ZERO;
                 case 128: return Long128Vector.ZERO;
@@ -3958,8 +4190,8 @@ public abstract class LongVector extends AbstractVector<Long> {
         @Override
         @ForceInline
         public final LongVector iota() {
-            if ((Class<?>) vectorType() == LongMaxVector.class)
-                return LongMaxVector.IOTA;
+            //if ((Class<?>) vectorType() == LongMaxVector.class)
+            //    return LongMaxVector.IOTA;
             switch (vectorBitSize()) {
                 case 64: return Long64Vector.IOTA;
                 case 128: return Long128Vector.IOTA;
@@ -3973,8 +4205,8 @@ public abstract class LongVector extends AbstractVector<Long> {
         @Override
         @ForceInline
         public final VectorMask<Long> maskAll(boolean bit) {
-            if ((Class<?>) vectorType() == LongMaxVector.class)
-                return LongMaxVector.LongMaxMask.maskAll(bit);
+            //if ((Class<?>) vectorType() == LongMaxVector.class)
+            //    return LongMaxVector.LongMaxMask.maskAll(bit);
             switch (vectorBitSize()) {
                 case 64: return Long64Vector.Long64Mask.maskAll(bit);
                 case 128: return Long128Vector.Long128Mask.maskAll(bit);
@@ -3983,6 +4215,16 @@ public abstract class LongVector extends AbstractVector<Long> {
             }
             throw new AssertionError();
         }
+
+        @Override
+        Object iotaArray() {
+            int laneCount = laneCount();
+            long [] init = new long[laneCount];
+            for (int i = 0; i < laneCount; i++) {
+                init[i] = (long)i;
+            }
+           return VectorSupport.VectorPayloadMF.createNewInstanceL(elementType(), laneCount, init);
+        }
     }
 
     /**
@@ -3999,7 +4241,7 @@ public abstract class LongVector extends AbstractVector<Long> {
             case VectorShape.SK_128_BIT: return (LongSpecies) SPECIES_128;
             case VectorShape.SK_256_BIT: return (LongSpecies) SPECIES_256;
             case VectorShape.SK_512_BIT: return (LongSpecies) SPECIES_512;
-            case VectorShape.SK_Max_BIT: return (LongSpecies) SPECIES_MAX;
+            //case VectorShape.SK_Max_BIT: return (LongSpecies) SPECIES_MAX;
             default: throw new IllegalArgumentException("Bad shape: " + s);
         }
     }
@@ -4033,11 +4275,12 @@ public abstract class LongVector extends AbstractVector<Long> {
                             Long512Vector::new);
 
     /** Species representing {@link LongVector}s of {@link VectorShape#S_Max_BIT VectorShape.S_Max_BIT}. */
-    public static final VectorSpecies<Long> SPECIES_MAX
+    /*public static final VectorSpecies<Long> SPECIES_MAX
         = new LongSpecies(VectorShape.S_Max_BIT,
                             LongMaxVector.class,
                             LongMaxVector.LongMaxMask.class,
                             LongMaxVector::new);
+     */
 
     /**
      * Preferred species for {@link LongVector}s.
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short128Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short128Vector.java
index 0cc80590473..61dc52e5c68 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short128Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short128Vector.java
@@ -39,7 +39,7 @@ import static jdk.incubator.vector.VectorOperators.*;
 // -- This file was mechanically generated: Do not edit! -- //
 
 @SuppressWarnings("cast")  // warning: redundant cast
-final class Short128Vector extends ShortVector {
+value class Short128Vector extends ShortVector {
     static final ShortSpecies VSPECIES =
         (ShortSpecies) ShortVector.SPECIES_128;
 
@@ -54,24 +54,40 @@ final class Short128Vector extends ShortVector {
 
     static final Class<Short> ETYPE = short.class; // used by the JVM
 
-    Short128Vector(short[] v) {
+    /*Short128Vector(short[] v) {
         super(v);
+    }*/
+
+    private final VectorSupport.Short128VectorPayload mf_storage;
+
+    Short128Vector(Object value) {
+        this.mf_storage = (VectorSupport.Short128VectorPayload)value;
+    }
+
+    VectorSupport.VectorPayloadMF vec_mf() {
+        return mf_storage;
+    }
+
+    @Override
+    protected final Object getPayload() {
+       return vec_mf();
     }
 
     // For compatibility as Short128Vector::new,
     // stored into species.vectorFactory.
-    Short128Vector(Object v) {
+    /*Short128Vector(Object v) {
         this((short[]) v);
-    }
+    }*/
 
-    static final Short128Vector ZERO = new Short128Vector(new short[VLENGTH]);
+    static final Short128Vector ZERO = new Short128Vector(VectorSupport.VectorPayloadMF.createNewInstanceS(short.class, 8, Short.valueOf((short)0)));
     static final Short128Vector IOTA = new Short128Vector(VSPECIES.iotaArray());
 
     static {
         // Warm up a few species caches.
         // If we do this too much we will
         // get NPEs from bootstrap circularity.
-        VSPECIES.dummyVector();
+        // VSPECIES.dummyVector();
+        VSPECIES.dummyVectorMF();
         VSPECIES.withLanes(LaneType.BYTE);
     }
 
@@ -171,6 +187,13 @@ final class Short128Vector extends ShortVector {
         return new Short128Vector(vec);
     }
 
+    // Make a vector of the same species but the given elements:
+    @ForceInline
+    final @Override
+    Short128Vector vectorFactory(VectorSupport.VectorPayloadMF vec) {
+        return new Short128Vector(vec);
+    }
+
     @ForceInline
     final @Override
     Byte128Vector asByteVectorRaw() {
@@ -206,6 +229,12 @@ final class Short128Vector extends ShortVector {
         return (Short128Vector) super.bOpTemplate((Short128Vector)v, f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Short128Vector bOpMF(Vector<Short> v, FBinOp f) {
+        return (Short128Vector) super.bOpTemplateMF((Short128Vector)v, f);  // specialize
+    }
+
     @ForceInline
     final @Override
     Short128Vector bOp(Vector<Short> v,
@@ -215,6 +244,15 @@ final class Short128Vector extends ShortVector {
                               f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Short128Vector bOpMF(Vector<Short> v,
+                     VectorMask<Short> m, FBinOp f) {
+        return (Short128Vector)
+            super.bOpTemplateMF((Short128Vector)v, (Short128Mask)m,
+                              f);  // specialize
+    }
+
     // Ternary operator
 
     @ForceInline
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short256Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short256Vector.java
index b39b7c509c1..07032f1d003 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short256Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short256Vector.java
@@ -39,7 +39,7 @@ import static jdk.incubator.vector.VectorOperators.*;
 // -- This file was mechanically generated: Do not edit! -- //
 
 @SuppressWarnings("cast")  // warning: redundant cast
-final class Short256Vector extends ShortVector {
+value class Short256Vector extends ShortVector {
     static final ShortSpecies VSPECIES =
         (ShortSpecies) ShortVector.SPECIES_256;
 
@@ -54,24 +54,40 @@ final class Short256Vector extends ShortVector {
 
     static final Class<Short> ETYPE = short.class; // used by the JVM
 
-    Short256Vector(short[] v) {
+    /*Short256Vector(short[] v) {
         super(v);
+    }*/
+
+    private final VectorSupport.Short256VectorPayload mf_storage;
+
+    Short256Vector(Object value) {
+        this.mf_storage = (VectorSupport.Short256VectorPayload)value;
+    }
+
+    VectorSupport.VectorPayloadMF vec_mf() {
+        return mf_storage;
+    }
+
+    @Override
+    protected final Object getPayload() {
+       return vec_mf();
     }
 
     // For compatibility as Short256Vector::new,
     // stored into species.vectorFactory.
-    Short256Vector(Object v) {
+    /*Short256Vector(Object v) {
         this((short[]) v);
-    }
+    }*/
 
-    static final Short256Vector ZERO = new Short256Vector(new short[VLENGTH]);
+    static final Short256Vector ZERO = new Short256Vector(VectorSupport.VectorPayloadMF.createNewInstanceS(short.class, 16, Short.valueOf((short)0)));
     static final Short256Vector IOTA = new Short256Vector(VSPECIES.iotaArray());
 
     static {
         // Warm up a few species caches.
         // If we do this too much we will
         // get NPEs from bootstrap circularity.
-        VSPECIES.dummyVector();
+        // VSPECIES.dummyVector();
+        VSPECIES.dummyVectorMF();
         VSPECIES.withLanes(LaneType.BYTE);
     }
 
@@ -171,6 +187,13 @@ final class Short256Vector extends ShortVector {
         return new Short256Vector(vec);
     }
 
+    // Make a vector of the same species but the given elements:
+    @ForceInline
+    final @Override
+    Short256Vector vectorFactory(VectorSupport.VectorPayloadMF vec) {
+        return new Short256Vector(vec);
+    }
+
     @ForceInline
     final @Override
     Byte256Vector asByteVectorRaw() {
@@ -206,6 +229,12 @@ final class Short256Vector extends ShortVector {
         return (Short256Vector) super.bOpTemplate((Short256Vector)v, f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Short256Vector bOpMF(Vector<Short> v, FBinOp f) {
+        return (Short256Vector) super.bOpTemplateMF((Short256Vector)v, f);  // specialize
+    }
+
     @ForceInline
     final @Override
     Short256Vector bOp(Vector<Short> v,
@@ -215,6 +244,15 @@ final class Short256Vector extends ShortVector {
                               f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Short256Vector bOpMF(Vector<Short> v,
+                     VectorMask<Short> m, FBinOp f) {
+        return (Short256Vector)
+            super.bOpTemplateMF((Short256Vector)v, (Short256Mask)m,
+                              f);  // specialize
+    }
+
     // Ternary operator
 
     @ForceInline
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short512Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short512Vector.java
index c7a07c4d283..28d02b73615 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short512Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short512Vector.java
@@ -39,7 +39,7 @@ import static jdk.incubator.vector.VectorOperators.*;
 // -- This file was mechanically generated: Do not edit! -- //
 
 @SuppressWarnings("cast")  // warning: redundant cast
-final class Short512Vector extends ShortVector {
+value class Short512Vector extends ShortVector {
     static final ShortSpecies VSPECIES =
         (ShortSpecies) ShortVector.SPECIES_512;
 
@@ -54,24 +54,40 @@ final class Short512Vector extends ShortVector {
 
     static final Class<Short> ETYPE = short.class; // used by the JVM
 
-    Short512Vector(short[] v) {
+    /*Short512Vector(short[] v) {
         super(v);
+    }*/
+
+    private final VectorSupport.Short512VectorPayload mf_storage;
+
+    Short512Vector(Object value) {
+        this.mf_storage = (VectorSupport.Short512VectorPayload)value;
+    }
+
+    VectorSupport.VectorPayloadMF vec_mf() {
+        return mf_storage;
+    }
+
+    @Override
+    protected final Object getPayload() {
+       return vec_mf();
     }
 
     // For compatibility as Short512Vector::new,
     // stored into species.vectorFactory.
-    Short512Vector(Object v) {
+    /*Short512Vector(Object v) {
         this((short[]) v);
-    }
+    }*/
 
-    static final Short512Vector ZERO = new Short512Vector(new short[VLENGTH]);
+    static final Short512Vector ZERO = new Short512Vector(VectorSupport.VectorPayloadMF.createNewInstanceS(short.class, 32, Short.valueOf((short)0)));
     static final Short512Vector IOTA = new Short512Vector(VSPECIES.iotaArray());
 
     static {
         // Warm up a few species caches.
         // If we do this too much we will
         // get NPEs from bootstrap circularity.
-        VSPECIES.dummyVector();
+        // VSPECIES.dummyVector();
+        VSPECIES.dummyVectorMF();
         VSPECIES.withLanes(LaneType.BYTE);
     }
 
@@ -171,6 +187,13 @@ final class Short512Vector extends ShortVector {
         return new Short512Vector(vec);
     }
 
+    // Make a vector of the same species but the given elements:
+    @ForceInline
+    final @Override
+    Short512Vector vectorFactory(VectorSupport.VectorPayloadMF vec) {
+        return new Short512Vector(vec);
+    }
+
     @ForceInline
     final @Override
     Byte512Vector asByteVectorRaw() {
@@ -206,6 +229,12 @@ final class Short512Vector extends ShortVector {
         return (Short512Vector) super.bOpTemplate((Short512Vector)v, f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Short512Vector bOpMF(Vector<Short> v, FBinOp f) {
+        return (Short512Vector) super.bOpTemplateMF((Short512Vector)v, f);  // specialize
+    }
+
     @ForceInline
     final @Override
     Short512Vector bOp(Vector<Short> v,
@@ -215,6 +244,15 @@ final class Short512Vector extends ShortVector {
                               f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Short512Vector bOpMF(Vector<Short> v,
+                     VectorMask<Short> m, FBinOp f) {
+        return (Short512Vector)
+            super.bOpTemplateMF((Short512Vector)v, (Short512Mask)m,
+                              f);  // specialize
+    }
+
     // Ternary operator
 
     @ForceInline
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short64Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short64Vector.java
index 4f0d8796482..bc277d3e6b6 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short64Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Short64Vector.java
@@ -39,7 +39,7 @@ import static jdk.incubator.vector.VectorOperators.*;
 // -- This file was mechanically generated: Do not edit! -- //
 
 @SuppressWarnings("cast")  // warning: redundant cast
-final class Short64Vector extends ShortVector {
+value class Short64Vector extends ShortVector {
     static final ShortSpecies VSPECIES =
         (ShortSpecies) ShortVector.SPECIES_64;
 
@@ -54,24 +54,40 @@ final class Short64Vector extends ShortVector {
 
     static final Class<Short> ETYPE = short.class; // used by the JVM
 
-    Short64Vector(short[] v) {
+    /*Short64Vector(short[] v) {
         super(v);
+    }*/
+
+    private final VectorSupport.Short64VectorPayload mf_storage;
+
+    Short64Vector(Object value) {
+        this.mf_storage = (VectorSupport.Short64VectorPayload)value;
+    }
+
+    VectorSupport.VectorPayloadMF vec_mf() {
+        return mf_storage;
+    }
+
+    @Override
+    protected final Object getPayload() {
+       return vec_mf();
     }
 
     // For compatibility as Short64Vector::new,
     // stored into species.vectorFactory.
-    Short64Vector(Object v) {
+    /*Short64Vector(Object v) {
         this((short[]) v);
-    }
+    }*/
 
-    static final Short64Vector ZERO = new Short64Vector(new short[VLENGTH]);
+    static final Short64Vector ZERO = new Short64Vector(VectorSupport.VectorPayloadMF.createNewInstanceS(short.class, 4, Short.valueOf((short)0)));
     static final Short64Vector IOTA = new Short64Vector(VSPECIES.iotaArray());
 
     static {
         // Warm up a few species caches.
         // If we do this too much we will
         // get NPEs from bootstrap circularity.
-        VSPECIES.dummyVector();
+        // VSPECIES.dummyVector();
+        VSPECIES.dummyVectorMF();
         VSPECIES.withLanes(LaneType.BYTE);
     }
 
@@ -171,6 +187,13 @@ final class Short64Vector extends ShortVector {
         return new Short64Vector(vec);
     }
 
+    // Make a vector of the same species but the given elements:
+    @ForceInline
+    final @Override
+    Short64Vector vectorFactory(VectorSupport.VectorPayloadMF vec) {
+        return new Short64Vector(vec);
+    }
+
     @ForceInline
     final @Override
     Byte64Vector asByteVectorRaw() {
@@ -206,6 +229,12 @@ final class Short64Vector extends ShortVector {
         return (Short64Vector) super.bOpTemplate((Short64Vector)v, f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Short64Vector bOpMF(Vector<Short> v, FBinOp f) {
+        return (Short64Vector) super.bOpTemplateMF((Short64Vector)v, f);  // specialize
+    }
+
     @ForceInline
     final @Override
     Short64Vector bOp(Vector<Short> v,
@@ -215,6 +244,15 @@ final class Short64Vector extends ShortVector {
                               f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    Short64Vector bOpMF(Vector<Short> v,
+                     VectorMask<Short> m, FBinOp f) {
+        return (Short64Vector)
+            super.bOpTemplateMF((Short64Vector)v, (Short64Mask)m,
+                              f);  // specialize
+    }
+
     // Ternary operator
 
     @ForceInline
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ShortMaxVector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ShortMaxVector.java
deleted file mode 100644
index 6724ae88682..00000000000
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ShortMaxVector.java
+++ /dev/null
@@ -1,920 +0,0 @@
-/*
- * Copyright (c) 2017, 2022, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package jdk.incubator.vector;
-
-import java.lang.foreign.MemorySegment;
-import java.util.Arrays;
-import java.util.Objects;
-import java.util.function.IntUnaryOperator;
-
-import jdk.internal.vm.annotation.ForceInline;
-import jdk.internal.vm.vector.VectorSupport;
-
-import static jdk.internal.vm.vector.VectorSupport.*;
-
-import static jdk.incubator.vector.VectorOperators.*;
-
-// -- This file was mechanically generated: Do not edit! -- //
-
-@SuppressWarnings("cast")  // warning: redundant cast
-final class ShortMaxVector extends ShortVector {
-    static final ShortSpecies VSPECIES =
-        (ShortSpecies) ShortVector.SPECIES_MAX;
-
-    static final VectorShape VSHAPE =
-        VSPECIES.vectorShape();
-
-    static final Class<ShortMaxVector> VCLASS = ShortMaxVector.class;
-
-    static final int VSIZE = VSPECIES.vectorBitSize();
-
-    static final int VLENGTH = VSPECIES.laneCount(); // used by the JVM
-
-    static final Class<Short> ETYPE = short.class; // used by the JVM
-
-    ShortMaxVector(short[] v) {
-        super(v);
-    }
-
-    // For compatibility as ShortMaxVector::new,
-    // stored into species.vectorFactory.
-    ShortMaxVector(Object v) {
-        this((short[]) v);
-    }
-
-    static final ShortMaxVector ZERO = new ShortMaxVector(new short[VLENGTH]);
-    static final ShortMaxVector IOTA = new ShortMaxVector(VSPECIES.iotaArray());
-
-    static {
-        // Warm up a few species caches.
-        // If we do this too much we will
-        // get NPEs from bootstrap circularity.
-        VSPECIES.dummyVector();
-        VSPECIES.withLanes(LaneType.BYTE);
-    }
-
-    // Specialized extractors
-
-    @ForceInline
-    final @Override
-    public ShortSpecies vspecies() {
-        // ISSUE:  This should probably be a @Stable
-        // field inside AbstractVector, rather than
-        // a megamorphic method.
-        return VSPECIES;
-    }
-
-    @ForceInline
-    @Override
-    public final Class<Short> elementType() { return short.class; }
-
-    @ForceInline
-    @Override
-    public final int elementSize() { return Short.SIZE; }
-
-    @ForceInline
-    @Override
-    public final VectorShape shape() { return VSHAPE; }
-
-    @ForceInline
-    @Override
-    public final int length() { return VLENGTH; }
-
-    @ForceInline
-    @Override
-    public final int bitSize() { return VSIZE; }
-
-    @ForceInline
-    @Override
-    public final int byteSize() { return VSIZE / Byte.SIZE; }
-
-    /*package-private*/
-    @ForceInline
-    final @Override
-    short[] vec() {
-        return (short[])getPayload();
-    }
-
-    // Virtualized constructors
-
-    @Override
-    @ForceInline
-    public final ShortMaxVector broadcast(short e) {
-        return (ShortMaxVector) super.broadcastTemplate(e);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final ShortMaxVector broadcast(long e) {
-        return (ShortMaxVector) super.broadcastTemplate(e);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    ShortMaxMask maskFromArray(boolean[] bits) {
-        return new ShortMaxMask(bits);
-    }
-
-    @Override
-    @ForceInline
-    ShortMaxShuffle iotaShuffle() { return ShortMaxShuffle.IOTA; }
-
-    @ForceInline
-    ShortMaxShuffle iotaShuffle(int start, int step, boolean wrap) {
-      if (wrap) {
-        return (ShortMaxShuffle)VectorSupport.shuffleIota(ETYPE, ShortMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,
-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));
-      } else {
-        return (ShortMaxShuffle)VectorSupport.shuffleIota(ETYPE, ShortMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,
-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));
-      }
-    }
-
-    @Override
-    @ForceInline
-    ShortMaxShuffle shuffleFromBytes(byte[] reorder) { return new ShortMaxShuffle(reorder); }
-
-    @Override
-    @ForceInline
-    ShortMaxShuffle shuffleFromArray(int[] indexes, int i) { return new ShortMaxShuffle(indexes, i); }
-
-    @Override
-    @ForceInline
-    ShortMaxShuffle shuffleFromOp(IntUnaryOperator fn) { return new ShortMaxShuffle(fn); }
-
-    // Make a vector of the same species but the given elements:
-    @ForceInline
-    final @Override
-    ShortMaxVector vectorFactory(short[] vec) {
-        return new ShortMaxVector(vec);
-    }
-
-    @ForceInline
-    final @Override
-    ByteMaxVector asByteVectorRaw() {
-        return (ByteMaxVector) super.asByteVectorRawTemplate();  // specialize
-    }
-
-    @ForceInline
-    final @Override
-    AbstractVector<?> asVectorRaw(LaneType laneType) {
-        return super.asVectorRawTemplate(laneType);  // specialize
-    }
-
-    // Unary operator
-
-    @ForceInline
-    final @Override
-    ShortMaxVector uOp(FUnOp f) {
-        return (ShortMaxVector) super.uOpTemplate(f);  // specialize
-    }
-
-    @ForceInline
-    final @Override
-    ShortMaxVector uOp(VectorMask<Short> m, FUnOp f) {
-        return (ShortMaxVector)
-            super.uOpTemplate((ShortMaxMask)m, f);  // specialize
-    }
-
-    // Binary operator
-
-    @ForceInline
-    final @Override
-    ShortMaxVector bOp(Vector<Short> v, FBinOp f) {
-        return (ShortMaxVector) super.bOpTemplate((ShortMaxVector)v, f);  // specialize
-    }
-
-    @ForceInline
-    final @Override
-    ShortMaxVector bOp(Vector<Short> v,
-                     VectorMask<Short> m, FBinOp f) {
-        return (ShortMaxVector)
-            super.bOpTemplate((ShortMaxVector)v, (ShortMaxMask)m,
-                              f);  // specialize
-    }
-
-    // Ternary operator
-
-    @ForceInline
-    final @Override
-    ShortMaxVector tOp(Vector<Short> v1, Vector<Short> v2, FTriOp f) {
-        return (ShortMaxVector)
-            super.tOpTemplate((ShortMaxVector)v1, (ShortMaxVector)v2,
-                              f);  // specialize
-    }
-
-    @ForceInline
-    final @Override
-    ShortMaxVector tOp(Vector<Short> v1, Vector<Short> v2,
-                     VectorMask<Short> m, FTriOp f) {
-        return (ShortMaxVector)
-            super.tOpTemplate((ShortMaxVector)v1, (ShortMaxVector)v2,
-                              (ShortMaxMask)m, f);  // specialize
-    }
-
-    @ForceInline
-    final @Override
-    short rOp(short v, VectorMask<Short> m, FBinOp f) {
-        return super.rOpTemplate(v, m, f);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final <F>
-    Vector<F> convertShape(VectorOperators.Conversion<Short,F> conv,
-                           VectorSpecies<F> rsp, int part) {
-        return super.convertShapeTemplate(conv, rsp, part);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final <F>
-    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {
-        return super.reinterpretShapeTemplate(toSpecies, part);  // specialize
-    }
-
-    // Specialized algebraic operations:
-
-    // The following definition forces a specialized version of this
-    // crucial method into the v-table of this class.  A call to add()
-    // will inline to a call to lanewise(ADD,), at which point the JIT
-    // intrinsic will have the opcode of ADD, plus all the metadata
-    // for this particular class, enabling it to generate precise
-    // code.
-    //
-    // There is probably no benefit to the JIT to specialize the
-    // masked or broadcast versions of the lanewise method.
-
-    @Override
-    @ForceInline
-    public ShortMaxVector lanewise(Unary op) {
-        return (ShortMaxVector) super.lanewiseTemplate(op);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public ShortMaxVector lanewise(Unary op, VectorMask<Short> m) {
-        return (ShortMaxVector) super.lanewiseTemplate(op, ShortMaxMask.class, (ShortMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public ShortMaxVector lanewise(Binary op, Vector<Short> v) {
-        return (ShortMaxVector) super.lanewiseTemplate(op, v);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public ShortMaxVector lanewise(Binary op, Vector<Short> v, VectorMask<Short> m) {
-        return (ShortMaxVector) super.lanewiseTemplate(op, ShortMaxMask.class, v, (ShortMaxMask) m);  // specialize
-    }
-
-    /*package-private*/
-    @Override
-    @ForceInline ShortMaxVector
-    lanewiseShift(VectorOperators.Binary op, int e) {
-        return (ShortMaxVector) super.lanewiseShiftTemplate(op, e);  // specialize
-    }
-
-    /*package-private*/
-    @Override
-    @ForceInline ShortMaxVector
-    lanewiseShift(VectorOperators.Binary op, int e, VectorMask<Short> m) {
-        return (ShortMaxVector) super.lanewiseShiftTemplate(op, ShortMaxMask.class, e, (ShortMaxMask) m);  // specialize
-    }
-
-    /*package-private*/
-    @Override
-    @ForceInline
-    public final
-    ShortMaxVector
-    lanewise(Ternary op, Vector<Short> v1, Vector<Short> v2) {
-        return (ShortMaxVector) super.lanewiseTemplate(op, v1, v2);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final
-    ShortMaxVector
-    lanewise(Ternary op, Vector<Short> v1, Vector<Short> v2, VectorMask<Short> m) {
-        return (ShortMaxVector) super.lanewiseTemplate(op, ShortMaxMask.class, v1, v2, (ShortMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final
-    ShortMaxVector addIndex(int scale) {
-        return (ShortMaxVector) super.addIndexTemplate(scale);  // specialize
-    }
-
-    // Type specific horizontal reductions
-
-    @Override
-    @ForceInline
-    public final short reduceLanes(VectorOperators.Associative op) {
-        return super.reduceLanesTemplate(op);  // specialized
-    }
-
-    @Override
-    @ForceInline
-    public final short reduceLanes(VectorOperators.Associative op,
-                                    VectorMask<Short> m) {
-        return super.reduceLanesTemplate(op, ShortMaxMask.class, (ShortMaxMask) m);  // specialized
-    }
-
-    @Override
-    @ForceInline
-    public final long reduceLanesToLong(VectorOperators.Associative op) {
-        return (long) super.reduceLanesTemplate(op);  // specialized
-    }
-
-    @Override
-    @ForceInline
-    public final long reduceLanesToLong(VectorOperators.Associative op,
-                                        VectorMask<Short> m) {
-        return (long) super.reduceLanesTemplate(op, ShortMaxMask.class, (ShortMaxMask) m);  // specialized
-    }
-
-    @ForceInline
-    public VectorShuffle<Short> toShuffle() {
-        return super.toShuffleTemplate(ShortMaxShuffle.class); // specialize
-    }
-
-    // Specialized unary testing
-
-    @Override
-    @ForceInline
-    public final ShortMaxMask test(Test op) {
-        return super.testTemplate(ShortMaxMask.class, op);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final ShortMaxMask test(Test op, VectorMask<Short> m) {
-        return super.testTemplate(ShortMaxMask.class, op, (ShortMaxMask) m);  // specialize
-    }
-
-    // Specialized comparisons
-
-    @Override
-    @ForceInline
-    public final ShortMaxMask compare(Comparison op, Vector<Short> v) {
-        return super.compareTemplate(ShortMaxMask.class, op, v);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final ShortMaxMask compare(Comparison op, short s) {
-        return super.compareTemplate(ShortMaxMask.class, op, s);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final ShortMaxMask compare(Comparison op, long s) {
-        return super.compareTemplate(ShortMaxMask.class, op, s);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public final ShortMaxMask compare(Comparison op, Vector<Short> v, VectorMask<Short> m) {
-        return super.compareTemplate(ShortMaxMask.class, op, v, (ShortMaxMask) m);
-    }
-
-
-    @Override
-    @ForceInline
-    public ShortMaxVector blend(Vector<Short> v, VectorMask<Short> m) {
-        return (ShortMaxVector)
-            super.blendTemplate(ShortMaxMask.class,
-                                (ShortMaxVector) v,
-                                (ShortMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public ShortMaxVector slice(int origin, Vector<Short> v) {
-        return (ShortMaxVector) super.sliceTemplate(origin, v);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public ShortMaxVector slice(int origin) {
-        return (ShortMaxVector) super.sliceTemplate(origin);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public ShortMaxVector unslice(int origin, Vector<Short> w, int part) {
-        return (ShortMaxVector) super.unsliceTemplate(origin, w, part);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public ShortMaxVector unslice(int origin, Vector<Short> w, int part, VectorMask<Short> m) {
-        return (ShortMaxVector)
-            super.unsliceTemplate(ShortMaxMask.class,
-                                  origin, w, part,
-                                  (ShortMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public ShortMaxVector unslice(int origin) {
-        return (ShortMaxVector) super.unsliceTemplate(origin);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public ShortMaxVector rearrange(VectorShuffle<Short> s) {
-        return (ShortMaxVector)
-            super.rearrangeTemplate(ShortMaxShuffle.class,
-                                    (ShortMaxShuffle) s);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public ShortMaxVector rearrange(VectorShuffle<Short> shuffle,
-                                  VectorMask<Short> m) {
-        return (ShortMaxVector)
-            super.rearrangeTemplate(ShortMaxShuffle.class,
-                                    ShortMaxMask.class,
-                                    (ShortMaxShuffle) shuffle,
-                                    (ShortMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public ShortMaxVector rearrange(VectorShuffle<Short> s,
-                                  Vector<Short> v) {
-        return (ShortMaxVector)
-            super.rearrangeTemplate(ShortMaxShuffle.class,
-                                    (ShortMaxShuffle) s,
-                                    (ShortMaxVector) v);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public ShortMaxVector compress(VectorMask<Short> m) {
-        return (ShortMaxVector)
-            super.compressTemplate(ShortMaxMask.class,
-                                   (ShortMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public ShortMaxVector expand(VectorMask<Short> m) {
-        return (ShortMaxVector)
-            super.expandTemplate(ShortMaxMask.class,
-                                   (ShortMaxMask) m);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public ShortMaxVector selectFrom(Vector<Short> v) {
-        return (ShortMaxVector)
-            super.selectFromTemplate((ShortMaxVector) v);  // specialize
-    }
-
-    @Override
-    @ForceInline
-    public ShortMaxVector selectFrom(Vector<Short> v,
-                                   VectorMask<Short> m) {
-        return (ShortMaxVector)
-            super.selectFromTemplate((ShortMaxVector) v,
-                                     (ShortMaxMask) m);  // specialize
-    }
-
-
-    @ForceInline
-    @Override
-    public short lane(int i) {
-        if (i < 0 || i >= VLENGTH) {
-            throw new IllegalArgumentException("Index " + i + " must be zero or positive, and less than " + VLENGTH);
-        }
-        return laneHelper(i);
-    }
-
-    public short laneHelper(int i) {
-        return (short) VectorSupport.extract(
-                                VCLASS, ETYPE, VLENGTH,
-                                this, i,
-                                (vec, ix) -> {
-                                    short[] vecarr = vec.vec();
-                                    return (long)vecarr[ix];
-                                });
-    }
-
-    @ForceInline
-    @Override
-    public ShortMaxVector withLane(int i, short e) {
-        if (i < 0 || i >= VLENGTH) {
-            throw new IllegalArgumentException("Index " + i + " must be zero or positive, and less than " + VLENGTH);
-        }
-        return withLaneHelper(i, e);
-    }
-
-    public ShortMaxVector withLaneHelper(int i, short e) {
-        return VectorSupport.insert(
-                                VCLASS, ETYPE, VLENGTH,
-                                this, i, (long)e,
-                                (v, ix, bits) -> {
-                                    short[] res = v.vec().clone();
-                                    res[ix] = (short)bits;
-                                    return v.vectorFactory(res);
-                                });
-    }
-
-    // Mask
-
-    static final class ShortMaxMask extends AbstractMask<Short> {
-        static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
-        static final Class<Short> ETYPE = short.class; // used by the JVM
-
-        ShortMaxMask(boolean[] bits) {
-            this(bits, 0);
-        }
-
-        ShortMaxMask(boolean[] bits, int offset) {
-            super(prepare(bits, offset));
-        }
-
-        ShortMaxMask(boolean val) {
-            super(prepare(val));
-        }
-
-        private static boolean[] prepare(boolean[] bits, int offset) {
-            boolean[] newBits = new boolean[VSPECIES.laneCount()];
-            for (int i = 0; i < newBits.length; i++) {
-                newBits[i] = bits[offset + i];
-            }
-            return newBits;
-        }
-
-        private static boolean[] prepare(boolean val) {
-            boolean[] bits = new boolean[VSPECIES.laneCount()];
-            Arrays.fill(bits, val);
-            return bits;
-        }
-
-        @ForceInline
-        final @Override
-        public ShortSpecies vspecies() {
-            // ISSUE:  This should probably be a @Stable
-            // field inside AbstractMask, rather than
-            // a megamorphic method.
-            return VSPECIES;
-        }
-
-        @ForceInline
-        boolean[] getBits() {
-            return (boolean[])getPayload();
-        }
-
-        @Override
-        ShortMaxMask uOp(MUnOp f) {
-            boolean[] res = new boolean[vspecies().laneCount()];
-            boolean[] bits = getBits();
-            for (int i = 0; i < res.length; i++) {
-                res[i] = f.apply(i, bits[i]);
-            }
-            return new ShortMaxMask(res);
-        }
-
-        @Override
-        ShortMaxMask bOp(VectorMask<Short> m, MBinOp f) {
-            boolean[] res = new boolean[vspecies().laneCount()];
-            boolean[] bits = getBits();
-            boolean[] mbits = ((ShortMaxMask)m).getBits();
-            for (int i = 0; i < res.length; i++) {
-                res[i] = f.apply(i, bits[i], mbits[i]);
-            }
-            return new ShortMaxMask(res);
-        }
-
-        @ForceInline
-        @Override
-        public final
-        ShortMaxVector toVector() {
-            return (ShortMaxVector) super.toVectorTemplate();  // specialize
-        }
-
-        /**
-         * Helper function for lane-wise mask conversions.
-         * This function kicks in after intrinsic failure.
-         */
-        @ForceInline
-        private final <E>
-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {
-            if (length() != dsp.laneCount())
-                throw new IllegalArgumentException("VectorMask length and species length differ");
-            boolean[] maskArray = toArray();
-            return  dsp.maskFactory(maskArray).check(dsp);
-        }
-
-        @Override
-        @ForceInline
-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {
-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;
-            if (length() != species.laneCount())
-                throw new IllegalArgumentException("VectorMask length and species length differ");
-
-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,
-                this.getClass(), ETYPE, VLENGTH,
-                species.maskType(), species.elementType(), VLENGTH,
-                this, species,
-                (m, s) -> s.maskFactory(m.toArray()).check(s));
-        }
-
-        @Override
-        @ForceInline
-        public ShortMaxMask eq(VectorMask<Short> mask) {
-            Objects.requireNonNull(mask);
-            ShortMaxMask m = (ShortMaxMask)mask;
-            return xor(m.not());
-        }
-
-        // Unary operations
-
-        @Override
-        @ForceInline
-        public ShortMaxMask not() {
-            return xor(maskAll(true));
-        }
-
-        @Override
-        @ForceInline
-        public ShortMaxMask compress() {
-            return (ShortMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,
-                ShortMaxVector.class, ShortMaxMask.class, ETYPE, VLENGTH, null, this,
-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));
-        }
-
-
-        // Binary operations
-
-        @Override
-        @ForceInline
-        public ShortMaxMask and(VectorMask<Short> mask) {
-            Objects.requireNonNull(mask);
-            ShortMaxMask m = (ShortMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_AND, ShortMaxMask.class, null, short.class, VLENGTH,
-                                          this, m, null,
-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));
-        }
-
-        @Override
-        @ForceInline
-        public ShortMaxMask or(VectorMask<Short> mask) {
-            Objects.requireNonNull(mask);
-            ShortMaxMask m = (ShortMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_OR, ShortMaxMask.class, null, short.class, VLENGTH,
-                                          this, m, null,
-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));
-        }
-
-        @ForceInline
-        /* package-private */
-        ShortMaxMask xor(VectorMask<Short> mask) {
-            Objects.requireNonNull(mask);
-            ShortMaxMask m = (ShortMaxMask)mask;
-            return VectorSupport.binaryOp(VECTOR_OP_XOR, ShortMaxMask.class, null, short.class, VLENGTH,
-                                          this, m, null,
-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));
-        }
-
-        // Mask Query operations
-
-        @Override
-        @ForceInline
-        public int trueCount() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, ShortMaxMask.class, short.class, VLENGTH, this,
-                                                      (m) -> trueCountHelper(m.getBits()));
-        }
-
-        @Override
-        @ForceInline
-        public int firstTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, ShortMaxMask.class, short.class, VLENGTH, this,
-                                                      (m) -> firstTrueHelper(m.getBits()));
-        }
-
-        @Override
-        @ForceInline
-        public int lastTrue() {
-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, ShortMaxMask.class, short.class, VLENGTH, this,
-                                                      (m) -> lastTrueHelper(m.getBits()));
-        }
-
-        @Override
-        @ForceInline
-        public long toLong() {
-            if (length() > Long.SIZE) {
-                throw new UnsupportedOperationException("too many lanes for one long");
-            }
-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, ShortMaxMask.class, short.class, VLENGTH, this,
-                                                      (m) -> toLongHelper(m.getBits()));
-        }
-
-        // Reductions
-
-        @Override
-        @ForceInline
-        public boolean anyTrue() {
-            return VectorSupport.test(BT_ne, ShortMaxMask.class, short.class, VLENGTH,
-                                         this, vspecies().maskAll(true),
-                                         (m, __) -> anyTrueHelper(((ShortMaxMask)m).getBits()));
-        }
-
-        @Override
-        @ForceInline
-        public boolean allTrue() {
-            return VectorSupport.test(BT_overflow, ShortMaxMask.class, short.class, VLENGTH,
-                                         this, vspecies().maskAll(true),
-                                         (m, __) -> allTrueHelper(((ShortMaxMask)m).getBits()));
-        }
-
-        @ForceInline
-        /*package-private*/
-        static ShortMaxMask maskAll(boolean bit) {
-            return VectorSupport.fromBitsCoerced(ShortMaxMask.class, short.class, VLENGTH,
-                                                 (bit ? -1 : 0), MODE_BROADCAST, null,
-                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));
-        }
-        private static final ShortMaxMask  TRUE_MASK = new ShortMaxMask(true);
-        private static final ShortMaxMask FALSE_MASK = new ShortMaxMask(false);
-
-    }
-
-    // Shuffle
-
-    static final class ShortMaxShuffle extends AbstractShuffle<Short> {
-        static final int VLENGTH = VSPECIES.laneCount();    // used by the JVM
-        static final Class<Short> ETYPE = short.class; // used by the JVM
-
-        ShortMaxShuffle(byte[] reorder) {
-            super(VLENGTH, reorder);
-        }
-
-        public ShortMaxShuffle(int[] reorder) {
-            super(VLENGTH, reorder);
-        }
-
-        public ShortMaxShuffle(int[] reorder, int i) {
-            super(VLENGTH, reorder, i);
-        }
-
-        public ShortMaxShuffle(IntUnaryOperator fn) {
-            super(VLENGTH, fn);
-        }
-
-        @Override
-        public ShortSpecies vspecies() {
-            return VSPECIES;
-        }
-
-        static {
-            // There must be enough bits in the shuffle lanes to encode
-            // VLENGTH valid indexes and VLENGTH exceptional ones.
-            assert(VLENGTH < Byte.MAX_VALUE);
-            assert(Byte.MIN_VALUE <= -VLENGTH);
-        }
-        static final ShortMaxShuffle IOTA = new ShortMaxShuffle(IDENTITY);
-
-        @Override
-        @ForceInline
-        public ShortMaxVector toVector() {
-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, ShortMaxShuffle.class, this, VLENGTH,
-                                                    (s) -> ((ShortMaxVector)(((AbstractShuffle<Short>)(s)).toVectorTemplate())));
-        }
-
-        @Override
-        @ForceInline
-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {
-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;
-            if (length() != species.laneCount())
-                throw new IllegalArgumentException("VectorShuffle length and species length differ");
-            int[] shuffleArray = toArray();
-            return s.shuffleFromArray(shuffleArray, 0).check(s);
-        }
-
-        @ForceInline
-        @Override
-        public ShortMaxShuffle rearrange(VectorShuffle<Short> shuffle) {
-            ShortMaxShuffle s = (ShortMaxShuffle) shuffle;
-            byte[] reorder1 = reorder();
-            byte[] reorder2 = s.reorder();
-            byte[] r = new byte[reorder1.length];
-            for (int i = 0; i < reorder1.length; i++) {
-                int ssi = reorder2[i];
-                r[i] = reorder1[ssi];  // throws on exceptional index
-            }
-            return new ShortMaxShuffle(r);
-        }
-    }
-
-    // ================================================
-
-    // Specialized low-level memory operations.
-
-    @ForceInline
-    @Override
-    final
-    ShortVector fromArray0(short[] a, int offset) {
-        return super.fromArray0Template(a, offset);  // specialize
-    }
-
-    @ForceInline
-    @Override
-    final
-    ShortVector fromArray0(short[] a, int offset, VectorMask<Short> m, int offsetInRange) {
-        return super.fromArray0Template(ShortMaxMask.class, a, offset, (ShortMaxMask) m, offsetInRange);  // specialize
-    }
-
-
-    @ForceInline
-    @Override
-    final
-    ShortVector fromCharArray0(char[] a, int offset) {
-        return super.fromCharArray0Template(a, offset);  // specialize
-    }
-
-    @ForceInline
-    @Override
-    final
-    ShortVector fromCharArray0(char[] a, int offset, VectorMask<Short> m, int offsetInRange) {
-        return super.fromCharArray0Template(ShortMaxMask.class, a, offset, (ShortMaxMask) m, offsetInRange);  // specialize
-    }
-
-
-    @ForceInline
-    @Override
-    final
-    ShortVector fromMemorySegment0(MemorySegment ms, long offset) {
-        return super.fromMemorySegment0Template(ms, offset);  // specialize
-    }
-
-    @ForceInline
-    @Override
-    final
-    ShortVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Short> m, int offsetInRange) {
-        return super.fromMemorySegment0Template(ShortMaxMask.class, ms, offset, (ShortMaxMask) m, offsetInRange);  // specialize
-    }
-
-    @ForceInline
-    @Override
-    final
-    void intoArray0(short[] a, int offset) {
-        super.intoArray0Template(a, offset);  // specialize
-    }
-
-    @ForceInline
-    @Override
-    final
-    void intoArray0(short[] a, int offset, VectorMask<Short> m) {
-        super.intoArray0Template(ShortMaxMask.class, a, offset, (ShortMaxMask) m);
-    }
-
-
-
-    @ForceInline
-    @Override
-    final
-    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Short> m) {
-        super.intoMemorySegment0Template(ShortMaxMask.class, ms, offset, (ShortMaxMask) m);
-    }
-
-    @ForceInline
-    @Override
-    final
-    void intoCharArray0(char[] a, int offset, VectorMask<Short> m) {
-        super.intoCharArray0Template(ShortMaxMask.class, a, offset, (ShortMaxMask) m);
-    }
-
-    // End of specialized low-level memory operations.
-
-    // ================================================
-
-}
-
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ShortVector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ShortVector.java
index af7ef119a92..f5cc54be1b8 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ShortVector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/ShortVector.java
@@ -51,9 +51,9 @@ import static jdk.incubator.vector.VectorOperators.*;
 @SuppressWarnings("cast")  // warning: redundant cast
 public abstract class ShortVector extends AbstractVector<Short> {
 
-    ShortVector(short[] vec) {
+    /*ShortVector(short[] vec) {
         super(vec);
-    }
+    }*/
 
     static final int FORBID_OPCODE_KIND = VO_ONLYFP;
 
@@ -96,6 +96,8 @@ public abstract class ShortVector extends AbstractVector<Short> {
     /*package-private*/
     abstract short[] vec();
 
+    abstract VectorSupport.VectorPayloadMF vec_mf();
+
     // Virtualized constructors
 
     /**
@@ -105,6 +107,17 @@ public abstract class ShortVector extends AbstractVector<Short> {
     /*package-private*/
     abstract ShortVector vectorFactory(short[] vec);
 
+    abstract ShortVector vectorFactory(VectorSupport.VectorPayloadMF vec);
+
+    @ForceInline
+    public static
+    ShortVector fromArray(VectorSpecies<Short> species,
+                                   short[] a, int offset) {
+        offset = checkFromIndexSize(offset, species.length(), a.length);
+        ShortSpecies vsp = (ShortSpecies) species;
+        return vsp.dummyVectorMF().fromArray0(a, offset);
+    }
+
     /**
      * Build a mask directly using my species.
      * It is an error if the array is aliased elsewhere.
@@ -210,6 +223,30 @@ public abstract class ShortVector extends AbstractVector<Short> {
         return vectorFactory(res);
     }
 
+    /*package-private*/
+    abstract
+    ShortVector bOpMF(Vector<Short> o,
+                             FBinOp f);
+    @ForceInline
+    final
+    ShortVector bOpTemplateMF(Vector<Short> o,
+                                     FBinOp f) {
+        VectorSupport.VectorPayloadMF vec1 = this.vec_mf();
+        VectorSupport.VectorPayloadMF vec2 = this.vec_mf();
+        VectorSupport.VectorPayloadMF tpayload = 
+            Unsafe.getUnsafe().makePrivateBuffer(VectorSupport.VectorPayloadMF.createNewInstanceS(
+                   short.class, length(), Short.valueOf((short)0)));
+        long start_offset = tpayload.multiFieldOffset();
+        int length = tpayload.length();
+        for (int i = 0; i < length; i++) {
+            short v1 = Unsafe.getUnsafe().getShort(vec1, start_offset + i * Integer.BYTES);
+            short v2 = Unsafe.getUnsafe().getShort(vec2, start_offset + i * Integer.BYTES);
+            Unsafe.getUnsafe().putShort(tpayload, start_offset + i * Integer.BYTES, f.apply(i, v1, v2));
+        }
+        Unsafe.getUnsafe().finishPrivateBuffer(tpayload);
+        return vectorFactory(tpayload);
+    }
+
     /*package-private*/
     abstract
     ShortVector bOp(Vector<Short> o,
@@ -233,6 +270,36 @@ public abstract class ShortVector extends AbstractVector<Short> {
         return vectorFactory(res);
     }
 
+    /*package-private*/
+    abstract
+    ShortVector bOpMF(Vector<Short> o,
+                             VectorMask<Short> m,
+                             FBinOp f);
+    @ForceInline
+    final
+    ShortVector bOpTemplateMF(Vector<Short> o,
+                                     VectorMask<Short> m,
+                                     FBinOp f) {
+        if (m == null) {
+            return bOpTemplateMF(o, f);
+        }
+        boolean[] mbits = ((AbstractMask<Short>)m).getBits();
+        VectorSupport.VectorPayloadMF vec1 = this.vec_mf();
+        VectorSupport.VectorPayloadMF vec2 = this.vec_mf();
+        VectorSupport.VectorPayloadMF tpayload =
+            Unsafe.getUnsafe().makePrivateBuffer(VectorSupport.VectorPayloadMF.createNewInstanceS(
+                short.class, length(), Short.valueOf((short)0)));
+        long start_offset = tpayload.multiFieldOffset();
+        int length = tpayload.length();
+        for (int i = 0; i < length; i++) {
+            short v1 = Unsafe.getUnsafe().getShort(vec1, start_offset + i * Integer.BYTES);
+            short v2 = Unsafe.getUnsafe().getShort(vec2, start_offset + i * Integer.BYTES);
+            Unsafe.getUnsafe().putShort(tpayload, start_offset + i * Integer.BYTES, mbits[i] ? f.apply(i, v1, v2): v1);
+        }
+        Unsafe.getUnsafe().finishPrivateBuffer(tpayload);
+        return vectorFactory(tpayload);
+    }
+
     // Ternary operator
 
     /*package-private*/
@@ -353,6 +420,45 @@ public abstract class ShortVector extends AbstractVector<Short> {
         return vectorFactory(res);
     }
 
+    /*package-private*/
+    @ForceInline
+    final
+    <M> ShortVector ldOpMF(M memory, int offset,
+                                  FLdOp<M> f) {
+        VectorSupport.VectorPayloadMF tpayload =
+            Unsafe.getUnsafe().makePrivateBuffer(VectorSupport.VectorPayloadMF.createNewInstanceS(
+                short.class, length(), Short.valueOf((short)0)));
+        int length = tpayload.length();
+        long start_offset = tpayload.multiFieldOffset();
+        for (int i = 0; i < length; i++) {
+            Unsafe.getUnsafe().putShort(tpayload, start_offset + i * Integer.BYTES, f.apply(memory, offset, i));
+        }
+        Unsafe.getUnsafe().finishPrivateBuffer(tpayload);
+        return vectorFactory(tpayload);
+    }
+
+    /*package-private*/
+    @ForceInline
+    final
+    <M> ShortVector ldOpMF(M memory, int offset,
+                                  VectorMask<Short> m,
+                                  FLdOp<M> f) {
+        VectorSupport.VectorPayloadMF tpayload =
+            Unsafe.getUnsafe().makePrivateBuffer(VectorSupport.VectorPayloadMF.createNewInstanceS(
+                short.class, length(), Short.valueOf((short)0)));
+        int length = tpayload.length();
+        long start_offset = tpayload.multiFieldOffset();
+        boolean[] mbits = ((AbstractMask<Short>)m).getBits();
+        for (int i = 0; i < length; i++) {
+            if (mbits[i]) {
+                Unsafe.getUnsafe().putShort(tpayload, start_offset + i * Integer.BYTES, f.apply(memory, offset, i));
+            }
+        }
+        Unsafe.getUnsafe().finishPrivateBuffer(tpayload);
+        return vectorFactory(tpayload);
+    }
+
+
     /*package-private*/
     interface FLdLongOp {
         short apply(MemorySegment memory, long offset, int i);
@@ -422,6 +528,37 @@ public abstract class ShortVector extends AbstractVector<Short> {
         }
     }
 
+    /*package-private*/
+    @ForceInline
+    final
+    <M> void stOpMF(M memory, int offset,
+                  FStOp<M> f) {
+        VectorSupport.VectorPayloadMF vec = vec_mf();
+        long start_offset = vec.multiFieldOffset();
+        int length = vec.length();
+        for (int i = 0; i < length; i++) {
+            f.apply(memory, offset, i, Unsafe.getUnsafe().getShort(vec, start_offset + i * Integer.BYTES));
+        }
+    }
+
+    /*package-private*/
+   @ForceInline
+    final
+    <M> void stOpMF(M memory, int offset,
+                  VectorMask<Short> m,
+                  FStOp<M> f) {
+        VectorSupport.VectorPayloadMF vec = vec_mf();
+        boolean[] mbits = ((AbstractMask<Short>)m).getBits();
+        long start_offset = vec.multiFieldOffset();
+        int length = vec.length();
+        for (int i = 0; i < length; i++) {
+            if (mbits[i]) {
+                f.apply(memory, offset, i, Unsafe.getUnsafe().getShort(vec, start_offset + i * Integer.BYTES));
+            }
+        }
+    }
+
+
     interface FStLongOp {
         void apply(MemorySegment memory, long offset, int i, short a);
     }
@@ -780,11 +917,18 @@ public abstract class ShortVector extends AbstractVector<Short> {
             }
         }
 
+        /*
         int opc = opCode(op);
         return VectorSupport.binaryOp(
             opc, getClass(), null, short.class, length(),
             this, that, null,
             BIN_IMPL.find(op, opc, ShortVector::binaryOperations));
+        */
+        int opc = opCode(op);
+        return VectorSupport.binaryOp(
+            opc, getClass(), null, short.class, length(),
+            this, that, null,
+            BIN_IMPL.find(op, opc, ShortVector::binaryOperationsMF));
     }
 
     /**
@@ -875,6 +1019,25 @@ public abstract class ShortVector extends AbstractVector<Short> {
         }
     }
 
+    private static BinaryOperation<ShortVector, VectorMask<Short>> binaryOperationsMF(int opc_) {
+        switch (opc_) {
+            case VECTOR_OP_ADD: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)(a + b));
+            case VECTOR_OP_SUB: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)(a - b));
+            case VECTOR_OP_MUL: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)(a * b));
+            case VECTOR_OP_DIV: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)(a / b));
+            case VECTOR_OP_MAX: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)Math.max(a, b));
+            case VECTOR_OP_MIN: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)Math.min(a, b));
+            default: return null;
+        }
+    }
+
+
     // FIXME: Maybe all of the public final methods in this file (the
     // simple ones that just call lanewise) should be pushed down to
     // the X-VectorBits template.  They can't optimize properly at
@@ -2969,6 +3132,7 @@ public abstract class ShortVector extends AbstractVector<Short> {
      *         if {@code offset+N < 0} or {@code offset+N >= a.length}
      *         for any lane {@code N} in the vector
      */
+    /*
     @ForceInline
     public static
     ShortVector fromArray(VectorSpecies<Short> species,
@@ -2976,7 +3140,7 @@ public abstract class ShortVector extends AbstractVector<Short> {
         offset = checkFromIndexSize(offset, species.length(), a.length);
         ShortSpecies vsp = (ShortSpecies) species;
         return vsp.dummyVector().fromArray0(a, offset);
-    }
+    }*/
 
     /**
      * Loads a vector from an array of type {@code short[]}
@@ -3374,6 +3538,7 @@ public abstract class ShortVector extends AbstractVector<Short> {
     void intoArray(short[] a, int offset) {
         offset = checkFromIndexSize(offset, length(), a.length);
         ShortSpecies vsp = vspecies();
+        /*
         VectorSupport.store(
             vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
             a, arrayAddress(a, offset),
@@ -3382,6 +3547,16 @@ public abstract class ShortVector extends AbstractVector<Short> {
             (arr, off, v)
             -> v.stOp(arr, (int) off,
                       (arr_, off_, i, e) -> arr_[off_ + i] = e));
+         */
+        VectorSupport.store(
+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
+            a, arrayAddress(a, offset),
+            this,
+            a, offset,
+            (arr, off, v)
+            -> v.stOpMF(arr, (int) off,
+                      (arr_, off_, i, e) -> arr_[off_ + i] = e));
+
     }
 
     /**
@@ -3723,6 +3898,7 @@ public abstract class ShortVector extends AbstractVector<Short> {
     ShortVector fromArray0(short[] a, int offset);
     @ForceInline
     final
+    /*
     ShortVector fromArray0Template(short[] a, int offset) {
         ShortSpecies vsp = vspecies();
         return VectorSupport.load(
@@ -3731,6 +3907,16 @@ public abstract class ShortVector extends AbstractVector<Short> {
             a, offset, vsp,
             (arr, off, s) -> s.ldOp(arr, (int) off,
                                     (arr_, off_, i) -> arr_[off_ + i]));
+    }*/
+
+    ShortVector fromArray0Template(short[] a, int offset) {
+        ShortSpecies vsp = vspecies();
+        return VectorSupport.load(
+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
+            a, arrayAddress(a, offset),
+            a, offset, vsp,
+            (arr, off, s) -> s.ldOpMF(arr, (int) off,
+                                    (arr_, off_, i) -> arr_[off_ + i]));
     }
 
     /*package-private*/
@@ -4203,6 +4389,12 @@ public abstract class ShortVector extends AbstractVector<Short> {
             return (ShortVector) super.dummyVector();
         }
 
+        @ForceInline
+        @Override final
+        ShortVector dummyVectorMF() {
+            return (ShortVector) super.dummyVectorMF();
+        }
+
         /*package-private*/
         final @Override
         @ForceInline
@@ -4249,6 +4441,22 @@ public abstract class ShortVector extends AbstractVector<Short> {
             return dummyVector().ldOp(memory, offset, m, f);
         }
 
+        /*package-private*/
+        @ForceInline
+        <M> ShortVector ldOpMF(M memory, int offset,
+                                      FLdOp<M> f) {
+            return dummyVectorMF().ldOpMF(memory, offset, f);
+        }
+
+        /*package-private*/
+        @ForceInline
+        <M> ShortVector ldOpMF(M memory, int offset,
+                                      VectorMask<Short> m,
+                                      FLdOp<M> f) {
+            return dummyVectorMF().ldOpMF(memory, offset, m, f);
+        }
+
+
         /*package-private*/
         @ForceInline
         ShortVector ldLongOp(MemorySegment memory, long offset,
@@ -4278,6 +4486,21 @@ public abstract class ShortVector extends AbstractVector<Short> {
             dummyVector().stOp(memory, offset, m, f);
         }
 
+        /*package-private*/
+        @ForceInline
+        <M> void stOpMF(M memory, int offset, FStOp<M> f) {
+            dummyVectorMF().stOpMF(memory, offset, f);
+        }
+
+        /*package-private*/
+        @ForceInline
+        <M> void stOpMF(M memory, int offset,
+                     AbstractMask<Short> m,
+                      FStOp<M> f) {
+            dummyVectorMF().stOpMF(memory, offset, m, f);
+        }
+
+
         /*package-private*/
         @ForceInline
         void stLongOp(MemorySegment memory, long offset, FStLongOp f) {
@@ -4303,8 +4526,8 @@ public abstract class ShortVector extends AbstractVector<Short> {
         @Override
         @ForceInline
         public final ShortVector zero() {
-            if ((Class<?>) vectorType() == ShortMaxVector.class)
-                return ShortMaxVector.ZERO;
+            //if ((Class<?>) vectorType() == ShortMaxVector.class)
+            //    return ShortMaxVector.ZERO;
             switch (vectorBitSize()) {
                 case 64: return Short64Vector.ZERO;
                 case 128: return Short128Vector.ZERO;
@@ -4317,8 +4540,8 @@ public abstract class ShortVector extends AbstractVector<Short> {
         @Override
         @ForceInline
         public final ShortVector iota() {
-            if ((Class<?>) vectorType() == ShortMaxVector.class)
-                return ShortMaxVector.IOTA;
+            //if ((Class<?>) vectorType() == ShortMaxVector.class)
+            //    return ShortMaxVector.IOTA;
             switch (vectorBitSize()) {
                 case 64: return Short64Vector.IOTA;
                 case 128: return Short128Vector.IOTA;
@@ -4332,8 +4555,8 @@ public abstract class ShortVector extends AbstractVector<Short> {
         @Override
         @ForceInline
         public final VectorMask<Short> maskAll(boolean bit) {
-            if ((Class<?>) vectorType() == ShortMaxVector.class)
-                return ShortMaxVector.ShortMaxMask.maskAll(bit);
+            //if ((Class<?>) vectorType() == ShortMaxVector.class)
+            //    return ShortMaxVector.ShortMaxMask.maskAll(bit);
             switch (vectorBitSize()) {
                 case 64: return Short64Vector.Short64Mask.maskAll(bit);
                 case 128: return Short128Vector.Short128Mask.maskAll(bit);
@@ -4342,6 +4565,16 @@ public abstract class ShortVector extends AbstractVector<Short> {
             }
             throw new AssertionError();
         }
+
+        @Override
+        Object iotaArray() {
+            int laneCount = laneCount();
+            short [] init = new short[laneCount];
+            for (int i = 0; i < laneCount; i++) {
+                init[i] = (short)i;
+            }
+           return VectorSupport.VectorPayloadMF.createNewInstanceS(elementType(), laneCount, init);
+        }
     }
 
     /**
@@ -4358,7 +4591,7 @@ public abstract class ShortVector extends AbstractVector<Short> {
             case VectorShape.SK_128_BIT: return (ShortSpecies) SPECIES_128;
             case VectorShape.SK_256_BIT: return (ShortSpecies) SPECIES_256;
             case VectorShape.SK_512_BIT: return (ShortSpecies) SPECIES_512;
-            case VectorShape.SK_Max_BIT: return (ShortSpecies) SPECIES_MAX;
+            //case VectorShape.SK_Max_BIT: return (ShortSpecies) SPECIES_MAX;
             default: throw new IllegalArgumentException("Bad shape: " + s);
         }
     }
@@ -4392,11 +4625,12 @@ public abstract class ShortVector extends AbstractVector<Short> {
                             Short512Vector::new);
 
     /** Species representing {@link ShortVector}s of {@link VectorShape#S_Max_BIT VectorShape.S_Max_BIT}. */
-    public static final VectorSpecies<Short> SPECIES_MAX
+    /*public static final VectorSpecies<Short> SPECIES_MAX
         = new ShortSpecies(VectorShape.S_Max_BIT,
                             ShortMaxVector.class,
                             ShortMaxVector.ShortMaxMask.class,
                             ShortMaxVector::new);
+     */
 
     /**
      * Preferred species for {@link ShortVector}s.
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Vector.java b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Vector.java
index d34ac79e7c3..9ba4b4dfb4e 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Vector.java
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/Vector.java
@@ -1176,9 +1176,9 @@ public abstract class Vector<E> extends jdk.internal.vm.vector.VectorSupport.Vec
 
     // This type is sealed within its package.
     // Users cannot roll their own vector types.
-    Vector(Object bits) {
+    /*Vector(Object bits) {
         super(bits);
-    }
+    }*/
 
     /**
      * Returns the species of this vector.
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/X-Vector.java.template b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/X-Vector.java.template
index a4b4750f252..08fb77bc400 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/X-Vector.java.template
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/X-Vector.java.template
@@ -51,9 +51,9 @@ import static jdk.incubator.vector.VectorOperators.*;
 @SuppressWarnings("cast")  // warning: redundant cast
 public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
 
-    $abstractvectortype$($type$[] vec) {
+    /*$abstractvectortype$($type$[] vec) {
         super(vec);
-    }
+    }*/
 
 #if[FP]
     static final int FORBID_OPCODE_KIND = VO_NOFP;
@@ -100,6 +100,8 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
     /*package-private*/
     abstract $type$[] vec();
 
+    abstract VectorSupport.VectorPayloadMF vec_mf();
+
     // Virtualized constructors
 
     /**
@@ -109,6 +111,17 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
     /*package-private*/
     abstract $abstractvectortype$ vectorFactory($type$[] vec);
 
+    abstract $abstractvectortype$ vectorFactory(VectorSupport.VectorPayloadMF vec);
+
+    @ForceInline
+    public static
+    $abstractvectortype$ fromArray(VectorSpecies<$Boxtype$> species,
+                                   $type$[] a, int offset) {
+        offset = checkFromIndexSize(offset, species.length(), a.length);
+        $Type$Species vsp = ($Type$Species) species;
+        return vsp.dummyVectorMF().fromArray0(a, offset);
+    }
+
     /**
      * Build a mask directly using my species.
      * It is an error if the array is aliased elsewhere.
@@ -214,6 +227,30 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         return vectorFactory(res);
     }
 
+    /*package-private*/
+    abstract
+    $abstractvectortype$ bOpMF(Vector<$Boxtype$> o,
+                             FBinOp f);
+    @ForceInline
+    final
+    $abstractvectortype$ bOpTemplateMF(Vector<$Boxtype$> o,
+                                     FBinOp f) {
+        VectorSupport.VectorPayloadMF vec1 = this.vec_mf();
+        VectorSupport.VectorPayloadMF vec2 = this.vec_mf();
+        VectorSupport.VectorPayloadMF tpayload = 
+            Unsafe.getUnsafe().makePrivateBuffer(VectorSupport.VectorPayloadMF.createNewInstance$Boxinitials$(
+                   $type$.class, length(), $Boxtype$.valueOf(($type$)0)));
+        long start_offset = tpayload.multiFieldOffset();
+        int length = tpayload.length();
+        for (int i = 0; i < length; i++) {
+            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec1, start_offset + i * Integer.BYTES);
+            $type$ v2 = Unsafe.getUnsafe().get$Type$(vec2, start_offset + i * Integer.BYTES);
+            Unsafe.getUnsafe().put$Type$(tpayload, start_offset + i * Integer.BYTES, f.apply(i, v1, v2));
+        }
+        Unsafe.getUnsafe().finishPrivateBuffer(tpayload);
+        return vectorFactory(tpayload);
+    }
+
     /*package-private*/
     abstract
     $abstractvectortype$ bOp(Vector<$Boxtype$> o,
@@ -237,6 +274,36 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         return vectorFactory(res);
     }
 
+    /*package-private*/
+    abstract
+    $abstractvectortype$ bOpMF(Vector<$Boxtype$> o,
+                             VectorMask<$Boxtype$> m,
+                             FBinOp f);
+    @ForceInline
+    final
+    $abstractvectortype$ bOpTemplateMF(Vector<$Boxtype$> o,
+                                     VectorMask<$Boxtype$> m,
+                                     FBinOp f) {
+        if (m == null) {
+            return bOpTemplateMF(o, f);
+        }
+        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();
+        VectorSupport.VectorPayloadMF vec1 = this.vec_mf();
+        VectorSupport.VectorPayloadMF vec2 = this.vec_mf();
+        VectorSupport.VectorPayloadMF tpayload =
+            Unsafe.getUnsafe().makePrivateBuffer(VectorSupport.VectorPayloadMF.createNewInstance$Boxinitials$(
+                $type$.class, length(), $Boxtype$.valueOf(($type$)0)));
+        long start_offset = tpayload.multiFieldOffset();
+        int length = tpayload.length();
+        for (int i = 0; i < length; i++) {
+            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec1, start_offset + i * Integer.BYTES);
+            $type$ v2 = Unsafe.getUnsafe().get$Type$(vec2, start_offset + i * Integer.BYTES);
+            Unsafe.getUnsafe().put$Type$(tpayload, start_offset + i * Integer.BYTES, mbits[i] ? f.apply(i, v1, v2): v1);
+        }
+        Unsafe.getUnsafe().finishPrivateBuffer(tpayload);
+        return vectorFactory(tpayload);
+    }
+
     // Ternary operator
 
     /*package-private*/
@@ -357,6 +424,45 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         return vectorFactory(res);
     }
 
+    /*package-private*/
+    @ForceInline
+    final
+    <M> $abstractvectortype$ ldOpMF(M memory, int offset,
+                                  FLdOp<M> f) {
+        VectorSupport.VectorPayloadMF tpayload =
+            Unsafe.getUnsafe().makePrivateBuffer(VectorSupport.VectorPayloadMF.createNewInstance$Boxinitials$(
+                $type$.class, length(), $Boxtype$.valueOf(($type$)0)));
+        int length = tpayload.length();
+        long start_offset = tpayload.multiFieldOffset();
+        for (int i = 0; i < length; i++) {
+            Unsafe.getUnsafe().put$Type$(tpayload, start_offset + i * Integer.BYTES, f.apply(memory, offset, i));
+        }
+        Unsafe.getUnsafe().finishPrivateBuffer(tpayload);
+        return vectorFactory(tpayload);
+    }
+
+    /*package-private*/
+    @ForceInline
+    final
+    <M> $abstractvectortype$ ldOpMF(M memory, int offset,
+                                  VectorMask<$Boxtype$> m,
+                                  FLdOp<M> f) {
+        VectorSupport.VectorPayloadMF tpayload =
+            Unsafe.getUnsafe().makePrivateBuffer(VectorSupport.VectorPayloadMF.createNewInstance$Boxinitials$(
+                $type$.class, length(), $Boxtype$.valueOf(($type$)0)));
+        int length = tpayload.length();
+        long start_offset = tpayload.multiFieldOffset();
+        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();
+        for (int i = 0; i < length; i++) {
+            if (mbits[i]) {
+                Unsafe.getUnsafe().put$Type$(tpayload, start_offset + i * Integer.BYTES, f.apply(memory, offset, i));
+            }
+        }
+        Unsafe.getUnsafe().finishPrivateBuffer(tpayload);
+        return vectorFactory(tpayload);
+    }
+
+
     /*package-private*/
     interface FLdLongOp {
         $type$ apply(MemorySegment memory, long offset, int i);
@@ -426,6 +532,37 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         }
     }
 
+    /*package-private*/
+    @ForceInline
+    final
+    <M> void stOpMF(M memory, int offset,
+                  FStOp<M> f) {
+        VectorSupport.VectorPayloadMF vec = vec_mf();
+        long start_offset = vec.multiFieldOffset();
+        int length = vec.length();
+        for (int i = 0; i < length; i++) {
+            f.apply(memory, offset, i, Unsafe.getUnsafe().get$Type$(vec, start_offset + i * Integer.BYTES));
+        }
+    }
+
+    /*package-private*/
+   @ForceInline
+    final
+    <M> void stOpMF(M memory, int offset,
+                  VectorMask<$Boxtype$> m,
+                  FStOp<M> f) {
+        VectorSupport.VectorPayloadMF vec = vec_mf();
+        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();
+        long start_offset = vec.multiFieldOffset();
+        int length = vec.length();
+        for (int i = 0; i < length; i++) {
+            if (mbits[i]) {
+                f.apply(memory, offset, i, Unsafe.getUnsafe().get$Type$(vec, start_offset + i * Integer.BYTES));
+            }
+        }
+    }
+
+
     interface FStLongOp {
         void apply(MemorySegment memory, long offset, int i, $type$ a);
     }
@@ -864,11 +1001,18 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
 #end[BITWISE]
         }
 
+        /*
         int opc = opCode(op);
         return VectorSupport.binaryOp(
             opc, getClass(), null, $type$.class, length(),
             this, that, null,
             BIN_IMPL.find(op, opc, $abstractvectortype$::binaryOperations));
+        */
+        int opc = opCode(op);
+        return VectorSupport.binaryOp(
+            opc, getClass(), null, $type$.class, length(),
+            this, that, null,
+            BIN_IMPL.find(op, opc, $abstractvectortype$::binaryOperationsMF));
     }
 
     /**
@@ -988,6 +1132,25 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         }
     }
 
+    private static BinaryOperation<$abstractvectortype$, VectorMask<$Boxtype$>> binaryOperationsMF(int opc_) {
+        switch (opc_) {
+            case VECTOR_OP_ADD: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)(a + b));
+            case VECTOR_OP_SUB: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)(a - b));
+            case VECTOR_OP_MUL: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)(a * b));
+            case VECTOR_OP_DIV: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)(a / b));
+            case VECTOR_OP_MAX: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)Math.max(a, b));
+            case VECTOR_OP_MIN: return (v0, v1, vm) ->
+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)Math.min(a, b));
+            default: return null;
+        }
+    }
+
+
     // FIXME: Maybe all of the public final methods in this file (the
     // simple ones that just call lanewise) should be pushed down to
     // the X-VectorBits template.  They can't optimize properly at
@@ -3540,6 +3703,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
      *         if {@code offset+N < 0} or {@code offset+N >= a.length}
      *         for any lane {@code N} in the vector
      */
+    /*
     @ForceInline
     public static
     $abstractvectortype$ fromArray(VectorSpecies<$Boxtype$> species,
@@ -3547,7 +3711,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         offset = checkFromIndexSize(offset, species.length(), a.length);
         $Type$Species vsp = ($Type$Species) species;
         return vsp.dummyVector().fromArray0(a, offset);
-    }
+    }*/
 
     /**
      * Loads a vector from an array of type {@code $type$[]}
@@ -3642,7 +3806,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         }
 
         // Index vector: vix[0:n] = k -> offset + indexMap[mapOffset + k]
-        IntVector vix;
+        IntVector vix = null;
         if (isp.laneCount() != vsp.laneCount()) {
             // For $Type$MaxVector,  if vector length is non-power-of-two or
             // 2048 bits, indexShape of $Type$ species is S_MAX_BIT.
@@ -3651,9 +3815,11 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
             // indexShape is still S_MAX_BIT, but the lane count of int vector
             // is 64. So when loading index vector (IntVector), only lower half
             // of index data is needed.
-            vix = IntVector
+            /*vix = IntVector
                 .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)
                 .add(offset);
+             */
+             assert false : "Unhandled case";
         } else {
             vix = IntVector
                 .fromArray(isp, indexMap, mapOffset)
@@ -4180,6 +4346,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
     void intoArray($type$[] a, int offset) {
         offset = checkFromIndexSize(offset, length(), a.length);
         $Type$Species vsp = vspecies();
+        /*
         VectorSupport.store(
             vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
             a, arrayAddress(a, offset),
@@ -4188,6 +4355,16 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
             (arr, off, v)
             -> v.stOp(arr, (int) off,
                       (arr_, off_, i, e) -> arr_[off_ + i] = e));
+         */
+        VectorSupport.store(
+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
+            a, arrayAddress(a, offset),
+            this,
+            a, offset,
+            (arr, off, v)
+            -> v.stOpMF(arr, (int) off,
+                      (arr_, off_, i, e) -> arr_[off_ + i] = e));
+
     }
 
     /**
@@ -4280,7 +4457,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         }
 
         // Index vector: vix[0:n] = i -> offset + indexMap[mo + i]
-        IntVector vix;
+        IntVector vix = null;
         if (isp.laneCount() != vsp.laneCount()) {
             // For $Type$MaxVector,  if vector length  is 2048 bits, indexShape
             // of $Type$ species is S_MAX_BIT. and the lane count of $Type$
@@ -4288,9 +4465,11 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
             // indexShape is still S_MAX_BIT, but the lane count of int vector
             // is 64. So when loading index vector (IntVector), only lower half
             // of index data is needed.
-            vix = IntVector
+            /*vix = IntVector
                 .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)
                 .add(offset);
+             */
+             assert false : "Unhandled case";
         } else {
             vix = IntVector
                 .fromArray(isp, indexMap, mapOffset)
@@ -4770,6 +4949,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
     $abstractvectortype$ fromArray0($type$[] a, int offset);
     @ForceInline
     final
+    /*
     $abstractvectortype$ fromArray0Template($type$[] a, int offset) {
         $Type$Species vsp = vspecies();
         return VectorSupport.load(
@@ -4778,6 +4958,16 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
             a, offset, vsp,
             (arr, off, s) -> s.ldOp(arr, (int) off,
                                     (arr_, off_, i) -> arr_[off_ + i]));
+    }*/
+
+    $abstractvectortype$ fromArray0Template($type$[] a, int offset) {
+        $Type$Species vsp = vspecies();
+        return VectorSupport.load(
+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),
+            a, arrayAddress(a, offset),
+            a, offset, vsp,
+            (arr, off, s) -> s.ldOpMF(arr, (int) off,
+                                    (arr_, off_, i) -> arr_[off_ + i]));
     }
 
     /*package-private*/
@@ -4821,7 +5011,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         }
 
         // Index vector: vix[0:n] = k -> offset + indexMap[mapOffset + k]
-        IntVector vix;
+        IntVector vix = null;
         if (isp.laneCount() != vsp.laneCount()) {
             // For $Type$MaxVector,  if vector length is non-power-of-two or
             // 2048 bits, indexShape of $Type$ species is S_MAX_BIT.
@@ -4830,9 +5020,11 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
             // indexShape is still S_MAX_BIT, but the lane count of int vector
             // is 64. So when loading index vector (IntVector), only lower half
             // of index data is needed.
-            vix = IntVector
+            /*vix = IntVector
                 .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)
                 .add(offset);
+             */
+            assert false : "Unhandled case";
         } else {
             vix = IntVector
                 .fromArray(isp, indexMap, mapOffset)
@@ -5012,7 +5204,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         }
 
         // Index vector: vix[0:n] = i -> offset + indexMap[mo + i]
-        IntVector vix;
+        IntVector vix = null;
         if (isp.laneCount() != vsp.laneCount()) {
             // For $Type$MaxVector,  if vector length  is 2048 bits, indexShape
             // of $Type$ species is S_MAX_BIT. and the lane count of $Type$
@@ -5020,9 +5212,12 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
             // indexShape is still S_MAX_BIT, but the lane count of int vector
             // is 64. So when loading index vector (IntVector), only lower half
             // of index data is needed.
-            vix = IntVector
+            /*vix = IntVector
                 .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)
                 .add(offset);
+             */
+             assert false : "Unhandled case";
+
         } else {
             vix = IntVector
                 .fromArray(isp, indexMap, mapOffset)
@@ -5468,6 +5663,12 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
             return ($abstractvectortype$) super.dummyVector();
         }
 
+        @ForceInline
+        @Override final
+        $abstractvectortype$ dummyVectorMF() {
+            return ($abstractvectortype$) super.dummyVectorMF();
+        }
+
         /*package-private*/
         final @Override
         @ForceInline
@@ -5514,6 +5715,22 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
             return dummyVector().ldOp(memory, offset, m, f);
         }
 
+        /*package-private*/
+        @ForceInline
+        <M> $abstractvectortype$ ldOpMF(M memory, int offset,
+                                      FLdOp<M> f) {
+            return dummyVectorMF().ldOpMF(memory, offset, f);
+        }
+
+        /*package-private*/
+        @ForceInline
+        <M> $abstractvectortype$ ldOpMF(M memory, int offset,
+                                      VectorMask<$Boxtype$> m,
+                                      FLdOp<M> f) {
+            return dummyVectorMF().ldOpMF(memory, offset, m, f);
+        }
+
+
         /*package-private*/
         @ForceInline
         $abstractvectortype$ ldLongOp(MemorySegment memory, long offset,
@@ -5543,6 +5760,21 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
             dummyVector().stOp(memory, offset, m, f);
         }
 
+        /*package-private*/
+        @ForceInline
+        <M> void stOpMF(M memory, int offset, FStOp<M> f) {
+            dummyVectorMF().stOpMF(memory, offset, f);
+        }
+
+        /*package-private*/
+        @ForceInline
+        <M> void stOpMF(M memory, int offset,
+                     AbstractMask<$Boxtype$> m,
+                      FStOp<M> f) {
+            dummyVectorMF().stOpMF(memory, offset, m, f);
+        }
+
+
         /*package-private*/
         @ForceInline
         void stLongOp(MemorySegment memory, long offset, FStLongOp f) {
@@ -5568,8 +5800,8 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         @Override
         @ForceInline
         public final $abstractvectortype$ zero() {
-            if ((Class<?>) vectorType() == $Type$MaxVector.class)
-                return $Type$MaxVector.ZERO;
+            //if ((Class<?>) vectorType() == $Type$MaxVector.class)
+            //    return $Type$MaxVector.ZERO;
             switch (vectorBitSize()) {
                 case 64: return $Type$64Vector.ZERO;
                 case 128: return $Type$128Vector.ZERO;
@@ -5582,8 +5814,8 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         @Override
         @ForceInline
         public final $abstractvectortype$ iota() {
-            if ((Class<?>) vectorType() == $Type$MaxVector.class)
-                return $Type$MaxVector.IOTA;
+            //if ((Class<?>) vectorType() == $Type$MaxVector.class)
+            //    return $Type$MaxVector.IOTA;
             switch (vectorBitSize()) {
                 case 64: return $Type$64Vector.IOTA;
                 case 128: return $Type$128Vector.IOTA;
@@ -5597,8 +5829,8 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
         @Override
         @ForceInline
         public final VectorMask<$Boxtype$> maskAll(boolean bit) {
-            if ((Class<?>) vectorType() == $Type$MaxVector.class)
-                return $Type$MaxVector.$Type$MaxMask.maskAll(bit);
+            //if ((Class<?>) vectorType() == $Type$MaxVector.class)
+            //    return $Type$MaxVector.$Type$MaxMask.maskAll(bit);
             switch (vectorBitSize()) {
                 case 64: return $Type$64Vector.$Type$64Mask.maskAll(bit);
                 case 128: return $Type$128Vector.$Type$128Mask.maskAll(bit);
@@ -5607,6 +5839,16 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
             }
             throw new AssertionError();
         }
+
+        @Override
+        Object iotaArray() {
+            int laneCount = laneCount();
+            $type$ [] init = new $type$[laneCount];
+            for (int i = 0; i < laneCount; i++) {
+                init[i] = ($type$)i;
+            }
+           return VectorSupport.VectorPayloadMF.createNewInstance$Boxinitials$(elementType(), laneCount, init);
+        }
     }
 
     /**
@@ -5623,7 +5865,7 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
             case VectorShape.SK_128_BIT: return ($Type$Species) SPECIES_128;
             case VectorShape.SK_256_BIT: return ($Type$Species) SPECIES_256;
             case VectorShape.SK_512_BIT: return ($Type$Species) SPECIES_512;
-            case VectorShape.SK_Max_BIT: return ($Type$Species) SPECIES_MAX;
+            //case VectorShape.SK_Max_BIT: return ($Type$Species) SPECIES_MAX;
             default: throw new IllegalArgumentException("Bad shape: " + s);
         }
     }
@@ -5657,11 +5899,12 @@ public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {
                             $Type$512Vector::new);
 
     /** Species representing {@link $Type$Vector}s of {@link VectorShape#S_Max_BIT VectorShape.S_Max_BIT}. */
-    public static final VectorSpecies<$Boxtype$> SPECIES_MAX
+    /*public static final VectorSpecies<$Boxtype$> SPECIES_MAX
         = new $Type$Species(VectorShape.S_Max_BIT,
                             $Type$MaxVector.class,
                             $Type$MaxVector.$Type$MaxMask.class,
                             $Type$MaxVector::new);
+     */
 
     /**
      * Preferred species for {@link $Type$Vector}s.
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/X-VectorBits.java.template b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/X-VectorBits.java.template
index 69ff064ec53..56c82327577 100644
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/X-VectorBits.java.template
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/X-VectorBits.java.template
@@ -39,7 +39,7 @@ import static jdk.incubator.vector.VectorOperators.*;
 #warn This file is preprocessed before being compiled
 
 @SuppressWarnings("cast")  // warning: redundant cast
-final class $vectortype$ extends $abstractvectortype$ {
+value class $vectortype$ extends $abstractvectortype$ {
     static final $Type$Species VSPECIES =
         ($Type$Species) $Type$Vector.SPECIES_$BITS$;
 
@@ -54,24 +54,40 @@ final class $vectortype$ extends $abstractvectortype$ {
 
     static final Class<$Boxtype$> ETYPE = $type$.class; // used by the JVM
 
-    $vectortype$($type$[] v) {
+    /*$vectortype$($type$[] v) {
         super(v);
+    }*/
+
+    private final VectorSupport.$vectortype$Payload mf_storage;
+
+    $vectortype$(Object value) {
+        this.mf_storage = (VectorSupport.$vectortype$Payload)value;
+    }
+
+    VectorSupport.VectorPayloadMF vec_mf() {
+        return mf_storage;
+    }
+
+    @Override
+    protected final Object getPayload() {
+       return vec_mf();
     }
 
     // For compatibility as $vectortype$::new,
     // stored into species.vectorFactory.
-    $vectortype$(Object v) {
+    /*$vectortype$(Object v) {
         this(($type$[]) v);
-    }
+    }*/
 
-    static final $vectortype$ ZERO = new $vectortype$(new $type$[VLENGTH]);
+    static final $vectortype$ ZERO = new $vectortype$(VectorSupport.VectorPayloadMF.createNewInstance$Boxinitials$($type$.class, $numLanes$, $Boxtype$.valueOf(($type$)0)));
     static final $vectortype$ IOTA = new $vectortype$(VSPECIES.iotaArray());
 
     static {
         // Warm up a few species caches.
         // If we do this too much we will
         // get NPEs from bootstrap circularity.
-        VSPECIES.dummyVector();
+        // VSPECIES.dummyVector();
+        VSPECIES.dummyVectorMF();
         VSPECIES.withLanes(LaneType.BYTE);
     }
 
@@ -173,6 +189,13 @@ final class $vectortype$ extends $abstractvectortype$ {
         return new $vectortype$(vec);
     }
 
+    // Make a vector of the same species but the given elements:
+    @ForceInline
+    final @Override
+    $vectortype$ vectorFactory(VectorSupport.VectorPayloadMF vec) {
+        return new $vectortype$(vec);
+    }
+
     @ForceInline
     final @Override
     Byte$bits$Vector asByteVectorRaw() {
@@ -208,6 +231,12 @@ final class $vectortype$ extends $abstractvectortype$ {
         return ($vectortype$) super.bOpTemplate(($vectortype$)v, f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    $vectortype$ bOpMF(Vector<$Boxtype$> v, FBinOp f) {
+        return ($vectortype$) super.bOpTemplateMF(($vectortype$)v, f);  // specialize
+    }
+
     @ForceInline
     final @Override
     $vectortype$ bOp(Vector<$Boxtype$> v,
@@ -217,6 +246,15 @@ final class $vectortype$ extends $abstractvectortype$ {
                               f);  // specialize
     }
 
+    @ForceInline
+    final @Override
+    $vectortype$ bOpMF(Vector<$Boxtype$> v,
+                     VectorMask<$Boxtype$> m, FBinOp f) {
+        return ($vectortype$)
+            super.bOpTemplateMF(($vectortype$)v, ($masktype$)m,
+                              f);  // specialize
+    }
+
     // Ternary operator
 
     @ForceInline
diff --git a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/gen-src.sh b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/gen-src.sh
old mode 100644
new mode 100755
index 6841a47c757..c815ec2740a
--- a/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/gen-src.sh
+++ b/src/jdk.incubator.vector/share/classes/jdk/incubator/vector/gen-src.sh
@@ -57,6 +57,7 @@ for type in byte short int long float double
 do
   Type="$(tr '[:lower:]' '[:upper:]' <<< ${type:0:1})${type:1}"
   TYPE="$(tr '[:lower:]' '[:upper:]' <<< ${type})"
+  Boxinitials="$(tr '[:lower:]' '[:upper:]' <<< ${type:0:1})"
   args=$globalArgs
   args="$args -K$type -Dtype=$type -DType=$Type -DTYPE=$TYPE"
 
@@ -119,7 +120,7 @@ do
       ;;
   esac
 
-  args="$args -K$kind -DBoxtype=$Boxtype -DWideboxtype=$Wideboxtype"
+  args="$args -K$kind -DBoxtype=$Boxtype -DBoxinitials=$Boxinitials -DWideboxtype=$Wideboxtype"
   args="$args -Dbitstype=$bitstype -DBitstype=$Bitstype -DBoxbitstype=$Boxbitstype"
   args="$args -Dfptype=$fptype -DFptype=$Fptype -DBoxfptype=$Boxfptype"
   args="$args -DsizeInBytes=$sizeInBytes"
@@ -144,7 +145,8 @@ do
   esac
 
   old_args="$args"
-  for bits in 64 128 256 512 Max
+  # for bits in 64 128 256 512 Max
+  for bits in 64 128 256 512
   do
     vectortype=${typeprefix}${Type}${bits}Vector
     masktype=${typeprefix}${Type}${bits}Mask
@@ -190,7 +192,7 @@ do
     if [[ "${vectortype}" == "IntMaxVector" ]]; then
       args="$args -KintAndMax"
     fi
-    bitargs="$args -Dbits=$bits -DBITS=$BITS -Dvectortype=$vectortype -Dmasktype=$masktype -Dshuffletype=$shuffletype -Dbitsvectortype=$bitsvectortype -Dfpvectortype=$fpvectortype -Dvectorindextype=$vectorindextype -Dshape=$shape -DShape=$Shape"
+    bitargs="$args -Dbits=$bits -DBITS=$BITS -Dvectortype=$vectortype -DnumLanes=$numLanes  -Dmasktype=$masktype -Dshuffletype=$shuffletype -Dbitsvectortype=$bitsvectortype -Dfpvectortype=$fpvectortype -Dvectorindextype=$vectorindextype -Dshape=$shape -DShape=$Shape"
 
     case $vectortype in
     $CLASS_FILTER)
